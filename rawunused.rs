/* automatically generated by rust-bindgen */

pub type __int8_t = ::libc::c_char;
pub type __uint8_t = ::libc::c_uchar;
pub type __int16_t = ::libc::c_short;
pub type __uint16_t = ::libc::c_ushort;
pub type __int32_t = ::libc::c_int;
pub type __uint32_t = ::libc::c_uint;
pub type __int64_t = ::libc::c_longlong;
pub type __uint64_t = ::libc::c_ulonglong;
pub type __int_least8_t = ::libc::c_char;
pub type __uint_least8_t = ::libc::c_uchar;
pub type __int_least16_t = ::libc::c_short;
pub type __uint_least16_t = ::libc::c_ushort;
pub type __int_least32_t = ::libc::c_int;
pub type __uint_least32_t = ::libc::c_uint;
pub type __int_least64_t = ::libc::c_long;
pub type __uint_least64_t = ::libc::c_ulong;
pub type __intptr_t = ::libc::c_long;
pub type __uintptr_t = ::libc::c_ulong;
pub type int8_t = __int8_t;
pub type uint8_t = __uint8_t;
pub type int_least8_t = __int_least8_t;
pub type uint_least8_t = __uint_least8_t;
pub type int16_t = __int16_t;
pub type uint16_t = __uint16_t;
pub type int_least16_t = __int_least16_t;
pub type uint_least16_t = __uint_least16_t;
pub type int32_t = __int32_t;
pub type uint32_t = __uint32_t;
pub type int_least32_t = __int_least32_t;
pub type uint_least32_t = __uint_least32_t;
pub type int64_t = __int64_t;
pub type uint64_t = __uint64_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::libc::c_char;
pub type uint_fast8_t = ::libc::c_uchar;
pub type int_fast16_t = ::libc::c_short;
pub type uint_fast16_t = ::libc::c_ushort;
pub type int_fast32_t = ::libc::c_int;
pub type uint_fast32_t = ::libc::c_uint;
pub type int_fast64_t = ::libc::c_long;
pub type uint_fast64_t = ::libc::c_ulong;
pub type intmax_t = ::libc::c_long;
pub type uintmax_t = ::libc::c_ulong;
pub type intptr_t = __intptr_t;
pub type uintptr_t = __uintptr_t;
pub type ptrdiff_t = ::libc::c_long;
pub type size_t = ::libc::c_ulong;
pub type wchar_t = ::libc::c_int;
pub type Enum_Unnamed1 = ::libc::c_uint;
pub const mediatype_NAND: ::libc::c_uint = 0;
pub const mediatype_SDMC: ::libc::c_uint = 1;
pub const mediatype_GAMECARD: ::libc::c_uint = 2;
pub type mediatypes_enum = Enum_Unnamed1;
pub type _u8 = uint8_t;
pub type _u16 = uint16_t;
pub type _u32 = uint32_t;
pub type u64 = uint64_t;
pub type s8 = int8_t;
pub type s16 = int16_t;
pub type s32 = int32_t;
pub type s64 = int64_t;
pub type vu8 = _u8;
pub type vu16 = _u16;
pub type vu32 = _u32;
pub type vu64 = u64;
pub type vs8 = s8;
pub type vs16 = s16;
pub type vs32 = s32;
pub type vs64 = s64;
pub type Handle = _u32;
pub type Result = s32;
pub type ThreadFunc =
    ::std::option::Option<extern "C" fn(arg1: *mut ::libc::c_void) -> ()>;
pub type Enum_Unnamed2 = ::libc::c_uint;
pub const MEMOP_FREE: ::libc::c_uint = 1;
pub const MEMOP_ALLOC: ::libc::c_uint = 3;
pub const MEMOP_MAP: ::libc::c_uint = 4;
pub const MEMOP_UNMAP: ::libc::c_uint = 5;
pub const MEMOP_PROT: ::libc::c_uint = 6;
pub const MEMOP_FREE_LINEAR: ::libc::c_uint = 65537;
pub const MEMOP_ALLOC_LINEAR: ::libc::c_uint = 65539;
pub type MemOp = Enum_Unnamed2;
pub type Enum_Unnamed3 = ::libc::c_uint;
pub const MEMSTATE_FREE: ::libc::c_uint = 0;
pub const MEMSTATE_RESERVED: ::libc::c_uint = 1;
pub const MEMSTATE_IO: ::libc::c_uint = 2;
pub const MEMSTATE_STATIC: ::libc::c_uint = 3;
pub const MEMSTATE_CODE: ::libc::c_uint = 4;
pub const MEMSTATE_PRIVATE: ::libc::c_uint = 5;
pub const MEMSTATE_SHARED: ::libc::c_uint = 6;
pub const MEMSTATE_CONTINUOUS: ::libc::c_uint = 7;
pub const MEMSTATE_ALIASED: ::libc::c_uint = 8;
pub const MEMSTATE_ALIAS: ::libc::c_uint = 9;
pub const MEMSTATE_ALIASCODE: ::libc::c_uint = 10;
pub const MEMSTATE_LOCKED: ::libc::c_uint = 11;
pub type MemState = Enum_Unnamed3;
pub type Enum_Unnamed4 = ::libc::c_uint;
pub const MEMPERM_READ: ::libc::c_uint = 1;
pub const MEMPERM_WRITE: ::libc::c_uint = 2;
pub const MEMPERM_EXECUTE: ::libc::c_uint = 4;
pub const MEMPERM_DONTCARE: ::libc::c_uint = 268435456;
pub const MEMPERM_MAX: ::libc::c_uint = -1;
pub type MemPerm = Enum_Unnamed4;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed5 {
    pub base_addr: _u32,
    pub size: _u32,
    pub perm: _u32,
    pub state: _u32,
}
impl ::std::clone::Clone for Struct_Unnamed5 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed5 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type MemInfo = Struct_Unnamed5;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed6 {
    pub flags: _u32,
}
impl ::std::clone::Clone for Struct_Unnamed6 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed6 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type PageInfo = Struct_Unnamed6;
pub type Enum_Unnamed7 = ::libc::c_uint;
pub const ARBITER_FREE: ::libc::c_uint = 0;
pub const ARBITER_ACQUIRE: ::libc::c_uint = 1;
pub const ARBITER_KERNEL2: ::libc::c_uint = 2;
pub const ARBITER_ACQUIRE_TIMEOUT: ::libc::c_uint = 3;
pub const ARBITER_KERNEL4: ::libc::c_uint = 4;
pub type ArbitrationType = Enum_Unnamed7;
pub type Enum_Unnamed8 = ::libc::c_uint;
pub const DBG_EVENT_PROCESS: ::libc::c_uint = 0;
pub const DBG_EVENT_CREATE_THREAD: ::libc::c_uint = 1;
pub const DBG_EVENT_EXIT_THREAD: ::libc::c_uint = 2;
pub const DBG_EVENT_EXIT_PROCESS: ::libc::c_uint = 3;
pub const DBG_EVENT_EXCEPTION: ::libc::c_uint = 4;
pub const DBG_EVENT_DLL_LOAD: ::libc::c_uint = 5;
pub const DBG_EVENT_DLL_UNLOAD: ::libc::c_uint = 6;
pub const DBG_EVENT_SCHEDULE_IN: ::libc::c_uint = 7;
pub const DBG_EVENT_SCHEDULE_OUT: ::libc::c_uint = 8;
pub const DBG_EVENT_SYSCALL_IN: ::libc::c_uint = 9;
pub const DBG_EVENT_SYSCALL_OUT: ::libc::c_uint = 10;
pub const DBG_EVENT_OUTPUT_STRING: ::libc::c_uint = 11;
pub const DBG_EVENT_MAP: ::libc::c_uint = 12;
pub type DebugEventType = Enum_Unnamed8;
pub type Enum_Unnamed9 = ::libc::c_uint;
pub const REASON_CREATE: ::libc::c_uint = 1;
pub const REASON_ATTACH: ::libc::c_uint = 2;
pub type ProcessEventReason = Enum_Unnamed9;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed10 {
    pub program_id: u64,
    pub process_name: [_u8; 8usize],
    pub process_id: _u32,
    pub reason: _u32,
}
impl ::std::clone::Clone for Struct_Unnamed10 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed10 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ProcessEvent = Struct_Unnamed10;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed11 {
    pub creator_thread_id: _u32,
    pub base_addr: _u32,
    pub entry_point: _u32,
}
impl ::std::clone::Clone for Struct_Unnamed11 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed11 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CreateThreadEvent = Struct_Unnamed11;
pub type Enum_Unnamed12 = ::libc::c_uint;
pub const EXITTHREAD_EVENT_NONE: ::libc::c_uint = 0;
pub const EXITTHREAD_EVENT_TERMINATE: ::libc::c_uint = 1;
pub const EXITTHREAD_EVENT_UNHANDLED_EXC: ::libc::c_uint = 2;
pub const EXITTHREAD_EVENT_TERMINATE_PROCESS: ::libc::c_uint = 3;
pub type ExitThreadEventReason = Enum_Unnamed12;
pub type Enum_Unnamed13 = ::libc::c_uint;
pub const EXITPROCESS_EVENT_NONE: ::libc::c_uint = 0;
pub const EXITPROCESS_EVENT_TERMINATE: ::libc::c_uint = 1;
pub const EXITPROCESS_EVENT_UNHANDLED_EXCEPTION: ::libc::c_uint = 2;
pub type ExitProcessEventReason = Enum_Unnamed13;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed14 {
    pub reason: _u32,
}
impl ::std::clone::Clone for Struct_Unnamed14 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed14 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ExitProcessEvent = Struct_Unnamed14;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed15 {
    pub reason: _u32,
}
impl ::std::clone::Clone for Struct_Unnamed15 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed15 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ExitThreadEvent = Struct_Unnamed15;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed16 {
    pub _type: _u32,
    pub address: _u32,
    pub argument: _u32,
}
impl ::std::clone::Clone for Struct_Unnamed16 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed16 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ExceptionEvent = Struct_Unnamed16;
pub type Enum_Unnamed17 = ::libc::c_uint;
pub const EXC_EVENT_UNDEFINED_INSTRUCTION: ::libc::c_uint = 0;
pub const EXC_EVENT_UNKNOWN1: ::libc::c_uint = 1;
pub const EXC_EVENT_UNKNOWN2: ::libc::c_uint = 2;
pub const EXC_EVENT_UNKNOWN3: ::libc::c_uint = 3;
pub const EXC_EVENT_ATTACH_BREAK: ::libc::c_uint = 4;
pub const EXC_EVENT_BREAKPOINT: ::libc::c_uint = 5;
pub const EXC_EVENT_USER_BREAK: ::libc::c_uint = 6;
pub const EXC_EVENT_DEBUGGER_BREAK: ::libc::c_uint = 7;
pub const EXC_EVENT_UNDEFINED_SYSCALL: ::libc::c_uint = 8;
pub type ExceptionEventType = Enum_Unnamed17;
pub type Enum_Unnamed18 = ::libc::c_uint;
pub const USERBREAK_PANIC: ::libc::c_uint = 0;
pub const USERBREAK_ASSERT: ::libc::c_uint = 1;
pub const USERBREAK_USER: ::libc::c_uint = 2;
pub type UserBreakType = Enum_Unnamed18;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed19 {
    pub clock_tick: u64,
}
impl ::std::clone::Clone for Struct_Unnamed19 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed19 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type SchedulerInOutEvent = Struct_Unnamed19;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed20 {
    pub clock_tick: u64,
    pub syscall: _u32,
}
impl ::std::clone::Clone for Struct_Unnamed20 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed20 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type SyscallInOutEvent = Struct_Unnamed20;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed21 {
    pub string_addr: _u32,
    pub string_size: _u32,
}
impl ::std::clone::Clone for Struct_Unnamed21 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed21 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type OutputStringEvent = Struct_Unnamed21;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed22 {
    pub mapped_addr: _u32,
    pub mapped_size: _u32,
    pub memperm: _u32,
    pub memstate: _u32,
}
impl ::std::clone::Clone for Struct_Unnamed22 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed22 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type MapEvent = Struct_Unnamed22;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed23 {
    pub _type: _u32,
    pub thread_id: _u32,
    pub unknown: [_u32; 2usize],
    pub _bindgen_data_1_: [u64; 3usize],
}
impl Struct_Unnamed23 {
    pub unsafe fn process(&mut self) -> *mut ProcessEvent {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_1_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn create_thread(&mut self) -> *mut CreateThreadEvent {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_1_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn exit_thread(&mut self) -> *mut ExitThreadEvent {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_1_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn exit_process(&mut self) -> *mut ExitProcessEvent {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_1_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn exception(&mut self) -> *mut ExceptionEvent {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_1_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn scheduler(&mut self) -> *mut SchedulerInOutEvent {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_1_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn syscall(&mut self) -> *mut SyscallInOutEvent {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_1_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn output_string(&mut self) -> *mut OutputStringEvent {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_1_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn map(&mut self) -> *mut MapEvent {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_1_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Struct_Unnamed23 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed23 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type DebugEventInfo = Struct_Unnamed23;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed24 {
    pub active_framebuf: _u32,
    pub framebuf0_vaddr: *mut _u32,
    pub framebuf1_vaddr: *mut _u32,
    pub framebuf_widthbytesize: _u32,
    pub format: _u32,
    pub framebuf_dispselect: _u32,
    pub unk: _u32,
}
impl ::std::clone::Clone for Struct_Unnamed24 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed24 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GSP_FramebufferInfo = Struct_Unnamed24;
pub type Enum_Unnamed25 = ::libc::c_uint;
pub const GSP_RGBA8_OES: ::libc::c_uint = 0;
pub const GSP_BGR8_OES: ::libc::c_uint = 1;
pub const GSP_RGB565_OES: ::libc::c_uint = 2;
pub const GSP_RGB5_A1_OES: ::libc::c_uint = 3;
pub const GSP_RGBA4_OES: ::libc::c_uint = 4;
pub type GSP_FramebufferFormats = Enum_Unnamed25;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed26 {
    pub framebuf0_vaddr: *mut _u32,
    pub framebuf1_vaddr: *mut _u32,
    pub format: _u32,
    pub framebuf_widthbytesize: _u32,
}
impl ::std::clone::Clone for Struct_Unnamed26 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed26 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GSP_CaptureInfoEntry = Struct_Unnamed26;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed27 {
    pub screencapture: [GSP_CaptureInfoEntry; 2usize],
}
impl ::std::clone::Clone for Struct_Unnamed27 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed27 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type GSP_CaptureInfo = Struct_Unnamed27;
pub type Enum_Unnamed28 = ::libc::c_uint;
pub const GSPEVENT_PSC0: ::libc::c_uint = 0;
pub const GSPEVENT_PSC1: ::libc::c_uint = 1;
pub const GSPEVENT_VBlank0: ::libc::c_uint = 2;
pub const GSPEVENT_VBlank1: ::libc::c_uint = 3;
pub const GSPEVENT_PPF: ::libc::c_uint = 4;
pub const GSPEVENT_P3D: ::libc::c_uint = 5;
pub const GSPEVENT_DMA: ::libc::c_uint = 6;
pub const GSPEVENT_MAX: ::libc::c_uint = 7;
pub type GSP_Event = Enum_Unnamed28;
pub type Enum_Unnamed29 = ::libc::c_uint;
pub const GFX_TOP: ::libc::c_uint = 0;
pub const GFX_BOTTOM: ::libc::c_uint = 1;
pub type gfxScreen_t = Enum_Unnamed29;
pub type Enum_Unnamed30 = ::libc::c_uint;
pub const GFX_LEFT: ::libc::c_uint = 0;
pub const GFX_RIGHT: ::libc::c_uint = 1;
pub type gfx3dSide_t = Enum_Unnamed30;
pub type ConsolePrint =
    ::std::option::Option<extern "C" fn(con: *mut ::libc::c_void,
                                        c: ::libc::c_int) -> u8>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ConsoleFont {
    pub gfx: *mut _u8,
    pub asciiOffset: _u16,
    pub numChars: _u16,
}
impl ::std::clone::Clone for Struct_ConsoleFont {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ConsoleFont {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ConsoleFont = Struct_ConsoleFont;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_PrintConsole {
    pub font: ConsoleFont,
    pub frameBuffer: *mut _u16,
    pub cursorX: ::libc::c_int,
    pub cursorY: ::libc::c_int,
    pub prevCursorX: ::libc::c_int,
    pub prevCursorY: ::libc::c_int,
    pub consoleWidth: ::libc::c_int,
    pub consoleHeight: ::libc::c_int,
    pub windowX: ::libc::c_int,
    pub windowY: ::libc::c_int,
    pub windowWidth: ::libc::c_int,
    pub windowHeight: ::libc::c_int,
    pub tabSize: ::libc::c_int,
    pub fg: ::libc::c_int,
    pub bg: ::libc::c_int,
    pub flags: ::libc::c_int,
    pub PrintChar: ConsolePrint,
    pub consoleInitialised: u8,
}
impl ::std::clone::Clone for Struct_PrintConsole {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_PrintConsole {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type PrintConsole = Struct_PrintConsole;
pub type Enum_Unnamed31 = ::libc::c_uint;
pub const debugDevice_NULL: ::libc::c_uint = 0;
pub const debugDevice_3DMOO: ::libc::c_uint = 1;
pub const debugDevice_CONSOLE: ::libc::c_uint = 2;
pub type debugDevice = Enum_Unnamed31;
pub type _LOCK_T = ::libc::c_int;
pub type _LOCK_RECURSIVE_T = ::libc::c_int;
pub type _off_t = ::libc::c_long;
pub type __dev_t = ::libc::c_int;
pub type __uid_t = ::libc::c_ushort;
pub type __gid_t = ::libc::c_ushort;
pub type _off64_t = ::libc::c_longlong;
pub type _fpos_t = ::libc::c_long;
pub type _ssize_t = ::libc::c_long;
pub type wint_t = ::libc::c_int;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed32 {
    pub __count: ::libc::c_int,
    pub __value: Union_Unnamed33,
}
impl ::std::clone::Clone for Struct_Unnamed32 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed32 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed33 {
    pub _bindgen_data_: [u32; 1usize],
}
impl Union_Unnamed33 {
    pub unsafe fn __wch(&mut self) -> *mut wint_t {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn __wchb(&mut self) -> *mut [::libc::c_uchar; 4usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed33 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed33 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type _mbstate_t = Struct_Unnamed32;
pub type _flock_t = _LOCK_RECURSIVE_T;
pub type _iconv_t = *mut ::libc::c_void;
pub type __off_t = ::libc::c_long;
pub type __pid_t = ::libc::c_int;
pub type __loff_t = ::libc::c_longlong;
pub type u_char = ::libc::c_uchar;
pub type u_short = ::libc::c_ushort;
pub type u_int = ::libc::c_uint;
pub type u_long = ::libc::c_ulong;
pub type ushort = ::libc::c_ushort;
pub type _uint = ::libc::c_uint;
pub type ulong = ::libc::c_ulong;
pub type clock_t = ::libc::c_ulong;
pub type time_t = ::libc::c_long;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_timespec {
    pub tv_sec: time_t,
    pub tv_nsec: ::libc::c_long,
}
impl ::std::clone::Clone for Struct_timespec {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_timespec {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_itimerspec {
    pub it_interval: Struct_timespec,
    pub it_value: Struct_timespec,
}
impl ::std::clone::Clone for Struct_itimerspec {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_itimerspec {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type daddr_t = ::libc::c_long;
pub type caddr_t = *mut ::libc::c_char;
pub type ino_t = ::libc::c_uint;
pub type off_t = _off_t;
pub type dev_t = __dev_t;
pub type uid_t = __uid_t;
pub type gid_t = __gid_t;
pub type pid_t = ::libc::c_int;
pub type key_t = ::libc::c_long;
pub type ssize_t = _ssize_t;
pub type mode_t = ::libc::c_uint;
pub type nlink_t = ::libc::c_ushort;
pub type fd_mask = ::libc::c_long;
#[repr(C)]
#[derive(Copy)]
pub struct Struct__types_fd_set {
    pub fds_bits: [fd_mask; 1usize],
}
impl ::std::clone::Clone for Struct__types_fd_set {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct__types_fd_set {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type _types_fd_set = Struct__types_fd_set;
pub type clockid_t = ::libc::c_ulong;
pub type timer_t = ::libc::c_ulong;
pub type useconds_t = ::libc::c_ulong;
pub type suseconds_t = ::libc::c_long;
pub type fsblkcnt_t = __uint32_t;
pub type fsfilcnt_t = __uint32_t;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed34 {
    pub titleID: u64,
    pub size: u64,
    pub titleVersion: _u16,
    pub unknown2: [_u8; 6usize],
}
impl ::std::clone::Clone for Struct_Unnamed34 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed34 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type TitleList = Struct_Unnamed34;
pub type Enum_Unnamed35 = ::libc::c_uint;
pub const APPID_HOMEMENU: ::libc::c_uint = 257;
pub const APPID_CAMERA: ::libc::c_uint = 272;
pub const APPID_WEB: ::libc::c_uint = 276;
pub const APPID_APPLICATION: ::libc::c_uint = 768;
pub type NS_APPID = Enum_Unnamed35;
pub type Enum_Unnamed36 = ::libc::c_uint;
pub const APP_NOTINITIALIZED: ::libc::c_uint = 0;
pub const APP_RUNNING: ::libc::c_uint = 1;
pub const APP_SUSPENDED: ::libc::c_uint = 2;
pub const APP_EXITING: ::libc::c_uint = 3;
pub const APP_SUSPENDING: ::libc::c_uint = 4;
pub const APP_SLEEPMODE: ::libc::c_uint = 5;
pub const APP_PREPARE_SLEEPMODE: ::libc::c_uint = 6;
pub const APP_APPLETSTARTED: ::libc::c_uint = 7;
pub const APP_APPLETCLOSED: ::libc::c_uint = 8;
pub type APP_STATUS = Enum_Unnamed36;
pub type Enum_Unnamed37 = ::libc::c_uint;
pub const APTSIGNAL_HOMEBUTTON: ::libc::c_uint = 1;
pub const APTSIGNAL_PREPARESLEEP: ::libc::c_uint = 3;
pub const APTSIGNAL_ENTERSLEEP: ::libc::c_uint = 5;
pub const APTSIGNAL_WAKEUP: ::libc::c_uint = 6;
pub const APTSIGNAL_ENABLE: ::libc::c_uint = 7;
pub const APTSIGNAL_POWERBUTTON: ::libc::c_uint = 8;
pub const APTSIGNAL_UTILITY: ::libc::c_uint = 9;
pub const APTSIGNAL_SLEEPSYSTEM: ::libc::c_uint = 10;
pub const APTSIGNAL_ERROR: ::libc::c_uint = 11;
pub type Enum_Unnamed38 = ::libc::c_uint;
pub const CSND_ENCODING_PCM8: ::libc::c_uint = 0;
pub const CSND_ENCODING_PCM16: ::libc::c_uint = 1;
pub const CSND_ENCODING_ADPCM: ::libc::c_uint = 2;
pub const CSND_ENCODING_PSG: ::libc::c_uint = 3;
pub type Enum_Unnamed39 = ::libc::c_uint;
pub const CSND_LOOPMODE_MANUAL: ::libc::c_uint = 0;
pub const CSND_LOOPMODE_NORMAL: ::libc::c_uint = 1;
pub const CSND_LOOPMODE_ONESHOT: ::libc::c_uint = 2;
pub const CSND_LOOPMODE_NORELOAD: ::libc::c_uint = 3;
pub type Enum_Unnamed40 = ::libc::c_uint;
pub const SOUND_LINEAR_INTERP: ::libc::c_uint = 64;
pub const SOUND_REPEAT: ::libc::c_uint = 1024;
pub const SOUND_ONE_SHOT: ::libc::c_uint = 2048;
pub const SOUND_FORMAT_8BIT: ::libc::c_uint = 0;
pub const SOUND_FORMAT_16BIT: ::libc::c_uint = 4096;
pub const SOUND_FORMAT_ADPCM: ::libc::c_uint = 8192;
pub const SOUND_FORMAT_PSG: ::libc::c_uint = 12288;
pub const SOUND_ENABLE: ::libc::c_uint = 16384;
pub type Enum_Unnamed41 = ::libc::c_uint;
pub const DutyCycle_0: ::libc::c_uint = 7;
pub const DutyCycle_12: ::libc::c_uint = 0;
pub const DutyCycle_25: ::libc::c_uint = 1;
pub const DutyCycle_37: ::libc::c_uint = 2;
pub const DutyCycle_50: ::libc::c_uint = 3;
pub const DutyCycle_62: ::libc::c_uint = 4;
pub const DutyCycle_75: ::libc::c_uint = 5;
pub const DutyCycle_87: ::libc::c_uint = 6;
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed42 {
    pub _bindgen_data_: [u32; 3usize],
}
impl Union_Unnamed42 {
    pub unsafe fn value(&mut self) -> *mut [_u32; 3usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn active(&mut self) -> *mut _u8 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn _pad1(&mut self) -> *mut _u8 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(1))
    }
    pub unsafe fn _pad2(&mut self) -> *mut _u16 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(2))
    }
    pub unsafe fn adpcmSample(&mut self) -> *mut s16 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(4))
    }
    pub unsafe fn adpcmIndex(&mut self) -> *mut _u8 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(6))
    }
    pub unsafe fn _pad3(&mut self) -> *mut _u8 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(7))
    }
    pub unsafe fn samplePAddr(&mut self) -> *mut _u32 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(8))
    }
}
impl ::std::clone::Clone for Union_Unnamed42 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed42 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type CSND_ChnInfo = Union_Unnamed42;
pub type Enum_Unnamed43 = ::libc::c_uint;
pub const PATH_INVALID: ::libc::c_uint = 0;
pub const PATH_EMPTY: ::libc::c_uint = 1;
pub const PATH_BINARY: ::libc::c_uint = 2;
pub const PATH_CHAR: ::libc::c_uint = 3;
pub const PATH_WCHAR: ::libc::c_uint = 4;
pub type FS_pathType = Enum_Unnamed43;
pub type Enum_Unnamed44 = ::libc::c_uint;
pub const ARCH_ROMFS: ::libc::c_uint = 3;
pub const ARCH_SAVEDATA: ::libc::c_uint = 4;
pub const ARCH_EXTDATA: ::libc::c_uint = 6;
pub const ARCH_SHARED_EXTDATA: ::libc::c_uint = 7;
pub const ARCH_SYSTEM_SAVEDATA: ::libc::c_uint = 8;
pub const ARCH_SDMC: ::libc::c_uint = 9;
pub const ARCH_SDMC_WRITE_ONLY: ::libc::c_uint = 10;
pub const ARCH_BOSS_EXTDATA: ::libc::c_uint = 305419896;
pub const ARCH_CARD_SPIFS: ::libc::c_uint = 305419897;
pub const ARCH_NAND_RW: ::libc::c_uint = 305419901;
pub const ARCH_NAND_RO: ::libc::c_uint = 305419902;
pub const ARCH_NAND_RO_WRITE_ACCESS: ::libc::c_uint = 305419903;
pub type FS_archiveIds = Enum_Unnamed44;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed45 {
    pub _type: FS_pathType,
    pub size: _u32,
    pub data: *const _u8,
}
impl ::std::clone::Clone for Struct_Unnamed45 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed45 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type FS_path = Struct_Unnamed45;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed46 {
    pub id: _u32,
    pub lowPath: FS_path,
    pub handleLow: Handle,
    pub handleHigh: Handle,
}
impl ::std::clone::Clone for Struct_Unnamed46 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed46 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type FS_archive = Struct_Unnamed46;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed47 {
    pub name: [_u16; 262usize],
    pub shortName: [_u8; 9usize],
    pub unknown1: _u8,
    pub shortExt: [_u8; 4usize],
    pub unknown2: _u8,
    pub unknown3: _u8,
    pub isDirectory: _u8,
    pub isHidden: _u8,
    pub isArchive: _u8,
    pub isReadOnly: _u8,
    pub fileSize: u64,
}
impl ::std::clone::Clone for Struct_Unnamed47 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed47 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type FS_dirent = Struct_Unnamed47;
pub type Enum_Unnamed48 = ::libc::c_uint;
pub const KEY_A: ::libc::c_uint = 1;
pub const KEY_B: ::libc::c_uint = 2;
pub const KEY_SELECT: ::libc::c_uint = 4;
pub const KEY_START: ::libc::c_uint = 8;
pub const KEY_DRIGHT: ::libc::c_uint = 16;
pub const KEY_DLEFT: ::libc::c_uint = 32;
pub const KEY_DUP: ::libc::c_uint = 64;
pub const KEY_DDOWN: ::libc::c_uint = 128;
pub const KEY_R: ::libc::c_uint = 256;
pub const KEY_L: ::libc::c_uint = 512;
pub const KEY_X: ::libc::c_uint = 1024;
pub const KEY_Y: ::libc::c_uint = 2048;
pub const KEY_ZL: ::libc::c_uint = 16384;
pub const KEY_ZR: ::libc::c_uint = 32768;
pub const KEY_TOUCH: ::libc::c_uint = 1048576;
pub const KEY_CSTICK_RIGHT: ::libc::c_uint = 16777216;
pub const KEY_CSTICK_LEFT: ::libc::c_uint = 33554432;
pub const KEY_CSTICK_UP: ::libc::c_uint = 67108864;
pub const KEY_CSTICK_DOWN: ::libc::c_uint = 134217728;
pub const KEY_CPAD_RIGHT: ::libc::c_uint = 268435456;
pub const KEY_CPAD_LEFT: ::libc::c_uint = 536870912;
pub const KEY_CPAD_UP: ::libc::c_uint = 1073741824;
pub const KEY_CPAD_DOWN: ::libc::c_uint = -2147483648;
pub const KEY_UP: ::libc::c_uint = 1073741888;
pub const KEY_DOWN: ::libc::c_uint = -2147483520;
pub const KEY_LEFT: ::libc::c_uint = 536870944;
pub const KEY_RIGHT: ::libc::c_uint = 268435472;
pub type PAD_KEY = Enum_Unnamed48;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed49 {
    pub px: _u16,
    pub py: _u16,
}
impl ::std::clone::Clone for Struct_Unnamed49 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed49 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type touchPosition = Struct_Unnamed49;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed50 {
    pub dx: s16,
    pub dy: s16,
}
impl ::std::clone::Clone for Struct_Unnamed50 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed50 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type circlePosition = Struct_Unnamed50;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed51 {
    pub x: s16,
    pub y: s16,
    pub z: s16,
}
impl ::std::clone::Clone for Struct_Unnamed51 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed51 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type accelVector = Struct_Unnamed51;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed52 {
    pub x: s16,
    pub z: s16,
    pub y: s16,
}
impl ::std::clone::Clone for Struct_Unnamed52 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed52 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type angularRate = Struct_Unnamed52;
pub type Enum_Unnamed53 = ::libc::c_uint;
pub const HIDEVENT_PAD0: ::libc::c_uint = 0;
pub const HIDEVENT_PAD1: ::libc::c_uint = 1;
pub const HIDEVENT_Accel: ::libc::c_uint = 2;
pub const HIDEVENT_Gyro: ::libc::c_uint = 3;
pub const HIDEVENT_DebugPad: ::libc::c_uint = 4;
pub const HIDEVENT_MAX: ::libc::c_uint = 5;
pub type HID_Event = Enum_Unnamed53;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed54 {
    pub servhandle: Handle,
    pub httphandle: _u32,
}
impl ::std::clone::Clone for Struct_Unnamed54 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed54 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type httpcContext = Struct_Unnamed54;
pub type Enum_Unnamed55 = ::libc::c_uint;
pub const HTTPCREQSTAT_INPROGRESS_REQSENT: ::libc::c_uint = 5;
pub const HTTPCREQSTAT_DLREADY: ::libc::c_uint = 7;
pub type httpcReqStatus = Enum_Unnamed55;
pub type Enum_Unnamed56 = ::libc::c_uint;
pub const ps_CBC_ENC: ::libc::c_uint = 0;
pub const ps_CBC_DEC: ::libc::c_uint = 1;
pub const ps_CTR_ENC: ::libc::c_uint = 2;
pub const ps_CTR_DEC: ::libc::c_uint = 3;
pub const ps_CCM_ENC: ::libc::c_uint = 4;
pub const ps_CCM_DEC: ::libc::c_uint = 5;
pub type ps_aes_algo = Enum_Unnamed56;
pub type Enum_Unnamed57 = ::libc::c_uint;
pub const ps_KEYSLOT_0D: ::libc::c_uint = 0;
pub const ps_KEYSLOT_2D: ::libc::c_uint = 1;
pub const ps_KEYSLOT_31: ::libc::c_uint = 2;
pub const ps_KEYSLOT_38: ::libc::c_uint = 3;
pub const ps_KEYSLOT_32: ::libc::c_uint = 4;
pub const ps_KEYSLOT_39: ::libc::c_uint = 5;
pub const ps_KEYSLOT_2E: ::libc::c_uint = 6;
pub const ps_KEYSLOT_INVALID: ::libc::c_uint = 7;
pub const ps_KEYSLOT_36: ::libc::c_uint = 8;
pub type ps_aes_keytypes = Enum_Unnamed57;
pub type Enum_Unnamed58 = ::libc::c_uint;
pub const MVDMODE_COLORFORMATCONV: ::libc::c_uint = 0;
pub const MVDMODE_VIDEOPROCESSING: ::libc::c_uint = 1;
pub type mvdstdMode = Enum_Unnamed58;
pub type Enum_Unnamed59 = ::libc::c_uint;
pub const MVDTYPEIN_YUYV422: ::libc::c_uint = 65537;
pub const MVDTYPEIN_H264: ::libc::c_uint = 131073;
pub type mvdstdTypeInput = Enum_Unnamed59;
pub type Enum_Unnamed60 = ::libc::c_uint;
pub const MVDTYPEOUT_RGB565: ::libc::c_uint = 262146;
pub type mvdstdTypeOutput = Enum_Unnamed60;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed61 {
    pub input_type: mvdstdTypeInput,
    pub unk_x04: _u32,
    pub unk_x08: _u32,
    pub inwidth: _u32,
    pub inheight: _u32,
    pub physaddr_colorconv_indata: _u32,
    pub unk_x18: [_u32; 10usize],
    pub flag_x40: _u32,
    pub unk_x44: _u32,
    pub unk_x48: _u32,
    pub outheight0: _u32,
    pub outwidth0: _u32,
    pub unk_x54: _u32,
    pub output_type: mvdstdTypeOutput,
    pub outwidth1: _u32,
    pub outheight1: _u32,
    pub physaddr_outdata0: _u32,
    pub physaddr_outdata1_colorconv: _u32,
    pub unk_x6c: [_u32; 44usize],
}
impl ::std::clone::Clone for Struct_Unnamed61 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed61 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type mvdstdConfig = Struct_Unnamed61;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed62 {
    pub x: ::libc::c_float,
    pub y: ::libc::c_float,
}
impl ::std::clone::Clone for Struct_Unnamed62 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed62 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type qtmHeadtrackingInfoCoord = Struct_Unnamed62;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed63 {
    pub flags: [_u8; 5usize],
    pub padding: [_u8; 3usize],
    pub floatdata_x08: ::libc::c_float,
    pub coords0: [qtmHeadtrackingInfoCoord; 4usize],
    pub unk_x2c: [_u32; 5usize],
}
impl ::std::clone::Clone for Struct_Unnamed63 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed63 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type qtmHeadtrackingInfo = Struct_Unnamed63;
pub type Enum_Unnamed64 = ::libc::c_uint;
pub const GPU_NEAREST: ::libc::c_uint = 0;
pub const GPU_LINEAR: ::libc::c_uint = 1;
pub type GPU_TEXTURE_FILTER_PARAM = Enum_Unnamed64;
pub type Enum_Unnamed65 = ::libc::c_uint;
pub const GPU_CLAMP_TO_EDGE: ::libc::c_uint = 0;
pub const GPU_REPEAT: ::libc::c_uint = 2;
pub type GPU_TEXTURE_WRAP_PARAM = Enum_Unnamed65;
pub type Enum_Unnamed66 = ::libc::c_uint;
pub const GPU_TEXUNIT0: ::libc::c_uint = 1;
pub const GPU_TEXUNIT1: ::libc::c_uint = 2;
pub const GPU_TEXUNIT2: ::libc::c_uint = 4;
pub type GPU_TEXUNIT = Enum_Unnamed66;
pub type Enum_Unnamed67 = ::libc::c_uint;
pub const GPU_RGBA8: ::libc::c_uint = 0;
pub const GPU_RGB8: ::libc::c_uint = 1;
pub const GPU_RGBA5551: ::libc::c_uint = 2;
pub const GPU_RGB565: ::libc::c_uint = 3;
pub const GPU_RGBA4: ::libc::c_uint = 4;
pub const GPU_LA8: ::libc::c_uint = 5;
pub const GPU_HILO8: ::libc::c_uint = 6;
pub const GPU_L8: ::libc::c_uint = 7;
pub const GPU_A8: ::libc::c_uint = 8;
pub const GPU_LA4: ::libc::c_uint = 9;
pub const GPU_L4: ::libc::c_uint = 10;
pub const GPU_ETC1: ::libc::c_uint = 11;
pub const GPU_ETC1A4: ::libc::c_uint = 12;
pub type GPU_TEXCOLOR = Enum_Unnamed67;
pub type Enum_Unnamed68 = ::libc::c_uint;
pub const GPU_NEVER: ::libc::c_uint = 0;
pub const GPU_ALWAYS: ::libc::c_uint = 1;
pub const GPU_EQUAL: ::libc::c_uint = 2;
pub const GPU_NOTEQUAL: ::libc::c_uint = 3;
pub const GPU_LESS: ::libc::c_uint = 4;
pub const GPU_LEQUAL: ::libc::c_uint = 5;
pub const GPU_GREATER: ::libc::c_uint = 6;
pub const GPU_GEQUAL: ::libc::c_uint = 7;
pub type GPU_TESTFUNC = Enum_Unnamed68;
pub type Enum_Unnamed69 = ::libc::c_uint;
pub const GPU_SCISSOR_DISABLE: ::libc::c_uint = 0;
pub const GPU_SCISSOR_INVERT: ::libc::c_uint = 1;
pub const GPU_SCISSOR_NORMAL: ::libc::c_uint = 3;
pub type GPU_SCISSORMODE = Enum_Unnamed69;
pub type Enum_Unnamed70 = ::libc::c_uint;
pub const GPU_KEEP: ::libc::c_uint = 0;
pub const GPU_AND_NOT: ::libc::c_uint = 1;
pub const GPU_XOR: ::libc::c_uint = 5;
pub type GPU_STENCILOP = Enum_Unnamed70;
pub type Enum_Unnamed71 = ::libc::c_uint;
pub const GPU_WRITE_RED: ::libc::c_uint = 1;
pub const GPU_WRITE_GREEN: ::libc::c_uint = 2;
pub const GPU_WRITE_BLUE: ::libc::c_uint = 4;
pub const GPU_WRITE_ALPHA: ::libc::c_uint = 8;
pub const GPU_WRITE_DEPTH: ::libc::c_uint = 16;
pub const GPU_WRITE_COLOR: ::libc::c_uint = 15;
pub const GPU_WRITE_ALL: ::libc::c_uint = 31;
pub type GPU_WRITEMASK = Enum_Unnamed71;
pub type Enum_Unnamed72 = ::libc::c_uint;
pub const GPU_BLEND_ADD: ::libc::c_uint = 0;
pub const GPU_BLEND_SUBTRACT: ::libc::c_uint = 1;
pub const GPU_BLEND_REVERSE_SUBTRACT: ::libc::c_uint = 2;
pub const GPU_BLEND_MIN: ::libc::c_uint = 3;
pub const GPU_BLEND_MAX: ::libc::c_uint = 4;
pub type GPU_BLENDEQUATION = Enum_Unnamed72;
pub type Enum_Unnamed73 = ::libc::c_uint;
pub const GPU_ZERO: ::libc::c_uint = 0;
pub const GPU_ONE: ::libc::c_uint = 1;
pub const GPU_SRC_COLOR: ::libc::c_uint = 2;
pub const GPU_ONE_MINUS_SRC_COLOR: ::libc::c_uint = 3;
pub const GPU_DST_COLOR: ::libc::c_uint = 4;
pub const GPU_ONE_MINUS_DST_COLOR: ::libc::c_uint = 5;
pub const GPU_SRC_ALPHA: ::libc::c_uint = 6;
pub const GPU_ONE_MINUS_SRC_ALPHA: ::libc::c_uint = 7;
pub const GPU_DST_ALPHA: ::libc::c_uint = 8;
pub const GPU_ONE_MINUS_DST_ALPHA: ::libc::c_uint = 9;
pub const GPU_CONSTANT_COLOR: ::libc::c_uint = 10;
pub const GPU_ONE_MINUS_CONSTANT_COLOR: ::libc::c_uint = 11;
pub const GPU_CONSTANT_ALPHA: ::libc::c_uint = 12;
pub const GPU_ONE_MINUS_CONSTANT_ALPHA: ::libc::c_uint = 13;
pub const GPU_SRC_ALPHA_SATURATE: ::libc::c_uint = 14;
pub type GPU_BLENDFACTOR = Enum_Unnamed73;
pub type Enum_Unnamed74 = ::libc::c_uint;
pub const GPU_LOGICOP_CLEAR: ::libc::c_uint = 0;
pub const GPU_LOGICOP_AND: ::libc::c_uint = 1;
pub const GPU_LOGICOP_AND_REVERSE: ::libc::c_uint = 2;
pub const GPU_LOGICOP_COPY: ::libc::c_uint = 3;
pub const GPU_LOGICOP_SET: ::libc::c_uint = 4;
pub const GPU_LOGICOP_COPY_INVERTED: ::libc::c_uint = 5;
pub const GPU_LOGICOP_NOOP: ::libc::c_uint = 6;
pub const GPU_LOGICOP_INVERT: ::libc::c_uint = 7;
pub const GPU_LOGICOP_NAND: ::libc::c_uint = 8;
pub const GPU_LOGICOP_OR: ::libc::c_uint = 9;
pub const GPU_LOGICOP_NOR: ::libc::c_uint = 10;
pub const GPU_LOGICOP_XOR: ::libc::c_uint = 11;
pub const GPU_LOGICOP_EQUIV: ::libc::c_uint = 12;
pub const GPU_LOGICOP_AND_INVERTED: ::libc::c_uint = 13;
pub const GPU_LOGICOP_OR_REVERSE: ::libc::c_uint = 14;
pub const GPU_LOGICOP_OR_INVERTED: ::libc::c_uint = 15;
pub type GPU_LOGICOP = Enum_Unnamed74;
pub type Enum_Unnamed75 = ::libc::c_uint;
pub const GPU_BYTE: ::libc::c_uint = 0;
pub const GPU_UNSIGNED_BYTE: ::libc::c_uint = 1;
pub const GPU_SHORT: ::libc::c_uint = 2;
pub const GPU_FLOAT: ::libc::c_uint = 3;
pub type GPU_FORMATS = Enum_Unnamed75;
pub type Enum_Unnamed76 = ::libc::c_uint;
pub const GPU_CULL_NONE: ::libc::c_uint = 0;
pub const GPU_CULL_FRONT_CCW: ::libc::c_uint = 1;
pub const GPU_CULL_BACK_CCW: ::libc::c_uint = 2;
pub type GPU_CULLMODE = Enum_Unnamed76;
pub type Enum_Unnamed77 = ::libc::c_uint;
pub const GPU_PRIMARY_COLOR: ::libc::c_uint = 0;
pub const GPU_TEXTURE0: ::libc::c_uint = 3;
pub const GPU_TEXTURE1: ::libc::c_uint = 4;
pub const GPU_TEXTURE2: ::libc::c_uint = 5;
pub const GPU_TEXTURE3: ::libc::c_uint = 6;
pub const GPU_CONSTANT: ::libc::c_uint = 14;
pub const GPU_PREVIOUS: ::libc::c_uint = 15;
pub type GPU_TEVSRC = Enum_Unnamed77;
pub type Enum_Unnamed78 = ::libc::c_uint;
pub const GPU_REPLACE: ::libc::c_uint = 0;
pub const GPU_MODULATE: ::libc::c_uint = 1;
pub const GPU_ADD: ::libc::c_uint = 2;
pub const GPU_ADD_SIGNED: ::libc::c_uint = 3;
pub const GPU_INTERPOLATE: ::libc::c_uint = 4;
pub const GPU_SUBTRACT: ::libc::c_uint = 5;
pub const GPU_DOT3_RGB: ::libc::c_uint = 6;
pub type GPU_COMBINEFUNC = Enum_Unnamed78;
pub type Enum_Unnamed79 = ::libc::c_uint;
pub const GPU_TRIANGLES: ::libc::c_uint = 0;
pub const GPU_TRIANGLE_STRIP: ::libc::c_uint = 256;
pub const GPU_TRIANGLE_FAN: ::libc::c_uint = 512;
pub const GPU_UNKPRIM: ::libc::c_uint = 768;
pub type GPU_Primitive_t = Enum_Unnamed79;
pub type Enum_Unnamed80 = ::libc::c_uint;
pub const GPU_VERTEX_SHADER: ::libc::c_uint = 0;
pub const GPU_GEOMETRY_SHADER: ::libc::c_uint = 1;
pub type GPU_SHADER_TYPE = Enum_Unnamed80;
pub type Enum_Unnamed81 = ::libc::c_uint;
pub const VERTEX_SHDR: ::libc::c_uint = 0;
pub const GEOMETRY_SHDR: ::libc::c_uint = 1;
pub type DVLE_type = Enum_Unnamed81;
pub type Enum_Unnamed82 = ::libc::c_uint;
pub const DVLE_CONST_BOOL: ::libc::c_uint = 0;
pub const DVLE_CONST_u8: ::libc::c_uint = 1;
pub const DVLE_CONST_FLOAT24: ::libc::c_uint = 2;
pub type DVLE_constantType = Enum_Unnamed82;
pub type Enum_Unnamed83 = ::libc::c_uint;
pub const RESULT_POSITION: ::libc::c_uint = 0;
pub const RESULT_NORMALQUAT: ::libc::c_uint = 1;
pub const RESULT_COLOR: ::libc::c_uint = 2;
pub const RESULT_TEXCOORD0: ::libc::c_uint = 3;
pub const RESULT_TEXCOORD0W: ::libc::c_uint = 4;
pub const RESULT_TEXCOORD1: ::libc::c_uint = 5;
pub const RESULT_TEXCOORD2: ::libc::c_uint = 6;
pub const RESULT_VIEW: ::libc::c_uint = 8;
pub type DVLE_outputAttribute_t = Enum_Unnamed83;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed84 {
    pub codeSize: _u32,
    pub codeData: *mut _u32,
    pub opdescSize: _u32,
    pub opcdescData: *mut _u32,
}
impl ::std::clone::Clone for Struct_Unnamed84 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed84 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type DVLP_s = Struct_Unnamed84;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed85 {
    pub _type: _u16,
    pub id: _u16,
    pub data: [_u32; 4usize],
}
impl ::std::clone::Clone for Struct_Unnamed85 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed85 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type DVLE_constEntry_s = Struct_Unnamed85;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed86 {
    pub _type: _u16,
    pub regID: _u16,
    pub mask: _u8,
    pub unk: [_u8; 3usize],
}
impl ::std::clone::Clone for Struct_Unnamed86 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed86 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type DVLE_outEntry_s = Struct_Unnamed86;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed87 {
    pub symbolOffset: _u32,
    pub startReg: _u16,
    pub endReg: _u16,
}
impl ::std::clone::Clone for Struct_Unnamed87 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed87 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type DVLE_uniformEntry_s = Struct_Unnamed87;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed88 {
    pub _type: DVLE_type,
    pub dvlp: *mut DVLP_s,
    pub mainOffset: _u32,
    pub endmainOffset: _u32,
    pub constTableSize: _u32,
    pub constTableData: *mut DVLE_constEntry_s,
    pub outTableSize: _u32,
    pub outTableData: *mut DVLE_outEntry_s,
    pub uniformTableSize: _u32,
    pub uniformTableData: *mut DVLE_uniformEntry_s,
    pub symbolTableData: *mut ::libc::c_char,
    pub outmapMask: _u8,
    pub outmapData: [_u32; 8usize],
}
impl ::std::clone::Clone for Struct_Unnamed88 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed88 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type DVLE_s = Struct_Unnamed88;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed89 {
    pub numDVLE: _u32,
    pub DVLP: DVLP_s,
    pub DVLE: *mut DVLE_s,
}
impl ::std::clone::Clone for Struct_Unnamed89 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed89 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type DVLB_s = Struct_Unnamed89;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed90 {
    pub id: _u32,
    pub data: [_u32; 3usize],
}
impl ::std::clone::Clone for Struct_Unnamed90 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed90 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type float24Uniform_s = Struct_Unnamed90;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed91 {
    pub dvle: *mut DVLE_s,
    pub boolUniforms: _u16,
    pub intUniforms: [_u32; 4usize],
    pub float24Uniforms: *mut float24Uniform_s,
    pub numFloat24Uniforms: _u8,
}
impl ::std::clone::Clone for Struct_Unnamed91 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed91 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type shaderInstance_s = Struct_Unnamed91;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed92 {
    pub vertexShader: *mut shaderInstance_s,
    pub geometryShader: *mut shaderInstance_s,
    pub geometryShaderInputStride: _u8,
}
impl ::std::clone::Clone for Struct_Unnamed92 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed92 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type shaderProgram_s = Struct_Unnamed92;
extern "C" {
    pub static mut gfxTopLeftFramebuffers: [*mut _u8; 2usize];
    pub static mut gfxTopRightFramebuffers: [*mut _u8; 2usize];
    pub static mut gfxBottomFramebuffers: [*mut _u8; 2usize];
    pub static mut gxCmdBuf: *mut _u32;
    pub static mut aptEvents: [Handle; 3usize];
    pub static mut csndSharedMem: *mut vu32;
    pub static mut csndSharedMemSize: _u32;
    pub static mut csndChannels: _u32;
    pub static mut hidMemHandle: Handle;
    pub static mut hidSharedMem: *mut vu32;
    pub static mut irrstMemHandle: Handle;
    pub static mut irrstSharedMem: *mut vu32;
}
extern "C" {
    pub fn svcControlMemory(addr_out: *mut _u32, addr0: _u32, addr1: _u32,
                            size: _u32, op: MemOp, perm: MemPerm) -> s32;
    pub fn svcQueryMemory(info: *mut MemInfo, out: *mut PageInfo, addr: _u32)
     -> s32;
    pub fn svcExitProcess() -> ();
    pub fn svcCreateThread(thread: *mut Handle, entrypoint: ThreadFunc,
                           arg: _u32, stack_top: *mut _u32,
                           thread_priority: s32, processor_id: s32) -> s32;
    pub fn svcExitThread() -> ();
    pub fn svcSleepThread(ns: s64) -> ();
    pub fn svcSetThreadPriority(thread: Handle, prio: s32) -> s32;
    pub fn svcCreateMutex(mutex: *mut Handle, initially_locked: u8) -> s32;
    pub fn svcReleaseMutex(handle: Handle) -> s32;
    pub fn svcCreateSemaphore(semaphore: *mut Handle, initial_count: s32,
                              max_count: s32) -> s32;
    pub fn svcReleaseSemaphore(count: *mut s32, semaphore: Handle,
                               release_count: s32) -> s32;
    pub fn svcCreateEvent(event: *mut Handle, reset_type: _u8) -> s32;
    pub fn svcSignalEvent(handle: Handle) -> s32;
    pub fn svcClearEvent(handle: Handle) -> s32;
    pub fn svcCreateTimer(timer: *mut Handle, reset_type: _u8) -> s32;
    pub fn svcSetTimer(timer: Handle, initial: s64, interval: s64) -> s32;
    pub fn svcCancelTimer(timer: Handle) -> s32;
    pub fn svcClearTimer(timer: Handle) -> s32;
    pub fn svcCreateMemoryBlock(memblock: *mut Handle, addr: _u32, size: _u32,
                                my_perm: MemPerm, other_perm: MemPerm) -> s32;
    pub fn svcMapMemoryBlock(memblock: Handle, addr: _u32, my_perm: MemPerm,
                             other_perm: MemPerm) -> s32;
    pub fn svcUnmapMemoryBlock(memblock: Handle, addr: _u32) -> s32;
    pub fn svcCreateAddressArbiter(arbiter: *mut Handle) -> s32;
    pub fn svcArbitrateAddress(arbiter: Handle, addr: _u32,
                               _type: ArbitrationType, value: s32,
                               nanoseconds: s64) -> s32;
    pub fn svcWaitSynchronization(handle: Handle, nanoseconds: s64) -> s32;
    pub fn svcWaitSynchronizationN(out: *mut s32, handles: *mut Handle,
                                   handles_num: s32, wait_all: u8,
                                   nanoseconds: s64) -> s32;
    pub fn svcCloseHandle(handle: Handle) -> s32;
    pub fn svcDuplicateHandle(out: *mut Handle, original: Handle) -> s32;
    pub fn svcGetSystemTick() -> u64;
    pub fn svcGetSystemInfo(out: *mut s64, _type: _u32, param: s32) -> s32;
    pub fn svcGetProcessInfo(out: *mut s64, process: Handle, _type: _u32)
     -> s32;
    pub fn svcConnectToPort(out: *mut Handle, portName: *const ::libc::c_char)
     -> s32;
    pub fn svcSendSyncRequest(session: Handle) -> s32;
    pub fn svcOpenProcess(process: *mut Handle, processId: _u32) -> Result;
    pub fn svcGetProcessId(out: *mut _u32, handle: Handle) -> s32;
    pub fn svcGetThreadId(out: *mut _u32, handle: Handle) -> s32;
    pub fn svcOutputDebugString(str: *const ::libc::c_char,
                                length: ::libc::c_int) -> s32;
    pub fn svcCreatePort(portServer: *mut Handle, portClient: *mut Handle,
                         name: *const ::libc::c_char, maxSessions: s32)
     -> Result;
    pub fn svcDebugActiveProcess(debug: *mut Handle, processId: _u32)
     -> Result;
    pub fn svcBreakDebugProcess(debug: Handle) -> Result;
    pub fn svcTerminateDebugProcess(debug: Handle) -> Result;
    pub fn svcGetProcessDebugEvent(info: *mut DebugEventInfo, debug: Handle)
     -> Result;
    pub fn svcContinueDebugEvent(debug: Handle, flags: _u32) -> Result;
    pub fn svcGetProcessList(processCount: *mut s32, processIds: *mut _u32,
                             processIdMaxCount: s32) -> Result;
    pub fn svcReadProcessMemory(buffer: *mut ::libc::c_void, debug: Handle,
                                addr: _u32, size: _u32) -> Result;
    pub fn svcMapProcessMemory(process: Handle, startAddr: _u32,
                               endAddr: _u32) -> Result;
    pub fn svcUnmapProcessMemory(process: Handle, startAddr: _u32,
                                 endAddr: _u32) -> Result;
    pub fn svcQueryProcessMemory(info: *mut MemInfo, out: *mut PageInfo,
                                 process: Handle, addr: _u32) -> Result;
    pub fn svcGetProcessorID() -> s32;
    pub fn srvInit() -> Result;
    pub fn srvExit() -> Result;
    pub fn srvRegisterClient() -> Result;
    pub fn srvGetServiceHandle(out: *mut Handle, name: *const ::libc::c_char)
     -> Result;
    pub fn srvPmInit() -> Result;
    pub fn srvRegisterProcess(procid: _u32, count: _u32,
                              serviceaccesscontrol: *mut ::libc::c_void)
     -> Result;
    pub fn srvUnregisterProcess(procid: _u32) -> Result;
    pub fn linearAlloc(size: size_t) -> *mut ::libc::c_void;
    pub fn linearMemAlign(size: size_t, alignment: size_t)
     -> *mut ::libc::c_void;
    pub fn linearRealloc(mem: *mut ::libc::c_void, size: size_t)
     -> *mut ::libc::c_void;
    pub fn linearFree(mem: *mut ::libc::c_void) -> ();
    pub fn linearSpaceFree() -> _u32;
    pub fn vramAlloc(size: size_t) -> *mut ::libc::c_void;
    pub fn vramMemAlign(size: size_t, alignment: size_t)
     -> *mut ::libc::c_void;
    pub fn vramRealloc(mem: *mut ::libc::c_void, size: size_t)
     -> *mut ::libc::c_void;
    pub fn vramFree(mem: *mut ::libc::c_void) -> ();
    pub fn vramSpaceFree() -> _u32;
    pub fn osConvertVirtToPhys(vaddr: _u32) -> _u32;
    pub fn osConvertOldLINEARMemToNew(addr: _u32) -> _u32;
    pub fn osStrError(error: _u32) -> *const ::libc::c_char;
    pub fn osGetFirmVersion() -> _u32;
    pub fn osGetKernelVersion() -> _u32;
    pub fn osGetTime() -> u64;
    pub fn gspInit() -> Result;
    pub fn gspExit() -> ();
    pub fn gspInitEventHandler(gspEvent: Handle, gspSharedMem: *mut vu8,
                               gspThreadId: _u8) -> Result;
    pub fn gspExitEventHandler() -> ();
    pub fn gspWaitForEvent(id: GSP_Event, nextEvent: u8) -> ();
    pub fn GSPGPU_AcquireRight(handle: *mut Handle, flags: _u8) -> Result;
    pub fn GSPGPU_ReleaseRight(handle: *mut Handle) -> Result;
    pub fn GSPGPU_ImportDisplayCaptureInfo(handle: *mut Handle,
                                           captureinfo: *mut GSP_CaptureInfo)
     -> Result;
    pub fn GSPGPU_SaveVramSysArea(handle: *mut Handle) -> Result;
    pub fn GSPGPU_RestoreVramSysArea(handle: *mut Handle) -> Result;
    pub fn GSPGPU_SetLcdForceBlack(handle: *mut Handle, flags: _u8) -> Result;
    pub fn GSPGPU_SetBufferSwap(handle: *mut Handle, screenid: _u32,
                                framebufinfo: *mut GSP_FramebufferInfo)
     -> Result;
    pub fn GSPGPU_FlushDataCache(handle: *mut Handle, adr: *mut _u8,
                                 size: _u32) -> Result;
    pub fn GSPGPU_InvalidateDataCache(handle: *mut Handle, adr: *mut _u8,
                                      size: _u32) -> Result;
    pub fn GSPGPU_WriteHWRegs(handle: *mut Handle, regAddr: _u32,
                              data: *mut _u32, size: _u8) -> Result;
    pub fn GSPGPU_WriteHWRegsWithMask(handle: *mut Handle, regAddr: _u32,
                                      data: *mut _u32, datasize: _u8,
                                      maskdata: *mut _u32, masksize: _u8)
     -> Result;
    pub fn GSPGPU_ReadHWRegs(handle: *mut Handle, regAddr: _u32,
                             data: *mut _u32, size: _u8) -> Result;
    pub fn GSPGPU_RegisterInterruptRelayQueue(handle: *mut Handle,
                                              eventHandle: Handle,
                                              flags: _u32,
                                              outMemHandle: *mut Handle,
                                              threadID: *mut _u8) -> Result;
    pub fn GSPGPU_UnregisterInterruptRelayQueue(handle: *mut Handle)
     -> Result;
    pub fn GSPGPU_TriggerCmdReqQueue(handle: *mut Handle) -> Result;
    pub fn GSPGPU_SubmitGxCommand(sharedGspCmdBuf: *mut _u32,
                                  gxCommand: *mut _u32, handle: *mut Handle)
     -> Result;
    pub fn gfxInitDefault() -> ();
    pub fn gfxInit(topFormat: GSP_FramebufferFormats,
                   bottomFormat: GSP_FramebufferFormats, vrambuffers: u8)
     -> ();
    pub fn gfxExit() -> ();
    pub fn gfxSet3D(enable: u8) -> ();
    pub fn gfxSetScreenFormat(screen: gfxScreen_t,
                              format: GSP_FramebufferFormats) -> ();
    pub fn gfxGetScreenFormat(screen: gfxScreen_t) -> GSP_FramebufferFormats;
    pub fn gfxSetDoubleBuffering(screen: gfxScreen_t, doubleBuffering: u8)
     -> ();
    pub fn gfxFlushBuffers() -> ();
    pub fn gfxSwapBuffers() -> ();
    pub fn gfxSwapBuffersGpu() -> ();
    pub fn gfxGetFramebuffer(screen: gfxScreen_t, side: gfx3dSide_t,
                             width: *mut _u16, height: *mut _u16) -> *mut _u8;
    pub fn consoleSetFont(console: *mut PrintConsole, font: *mut ConsoleFont)
     -> ();
    pub fn consoleSetWindow(console: *mut PrintConsole, x: ::libc::c_int,
                            y: ::libc::c_int, width: ::libc::c_int,
                            height: ::libc::c_int) -> ();
    pub fn consoleGetDefault() -> *mut PrintConsole;
    pub fn consoleSelect(console: *mut PrintConsole) -> *mut PrintConsole;
    pub fn consoleInit(screen: gfxScreen_t, console: *mut PrintConsole)
     -> *mut PrintConsole;
    pub fn consoleDebugInit(device: debugDevice) -> ();
    pub fn consoleClear() -> ();
    pub fn decode_utf8(out: *mut uint32_t, _in: *const uint8_t) -> ssize_t;
    pub fn decode_utf16(out: *mut uint32_t, _in: *const uint16_t) -> ssize_t;
    pub fn encode_utf8(out: *mut uint8_t, _in: uint32_t) -> ssize_t;
    pub fn encode_utf16(out: *mut uint16_t, _in: uint32_t) -> ssize_t;
    pub fn utf8_to_utf16(out: *mut uint16_t, _in: *const uint8_t, len: size_t)
     -> size_t;
    pub fn utf8_to_utf32(out: *mut uint32_t, _in: *const uint8_t, len: size_t)
     -> size_t;
    pub fn utf16_to_utf8(out: *mut uint8_t, _in: *const uint16_t, len: size_t)
     -> size_t;
    pub fn utf16_to_utf32(out: *mut uint32_t, _in: *const uint16_t,
                          len: size_t) -> size_t;
    pub fn utf32_to_utf8(out: *mut uint8_t, _in: *const uint32_t, len: size_t)
     -> size_t;
    pub fn utf32_to_utf16(out: *mut uint16_t, _in: *const uint32_t,
                          len: size_t) -> size_t;
    pub fn acInit() -> Result;
    pub fn acExit() -> Result;
    pub fn ACU_GetWifiStatus(servhandle: *mut Handle, out: *mut _u32)
     -> Result;
    pub fn ACU_WaitInternetConnection() -> Result;
    pub fn amInit() -> Result;
    pub fn amExit() -> Result;
    pub fn AM_GetTitleCount(mediatype: _u8, count: *mut _u32) -> Result;
    pub fn AM_GetTitleIdList(mediatype: _u8, count: _u32, titleIDs: *mut u64)
     -> Result;
    pub fn AM_GetDeviceId(deviceID: *mut _u32) -> Result;
    pub fn AM_ListTitles(mediatype: _u8, titleCount: _u32,
                         titleIdList: *mut u64, titleList: *mut TitleList)
     -> Result;
    pub fn AM_StartCiaInstall(mediatype: _u8, ciaHandle: *mut Handle)
     -> Result;
    pub fn AM_StartDlpChildCiaInstall(ciaHandle: *mut Handle) -> Result;
    pub fn AM_CancelCIAInstall(ciaHandle: *mut Handle) -> Result;
    pub fn AM_FinishCiaInstall(mediatype: _u8, ciaHandle: *mut Handle)
     -> Result;
    pub fn AM_DeleteTitle(mediatype: _u8, titleID: u64) -> Result;
    pub fn AM_DeleteAppTitle(mediatype: _u8, titleID: u64) -> Result;
    pub fn AM_InstallFIRM(titleID: u64) -> Result;
    pub fn AM_GetTitleProductCode(mediatype: _u8, titleID: u64,
                                  productCode: *mut ::libc::c_char) -> Result;
    pub fn aptInit() -> Result;
    pub fn aptExit() -> ();
    pub fn aptOpenSession() -> ();
    pub fn aptCloseSession() -> ();
    pub fn aptSetStatus(status: APP_STATUS) -> ();
    pub fn aptGetStatus() -> APP_STATUS;
    pub fn aptGetStatusPower() -> _u32;
    pub fn aptSetStatusPower(status: _u32) -> ();
    pub fn aptReturnToMenu() -> ();
    pub fn aptWaitStatusEvent() -> ();
    pub fn aptSignalReadyForSleep() -> ();
    pub fn aptGetMenuAppID() -> NS_APPID;
    pub fn aptMainLoop() -> u8;
    pub fn APT_GetLockHandle(handle: *mut Handle, flags: _u16,
                             lockHandle: *mut Handle) -> Result;
    pub fn APT_Initialize(handle: *mut Handle, appId: NS_APPID,
                          eventHandle1: *mut Handle,
                          eventHandle2: *mut Handle) -> Result;
    pub fn APT_HardwareResetAsync(handle: *mut Handle) -> Result;
    pub fn APT_Enable(handle: *mut Handle, a: _u32) -> Result;
    pub fn APT_GetAppletManInfo(handle: *mut Handle, inval: _u8,
                                outval8: *mut _u8, outval32: *mut _u32,
                                menu_appid: *mut NS_APPID,
                                active_appid: *mut NS_APPID) -> Result;
    pub fn APT_PrepareToJumpToHomeMenu(handle: *mut Handle) -> Result;
    pub fn APT_JumpToHomeMenu(handle: *mut Handle, a: _u32, b: _u32, c: _u32)
     -> Result;
    pub fn APT_IsRegistered(handle: *mut Handle, appID: NS_APPID,
                            out: *mut _u8) -> Result;
    pub fn APT_InquireNotification(handle: *mut Handle, appID: _u32,
                                   signalType: *mut _u8) -> Result;
    pub fn APT_NotifyToWait(handle: *mut Handle, appID: NS_APPID) -> Result;
    pub fn APT_AppletUtility(handle: *mut Handle, out: *mut _u32, a: _u32,
                             size1: _u32, buf1: *mut _u8, size2: _u32,
                             buf2: *mut _u8) -> Result;
    pub fn APT_GlanceParameter(handle: *mut Handle, appID: NS_APPID,
                               bufferSize: _u32, buffer: *mut _u32,
                               actualSize: *mut _u32, signalType: *mut _u8)
     -> Result;
    pub fn APT_ReceiveParameter(handle: *mut Handle, appID: NS_APPID,
                                bufferSize: _u32, buffer: *mut _u32,
                                actualSize: *mut _u32, signalType: *mut _u8)
     -> Result;
    pub fn APT_SendParameter(handle: *mut Handle, src_appID: NS_APPID,
                             dst_appID: NS_APPID, bufferSize: _u32,
                             buffer: *mut _u32, paramhandle: Handle,
                             signalType: _u8) -> Result;
    pub fn APT_SendCaptureBufferInfo(handle: *mut Handle, bufferSize: _u32,
                                     buffer: *mut _u32) -> Result;
    pub fn APT_ReplySleepQuery(handle: *mut Handle, appID: NS_APPID, a: _u32)
     -> Result;
    pub fn APT_ReplySleepNotificationComplete(handle: *mut Handle,
                                              appID: NS_APPID) -> Result;
    pub fn APT_PrepareToCloseApplication(handle: *mut Handle, a: _u8)
     -> Result;
    pub fn APT_CloseApplication(handle: *mut Handle, a: _u32, b: _u32,
                                c: _u32) -> Result;
    pub fn APT_SetAppCpuTimeLimit(handle: *mut Handle, percent: _u32)
     -> Result;
    pub fn APT_GetAppCpuTimeLimit(handle: *mut Handle, percent: *mut _u32)
     -> Result;
    pub fn APT_CheckNew3DS_Application(handle: *mut Handle, out: *mut _u8)
     -> Result;
    pub fn APT_CheckNew3DS_System(handle: *mut Handle, out: *mut _u8)
     -> Result;
    pub fn APT_CheckNew3DS(handle: *mut Handle, out: *mut _u8) -> Result;
    pub fn APT_PrepareToDoAppJump(handle: *mut Handle, flags: _u8,
                                  programID: u64, mediatype: _u8) -> Result;
    pub fn APT_DoAppJump(handle: *mut Handle, NSbuf0Size: _u32,
                         NSbuf1Size: _u32, NSbuf0Ptr: *mut _u8,
                         NSbuf1Ptr: *mut _u8) -> Result;
    pub fn APT_PrepareToStartLibraryApplet(handle: *mut Handle,
                                           appID: NS_APPID) -> Result;
    pub fn APT_StartLibraryApplet(handle: *mut Handle, appID: NS_APPID,
                                  inhandle: Handle, parambuf: *mut _u32,
                                  parambufsize: _u32) -> Result;
    pub fn APT_LaunchLibraryApplet(appID: NS_APPID, inhandle: Handle,
                                   parambuf: *mut _u32, parambufsize: _u32)
     -> Result;
    pub fn APT_PrepareToStartSystemApplet(handle: *mut Handle,
                                          appID: NS_APPID) -> Result;
    pub fn APT_StartSystemApplet(handle: *mut Handle, appID: NS_APPID,
                                 bufSize: _u32, applHandle: Handle,
                                 buf: *mut _u8) -> Result;
    pub fn CFGNOR_Initialize(value: _u8) -> Result;
    pub fn CFGNOR_Shutdown() -> Result;
    pub fn CFGNOR_ReadData(offset: _u32, buf: *mut _u32, size: _u32)
     -> Result;
    pub fn CFGNOR_WriteData(offset: _u32, buf: *mut _u32, size: _u32)
     -> Result;
    pub fn CFGNOR_DumpFlash(buf: *mut _u32, size: _u32) -> Result;
    pub fn CFGNOR_WriteFlash(buf: *mut _u32, size: _u32) -> Result;
    pub fn initCfgu() -> Result;
    pub fn exitCfgu() -> Result;
    pub fn CFGU_SecureInfoGetRegion(region: *mut _u8) -> Result;
    pub fn CFGU_GenHashConsoleUnique(appIDSalt: _u32, hash: *mut u64)
     -> Result;
    pub fn CFGU_GetRegionCanadaUSA(value: *mut _u8) -> Result;
    pub fn CFGU_GetSystemModel(model: *mut _u8) -> Result;
    pub fn CFGU_GetModelNintendo2DS(value: *mut _u8) -> Result;
    pub fn CFGU_GetCountryCodeString(code: _u16, string: *mut _u16) -> Result;
    pub fn CFGU_GetCountryCodeID(string: _u16, code: *mut _u16) -> Result;
    pub fn CFGU_GetConfigInfoBlk2(size: _u32, blkID: _u32, outData: *mut _u8)
     -> Result;
    pub fn CFGU_GetSystemLanguage(language: *mut _u8) -> Result;
    pub fn CSND_AcquireCapUnit(capUnit: *mut _u32) -> Result;
    pub fn CSND_ReleaseCapUnit(capUnit: _u32) -> Result;
    pub fn csndInit() -> Result;
    pub fn csndExit() -> Result;
    pub fn csndWriteCmd(cmdid: ::libc::c_int, cmdparams: *mut _u8) -> ();
    pub fn csndExecCmds(waitDone: u8) -> Result;
    pub fn CSND_SetPlayStateR(channel: _u32, value: _u32) -> ();
    pub fn CSND_SetPlayState(channel: _u32, value: _u32) -> ();
    pub fn CSND_SetBlock(channel: _u32, block: ::libc::c_int, physaddr: _u32,
                         size: _u32) -> ();
    pub fn CSND_SetVol(channel: _u32, left: _u16, right: _u16) -> ();
    pub fn CSND_SetTimer(channel: _u32, timer: _u32) -> ();
    pub fn CSND_SetDuty(channel: _u32, duty: _u32) -> ();
    pub fn CSND_SetAdpcmState(channel: _u32, block: ::libc::c_int,
                              sample: ::libc::c_int, index: ::libc::c_int)
     -> ();
    pub fn CSND_SetAdpcmReload(channel: _u32, reload: u8) -> ();
    pub fn CSND_SetChnRegs(flags: _u32, physaddr0: _u32, physaddr1: _u32,
                           totalbytesize: _u32) -> ();
    pub fn CSND_CapEnable(capUnit: _u32, enable: u8) -> ();
    pub fn CSND_CapSetBit(capUnit: _u32, bit: ::libc::c_int, state: u8) -> ();
    pub fn CSND_CapSetTimer(capUnit: _u32, timer: _u32) -> ();
    pub fn CSND_CapSetBuffer(capUnit: _u32, paddr: _u32, size: _u32) -> ();
    pub fn CSND_UpdateInfo(waitDone: u8) -> Result;
    pub fn csndPlaySound(chn: ::libc::c_int, flags: _u32, sampleRate: _u32,
                         data0: *mut ::libc::c_void,
                         data1: *mut ::libc::c_void, size: _u32) -> Result;
    pub fn csndGetChnInfo(channel: _u32) -> *mut CSND_ChnInfo;
    pub fn csndGetState(channel: _u32, out: *mut CSND_ChnInfo) -> Result;
    pub fn csndIsPlaying(channel: _u32, status: *mut _u8) -> Result;
    pub fn fsInit() -> Result;
    pub fn fsExit() -> Result;
    pub fn FS_makePath(_type: FS_pathType, path: *const ::libc::c_char)
     -> FS_path;
    pub fn FSUSER_Initialize(handle: *mut Handle) -> Result;
    pub fn FSUSER_OpenArchive(handle: *mut Handle, archive: *mut FS_archive)
     -> Result;
    pub fn FSUSER_OpenDirectory(handle: *mut Handle, out: *mut Handle,
                                archive: FS_archive, dirLowPath: FS_path)
     -> Result;
    pub fn FSUSER_OpenFile(handle: *mut Handle, out: *mut Handle,
                           archive: FS_archive, fileLowPath: FS_path,
                           openflags: _u32, attributes: _u32) -> Result;
    pub fn FSUSER_OpenFileDirectly(handle: *mut Handle, out: *mut Handle,
                                   archive: FS_archive, fileLowPath: FS_path,
                                   openflags: _u32, attributes: _u32)
     -> Result;
    pub fn FSUSER_CloseArchive(handle: *mut Handle, archive: *mut FS_archive)
     -> Result;
    pub fn FSUSER_CreateFile(handle: *mut Handle, archive: FS_archive,
                             fileLowPath: FS_path, fileSize: _u32) -> Result;
    pub fn FSUSER_CreateDirectory(handle: *mut Handle, archive: FS_archive,
                                  dirLowPath: FS_path) -> Result;
    pub fn FSUSER_DeleteFile(handle: *mut Handle, archive: FS_archive,
                             fileLowPath: FS_path) -> Result;
    pub fn FSUSER_DeleteDirectory(handle: *mut Handle, archive: FS_archive,
                                  dirLowPath: FS_path) -> Result;
    pub fn FSUSER_RenameFile(handle: *mut Handle, srcArchive: FS_archive,
                             srcFileLowPath: FS_path, destArchive: FS_archive,
                             destFileLowPath: FS_path) -> Result;
    pub fn FSUSER_RenameDirectory(handle: *mut Handle, srcArchive: FS_archive,
                                  srcDirLowPath: FS_path,
                                  destArchive: FS_archive,
                                  destDirLowPath: FS_path) -> Result;
    pub fn FSUSER_GetSdmcArchiveResource(handle: *mut Handle,
                                         sectorSize: *mut _u32,
                                         clusterSize: *mut _u32,
                                         numClusters: *mut _u32,
                                         freeClusters: *mut _u32) -> Result;
    pub fn FSUSER_GetNandArchiveResource(handle: *mut Handle,
                                         sectorSize: *mut _u32,
                                         clusterSize: *mut _u32,
                                         numClusters: *mut _u32,
                                         freeClusters: *mut _u32) -> Result;
    pub fn FSUSER_IsSdmcDetected(handle: *mut Handle, detected: *mut _u8)
     -> Result;
    pub fn FSUSER_IsSdmcWritable(handle: *mut Handle, writable: *mut _u8)
     -> Result;
    pub fn FSFILE_Close(handle: Handle) -> Result;
    pub fn FSFILE_Read(handle: Handle, bytesRead: *mut _u32, offset: u64,
                       buffer: *mut ::libc::c_void, size: _u32) -> Result;
    pub fn FSFILE_Write(handle: Handle, bytesWritten: *mut _u32, offset: u64,
                        buffer: *const ::libc::c_void, size: _u32,
                        flushFlags: _u32) -> Result;
    pub fn FSFILE_GetSize(handle: Handle, size: *mut u64) -> Result;
    pub fn FSFILE_SetSize(handle: Handle, size: u64) -> Result;
    pub fn FSFILE_GetAttributes(handle: Handle, attributes: *mut _u32)
     -> Result;
    pub fn FSFILE_SetAttributes(handle: Handle, attributes: _u32) -> Result;
    pub fn FSFILE_Flush(handle: Handle) -> Result;
    pub fn FSDIR_Read(handle: Handle, entriesRead: *mut _u32,
                      entrycount: _u32, buffer: *mut FS_dirent) -> Result;
    pub fn FSDIR_Close(handle: Handle) -> Result;
    pub fn hidInit(sharedMem: *mut _u32) -> Result;
    pub fn hidExit() -> ();
    pub fn hidScanInput() -> ();
    pub fn hidKeysHeld() -> _u32;
    pub fn hidKeysDown() -> _u32;
    pub fn hidKeysUp() -> _u32;
    pub fn hidTouchRead(pos: *mut touchPosition) -> ();
    pub fn hidCircleRead(pos: *mut circlePosition) -> ();
    pub fn hidAccelRead(vector: *mut accelVector) -> ();
    pub fn hidGyroRead(rate: *mut angularRate) -> ();
    pub fn hidWaitForEvent(id: HID_Event, nextEvent: u8) -> ();
    pub fn HIDUSER_GetHandles(outMemHandle: *mut Handle,
                              eventpad0: *mut Handle, eventpad1: *mut Handle,
                              eventaccel: *mut Handle, eventgyro: *mut Handle,
                              eventdebugpad: *mut Handle) -> Result;
    pub fn HIDUSER_EnableAccelerometer() -> Result;
    pub fn HIDUSER_DisableAccelerometer() -> Result;
    pub fn HIDUSER_EnableGyroscope() -> Result;
    pub fn HIDUSER_DisableGyroscope() -> Result;
    pub fn HIDUSER_GetGyroscopeRawToDpsCoefficient(coeff:
                                                       *mut ::libc::c_float)
     -> Result;
    pub fn HIDUSER_GetSoundVolume(volume: *mut _u8) -> Result;
    pub fn irrstInit(sharedMem: *mut _u32) -> Result;
    pub fn irrstExit() -> ();
    pub fn irrstScanInput() -> ();
    pub fn irrstKeysHeld() -> _u32;
    pub fn irrstCstickRead(pos: *mut circlePosition) -> ();
    pub fn irrstWaitForEvent(nextEvent: u8) -> ();
    pub fn IRRST_GetHandles(outMemHandle: *mut Handle,
                            outEventHandle: *mut Handle) -> Result;
    pub fn IRRST_Initialize(unk1: _u32, unk2: _u8) -> Result;
    pub fn IRRST_Shutdown() -> Result;
    pub fn httpcInit() -> Result;
    pub fn httpcExit() -> ();
    pub fn httpcOpenContext(context: *mut httpcContext,
                            url: *mut ::libc::c_char, use_defaultproxy: _u32)
     -> Result;
    pub fn httpcCloseContext(context: *mut httpcContext) -> Result;
    pub fn httpcBeginRequest(context: *mut httpcContext) -> Result;
    pub fn httpcReceiveData(context: *mut httpcContext, buffer: *mut _u8,
                            size: _u32) -> Result;
    pub fn httpcGetRequestState(context: *mut httpcContext,
                                out: *mut httpcReqStatus) -> Result;
    pub fn httpcGetDownloadSizeState(context: *mut httpcContext,
                                     downloadedsize: *mut _u32,
                                     contentsize: *mut _u32) -> Result;
    pub fn httpcGetResponseStatusCode(context: *mut httpcContext,
                                      out: *mut _u32, delay: u64) -> Result;
    pub fn httpcDownloadData(context: *mut httpcContext, buffer: *mut _u8,
                             size: _u32, downloadedsize: *mut _u32) -> Result;
    pub fn HTTPC_Initialize(handle: Handle) -> Result;
    pub fn HTTPC_InitializeConnectionSession(handle: Handle,
                                             contextHandle: Handle) -> Result;
    pub fn HTTPC_CreateContext(handle: Handle, url: *mut ::libc::c_char,
                               contextHandle: *mut Handle) -> Result;
    pub fn HTTPC_CloseContext(handle: Handle, contextHandle: Handle)
     -> Result;
    pub fn HTTPC_SetProxyDefault(handle: Handle, contextHandle: Handle)
     -> Result;
    pub fn HTTPC_AddRequestHeaderField(handle: Handle, contextHandle: Handle,
                                       name: *mut ::libc::c_char,
                                       value: *mut ::libc::c_char) -> Result;
    pub fn HTTPC_BeginRequest(handle: Handle, contextHandle: Handle)
     -> Result;
    pub fn HTTPC_ReceiveData(handle: Handle, contextHandle: Handle,
                             buffer: *mut _u8, size: _u32) -> Result;
    pub fn HTTPC_GetRequestState(handle: Handle, contextHandle: Handle,
                                 out: *mut httpcReqStatus) -> Result;
    pub fn HTTPC_GetDownloadSizeState(handle: Handle, contextHandle: Handle,
                                      downloadedsize: *mut _u32,
                                      contentsize: *mut _u32) -> Result;
    pub fn HTTPC_GetResponseStatusCode(handle: Handle, contextHandle: Handle,
                                       out: *mut _u32) -> Result;
    pub fn IRU_Initialize(sharedmem_addr: *mut _u32, sharedmem_size: _u32)
     -> Result;
    pub fn IRU_Shutdown() -> Result;
    pub fn IRU_GetServHandle() -> Handle;
    pub fn IRU_SendData(buf: *mut _u8, size: _u32, wait: _u32) -> Result;
    pub fn IRU_RecvData(buf: *mut _u8, size: _u32, flag: _u8,
                        transfercount: *mut _u32, wait: _u32) -> Result;
    pub fn IRU_SetBitRate(value: _u8) -> Result;
    pub fn IRU_GetBitRate(out: *mut _u8) -> Result;
    pub fn IRU_SetIRLEDState(value: _u32) -> Result;
    pub fn IRU_GetIRLEDRecvState(out: *mut _u32) -> Result;
    pub fn nsInit() -> Result;
    pub fn nsExit() -> Result;
    pub fn NS_LaunchTitle(titleid: u64, launch_flags: _u32, procid: *mut _u32)
     -> Result;
    pub fn NS_RebootToTitle(mediatype: _u8, titleid: u64) -> Result;
    pub fn pmInit() -> Result;
    pub fn pmExit() -> Result;
    pub fn PM_LaunchTitle(mediatype: _u8, titleid: u64, launch_flags: _u32)
     -> Result;
    pub fn PM_GetTitleExheaderFlags(mediatype: _u8, titleid: u64,
                                    out: *mut _u8) -> Result;
    pub fn PM_SetFIRMLaunchParams(size: _u32, _in: *mut _u8) -> Result;
    pub fn PM_GetFIRMLaunchParams(size: _u32, out: *mut _u8) -> Result;
    pub fn PM_LaunchFIRMSetParams(firm_titleid_low: _u32, size: _u32,
                                  _in: *mut _u8) -> Result;
    pub fn psInit() -> Result;
    pub fn psExit() -> Result;
    pub fn PS_EncryptDecryptAes(size: _u32, _in: *mut _u8, out: *mut _u8,
                                aes_algo: _u32, key_type: _u32, iv: *mut _u8)
     -> Result;
    pub fn PS_EncryptSignDecryptVerifyAesCcm(_in: *mut _u8, in_size: _u32,
                                             out: *mut _u8, out_size: _u32,
                                             data_len: _u32,
                                             mac_data_len: _u32,
                                             mac_len: _u32, aes_algo: _u32,
                                             key_type: _u32, nonce: *mut _u8)
     -> Result;
    pub fn PS_GetLocalFriendCodeSeed(seed: *mut u64) -> Result;
    pub fn PS_GetDeviceId(device_id: *mut _u32) -> Result;
    pub fn ptmInit() -> Result;
    pub fn ptmExit() -> Result;
    pub fn PTMU_GetShellState(servhandle: *mut Handle, out: *mut _u8)
     -> Result;
    pub fn PTMU_GetBatteryLevel(servhandle: *mut Handle, out: *mut _u8)
     -> Result;
    pub fn PTMU_GetBatteryChargeState(servhandle: *mut Handle, out: *mut _u8)
     -> Result;
    pub fn PTMU_GetPedometerState(servhandle: *mut Handle, out: *mut _u8)
     -> Result;
    pub fn PTMU_GetTotalStepCount(servhandle: *mut Handle, steps: *mut _u32)
     -> Result;
    pub fn SOC_Initialize(context_addr: *mut _u32, context_size: _u32)
     -> Result;
    pub fn SOC_Shutdown() -> Result;
    pub fn gethostid() -> ::libc::c_long;
    pub fn MIC_Initialize(sharedmem: *mut _u32, sharedmem_size: _u32,
                          control: _u8, recording: _u8, unk0: _u8, unk1: _u8,
                          unk2: _u8) -> Result;
    pub fn MIC_Shutdown() -> Result;
    pub fn MIC_GetSharedMemOffsetValue() -> _u32;
    pub fn MIC_ReadAudioData(outbuf: *mut _u8, readsize: _u32,
                             waitforevent: _u32) -> _u32;
    pub fn MIC_MapSharedMem(handle: Handle, size: _u32) -> Result;
    pub fn MIC_UnmapSharedMem() -> Result;
    pub fn MIC_cmd3_Initialize(unk0: _u8, unk1: _u8,
                               sharedmem_baseoffset: _u32,
                               sharedmem_endoffset: _u32, unk2: _u8)
     -> Result;
    pub fn MIC_cmd5() -> Result;
    pub fn MIC_GetCNTBit15(out: *mut _u8) -> Result;
    pub fn MIC_GetEventHandle(handle: *mut Handle) -> Result;
    pub fn MIC_SetControl(value: _u8) -> Result;
    pub fn MIC_GetControl(value: *mut _u8) -> Result;
    pub fn MIC_SetRecording(value: _u8) -> Result;
    pub fn MIC_IsRecoding(value: *mut _u8) -> Result;
    pub fn mvdstdGenerateDefaultConfig(config: *mut mvdstdConfig,
                                       input_width: _u32, input_height: _u32,
                                       output_width: _u32,
                                       output_height: _u32,
                                       vaddr_colorconv_indata: *mut _u32,
                                       vaddr_outdata0: *mut _u32,
                                       vaddr_outdata1_colorconv: *mut _u32)
     -> ();
    pub fn mvdstdInit(mode: mvdstdMode, input_type: mvdstdTypeInput,
                      output_type: mvdstdTypeOutput, size: _u32) -> Result;
    pub fn mvdstdShutdown() -> Result;
    pub fn mvdstdSetConfig(config: *mut mvdstdConfig) -> Result;
    pub fn mvdstdProcessFrame(config: *mut mvdstdConfig,
                              h264_vaddr_inframe: *mut _u32,
                              h264_inframesize: _u32, h264_frameid: _u32)
     -> Result;
    pub fn qtmInit() -> Result;
    pub fn qtmExit() -> ();
    pub fn qtmCheckInitialized() -> u8;
    pub fn qtmGetHeadtrackingInfo(val: u64, out: *mut qtmHeadtrackingInfo)
     -> Result;
    pub fn qtmCheckHeadFullyDetected(info: *mut qtmHeadtrackingInfo) -> u8;
    pub fn qtmConvertCoordToScreen(coord: *mut qtmHeadtrackingInfoCoord,
                                   screen_width: *mut ::libc::c_float,
                                   screen_height: *mut ::libc::c_float,
                                   x: *mut _u32, y: *mut _u32) -> Result;
    pub fn hbInit() -> Result;
    pub fn hbExit() -> ();
    pub fn HB_FlushInvalidateCache() -> Result;
    pub fn HB_GetBootloaderAddresses(load3dsx: *mut *mut ::libc::c_void,
                                     setArgv: *mut *mut ::libc::c_void)
     -> Result;
    pub fn HB_ReprotectMemory(addr: *mut _u32, pages: _u32, mode: _u32,
                              reprotectedPages: *mut _u32) -> Result;
    pub fn GX_RequestDma(gxbuf: *mut _u32, src: *mut _u32, dst: *mut _u32,
                         length: _u32) -> Result;
    pub fn GX_SetCommandList_Last(gxbuf: *mut _u32, buf0a: *mut _u32,
                                  buf0s: _u32, flags: _u8) -> Result;
    pub fn GX_SetMemoryFill(gxbuf: *mut _u32, buf0a: *mut _u32, buf0v: _u32,
                            buf0e: *mut _u32, width0: _u16, buf1a: *mut _u32,
                            buf1v: _u32, buf1e: *mut _u32, width1: _u16)
     -> Result;
    pub fn GX_SetDisplayTransfer(gxbuf: *mut _u32, inadr: *mut _u32,
                                 indim: _u32, outadr: *mut _u32, outdim: _u32,
                                 flags: _u32) -> Result;
    pub fn GX_SetTextureCopy(gxbuf: *mut _u32, inadr: *mut _u32, indim: _u32,
                             outadr: *mut _u32, outdim: _u32, size: _u32,
                             flags: _u32) -> Result;
    pub fn GX_SetCommandList_First(gxbuf: *mut _u32, buf0a: *mut _u32,
                                   buf0s: _u32, buf1a: *mut _u32, buf1s: _u32,
                                   buf2a: *mut _u32, buf2s: _u32) -> Result;
    pub fn GPU_Init(gsphandle: *mut Handle) -> ();
    pub fn GPU_Reset(gxbuf: *mut _u32, gpuBuf: *mut _u32, gpuBufSize: _u32)
     -> ();
    pub fn GPUCMD_SetBuffer(adr: *mut _u32, size: _u32, offset: _u32) -> ();
    pub fn GPUCMD_SetBufferOffset(offset: _u32) -> ();
    pub fn GPUCMD_GetBuffer(adr: *mut *mut _u32, size: *mut _u32,
                            offset: *mut _u32) -> ();
    pub fn GPUCMD_AddRawCommands(cmd: *mut _u32, size: _u32) -> ();
    pub fn GPUCMD_Run(gxbuf: *mut _u32) -> ();
    pub fn GPUCMD_FlushAndRun(gxbuf: *mut _u32) -> ();
    pub fn GPUCMD_Add(header: _u32, param: *mut _u32, paramlength: _u32)
     -> ();
    pub fn GPUCMD_Finalize() -> ();
    pub fn GPU_SetFloatUniform(_type: GPU_SHADER_TYPE, startreg: _u32,
                               data: *mut _u32, numreg: _u32) -> ();
    pub fn GPU_SetViewport(depthBuffer: *mut _u32, colorBuffer: *mut _u32,
                           x: _u32, y: _u32, w: _u32, h: _u32) -> ();
    pub fn GPU_SetScissorTest(mode: GPU_SCISSORMODE, x: _u32, y: _u32,
                              w: _u32, h: _u32) -> ();
    pub fn GPU_DepthMap(zScale: ::libc::c_float, zOffset: ::libc::c_float)
     -> ();
    pub fn GPU_SetAlphaTest(enable: u8, function: GPU_TESTFUNC, _ref: _u8)
     -> ();
    pub fn GPU_SetDepthTestAndWriteMask(enable: u8, function: GPU_TESTFUNC,
                                        writemask: GPU_WRITEMASK) -> ();
    pub fn GPU_SetStencilTest(enable: u8, function: GPU_TESTFUNC, _ref: _u8,
                              mask: _u8, replace: _u8) -> ();
    pub fn GPU_SetStencilOp(sfail: GPU_STENCILOP, dfail: GPU_STENCILOP,
                            pass: GPU_STENCILOP) -> ();
    pub fn GPU_SetFaceCulling(mode: GPU_CULLMODE) -> ();
    pub fn GPU_SetAlphaBlending(colorEquation: GPU_BLENDEQUATION,
                                alphaEquation: GPU_BLENDEQUATION,
                                colorSrc: GPU_BLENDFACTOR,
                                colorDst: GPU_BLENDFACTOR,
                                alphaSrc: GPU_BLENDFACTOR,
                                alphaDst: GPU_BLENDFACTOR) -> ();
    pub fn GPU_SetColorLogicOp(op: GPU_LOGICOP) -> ();
    pub fn GPU_SetBlendingColor(r: _u8, g: _u8, b: _u8, a: _u8) -> ();
    pub fn GPU_SetAttributeBuffers(totalAttributes: _u8,
                                   baseAddress: *mut _u32,
                                   attributeFormats: u64, attributeMask: _u16,
                                   attributePermutation: u64, numBuffers: _u8,
                                   bufferOffsets: *mut _u32,
                                   bufferPermutations: *mut u64,
                                   bufferNumAttributes: *mut _u8) -> ();
    pub fn GPU_SetTextureEnable(units: GPU_TEXUNIT) -> ();
    pub fn GPU_SetTexture(unit: GPU_TEXUNIT, data: *mut _u32, width: _u16,
                          height: _u16, param: _u32, colorType: GPU_TEXCOLOR)
     -> ();
    pub fn GPU_SetTexEnv(id: _u8, rgbSources: _u16, alphaSources: _u16,
                         rgbOperands: _u16, alphaOperands: _u16,
                         rgbCombine: GPU_COMBINEFUNC,
                         alphaCombine: GPU_COMBINEFUNC, constantColor: _u32)
     -> ();
    pub fn GPU_DrawArray(primitive: GPU_Primitive_t, n: _u32) -> ();
    pub fn GPU_DrawElements(primitive: GPU_Primitive_t, indexArray: *mut _u32,
                            n: _u32) -> ();
    pub fn GPU_FinishDrawing() -> ();
    pub fn GPU_SetShaderOutmap(outmapData: *mut _u32) -> ();
    pub fn GPU_SendShaderCode(_type: GPU_SHADER_TYPE, data: *mut _u32,
                              offset: _u16, length: _u16) -> ();
    pub fn GPU_SendOperandDescriptors(_type: GPU_SHADER_TYPE, data: *mut _u32,
                                      offset: _u16, length: _u16) -> ();
    pub fn DVLB_ParseFile(shbinData: *mut _u32, shbinSize: _u32)
     -> *mut DVLB_s;
    pub fn DVLB_Free(dvlb: *mut DVLB_s) -> ();
    pub fn DVLE_GetUniformRegister(dvle: *mut DVLE_s,
                                   name: *const ::libc::c_char) -> s8;
    pub fn DVLE_GenerateOutmap(dvle: *mut DVLE_s) -> ();
    pub fn shaderInstanceInit(si: *mut shaderInstance_s, dvle: *mut DVLE_s)
     -> Result;
    pub fn shaderInstanceFree(si: *mut shaderInstance_s) -> Result;
    pub fn shaderInstanceSetBool(si: *mut shaderInstance_s, id: ::libc::c_int,
                                 value: u8) -> Result;
    pub fn shaderInstanceGetBool(si: *mut shaderInstance_s, id: ::libc::c_int,
                                 value: *mut u8) -> Result;
    pub fn shaderInstanceGetUniformLocation(si: *mut shaderInstance_s,
                                            name: *const ::libc::c_char)
     -> Result;
    pub fn shaderProgramInit(sp: *mut shaderProgram_s) -> Result;
    pub fn shaderProgramFree(sp: *mut shaderProgram_s) -> Result;
    pub fn shaderProgramSetVsh(sp: *mut shaderProgram_s, dvle: *mut DVLE_s)
     -> Result;
    pub fn shaderProgramSetGsh(sp: *mut shaderProgram_s, dvle: *mut DVLE_s,
                               stride: _u8) -> Result;
    pub fn shaderProgramUse(sp: *mut shaderProgram_s) -> Result;
    pub fn sdmcInit() -> Result;
    pub fn sdmcExit() -> Result;
}
