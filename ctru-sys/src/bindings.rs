/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>);
impl <T> __IncompleteArrayField<T> {
    #[inline]
    pub fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ptr(&self) -> *const T { ::core::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut_ptr(&mut self) -> *mut T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl <T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
impl <T> ::core::clone::Clone for __IncompleteArrayField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::core::marker::Copy for __IncompleteArrayField<T> { }
pub const _NEWLIB_VERSION_H__: libc::c_uint = 1;
pub const _NEWLIB_VERSION: &'static [u8; 6usize] = b"2.5.0\x00";
pub const __NEWLIB__: libc::c_uint = 2;
pub const __NEWLIB_MINOR__: libc::c_uint = 5;
pub const __NEWLIB_PATCHLEVEL__: libc::c_uint = 0;
pub const _DEFAULT_SOURCE: libc::c_uint = 1;
pub const _POSIX_SOURCE: libc::c_uint = 1;
pub const _POSIX_C_SOURCE: libc::c_uint = 200809;
pub const _ATFILE_SOURCE: libc::c_uint = 1;
pub const __ATFILE_VISIBLE: libc::c_uint = 1;
pub const __BSD_VISIBLE: libc::c_uint = 1;
pub const __GNU_VISIBLE: libc::c_uint = 0;
pub const __ISO_C_VISIBLE: libc::c_uint = 2011;
pub const __LARGEFILE_VISIBLE: libc::c_uint = 0;
pub const __MISC_VISIBLE: libc::c_uint = 1;
pub const __POSIX_VISIBLE: libc::c_uint = 200809;
pub const __SVID_VISIBLE: libc::c_uint = 1;
pub const __XSI_VISIBLE: libc::c_uint = 0;
pub const __have_longlong64: libc::c_uint = 1;
pub const __have_long32: libc::c_uint = 1;
pub const ___int8_t_defined: libc::c_uint = 1;
pub const ___int16_t_defined: libc::c_uint = 1;
pub const ___int32_t_defined: libc::c_uint = 1;
pub const ___int64_t_defined: libc::c_uint = 1;
pub const ___int_least8_t_defined: libc::c_uint = 1;
pub const ___int_least16_t_defined: libc::c_uint = 1;
pub const ___int_least32_t_defined: libc::c_uint = 1;
pub const ___int_least64_t_defined: libc::c_uint = 1;
pub const __int20: libc::c_uint = 2;
pub const __INT8: &'static [u8; 3usize] = b"hh\x00";
pub const __INT16: &'static [u8; 2usize] = b"h\x00";
pub const __INT64: &'static [u8; 3usize] = b"ll\x00";
pub const __FAST8: &'static [u8; 3usize] = b"hh\x00";
pub const __FAST16: &'static [u8; 2usize] = b"h\x00";
pub const __FAST64: &'static [u8; 3usize] = b"ll\x00";
pub const __LEAST8: &'static [u8; 3usize] = b"hh\x00";
pub const __LEAST16: &'static [u8; 2usize] = b"h\x00";
pub const __LEAST64: &'static [u8; 3usize] = b"ll\x00";
pub const __int8_t_defined: libc::c_uint = 1;
pub const __int16_t_defined: libc::c_uint = 1;
pub const __int32_t_defined: libc::c_uint = 1;
pub const __int64_t_defined: libc::c_uint = 1;
pub const __int_least8_t_defined: libc::c_uint = 1;
pub const __int_least16_t_defined: libc::c_uint = 1;
pub const __int_least32_t_defined: libc::c_uint = 1;
pub const __int_least64_t_defined: libc::c_uint = 1;
pub const __int_fast8_t_defined: libc::c_uint = 1;
pub const __int_fast16_t_defined: libc::c_uint = 1;
pub const __int_fast32_t_defined: libc::c_uint = 1;
pub const __int_fast64_t_defined: libc::c_uint = 1;
pub const WINT_MIN: libc::c_uint = 0;
pub const true_: libc::c_uint = 1;
pub const false_: libc::c_uint = 0;
pub const __bool_true_false_are_defined: libc::c_uint = 1;
pub const CUR_PROCESS_HANDLE: libc::c_uint = 4294934529;
pub const ARBITRATION_SIGNAL_ALL: libc::c_int = -1;
pub const CUR_THREAD_HANDLE: libc::c_uint = 4294934528;
pub const __NEWLIB_H__: libc::c_uint = 1;
pub const _WANT_IO_C99_FORMATS: libc::c_uint = 1;
pub const _WANT_IO_LONG_LONG: libc::c_uint = 1;
pub const _WANT_IO_POS_ARGS: libc::c_uint = 1;
pub const _MB_CAPABLE: libc::c_uint = 1;
pub const _MB_LEN_MAX: libc::c_uint = 8;
pub const HAVE_INITFINI_ARRAY: libc::c_uint = 1;
pub const _ATEXIT_DYNAMIC_ALLOC: libc::c_uint = 1;
pub const _HAVE_LONG_DOUBLE: libc::c_uint = 1;
pub const _HAVE_CC_INHIBIT_LOOP_TO_LIBCALL: libc::c_uint = 1;
pub const _LDBL_EQ_DBL: libc::c_uint = 1;
pub const _FVWRITE_IN_STREAMIO: libc::c_uint = 1;
pub const _FSEEK_OPTIMIZATION: libc::c_uint = 1;
pub const _UNBUF_STREAM_OPT: libc::c_uint = 1;
pub const __RAND_MAX: libc::c_uint = 2147483647;
pub const CONSOLE_COLOR_BOLD: libc::c_uint = 1;
pub const CONSOLE_COLOR_FAINT: libc::c_uint = 2;
pub const CONSOLE_ITALIC: libc::c_uint = 4;
pub const CONSOLE_UNDERLINE: libc::c_uint = 8;
pub const CONSOLE_BLINK_SLOW: libc::c_uint = 16;
pub const CONSOLE_BLINK_FAST: libc::c_uint = 32;
pub const CONSOLE_COLOR_REVERSE: libc::c_uint = 64;
pub const CONSOLE_CONCEAL: libc::c_uint = 128;
pub const CONSOLE_CROSSED_OUT: libc::c_uint = 256;
pub const __GNUCLIKE_ASM: libc::c_uint = 3;
pub const __GNUCLIKE___TYPEOF: libc::c_uint = 1;
pub const __GNUCLIKE___OFFSETOF: libc::c_uint = 1;
pub const __GNUCLIKE___SECTION: libc::c_uint = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: libc::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: libc::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: libc::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: libc::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: libc::c_uint = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: libc::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: libc::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: libc::c_uint = 1;
pub const __CC_SUPPORTS_INLINE: libc::c_uint = 1;
pub const __CC_SUPPORTS___INLINE: libc::c_uint = 1;
pub const __CC_SUPPORTS___INLINE__: libc::c_uint = 1;
pub const __CC_SUPPORTS___FUNC__: libc::c_uint = 1;
pub const __CC_SUPPORTS_WARNING: libc::c_uint = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: libc::c_uint = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: libc::c_uint = 1;
pub const __BIT_TYPES_DEFINED__: libc::c_uint = 1;
pub const _LITTLE_ENDIAN: libc::c_uint = 1234;
pub const _BIG_ENDIAN: libc::c_uint = 4321;
pub const _PDP_ENDIAN: libc::c_uint = 3412;
pub const _BYTE_ORDER: libc::c_uint = 1234;
pub const _QUAD_HIGHWORD: libc::c_uint = 1;
pub const _QUAD_LOWWORD: libc::c_uint = 0;
pub const LITTLE_ENDIAN: libc::c_uint = 1234;
pub const BIG_ENDIAN: libc::c_uint = 4321;
pub const PDP_ENDIAN: libc::c_uint = 3412;
pub const BYTE_ORDER: libc::c_uint = 1234;
pub const FD_SETSIZE: libc::c_uint = 64;
pub const CSND_NUM_CHANNELS: libc::c_uint = 32;
pub const HTTPC_RESULTCODE_DOWNLOADPENDING: libc::c_uint = 3628113963;
pub const HTTPC_RESULTCODE_NOTFOUND: libc::c_uint = 3628113960;
pub const HTTPC_RESULTCODE_TIMEDOUT: libc::c_uint = 3626016873;
pub const UDS_MAXNODES: libc::c_uint = 16;
pub const UDS_BROADCAST_NETWORKNODEID: libc::c_uint = 65535;
pub const UDS_HOST_NETWORKNODEID: libc::c_uint = 1;
pub const UDS_DEFAULT_RECVBUFSIZE: libc::c_uint = 11824;
pub const UDS_DATAFRAME_MAXSIZE: libc::c_uint = 1478;
pub const DST_NONE: libc::c_uint = 0;
pub const DST_USA: libc::c_uint = 1;
pub const DST_AUST: libc::c_uint = 2;
pub const DST_WET: libc::c_uint = 3;
pub const DST_MET: libc::c_uint = 4;
pub const DST_EET: libc::c_uint = 5;
pub const DST_CAN: libc::c_uint = 6;
pub const SBT_MAX: libc::c_ulonglong = 9223372036854775807;
pub const ITIMER_REAL: libc::c_uint = 0;
pub const ITIMER_VIRTUAL: libc::c_uint = 1;
pub const ITIMER_PROF: libc::c_uint = 2;
pub const _NULL: libc::c_uint = 0;
pub const _ATEXIT_SIZE: libc::c_uint = 32;
pub const _RAND48_SEED_0: libc::c_uint = 13070;
pub const _RAND48_SEED_1: libc::c_uint = 43981;
pub const _RAND48_SEED_2: libc::c_uint = 4660;
pub const _RAND48_MULT_0: libc::c_uint = 58989;
pub const _RAND48_MULT_1: libc::c_uint = 57068;
pub const _RAND48_MULT_2: libc::c_uint = 5;
pub const _RAND48_ADD: libc::c_uint = 11;
pub const _REENT_EMERGENCY_SIZE: libc::c_uint = 25;
pub const _REENT_ASCTIME_SIZE: libc::c_uint = 26;
pub const _REENT_SIGNAL_SIZE: libc::c_uint = 24;
pub const _N_LISTS: libc::c_uint = 30;
pub const _CLOCKS_PER_SEC_: libc::c_uint = 100;
pub const CLOCKS_PER_SEC: libc::c_uint = 100;
pub const CLK_TCK: libc::c_uint = 100;
pub const CLOCK_ENABLED: libc::c_uint = 1;
pub const CLOCK_DISABLED: libc::c_uint = 0;
pub const CLOCK_ALLOWED: libc::c_uint = 1;
pub const CLOCK_DISALLOWED: libc::c_uint = 0;
pub const TIMER_ABSTIME: libc::c_uint = 4;
pub const SOL_SOCKET: libc::c_uint = 65535;
pub const PF_UNSPEC: libc::c_uint = 0;
pub const PF_INET: libc::c_uint = 2;
pub const PF_INET6: libc::c_uint = 23;
pub const AF_UNSPEC: libc::c_uint = 0;
pub const AF_INET: libc::c_uint = 2;
pub const AF_INET6: libc::c_uint = 23;
pub const SOCK_STREAM: libc::c_uint = 1;
pub const SOCK_DGRAM: libc::c_uint = 2;
pub const MSG_OOB: libc::c_uint = 1;
pub const MSG_PEEK: libc::c_uint = 2;
pub const MSG_DONTWAIT: libc::c_uint = 4;
pub const MSG_DONTROUTE: libc::c_uint = 0;
pub const MSG_WAITALL: libc::c_uint = 0;
pub const MSG_MORE: libc::c_uint = 0;
pub const MSG_NOSIGNAL: libc::c_uint = 0;
pub const SHUT_RD: libc::c_uint = 0;
pub const SHUT_WR: libc::c_uint = 1;
pub const SHUT_RDWR: libc::c_uint = 2;
pub const SO_REUSEADDR: libc::c_uint = 4;
pub const SO_LINGER: libc::c_uint = 128;
pub const SO_OOBINLINE: libc::c_uint = 256;
pub const SO_SNDBUF: libc::c_uint = 4097;
pub const SO_RCVBUF: libc::c_uint = 4098;
pub const SO_SNDLOWAT: libc::c_uint = 4099;
pub const SO_RCVLOWAT: libc::c_uint = 4100;
pub const SO_TYPE: libc::c_uint = 4104;
pub const SO_ERROR: libc::c_uint = 4105;
pub const INADDR_LOOPBACK: libc::c_uint = 2130706433;
pub const INADDR_ANY: libc::c_uint = 0;
pub const INADDR_BROADCAST: libc::c_uint = 4294967295;
pub const INADDR_NONE: libc::c_uint = 4294967295;
pub const INET_ADDRSTRLEN: libc::c_uint = 16;
pub const IPPROTO_IP: libc::c_uint = 0;
pub const IPPROTO_UDP: libc::c_uint = 17;
pub const IPPROTO_TCP: libc::c_uint = 6;
pub const IP_TOS: libc::c_uint = 7;
pub const IP_TTL: libc::c_uint = 8;
pub const IP_MULTICAST_LOOP: libc::c_uint = 9;
pub const IP_MULTICAST_TTL: libc::c_uint = 10;
pub const IP_ADD_MEMBERSHIP: libc::c_uint = 11;
pub const IP_DROP_MEMBERSHIP: libc::c_uint = 12;
pub const SOL_CONFIG: libc::c_uint = 65534;
pub const ROUTING_FLAG_G: libc::c_uint = 1;
pub const TCP_STATE_CLOSED: libc::c_uint = 1;
pub const TCP_STATE_LISTEN: libc::c_uint = 2;
pub const TCP_STATE_ESTABLISHED: libc::c_uint = 5;
pub const TCP_STATE_FINWAIT1: libc::c_uint = 6;
pub const TCP_STATE_FINWAIT2: libc::c_uint = 7;
pub const TCP_STATE_CLOSE_WAIT: libc::c_uint = 8;
pub const TCP_STATE_LAST_ACK: libc::c_uint = 9;
pub const TCP_STATE_TIME_WAIT: libc::c_uint = 11;
pub const MVD_STATUS_OK: libc::c_uint = 94208;
pub const MVD_STATUS_PARAMSET: libc::c_uint = 94209;
pub const MVD_STATUS_BUSY: libc::c_uint = 94210;
pub const MVD_STATUS_FRAMEREADY: libc::c_uint = 94211;
pub const MVD_STATUS_INCOMPLETEPROCESSING: libc::c_uint = 94212;
pub const MVD_STATUS_NALUPROCFLAG: libc::c_uint = 94215;
pub const MVD_DEFAULT_WORKBUF_SIZE: libc::c_uint = 9438920;
pub const NFC_ERR_INVALID_STATE: libc::c_uint = 3366024704;
pub const NFC_ERR_APPDATA_UNINITIALIZED: libc::c_uint = 3366024736;
pub const NFC_ERR_AMIIBO_NOTSETUP: libc::c_uint = 3366024744;
pub const NFC_ERR_APPID_MISMATCH: libc::c_uint = 3366024760;
pub const NFC_ERR_DATACORRUPTION0: libc::c_uint = 3368121868;
pub const NFC_ERR_DATACORRUPTION1: libc::c_uint = 3366024728;
pub const NFC_STARTSCAN_DEFAULTINPUT: libc::c_uint = 0;
pub const GPUREG_0000: libc::c_uint = 0;
pub const GPUREG_0001: libc::c_uint = 1;
pub const GPUREG_0002: libc::c_uint = 2;
pub const GPUREG_0003: libc::c_uint = 3;
pub const GPUREG_0004: libc::c_uint = 4;
pub const GPUREG_0005: libc::c_uint = 5;
pub const GPUREG_0006: libc::c_uint = 6;
pub const GPUREG_0007: libc::c_uint = 7;
pub const GPUREG_0008: libc::c_uint = 8;
pub const GPUREG_0009: libc::c_uint = 9;
pub const GPUREG_000A: libc::c_uint = 10;
pub const GPUREG_000B: libc::c_uint = 11;
pub const GPUREG_000C: libc::c_uint = 12;
pub const GPUREG_000D: libc::c_uint = 13;
pub const GPUREG_000E: libc::c_uint = 14;
pub const GPUREG_000F: libc::c_uint = 15;
pub const GPUREG_FINALIZE: libc::c_uint = 16;
pub const GPUREG_0011: libc::c_uint = 17;
pub const GPUREG_0012: libc::c_uint = 18;
pub const GPUREG_0013: libc::c_uint = 19;
pub const GPUREG_0014: libc::c_uint = 20;
pub const GPUREG_0015: libc::c_uint = 21;
pub const GPUREG_0016: libc::c_uint = 22;
pub const GPUREG_0017: libc::c_uint = 23;
pub const GPUREG_0018: libc::c_uint = 24;
pub const GPUREG_0019: libc::c_uint = 25;
pub const GPUREG_001A: libc::c_uint = 26;
pub const GPUREG_001B: libc::c_uint = 27;
pub const GPUREG_001C: libc::c_uint = 28;
pub const GPUREG_001D: libc::c_uint = 29;
pub const GPUREG_001E: libc::c_uint = 30;
pub const GPUREG_001F: libc::c_uint = 31;
pub const GPUREG_0020: libc::c_uint = 32;
pub const GPUREG_0021: libc::c_uint = 33;
pub const GPUREG_0022: libc::c_uint = 34;
pub const GPUREG_0023: libc::c_uint = 35;
pub const GPUREG_0024: libc::c_uint = 36;
pub const GPUREG_0025: libc::c_uint = 37;
pub const GPUREG_0026: libc::c_uint = 38;
pub const GPUREG_0027: libc::c_uint = 39;
pub const GPUREG_0028: libc::c_uint = 40;
pub const GPUREG_0029: libc::c_uint = 41;
pub const GPUREG_002A: libc::c_uint = 42;
pub const GPUREG_002B: libc::c_uint = 43;
pub const GPUREG_002C: libc::c_uint = 44;
pub const GPUREG_002D: libc::c_uint = 45;
pub const GPUREG_002E: libc::c_uint = 46;
pub const GPUREG_002F: libc::c_uint = 47;
pub const GPUREG_0030: libc::c_uint = 48;
pub const GPUREG_0031: libc::c_uint = 49;
pub const GPUREG_0032: libc::c_uint = 50;
pub const GPUREG_0033: libc::c_uint = 51;
pub const GPUREG_0034: libc::c_uint = 52;
pub const GPUREG_0035: libc::c_uint = 53;
pub const GPUREG_0036: libc::c_uint = 54;
pub const GPUREG_0037: libc::c_uint = 55;
pub const GPUREG_0038: libc::c_uint = 56;
pub const GPUREG_0039: libc::c_uint = 57;
pub const GPUREG_003A: libc::c_uint = 58;
pub const GPUREG_003B: libc::c_uint = 59;
pub const GPUREG_003C: libc::c_uint = 60;
pub const GPUREG_003D: libc::c_uint = 61;
pub const GPUREG_003E: libc::c_uint = 62;
pub const GPUREG_003F: libc::c_uint = 63;
pub const GPUREG_FACECULLING_CONFIG: libc::c_uint = 64;
pub const GPUREG_VIEWPORT_WIDTH: libc::c_uint = 65;
pub const GPUREG_VIEWPORT_INVW: libc::c_uint = 66;
pub const GPUREG_VIEWPORT_HEIGHT: libc::c_uint = 67;
pub const GPUREG_VIEWPORT_INVH: libc::c_uint = 68;
pub const GPUREG_0045: libc::c_uint = 69;
pub const GPUREG_0046: libc::c_uint = 70;
pub const GPUREG_FRAGOP_CLIP: libc::c_uint = 71;
pub const GPUREG_FRAGOP_CLIP_DATA0: libc::c_uint = 72;
pub const GPUREG_FRAGOP_CLIP_DATA1: libc::c_uint = 73;
pub const GPUREG_FRAGOP_CLIP_DATA2: libc::c_uint = 74;
pub const GPUREG_FRAGOP_CLIP_DATA3: libc::c_uint = 75;
pub const GPUREG_004C: libc::c_uint = 76;
pub const GPUREG_DEPTHMAP_SCALE: libc::c_uint = 77;
pub const GPUREG_DEPTHMAP_OFFSET: libc::c_uint = 78;
pub const GPUREG_SH_OUTMAP_TOTAL: libc::c_uint = 79;
pub const GPUREG_SH_OUTMAP_O0: libc::c_uint = 80;
pub const GPUREG_SH_OUTMAP_O1: libc::c_uint = 81;
pub const GPUREG_SH_OUTMAP_O2: libc::c_uint = 82;
pub const GPUREG_SH_OUTMAP_O3: libc::c_uint = 83;
pub const GPUREG_SH_OUTMAP_O4: libc::c_uint = 84;
pub const GPUREG_SH_OUTMAP_O5: libc::c_uint = 85;
pub const GPUREG_SH_OUTMAP_O6: libc::c_uint = 86;
pub const GPUREG_0057: libc::c_uint = 87;
pub const GPUREG_0058: libc::c_uint = 88;
pub const GPUREG_0059: libc::c_uint = 89;
pub const GPUREG_005A: libc::c_uint = 90;
pub const GPUREG_005B: libc::c_uint = 91;
pub const GPUREG_005C: libc::c_uint = 92;
pub const GPUREG_005D: libc::c_uint = 93;
pub const GPUREG_005E: libc::c_uint = 94;
pub const GPUREG_005F: libc::c_uint = 95;
pub const GPUREG_0060: libc::c_uint = 96;
pub const GPUREG_EARLYDEPTH_FUNC: libc::c_uint = 97;
pub const GPUREG_EARLYDEPTH_TEST1: libc::c_uint = 98;
pub const GPUREG_EARLYDEPTH_CLEAR: libc::c_uint = 99;
pub const GPUREG_SH_OUTATTR_MODE: libc::c_uint = 100;
pub const GPUREG_SCISSORTEST_MODE: libc::c_uint = 101;
pub const GPUREG_SCISSORTEST_POS: libc::c_uint = 102;
pub const GPUREG_SCISSORTEST_DIM: libc::c_uint = 103;
pub const GPUREG_VIEWPORT_XY: libc::c_uint = 104;
pub const GPUREG_0069: libc::c_uint = 105;
pub const GPUREG_EARLYDEPTH_DATA: libc::c_uint = 106;
pub const GPUREG_006B: libc::c_uint = 107;
pub const GPUREG_006C: libc::c_uint = 108;
pub const GPUREG_DEPTHMAP_ENABLE: libc::c_uint = 109;
pub const GPUREG_RENDERBUF_DIM: libc::c_uint = 110;
pub const GPUREG_SH_OUTATTR_CLOCK: libc::c_uint = 111;
pub const GPUREG_0070: libc::c_uint = 112;
pub const GPUREG_0071: libc::c_uint = 113;
pub const GPUREG_0072: libc::c_uint = 114;
pub const GPUREG_0073: libc::c_uint = 115;
pub const GPUREG_0074: libc::c_uint = 116;
pub const GPUREG_0075: libc::c_uint = 117;
pub const GPUREG_0076: libc::c_uint = 118;
pub const GPUREG_0077: libc::c_uint = 119;
pub const GPUREG_0078: libc::c_uint = 120;
pub const GPUREG_0079: libc::c_uint = 121;
pub const GPUREG_007A: libc::c_uint = 122;
pub const GPUREG_007B: libc::c_uint = 123;
pub const GPUREG_007C: libc::c_uint = 124;
pub const GPUREG_007D: libc::c_uint = 125;
pub const GPUREG_007E: libc::c_uint = 126;
pub const GPUREG_007F: libc::c_uint = 127;
pub const GPUREG_TEXUNIT_CONFIG: libc::c_uint = 128;
pub const GPUREG_TEXUNIT0_BORDER_COLOR: libc::c_uint = 129;
pub const GPUREG_TEXUNIT0_DIM: libc::c_uint = 130;
pub const GPUREG_TEXUNIT0_PARAM: libc::c_uint = 131;
pub const GPUREG_TEXUNIT0_LOD: libc::c_uint = 132;
pub const GPUREG_TEXUNIT0_ADDR1: libc::c_uint = 133;
pub const GPUREG_TEXUNIT0_ADDR2: libc::c_uint = 134;
pub const GPUREG_TEXUNIT0_ADDR3: libc::c_uint = 135;
pub const GPUREG_TEXUNIT0_ADDR4: libc::c_uint = 136;
pub const GPUREG_TEXUNIT0_ADDR5: libc::c_uint = 137;
pub const GPUREG_TEXUNIT0_ADDR6: libc::c_uint = 138;
pub const GPUREG_TEXUNIT0_SHADOW: libc::c_uint = 139;
pub const GPUREG_008C: libc::c_uint = 140;
pub const GPUREG_008D: libc::c_uint = 141;
pub const GPUREG_TEXUNIT0_TYPE: libc::c_uint = 142;
pub const GPUREG_LIGHTING_ENABLE0: libc::c_uint = 143;
pub const GPUREG_0090: libc::c_uint = 144;
pub const GPUREG_TEXUNIT1_BORDER_COLOR: libc::c_uint = 145;
pub const GPUREG_TEXUNIT1_DIM: libc::c_uint = 146;
pub const GPUREG_TEXUNIT1_PARAM: libc::c_uint = 147;
pub const GPUREG_TEXUNIT1_LOD: libc::c_uint = 148;
pub const GPUREG_TEXUNIT1_ADDR: libc::c_uint = 149;
pub const GPUREG_TEXUNIT1_TYPE: libc::c_uint = 150;
pub const GPUREG_0097: libc::c_uint = 151;
pub const GPUREG_0098: libc::c_uint = 152;
pub const GPUREG_TEXUNIT2_BORDER_COLOR: libc::c_uint = 153;
pub const GPUREG_TEXUNIT2_DIM: libc::c_uint = 154;
pub const GPUREG_TEXUNIT2_PARAM: libc::c_uint = 155;
pub const GPUREG_TEXUNIT2_LOD: libc::c_uint = 156;
pub const GPUREG_TEXUNIT2_ADDR: libc::c_uint = 157;
pub const GPUREG_TEXUNIT2_TYPE: libc::c_uint = 158;
pub const GPUREG_009F: libc::c_uint = 159;
pub const GPUREG_00A0: libc::c_uint = 160;
pub const GPUREG_00A1: libc::c_uint = 161;
pub const GPUREG_00A2: libc::c_uint = 162;
pub const GPUREG_00A3: libc::c_uint = 163;
pub const GPUREG_00A4: libc::c_uint = 164;
pub const GPUREG_00A5: libc::c_uint = 165;
pub const GPUREG_00A6: libc::c_uint = 166;
pub const GPUREG_00A7: libc::c_uint = 167;
pub const GPUREG_TEXUNIT3_PROCTEX0: libc::c_uint = 168;
pub const GPUREG_TEXUNIT3_PROCTEX1: libc::c_uint = 169;
pub const GPUREG_TEXUNIT3_PROCTEX2: libc::c_uint = 170;
pub const GPUREG_TEXUNIT3_PROCTEX3: libc::c_uint = 171;
pub const GPUREG_TEXUNIT3_PROCTEX4: libc::c_uint = 10;
pub const GPUREG_TEXUNIT3_PROCTEX5: libc::c_uint = 13;
pub const GPUREG_00AE: libc::c_uint = 174;
pub const GPUREG_PROCTEX_LUT: libc::c_uint = 175;
pub const GPUREG_PROCTEX_LUT_DATA0: libc::c_uint = 176;
pub const GPUREG_PROCTEX_LUT_DATA1: libc::c_uint = 177;
pub const GPUREG_PROCTEX_LUT_DATA2: libc::c_uint = 178;
pub const GPUREG_PROCTEX_LUT_DATA3: libc::c_uint = 179;
pub const GPUREG_PROCTEX_LUT_DATA4: libc::c_uint = 180;
pub const GPUREG_PROCTEX_LUT_DATA5: libc::c_uint = 181;
pub const GPUREG_PROCTEX_LUT_DATA6: libc::c_uint = 182;
pub const GPUREG_PROCTEX_LUT_DATA7: libc::c_uint = 183;
pub const GPUREG_00B8: libc::c_uint = 184;
pub const GPUREG_00B9: libc::c_uint = 185;
pub const GPUREG_00BA: libc::c_uint = 186;
pub const GPUREG_00BB: libc::c_uint = 187;
pub const GPUREG_00BC: libc::c_uint = 188;
pub const GPUREG_00BD: libc::c_uint = 189;
pub const GPUREG_00BE: libc::c_uint = 190;
pub const GPUREG_00BF: libc::c_uint = 191;
pub const GPUREG_TEXENV0_SOURCE: libc::c_uint = 192;
pub const GPUREG_TEXENV0_OPERAND: libc::c_uint = 193;
pub const GPUREG_TEXENV0_COMBINER: libc::c_uint = 194;
pub const GPUREG_TEXENV0_COLOR: libc::c_uint = 195;
pub const GPUREG_TEXENV0_SCALE: libc::c_uint = 196;
pub const GPUREG_00C5: libc::c_uint = 197;
pub const GPUREG_00C6: libc::c_uint = 198;
pub const GPUREG_00C7: libc::c_uint = 199;
pub const GPUREG_TEXENV1_SOURCE: libc::c_uint = 200;
pub const GPUREG_TEXENV1_OPERAND: libc::c_uint = 201;
pub const GPUREG_TEXENV1_COMBINER: libc::c_uint = 202;
pub const GPUREG_TEXENV1_COLOR: libc::c_uint = 203;
pub const GPUREG_TEXENV1_SCALE: libc::c_uint = 204;
pub const GPUREG_00CD: libc::c_uint = 205;
pub const GPUREG_00CE: libc::c_uint = 206;
pub const GPUREG_00CF: libc::c_uint = 207;
pub const GPUREG_TEXENV2_SOURCE: libc::c_uint = 208;
pub const GPUREG_TEXENV2_OPERAND: libc::c_uint = 209;
pub const GPUREG_TEXENV2_COMBINER: libc::c_uint = 210;
pub const GPUREG_TEXENV2_COLOR: libc::c_uint = 211;
pub const GPUREG_TEXENV2_SCALE: libc::c_uint = 212;
pub const GPUREG_00D5: libc::c_uint = 213;
pub const GPUREG_00D6: libc::c_uint = 214;
pub const GPUREG_00D7: libc::c_uint = 215;
pub const GPUREG_TEXENV3_SOURCE: libc::c_uint = 216;
pub const GPUREG_TEXENV3_OPERAND: libc::c_uint = 217;
pub const GPUREG_TEXENV3_COMBINER: libc::c_uint = 218;
pub const GPUREG_TEXENV3_COLOR: libc::c_uint = 219;
pub const GPUREG_TEXENV3_SCALE: libc::c_uint = 220;
pub const GPUREG_00DD: libc::c_uint = 221;
pub const GPUREG_00DE: libc::c_uint = 222;
pub const GPUREG_00DF: libc::c_uint = 223;
pub const GPUREG_TEXENV_UPDATE_BUFFER: libc::c_uint = 224;
pub const GPUREG_FOG_COLOR: libc::c_uint = 225;
pub const GPUREG_00E2: libc::c_uint = 226;
pub const GPUREG_00E3: libc::c_uint = 227;
pub const GPUREG_GAS_ATTENUATION: libc::c_uint = 228;
pub const GPUREG_GAS_ACCMAX: libc::c_uint = 229;
pub const GPUREG_FOG_LUT_INDEX: libc::c_uint = 230;
pub const GPUREG_00E7: libc::c_uint = 231;
pub const GPUREG_FOG_LUT_DATA0: libc::c_uint = 232;
pub const GPUREG_FOG_LUT_DATA1: libc::c_uint = 233;
pub const GPUREG_FOG_LUT_DATA2: libc::c_uint = 234;
pub const GPUREG_FOG_LUT_DATA3: libc::c_uint = 235;
pub const GPUREG_FOG_LUT_DATA4: libc::c_uint = 236;
pub const GPUREG_FOG_LUT_DATA5: libc::c_uint = 237;
pub const GPUREG_FOG_LUT_DATA6: libc::c_uint = 238;
pub const GPUREG_FOG_LUT_DATA7: libc::c_uint = 239;
pub const GPUREG_TEXENV4_SOURCE: libc::c_uint = 240;
pub const GPUREG_TEXENV4_OPERAND: libc::c_uint = 241;
pub const GPUREG_TEXENV4_COMBINER: libc::c_uint = 242;
pub const GPUREG_TEXENV4_COLOR: libc::c_uint = 243;
pub const GPUREG_TEXENV4_SCALE: libc::c_uint = 244;
pub const GPUREG_00F5: libc::c_uint = 245;
pub const GPUREG_00F6: libc::c_uint = 246;
pub const GPUREG_00F7: libc::c_uint = 247;
pub const GPUREG_TEXENV5_SOURCE: libc::c_uint = 248;
pub const GPUREG_TEXENV5_OPERAND: libc::c_uint = 249;
pub const GPUREG_TEXENV5_COMBINER: libc::c_uint = 250;
pub const GPUREG_TEXENV5_COLOR: libc::c_uint = 251;
pub const GPUREG_TEXENV5_SCALE: libc::c_uint = 252;
pub const GPUREG_TEXENV_BUFFER_COLOR: libc::c_uint = 253;
pub const GPUREG_00FE: libc::c_uint = 254;
pub const GPUREG_00FF: libc::c_uint = 255;
pub const GPUREG_COLOR_OPERATION: libc::c_uint = 256;
pub const GPUREG_BLEND_FUNC: libc::c_uint = 257;
pub const GPUREG_LOGIC_OP: libc::c_uint = 258;
pub const GPUREG_BLEND_COLOR: libc::c_uint = 259;
pub const GPUREG_FRAGOP_ALPHA_TEST: libc::c_uint = 260;
pub const GPUREG_STENCIL_TEST: libc::c_uint = 261;
pub const GPUREG_STENCIL_OP: libc::c_uint = 262;
pub const GPUREG_DEPTH_COLOR_MASK: libc::c_uint = 263;
pub const GPUREG_0108: libc::c_uint = 264;
pub const GPUREG_0109: libc::c_uint = 265;
pub const GPUREG_010A: libc::c_uint = 266;
pub const GPUREG_010B: libc::c_uint = 267;
pub const GPUREG_010C: libc::c_uint = 268;
pub const GPUREG_010D: libc::c_uint = 269;
pub const GPUREG_010E: libc::c_uint = 270;
pub const GPUREG_010F: libc::c_uint = 271;
pub const GPUREG_FRAMEBUFFER_INVALIDATE: libc::c_uint = 272;
pub const GPUREG_FRAMEBUFFER_FLUSH: libc::c_uint = 273;
pub const GPUREG_COLORBUFFER_READ: libc::c_uint = 274;
pub const GPUREG_COLORBUFFER_WRITE: libc::c_uint = 275;
pub const GPUREG_DEPTHBUFFER_READ: libc::c_uint = 276;
pub const GPUREG_DEPTHBUFFER_WRITE: libc::c_uint = 277;
pub const GPUREG_DEPTHBUFFER_FORMAT: libc::c_uint = 278;
pub const GPUREG_COLORBUFFER_FORMAT: libc::c_uint = 279;
pub const GPUREG_EARLYDEPTH_TEST2: libc::c_uint = 280;
pub const GPUREG_0119: libc::c_uint = 281;
pub const GPUREG_011A: libc::c_uint = 282;
pub const GPUREG_FRAMEBUFFER_BLOCK32: libc::c_uint = 283;
pub const GPUREG_DEPTHBUFFER_LOC: libc::c_uint = 284;
pub const GPUREG_COLORBUFFER_LOC: libc::c_uint = 285;
pub const GPUREG_FRAMEBUFFER_DIM: libc::c_uint = 286;
pub const GPUREG_011F: libc::c_uint = 287;
pub const GPUREG_GAS_LIGHT_XY: libc::c_uint = 288;
pub const GPUREG_GAS_LIGHT_Z: libc::c_uint = 289;
pub const GPUREG_GAS_LIGHT_Z_COLOR: libc::c_uint = 290;
pub const GPUREG_GAS_LUT_INDEX: libc::c_uint = 291;
pub const GPUREG_GAS_LUT_DATA: libc::c_uint = 292;
pub const GPUREG_0125: libc::c_uint = 293;
pub const GPUREG_GAS_DELTAZ_DEPTH: libc::c_uint = 294;
pub const GPUREG_0127: libc::c_uint = 295;
pub const GPUREG_0128: libc::c_uint = 296;
pub const GPUREG_0129: libc::c_uint = 297;
pub const GPUREG_012A: libc::c_uint = 298;
pub const GPUREG_012B: libc::c_uint = 299;
pub const GPUREG_012C: libc::c_uint = 300;
pub const GPUREG_012D: libc::c_uint = 301;
pub const GPUREG_012E: libc::c_uint = 302;
pub const GPUREG_012F: libc::c_uint = 303;
pub const GPUREG_FRAGOP_SHADOW: libc::c_uint = 304;
pub const GPUREG_0131: libc::c_uint = 305;
pub const GPUREG_0132: libc::c_uint = 306;
pub const GPUREG_0133: libc::c_uint = 307;
pub const GPUREG_0134: libc::c_uint = 308;
pub const GPUREG_0135: libc::c_uint = 309;
pub const GPUREG_0136: libc::c_uint = 310;
pub const GPUREG_0137: libc::c_uint = 311;
pub const GPUREG_0138: libc::c_uint = 312;
pub const GPUREG_0139: libc::c_uint = 313;
pub const GPUREG_013A: libc::c_uint = 314;
pub const GPUREG_013B: libc::c_uint = 315;
pub const GPUREG_013C: libc::c_uint = 316;
pub const GPUREG_013D: libc::c_uint = 317;
pub const GPUREG_013E: libc::c_uint = 318;
pub const GPUREG_013F: libc::c_uint = 319;
pub const GPUREG_LIGHT0_SPECULAR0: libc::c_uint = 320;
pub const GPUREG_LIGHT0_SPECULAR1: libc::c_uint = 321;
pub const GPUREG_LIGHT0_DIFFUSE: libc::c_uint = 322;
pub const GPUREG_LIGHT0_AMBIENT: libc::c_uint = 323;
pub const GPUREG_LIGHT0_XY: libc::c_uint = 324;
pub const GPUREG_LIGHT0_Z: libc::c_uint = 325;
pub const GPUREG_LIGHT0_SPOTDIR_XY: libc::c_uint = 326;
pub const GPUREG_LIGHT0_SPOTDIR_Z: libc::c_uint = 327;
pub const GPUREG_0148: libc::c_uint = 328;
pub const GPUREG_LIGHT0_CONFIG: libc::c_uint = 329;
pub const GPUREG_LIGHT0_ATTENUATION_BIAS: libc::c_uint = 330;
pub const GPUREG_LIGHT0_ATTENUATION_SCALE: libc::c_uint = 331;
pub const GPUREG_014C: libc::c_uint = 332;
pub const GPUREG_014D: libc::c_uint = 333;
pub const GPUREG_014E: libc::c_uint = 334;
pub const GPUREG_014F: libc::c_uint = 335;
pub const GPUREG_LIGHT1_SPECULAR0: libc::c_uint = 336;
pub const GPUREG_LIGHT1_SPECULAR1: libc::c_uint = 337;
pub const GPUREG_LIGHT1_DIFFUSE: libc::c_uint = 338;
pub const GPUREG_LIGHT1_AMBIENT: libc::c_uint = 339;
pub const GPUREG_LIGHT1_XY: libc::c_uint = 340;
pub const GPUREG_LIGHT1_Z: libc::c_uint = 341;
pub const GPUREG_LIGHT1_SPOTDIR_XY: libc::c_uint = 342;
pub const GPUREG_LIGHT1_SPOTDIR_Z: libc::c_uint = 343;
pub const GPUREG_0158: libc::c_uint = 344;
pub const GPUREG_LIGHT1_CONFIG: libc::c_uint = 345;
pub const GPUREG_LIGHT1_ATTENUATION_BIAS: libc::c_uint = 346;
pub const GPUREG_LIGHT1_ATTENUATION_SCALE: libc::c_uint = 347;
pub const GPUREG_015C: libc::c_uint = 348;
pub const GPUREG_015D: libc::c_uint = 349;
pub const GPUREG_015E: libc::c_uint = 350;
pub const GPUREG_015F: libc::c_uint = 351;
pub const GPUREG_LIGHT2_SPECULAR0: libc::c_uint = 352;
pub const GPUREG_LIGHT2_SPECULAR1: libc::c_uint = 353;
pub const GPUREG_LIGHT2_DIFFUSE: libc::c_uint = 354;
pub const GPUREG_LIGHT2_AMBIENT: libc::c_uint = 355;
pub const GPUREG_LIGHT2_XY: libc::c_uint = 356;
pub const GPUREG_LIGHT2_Z: libc::c_uint = 357;
pub const GPUREG_LIGHT2_SPOTDIR_XY: libc::c_uint = 358;
pub const GPUREG_LIGHT2_SPOTDIR_Z: libc::c_uint = 359;
pub const GPUREG_0168: libc::c_uint = 360;
pub const GPUREG_LIGHT2_CONFIG: libc::c_uint = 361;
pub const GPUREG_LIGHT2_ATTENUATION_BIAS: libc::c_uint = 362;
pub const GPUREG_LIGHT2_ATTENUATION_SCALE: libc::c_uint = 363;
pub const GPUREG_016C: libc::c_uint = 364;
pub const GPUREG_016D: libc::c_uint = 365;
pub const GPUREG_016E: libc::c_uint = 366;
pub const GPUREG_016F: libc::c_uint = 367;
pub const GPUREG_LIGHT3_SPECULAR0: libc::c_uint = 368;
pub const GPUREG_LIGHT3_SPECULAR1: libc::c_uint = 369;
pub const GPUREG_LIGHT3_DIFFUSE: libc::c_uint = 370;
pub const GPUREG_LIGHT3_AMBIENT: libc::c_uint = 371;
pub const GPUREG_LIGHT3_XY: libc::c_uint = 372;
pub const GPUREG_LIGHT3_Z: libc::c_uint = 373;
pub const GPUREG_LIGHT3_SPOTDIR_XY: libc::c_uint = 374;
pub const GPUREG_LIGHT3_SPOTDIR_Z: libc::c_uint = 375;
pub const GPUREG_0178: libc::c_uint = 376;
pub const GPUREG_LIGHT3_CONFIG: libc::c_uint = 377;
pub const GPUREG_LIGHT3_ATTENUATION_BIAS: libc::c_uint = 378;
pub const GPUREG_LIGHT3_ATTENUATION_SCALE: libc::c_uint = 379;
pub const GPUREG_017C: libc::c_uint = 380;
pub const GPUREG_017D: libc::c_uint = 381;
pub const GPUREG_017E: libc::c_uint = 382;
pub const GPUREG_017F: libc::c_uint = 383;
pub const GPUREG_LIGHT4_SPECULAR0: libc::c_uint = 384;
pub const GPUREG_LIGHT4_SPECULAR1: libc::c_uint = 385;
pub const GPUREG_LIGHT4_DIFFUSE: libc::c_uint = 386;
pub const GPUREG_LIGHT4_AMBIENT: libc::c_uint = 387;
pub const GPUREG_LIGHT4_XY: libc::c_uint = 388;
pub const GPUREG_LIGHT4_Z: libc::c_uint = 389;
pub const GPUREG_LIGHT4_SPOTDIR_XY: libc::c_uint = 390;
pub const GPUREG_LIGHT4_SPOTDIR_Z: libc::c_uint = 391;
pub const GPUREG_0188: libc::c_uint = 392;
pub const GPUREG_LIGHT4_CONFIG: libc::c_uint = 393;
pub const GPUREG_LIGHT4_ATTENUATION_BIAS: libc::c_uint = 394;
pub const GPUREG_LIGHT4_ATTENUATION_SCALE: libc::c_uint = 395;
pub const GPUREG_018C: libc::c_uint = 396;
pub const GPUREG_018D: libc::c_uint = 397;
pub const GPUREG_018E: libc::c_uint = 398;
pub const GPUREG_018F: libc::c_uint = 399;
pub const GPUREG_LIGHT5_SPECULAR0: libc::c_uint = 400;
pub const GPUREG_LIGHT5_SPECULAR1: libc::c_uint = 401;
pub const GPUREG_LIGHT5_DIFFUSE: libc::c_uint = 402;
pub const GPUREG_LIGHT5_AMBIENT: libc::c_uint = 403;
pub const GPUREG_LIGHT5_XY: libc::c_uint = 404;
pub const GPUREG_LIGHT5_Z: libc::c_uint = 405;
pub const GPUREG_LIGHT5_SPOTDIR_XY: libc::c_uint = 406;
pub const GPUREG_LIGHT5_SPOTDIR_Z: libc::c_uint = 407;
pub const GPUREG_0198: libc::c_uint = 408;
pub const GPUREG_LIGHT5_CONFIG: libc::c_uint = 409;
pub const GPUREG_LIGHT5_ATTENUATION_BIAS: libc::c_uint = 410;
pub const GPUREG_LIGHT5_ATTENUATION_SCALE: libc::c_uint = 411;
pub const GPUREG_019C: libc::c_uint = 412;
pub const GPUREG_019D: libc::c_uint = 413;
pub const GPUREG_019E: libc::c_uint = 414;
pub const GPUREG_019F: libc::c_uint = 415;
pub const GPUREG_LIGHT6_SPECULAR0: libc::c_uint = 416;
pub const GPUREG_LIGHT6_SPECULAR1: libc::c_uint = 417;
pub const GPUREG_LIGHT6_DIFFUSE: libc::c_uint = 418;
pub const GPUREG_LIGHT6_AMBIENT: libc::c_uint = 419;
pub const GPUREG_LIGHT6_XY: libc::c_uint = 420;
pub const GPUREG_LIGHT6_Z: libc::c_uint = 421;
pub const GPUREG_LIGHT6_SPOTDIR_XY: libc::c_uint = 422;
pub const GPUREG_LIGHT6_SPOTDIR_Z: libc::c_uint = 423;
pub const GPUREG_01A8: libc::c_uint = 424;
pub const GPUREG_LIGHT6_CONFIG: libc::c_uint = 425;
pub const GPUREG_LIGHT6_ATTENUATION_BIAS: libc::c_uint = 426;
pub const GPUREG_LIGHT6_ATTENUATION_SCALE: libc::c_uint = 427;
pub const GPUREG_01AC: libc::c_uint = 428;
pub const GPUREG_01AD: libc::c_uint = 429;
pub const GPUREG_01AE: libc::c_uint = 430;
pub const GPUREG_01AF: libc::c_uint = 431;
pub const GPUREG_LIGHT7_SPECULAR0: libc::c_uint = 432;
pub const GPUREG_LIGHT7_SPECULAR1: libc::c_uint = 433;
pub const GPUREG_LIGHT7_DIFFUSE: libc::c_uint = 434;
pub const GPUREG_LIGHT7_AMBIENT: libc::c_uint = 435;
pub const GPUREG_LIGHT7_XY: libc::c_uint = 436;
pub const GPUREG_LIGHT7_Z: libc::c_uint = 437;
pub const GPUREG_LIGHT7_SPOTDIR_XY: libc::c_uint = 438;
pub const GPUREG_LIGHT7_SPOTDIR_Z: libc::c_uint = 439;
pub const GPUREG_01B8: libc::c_uint = 440;
pub const GPUREG_LIGHT7_CONFIG: libc::c_uint = 441;
pub const GPUREG_LIGHT7_ATTENUATION_BIAS: libc::c_uint = 442;
pub const GPUREG_LIGHT7_ATTENUATION_SCALE: libc::c_uint = 443;
pub const GPUREG_01BC: libc::c_uint = 444;
pub const GPUREG_01BD: libc::c_uint = 445;
pub const GPUREG_01BE: libc::c_uint = 446;
pub const GPUREG_01BF: libc::c_uint = 447;
pub const GPUREG_LIGHTING_AMBIENT: libc::c_uint = 448;
pub const GPUREG_01C1: libc::c_uint = 449;
pub const GPUREG_LIGHTING_NUM_LIGHTS: libc::c_uint = 450;
pub const GPUREG_LIGHTING_CONFIG0: libc::c_uint = 451;
pub const GPUREG_LIGHTING_CONFIG1: libc::c_uint = 452;
pub const GPUREG_LIGHTING_LUT_INDEX: libc::c_uint = 453;
pub const GPUREG_LIGHTING_ENABLE1: libc::c_uint = 454;
pub const GPUREG_01C7: libc::c_uint = 455;
pub const GPUREG_LIGHTING_LUT_DATA0: libc::c_uint = 456;
pub const GPUREG_LIGHTING_LUT_DATA1: libc::c_uint = 457;
pub const GPUREG_LIGHTING_LUT_DATA2: libc::c_uint = 458;
pub const GPUREG_LIGHTING_LUT_DATA3: libc::c_uint = 459;
pub const GPUREG_LIGHTING_LUT_DATA4: libc::c_uint = 460;
pub const GPUREG_LIGHTING_LUT_DATA5: libc::c_uint = 461;
pub const GPUREG_LIGHTING_LUT_DATA6: libc::c_uint = 462;
pub const GPUREG_LIGHTING_LUT_DATA7: libc::c_uint = 463;
pub const GPUREG_LIGHTING_LUTINPUT_ABS: libc::c_uint = 464;
pub const GPUREG_LIGHTING_LUTINPUT_SELECT: libc::c_uint = 465;
pub const GPUREG_LIGHTING_LUTINPUT_SCALE: libc::c_uint = 466;
pub const GPUREG_01D3: libc::c_uint = 467;
pub const GPUREG_01D4: libc::c_uint = 468;
pub const GPUREG_01D5: libc::c_uint = 469;
pub const GPUREG_01D6: libc::c_uint = 470;
pub const GPUREG_01D7: libc::c_uint = 471;
pub const GPUREG_01D8: libc::c_uint = 472;
pub const GPUREG_LIGHTING_LIGHT_PERMUTATION: libc::c_uint = 473;
pub const GPUREG_01DA: libc::c_uint = 474;
pub const GPUREG_01DB: libc::c_uint = 475;
pub const GPUREG_01DC: libc::c_uint = 476;
pub const GPUREG_01DD: libc::c_uint = 477;
pub const GPUREG_01DE: libc::c_uint = 478;
pub const GPUREG_01DF: libc::c_uint = 479;
pub const GPUREG_01E0: libc::c_uint = 480;
pub const GPUREG_01E1: libc::c_uint = 481;
pub const GPUREG_01E2: libc::c_uint = 482;
pub const GPUREG_01E3: libc::c_uint = 483;
pub const GPUREG_01E4: libc::c_uint = 484;
pub const GPUREG_01E5: libc::c_uint = 485;
pub const GPUREG_01E6: libc::c_uint = 486;
pub const GPUREG_01E7: libc::c_uint = 487;
pub const GPUREG_01E8: libc::c_uint = 488;
pub const GPUREG_01E9: libc::c_uint = 489;
pub const GPUREG_01EA: libc::c_uint = 490;
pub const GPUREG_01EB: libc::c_uint = 491;
pub const GPUREG_01EC: libc::c_uint = 492;
pub const GPUREG_01ED: libc::c_uint = 493;
pub const GPUREG_01EE: libc::c_uint = 494;
pub const GPUREG_01EF: libc::c_uint = 495;
pub const GPUREG_01F0: libc::c_uint = 496;
pub const GPUREG_01F1: libc::c_uint = 497;
pub const GPUREG_01F2: libc::c_uint = 498;
pub const GPUREG_01F3: libc::c_uint = 499;
pub const GPUREG_01F4: libc::c_uint = 500;
pub const GPUREG_01F5: libc::c_uint = 501;
pub const GPUREG_01F6: libc::c_uint = 502;
pub const GPUREG_01F7: libc::c_uint = 503;
pub const GPUREG_01F8: libc::c_uint = 504;
pub const GPUREG_01F9: libc::c_uint = 505;
pub const GPUREG_01FA: libc::c_uint = 506;
pub const GPUREG_01FB: libc::c_uint = 507;
pub const GPUREG_01FC: libc::c_uint = 508;
pub const GPUREG_01FD: libc::c_uint = 509;
pub const GPUREG_01FE: libc::c_uint = 510;
pub const GPUREG_01FF: libc::c_uint = 511;
pub const GPUREG_ATTRIBBUFFERS_LOC: libc::c_uint = 512;
pub const GPUREG_ATTRIBBUFFERS_FORMAT_LOW: libc::c_uint = 513;
pub const GPUREG_ATTRIBBUFFERS_FORMAT_HIGH: libc::c_uint = 514;
pub const GPUREG_ATTRIBBUFFER0_OFFSET: libc::c_uint = 515;
pub const GPUREG_ATTRIBBUFFER0_CONFIG1: libc::c_uint = 516;
pub const GPUREG_ATTRIBBUFFER0_CONFIG2: libc::c_uint = 517;
pub const GPUREG_ATTRIBBUFFER1_OFFSET: libc::c_uint = 518;
pub const GPUREG_ATTRIBBUFFER1_CONFIG1: libc::c_uint = 519;
pub const GPUREG_ATTRIBBUFFER1_CONFIG2: libc::c_uint = 520;
pub const GPUREG_ATTRIBBUFFER2_OFFSET: libc::c_uint = 521;
pub const GPUREG_ATTRIBBUFFER2_CONFIG1: libc::c_uint = 522;
pub const GPUREG_ATTRIBBUFFER2_CONFIG2: libc::c_uint = 523;
pub const GPUREG_ATTRIBBUFFER3_OFFSET: libc::c_uint = 524;
pub const GPUREG_ATTRIBBUFFER3_CONFIG1: libc::c_uint = 525;
pub const GPUREG_ATTRIBBUFFER3_CONFIG2: libc::c_uint = 526;
pub const GPUREG_ATTRIBBUFFER4_OFFSET: libc::c_uint = 527;
pub const GPUREG_ATTRIBBUFFER4_CONFIG1: libc::c_uint = 528;
pub const GPUREG_ATTRIBBUFFER4_CONFIG2: libc::c_uint = 529;
pub const GPUREG_ATTRIBBUFFER5_OFFSET: libc::c_uint = 530;
pub const GPUREG_ATTRIBBUFFER5_CONFIG1: libc::c_uint = 531;
pub const GPUREG_ATTRIBBUFFER5_CONFIG2: libc::c_uint = 532;
pub const GPUREG_ATTRIBBUFFER6_OFFSET: libc::c_uint = 533;
pub const GPUREG_ATTRIBBUFFER6_CONFIG1: libc::c_uint = 534;
pub const GPUREG_ATTRIBBUFFER6_CONFIG2: libc::c_uint = 535;
pub const GPUREG_ATTRIBBUFFER7_OFFSET: libc::c_uint = 536;
pub const GPUREG_ATTRIBBUFFER7_CONFIG1: libc::c_uint = 537;
pub const GPUREG_ATTRIBBUFFER7_CONFIG2: libc::c_uint = 538;
pub const GPUREG_ATTRIBBUFFER8_OFFSET: libc::c_uint = 539;
pub const GPUREG_ATTRIBBUFFER8_CONFIG1: libc::c_uint = 540;
pub const GPUREG_ATTRIBBUFFER8_CONFIG2: libc::c_uint = 541;
pub const GPUREG_ATTRIBBUFFER9_OFFSET: libc::c_uint = 542;
pub const GPUREG_ATTRIBBUFFER9_CONFIG1: libc::c_uint = 543;
pub const GPUREG_ATTRIBBUFFER9_CONFIG2: libc::c_uint = 544;
pub const GPUREG_ATTRIBBUFFERA_OFFSET: libc::c_uint = 545;
pub const GPUREG_ATTRIBBUFFERA_CONFIG1: libc::c_uint = 546;
pub const GPUREG_ATTRIBBUFFERA_CONFIG2: libc::c_uint = 547;
pub const GPUREG_ATTRIBBUFFERB_OFFSET: libc::c_uint = 548;
pub const GPUREG_ATTRIBBUFFERB_CONFIG1: libc::c_uint = 549;
pub const GPUREG_ATTRIBBUFFERB_CONFIG2: libc::c_uint = 550;
pub const GPUREG_INDEXBUFFER_CONFIG: libc::c_uint = 551;
pub const GPUREG_NUMVERTICES: libc::c_uint = 552;
pub const GPUREG_GEOSTAGE_CONFIG: libc::c_uint = 553;
pub const GPUREG_VERTEX_OFFSET: libc::c_uint = 554;
pub const GPUREG_022B: libc::c_uint = 555;
pub const GPUREG_022C: libc::c_uint = 556;
pub const GPUREG_POST_VERTEX_CACHE_NUM: libc::c_uint = 557;
pub const GPUREG_DRAWARRAYS: libc::c_uint = 558;
pub const GPUREG_DRAWELEMENTS: libc::c_uint = 559;
pub const GPUREG_0230: libc::c_uint = 560;
pub const GPUREG_VTX_FUNC: libc::c_uint = 561;
pub const GPUREG_FIXEDATTRIB_INDEX: libc::c_uint = 562;
pub const GPUREG_FIXEDATTRIB_DATA0: libc::c_uint = 563;
pub const GPUREG_FIXEDATTRIB_DATA1: libc::c_uint = 564;
pub const GPUREG_FIXEDATTRIB_DATA2: libc::c_uint = 565;
pub const GPUREG_0236: libc::c_uint = 566;
pub const GPUREG_0237: libc::c_uint = 567;
pub const GPUREG_CMDBUF_SIZE0: libc::c_uint = 568;
pub const GPUREG_CMDBUF_SIZE1: libc::c_uint = 569;
pub const GPUREG_CMDBUF_ADDR0: libc::c_uint = 570;
pub const GPUREG_CMDBUF_ADDR1: libc::c_uint = 571;
pub const GPUREG_CMDBUF_JUMP0: libc::c_uint = 572;
pub const GPUREG_CMDBUF_JUMP1: libc::c_uint = 573;
pub const GPUREG_023E: libc::c_uint = 574;
pub const GPUREG_023F: libc::c_uint = 575;
pub const GPUREG_0240: libc::c_uint = 576;
pub const GPUREG_0241: libc::c_uint = 577;
pub const GPUREG_VSH_NUM_ATTR: libc::c_uint = 578;
pub const GPUREG_0243: libc::c_uint = 579;
pub const GPUREG_VSH_COM_MODE: libc::c_uint = 580;
pub const GPUREG_START_DRAW_FUNC0: libc::c_uint = 581;
pub const GPUREG_0246: libc::c_uint = 582;
pub const GPUREG_0247: libc::c_uint = 583;
pub const GPUREG_0248: libc::c_uint = 584;
pub const GPUREG_0249: libc::c_uint = 585;
pub const GPUREG_VSH_OUTMAP_TOTAL1: libc::c_uint = 586;
pub const GPUREG_024B: libc::c_uint = 587;
pub const GPUREG_024C: libc::c_uint = 588;
pub const GPUREG_024D: libc::c_uint = 589;
pub const GPUREG_024E: libc::c_uint = 590;
pub const GPUREG_024F: libc::c_uint = 591;
pub const GPUREG_0250: libc::c_uint = 592;
pub const GPUREG_VSH_OUTMAP_TOTAL2: libc::c_uint = 593;
pub const GPUREG_GSH_MISC0: libc::c_uint = 594;
pub const GPUREG_GEOSTAGE_CONFIG2: libc::c_uint = 595;
pub const GPUREG_GSH_MISC1: libc::c_uint = 596;
pub const GPUREG_0255: libc::c_uint = 597;
pub const GPUREG_0256: libc::c_uint = 598;
pub const GPUREG_0257: libc::c_uint = 599;
pub const GPUREG_0258: libc::c_uint = 600;
pub const GPUREG_0259: libc::c_uint = 601;
pub const GPUREG_025A: libc::c_uint = 602;
pub const GPUREG_025B: libc::c_uint = 603;
pub const GPUREG_025C: libc::c_uint = 604;
pub const GPUREG_025D: libc::c_uint = 605;
pub const GPUREG_PRIMITIVE_CONFIG: libc::c_uint = 606;
pub const GPUREG_RESTART_PRIMITIVE: libc::c_uint = 607;
pub const GPUREG_0260: libc::c_uint = 608;
pub const GPUREG_0261: libc::c_uint = 609;
pub const GPUREG_0262: libc::c_uint = 610;
pub const GPUREG_0263: libc::c_uint = 611;
pub const GPUREG_0264: libc::c_uint = 612;
pub const GPUREG_0265: libc::c_uint = 613;
pub const GPUREG_0266: libc::c_uint = 614;
pub const GPUREG_0267: libc::c_uint = 615;
pub const GPUREG_0268: libc::c_uint = 616;
pub const GPUREG_0269: libc::c_uint = 617;
pub const GPUREG_026A: libc::c_uint = 618;
pub const GPUREG_026B: libc::c_uint = 619;
pub const GPUREG_026C: libc::c_uint = 620;
pub const GPUREG_026D: libc::c_uint = 621;
pub const GPUREG_026E: libc::c_uint = 622;
pub const GPUREG_026F: libc::c_uint = 623;
pub const GPUREG_0270: libc::c_uint = 624;
pub const GPUREG_0271: libc::c_uint = 625;
pub const GPUREG_0272: libc::c_uint = 626;
pub const GPUREG_0273: libc::c_uint = 627;
pub const GPUREG_0274: libc::c_uint = 628;
pub const GPUREG_0275: libc::c_uint = 629;
pub const GPUREG_0276: libc::c_uint = 630;
pub const GPUREG_0277: libc::c_uint = 631;
pub const GPUREG_0278: libc::c_uint = 632;
pub const GPUREG_0279: libc::c_uint = 633;
pub const GPUREG_027A: libc::c_uint = 634;
pub const GPUREG_027B: libc::c_uint = 635;
pub const GPUREG_027C: libc::c_uint = 636;
pub const GPUREG_027D: libc::c_uint = 637;
pub const GPUREG_027E: libc::c_uint = 638;
pub const GPUREG_027F: libc::c_uint = 639;
pub const GPUREG_GSH_BOOLUNIFORM: libc::c_uint = 640;
pub const GPUREG_GSH_INTUNIFORM_I0: libc::c_uint = 641;
pub const GPUREG_GSH_INTUNIFORM_I1: libc::c_uint = 642;
pub const GPUREG_GSH_INTUNIFORM_I2: libc::c_uint = 643;
pub const GPUREG_GSH_INTUNIFORM_I3: libc::c_uint = 644;
pub const GPUREG_0285: libc::c_uint = 645;
pub const GPUREG_0286: libc::c_uint = 646;
pub const GPUREG_0287: libc::c_uint = 647;
pub const GPUREG_0288: libc::c_uint = 648;
pub const GPUREG_GSH_INPUTBUFFER_CONFIG: libc::c_uint = 649;
pub const GPUREG_GSH_ENTRYPOINT: libc::c_uint = 650;
pub const GPUREG_GSH_ATTRIBUTES_PERMUTATION_LOW: libc::c_uint = 651;
pub const GPUREG_GSH_ATTRIBUTES_PERMUTATION_HIGH: libc::c_uint = 652;
pub const GPUREG_GSH_OUTMAP_MASK: libc::c_uint = 653;
pub const GPUREG_028E: libc::c_uint = 654;
pub const GPUREG_GSH_CODETRANSFER_END: libc::c_uint = 655;
pub const GPUREG_GSH_FLOATUNIFORM_CONFIG: libc::c_uint = 656;
pub const GPUREG_GSH_FLOATUNIFORM_DATA: libc::c_uint = 657;
pub const GPUREG_0299: libc::c_uint = 665;
pub const GPUREG_029A: libc::c_uint = 666;
pub const GPUREG_GSH_CODETRANSFER_CONFIG: libc::c_uint = 667;
pub const GPUREG_GSH_CODETRANSFER_DATA: libc::c_uint = 668;
pub const GPUREG_02A4: libc::c_uint = 676;
pub const GPUREG_GSH_OPDESCS_CONFIG: libc::c_uint = 677;
pub const GPUREG_GSH_OPDESCS_DATA: libc::c_uint = 678;
pub const GPUREG_02AE: libc::c_uint = 686;
pub const GPUREG_02AF: libc::c_uint = 687;
pub const GPUREG_VSH_BOOLUNIFORM: libc::c_uint = 688;
pub const GPUREG_VSH_INTUNIFORM_I0: libc::c_uint = 689;
pub const GPUREG_VSH_INTUNIFORM_I1: libc::c_uint = 690;
pub const GPUREG_VSH_INTUNIFORM_I2: libc::c_uint = 691;
pub const GPUREG_VSH_INTUNIFORM_I3: libc::c_uint = 692;
pub const GPUREG_02B5: libc::c_uint = 693;
pub const GPUREG_02B6: libc::c_uint = 694;
pub const GPUREG_02B7: libc::c_uint = 695;
pub const GPUREG_02B8: libc::c_uint = 696;
pub const GPUREG_VSH_INPUTBUFFER_CONFIG: libc::c_uint = 697;
pub const GPUREG_VSH_ENTRYPOINT: libc::c_uint = 698;
pub const GPUREG_VSH_ATTRIBUTES_PERMUTATION_LOW: libc::c_uint = 699;
pub const GPUREG_VSH_ATTRIBUTES_PERMUTATION_HIGH: libc::c_uint = 700;
pub const GPUREG_VSH_OUTMAP_MASK: libc::c_uint = 701;
pub const GPUREG_02BE: libc::c_uint = 702;
pub const GPUREG_VSH_CODETRANSFER_END: libc::c_uint = 703;
pub const GPUREG_VSH_FLOATUNIFORM_CONFIG: libc::c_uint = 704;
pub const GPUREG_VSH_FLOATUNIFORM_DATA: libc::c_uint = 705;
pub const GPUREG_02C9: libc::c_uint = 713;
pub const GPUREG_02CA: libc::c_uint = 714;
pub const GPUREG_VSH_CODETRANSFER_CONFIG: libc::c_uint = 715;
pub const GPUREG_VSH_CODETRANSFER_DATA: libc::c_uint = 716;
pub const GPUREG_02D4: libc::c_uint = 724;
pub const GPUREG_VSH_OPDESCS_CONFIG: libc::c_uint = 725;
pub const GPUREG_VSH_OPDESCS_DATA: libc::c_uint = 726;
pub const GPUREG_02DE: libc::c_uint = 734;
pub const GPUREG_02DF: libc::c_uint = 735;
pub const GPUREG_02E0: libc::c_uint = 736;
pub const GPUREG_02E1: libc::c_uint = 737;
pub const GPUREG_02E2: libc::c_uint = 738;
pub const GPUREG_02E3: libc::c_uint = 739;
pub const GPUREG_02E4: libc::c_uint = 740;
pub const GPUREG_02E5: libc::c_uint = 741;
pub const GPUREG_02E6: libc::c_uint = 742;
pub const GPUREG_02E7: libc::c_uint = 743;
pub const GPUREG_02E8: libc::c_uint = 744;
pub const GPUREG_02E9: libc::c_uint = 745;
pub const GPUREG_02EA: libc::c_uint = 746;
pub const GPUREG_02EB: libc::c_uint = 747;
pub const GPUREG_02EC: libc::c_uint = 748;
pub const GPUREG_02ED: libc::c_uint = 749;
pub const GPUREG_02EE: libc::c_uint = 750;
pub const GPUREG_02EF: libc::c_uint = 751;
pub const GPUREG_02F0: libc::c_uint = 752;
pub const GPUREG_02F1: libc::c_uint = 753;
pub const GPUREG_02F2: libc::c_uint = 754;
pub const GPUREG_02F3: libc::c_uint = 755;
pub const GPUREG_02F4: libc::c_uint = 756;
pub const GPUREG_02F5: libc::c_uint = 757;
pub const GPUREG_02F6: libc::c_uint = 758;
pub const GPUREG_02F7: libc::c_uint = 759;
pub const GPUREG_02F8: libc::c_uint = 760;
pub const GPUREG_02F9: libc::c_uint = 761;
pub const GPUREG_02FA: libc::c_uint = 762;
pub const GPUREG_02FB: libc::c_uint = 763;
pub const GPUREG_02FC: libc::c_uint = 764;
pub const GPUREG_02FD: libc::c_uint = 765;
pub const GPUREG_02FE: libc::c_uint = 766;
pub const GPUREG_02FF: libc::c_uint = 767;
pub const SWKBD_MAX_WORD_LEN: libc::c_uint = 40;
pub const SWKBD_MAX_BUTTON_TEXT_LEN: libc::c_uint = 16;
pub const SWKBD_MAX_HINT_TEXT_LEN: libc::c_uint = 64;
pub const SWKBD_MAX_CALLBACK_MSG_LEN: libc::c_uint = 256;
pub const SDMC_DIRITER_MAGIC: libc::c_uint = 1935961443;
pub type __int8_t = libc::c_schar;
pub type __uint8_t = libc::c_uchar;
pub type __int16_t = libc::c_short;
pub type __uint16_t = libc::c_ushort;
pub type __int32_t = libc::c_int;
pub type __uint32_t = libc::c_uint;
pub type __int64_t = libc::c_longlong;
pub type __uint64_t = libc::c_ulonglong;
pub type __int_least8_t = libc::c_schar;
pub type __uint_least8_t = libc::c_uchar;
pub type __int_least16_t = libc::c_short;
pub type __uint_least16_t = libc::c_ushort;
pub type __int_least32_t = libc::c_int;
pub type __uint_least32_t = libc::c_uint;
pub type __int_least64_t = libc::c_longlong;
pub type __uint_least64_t = libc::c_ulonglong;
pub type __intmax_t = libc::c_longlong;
pub type __uintmax_t = libc::c_ulonglong;
pub type __intptr_t = libc::c_long;
pub type __uintptr_t = libc::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type int_least8_t = __int_least8_t;
pub type uint_least8_t = __uint_least8_t;
pub type int_least16_t = __int_least16_t;
pub type uint_least16_t = __uint_least16_t;
pub type int_least32_t = __int_least32_t;
pub type uint_least32_t = __uint_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = libc::c_schar;
pub type uint_fast8_t = libc::c_uchar;
pub type int_fast16_t = libc::c_short;
pub type uint_fast16_t = libc::c_ushort;
pub type int_fast32_t = libc::c_int;
pub type uint_fast32_t = libc::c_uint;
pub type int_fast64_t = libc::c_longlong;
pub type uint_fast64_t = libc::c_ulonglong;
pub type wchar_t = libc::c_uint;
#[repr(C)]
#[derive(Copy)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: libc::c_longlong,
    pub __clang_max_align_nonce2: f64,
}
impl Clone for max_align_t {
    fn clone(&self) -> Self { *self }
}
pub type s8 = i8;
pub type s16 = i16;
pub type s32 = i32;
pub type s64 = i64;
pub type vu8 = u8;
pub type vu16 = u16;
pub type vu32 = u32;
pub type vu64 = u64;
pub type vs8 = s8;
pub type vs16 = s16;
pub type vs32 = s32;
pub type vs64 = s64;
pub type Handle = u32;
pub type Result = s32;
pub type ThreadFunc =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut libc::c_void)>;
pub type voidfn = ::core::option::Option<unsafe extern "C" fn()>;
#[repr(C)]
#[derive(Copy)]
pub struct CpuRegisters {
    pub r: [u32; 13usize],
    pub sp: u32,
    pub lr: u32,
    pub pc: u32,
    pub cpsr: u32,
}
impl Clone for CpuRegisters {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct FpuRegisters {
    pub __bindgen_anon_1: FpuRegisters__bindgen_ty_1,
    pub fpscr: u32,
    pub fpexc: u32,
}
#[repr(C)]
#[derive(Copy)]
pub union FpuRegisters__bindgen_ty_1 {
    pub __bindgen_anon_1: FpuRegisters__bindgen_ty_1__bindgen_ty_1,
    pub s: [f32; 32usize],
}
#[repr(C, packed)]
#[derive(Copy)]
pub struct FpuRegisters__bindgen_ty_1__bindgen_ty_1 {
    pub d: [f64; 16usize],
}
impl Clone for FpuRegisters__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Clone for FpuRegisters__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Clone for FpuRegisters {
    fn clone(&self) -> Self { *self }
}
pub const RL_SUCCESS: _bindgen_ty_1 = _bindgen_ty_1::RL_SUCCESS;
pub const RL_INFO: _bindgen_ty_1 = _bindgen_ty_1::RL_INFO;
pub const RL_FATAL: _bindgen_ty_1 = _bindgen_ty_1::RL_FATAL;
pub const RL_RESET: _bindgen_ty_1 = _bindgen_ty_1::RL_RESET;
pub const RL_REINITIALIZE: _bindgen_ty_1 = _bindgen_ty_1::RL_REINITIALIZE;
pub const RL_USAGE: _bindgen_ty_1 = _bindgen_ty_1::RL_USAGE;
pub const RL_PERMANENT: _bindgen_ty_1 = _bindgen_ty_1::RL_PERMANENT;
pub const RL_TEMPORARY: _bindgen_ty_1 = _bindgen_ty_1::RL_TEMPORARY;
pub const RL_STATUS: _bindgen_ty_1 = _bindgen_ty_1::RL_STATUS;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_1 {
    RL_SUCCESS = 0,
    RL_INFO = 1,
    RL_FATAL = 31,
    RL_RESET = 30,
    RL_REINITIALIZE = 29,
    RL_USAGE = 28,
    RL_PERMANENT = 27,
    RL_TEMPORARY = 26,
    RL_STATUS = 25,
}
pub const RS_SUCCESS: _bindgen_ty_2 = _bindgen_ty_2::RS_SUCCESS;
pub const RS_NOP: _bindgen_ty_2 = _bindgen_ty_2::RS_NOP;
pub const RS_WOULDBLOCK: _bindgen_ty_2 = _bindgen_ty_2::RS_WOULDBLOCK;
pub const RS_OUTOFRESOURCE: _bindgen_ty_2 = _bindgen_ty_2::RS_OUTOFRESOURCE;
pub const RS_NOTFOUND: _bindgen_ty_2 = _bindgen_ty_2::RS_NOTFOUND;
pub const RS_INVALIDSTATE: _bindgen_ty_2 = _bindgen_ty_2::RS_INVALIDSTATE;
pub const RS_NOTSUPPORTED: _bindgen_ty_2 = _bindgen_ty_2::RS_NOTSUPPORTED;
pub const RS_INVALIDARG: _bindgen_ty_2 = _bindgen_ty_2::RS_INVALIDARG;
pub const RS_WRONGARG: _bindgen_ty_2 = _bindgen_ty_2::RS_WRONGARG;
pub const RS_CANCELED: _bindgen_ty_2 = _bindgen_ty_2::RS_CANCELED;
pub const RS_STATUSCHANGED: _bindgen_ty_2 = _bindgen_ty_2::RS_STATUSCHANGED;
pub const RS_INTERNAL: _bindgen_ty_2 = _bindgen_ty_2::RS_INTERNAL;
pub const RS_INVALIDRESVAL: _bindgen_ty_2 = _bindgen_ty_2::RS_INVALIDRESVAL;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_2 {
    RS_SUCCESS = 0,
    RS_NOP = 1,
    RS_WOULDBLOCK = 2,
    RS_OUTOFRESOURCE = 3,
    RS_NOTFOUND = 4,
    RS_INVALIDSTATE = 5,
    RS_NOTSUPPORTED = 6,
    RS_INVALIDARG = 7,
    RS_WRONGARG = 8,
    RS_CANCELED = 9,
    RS_STATUSCHANGED = 10,
    RS_INTERNAL = 11,
    RS_INVALIDRESVAL = 63,
}
pub const RM_COMMON: _bindgen_ty_3 = _bindgen_ty_3::RM_COMMON;
pub const RM_KERNEL: _bindgen_ty_3 = _bindgen_ty_3::RM_KERNEL;
pub const RM_UTIL: _bindgen_ty_3 = _bindgen_ty_3::RM_UTIL;
pub const RM_FILE_SERVER: _bindgen_ty_3 = _bindgen_ty_3::RM_FILE_SERVER;
pub const RM_LOADER_SERVER: _bindgen_ty_3 = _bindgen_ty_3::RM_LOADER_SERVER;
pub const RM_TCB: _bindgen_ty_3 = _bindgen_ty_3::RM_TCB;
pub const RM_OS: _bindgen_ty_3 = _bindgen_ty_3::RM_OS;
pub const RM_DBG: _bindgen_ty_3 = _bindgen_ty_3::RM_DBG;
pub const RM_DMNT: _bindgen_ty_3 = _bindgen_ty_3::RM_DMNT;
pub const RM_PDN: _bindgen_ty_3 = _bindgen_ty_3::RM_PDN;
pub const RM_GSP: _bindgen_ty_3 = _bindgen_ty_3::RM_GSP;
pub const RM_I2C: _bindgen_ty_3 = _bindgen_ty_3::RM_I2C;
pub const RM_GPIO: _bindgen_ty_3 = _bindgen_ty_3::RM_GPIO;
pub const RM_DD: _bindgen_ty_3 = _bindgen_ty_3::RM_DD;
pub const RM_CODEC: _bindgen_ty_3 = _bindgen_ty_3::RM_CODEC;
pub const RM_SPI: _bindgen_ty_3 = _bindgen_ty_3::RM_SPI;
pub const RM_PXI: _bindgen_ty_3 = _bindgen_ty_3::RM_PXI;
pub const RM_FS: _bindgen_ty_3 = _bindgen_ty_3::RM_FS;
pub const RM_DI: _bindgen_ty_3 = _bindgen_ty_3::RM_DI;
pub const RM_HID: _bindgen_ty_3 = _bindgen_ty_3::RM_HID;
pub const RM_CAM: _bindgen_ty_3 = _bindgen_ty_3::RM_CAM;
pub const RM_PI: _bindgen_ty_3 = _bindgen_ty_3::RM_PI;
pub const RM_PM: _bindgen_ty_3 = _bindgen_ty_3::RM_PM;
pub const RM_PM_LOW: _bindgen_ty_3 = _bindgen_ty_3::RM_PM_LOW;
pub const RM_FSI: _bindgen_ty_3 = _bindgen_ty_3::RM_FSI;
pub const RM_SRV: _bindgen_ty_3 = _bindgen_ty_3::RM_SRV;
pub const RM_NDM: _bindgen_ty_3 = _bindgen_ty_3::RM_NDM;
pub const RM_NWM: _bindgen_ty_3 = _bindgen_ty_3::RM_NWM;
pub const RM_SOC: _bindgen_ty_3 = _bindgen_ty_3::RM_SOC;
pub const RM_LDR: _bindgen_ty_3 = _bindgen_ty_3::RM_LDR;
pub const RM_ACC: _bindgen_ty_3 = _bindgen_ty_3::RM_ACC;
pub const RM_ROMFS: _bindgen_ty_3 = _bindgen_ty_3::RM_ROMFS;
pub const RM_AM: _bindgen_ty_3 = _bindgen_ty_3::RM_AM;
pub const RM_HIO: _bindgen_ty_3 = _bindgen_ty_3::RM_HIO;
pub const RM_UPDATER: _bindgen_ty_3 = _bindgen_ty_3::RM_UPDATER;
pub const RM_MIC: _bindgen_ty_3 = _bindgen_ty_3::RM_MIC;
pub const RM_FND: _bindgen_ty_3 = _bindgen_ty_3::RM_FND;
pub const RM_MP: _bindgen_ty_3 = _bindgen_ty_3::RM_MP;
pub const RM_MPWL: _bindgen_ty_3 = _bindgen_ty_3::RM_MPWL;
pub const RM_AC: _bindgen_ty_3 = _bindgen_ty_3::RM_AC;
pub const RM_HTTP: _bindgen_ty_3 = _bindgen_ty_3::RM_HTTP;
pub const RM_DSP: _bindgen_ty_3 = _bindgen_ty_3::RM_DSP;
pub const RM_SND: _bindgen_ty_3 = _bindgen_ty_3::RM_SND;
pub const RM_DLP: _bindgen_ty_3 = _bindgen_ty_3::RM_DLP;
pub const RM_HIO_LOW: _bindgen_ty_3 = _bindgen_ty_3::RM_HIO_LOW;
pub const RM_CSND: _bindgen_ty_3 = _bindgen_ty_3::RM_CSND;
pub const RM_SSL: _bindgen_ty_3 = _bindgen_ty_3::RM_SSL;
pub const RM_AM_LOW: _bindgen_ty_3 = _bindgen_ty_3::RM_AM_LOW;
pub const RM_NEX: _bindgen_ty_3 = _bindgen_ty_3::RM_NEX;
pub const RM_FRIENDS: _bindgen_ty_3 = _bindgen_ty_3::RM_FRIENDS;
pub const RM_RDT: _bindgen_ty_3 = _bindgen_ty_3::RM_RDT;
pub const RM_APPLET: _bindgen_ty_3 = _bindgen_ty_3::RM_APPLET;
pub const RM_NIM: _bindgen_ty_3 = _bindgen_ty_3::RM_NIM;
pub const RM_PTM: _bindgen_ty_3 = _bindgen_ty_3::RM_PTM;
pub const RM_MIDI: _bindgen_ty_3 = _bindgen_ty_3::RM_MIDI;
pub const RM_MC: _bindgen_ty_3 = _bindgen_ty_3::RM_MC;
pub const RM_SWC: _bindgen_ty_3 = _bindgen_ty_3::RM_SWC;
pub const RM_FATFS: _bindgen_ty_3 = _bindgen_ty_3::RM_FATFS;
pub const RM_NGC: _bindgen_ty_3 = _bindgen_ty_3::RM_NGC;
pub const RM_CARD: _bindgen_ty_3 = _bindgen_ty_3::RM_CARD;
pub const RM_CARDNOR: _bindgen_ty_3 = _bindgen_ty_3::RM_CARDNOR;
pub const RM_SDMC: _bindgen_ty_3 = _bindgen_ty_3::RM_SDMC;
pub const RM_BOSS: _bindgen_ty_3 = _bindgen_ty_3::RM_BOSS;
pub const RM_DBM: _bindgen_ty_3 = _bindgen_ty_3::RM_DBM;
pub const RM_CONFIG: _bindgen_ty_3 = _bindgen_ty_3::RM_CONFIG;
pub const RM_PS: _bindgen_ty_3 = _bindgen_ty_3::RM_PS;
pub const RM_CEC: _bindgen_ty_3 = _bindgen_ty_3::RM_CEC;
pub const RM_IR: _bindgen_ty_3 = _bindgen_ty_3::RM_IR;
pub const RM_UDS: _bindgen_ty_3 = _bindgen_ty_3::RM_UDS;
pub const RM_PL: _bindgen_ty_3 = _bindgen_ty_3::RM_PL;
pub const RM_CUP: _bindgen_ty_3 = _bindgen_ty_3::RM_CUP;
pub const RM_GYROSCOPE: _bindgen_ty_3 = _bindgen_ty_3::RM_GYROSCOPE;
pub const RM_MCU: _bindgen_ty_3 = _bindgen_ty_3::RM_MCU;
pub const RM_NS: _bindgen_ty_3 = _bindgen_ty_3::RM_NS;
pub const RM_NEWS: _bindgen_ty_3 = _bindgen_ty_3::RM_NEWS;
pub const RM_RO: _bindgen_ty_3 = _bindgen_ty_3::RM_RO;
pub const RM_GD: _bindgen_ty_3 = _bindgen_ty_3::RM_GD;
pub const RM_CARD_SPI: _bindgen_ty_3 = _bindgen_ty_3::RM_CARD_SPI;
pub const RM_EC: _bindgen_ty_3 = _bindgen_ty_3::RM_EC;
pub const RM_WEB_BROWSER: _bindgen_ty_3 = _bindgen_ty_3::RM_WEB_BROWSER;
pub const RM_TEST: _bindgen_ty_3 = _bindgen_ty_3::RM_TEST;
pub const RM_ENC: _bindgen_ty_3 = _bindgen_ty_3::RM_ENC;
pub const RM_PIA: _bindgen_ty_3 = _bindgen_ty_3::RM_PIA;
pub const RM_ACT: _bindgen_ty_3 = _bindgen_ty_3::RM_ACT;
pub const RM_VCTL: _bindgen_ty_3 = _bindgen_ty_3::RM_VCTL;
pub const RM_OLV: _bindgen_ty_3 = _bindgen_ty_3::RM_OLV;
pub const RM_NEIA: _bindgen_ty_3 = _bindgen_ty_3::RM_NEIA;
pub const RM_NPNS: _bindgen_ty_3 = _bindgen_ty_3::RM_NPNS;
pub const RM_AVD: _bindgen_ty_3 = _bindgen_ty_3::RM_AVD;
pub const RM_L2B: _bindgen_ty_3 = _bindgen_ty_3::RM_L2B;
pub const RM_MVD: _bindgen_ty_3 = _bindgen_ty_3::RM_MVD;
pub const RM_NFC: _bindgen_ty_3 = _bindgen_ty_3::RM_NFC;
pub const RM_UART: _bindgen_ty_3 = _bindgen_ty_3::RM_UART;
pub const RM_SPM: _bindgen_ty_3 = _bindgen_ty_3::RM_SPM;
pub const RM_QTM: _bindgen_ty_3 = _bindgen_ty_3::RM_QTM;
pub const RM_NFP: _bindgen_ty_3 = _bindgen_ty_3::RM_NFP;
pub const RM_APPLICATION: _bindgen_ty_3 = _bindgen_ty_3::RM_APPLICATION;
pub const RM_INVALIDRESVAL: _bindgen_ty_3 = _bindgen_ty_3::RM_INVALIDRESVAL;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_3 {
    RM_COMMON = 0,
    RM_KERNEL = 1,
    RM_UTIL = 2,
    RM_FILE_SERVER = 3,
    RM_LOADER_SERVER = 4,
    RM_TCB = 5,
    RM_OS = 6,
    RM_DBG = 7,
    RM_DMNT = 8,
    RM_PDN = 9,
    RM_GSP = 10,
    RM_I2C = 11,
    RM_GPIO = 12,
    RM_DD = 13,
    RM_CODEC = 14,
    RM_SPI = 15,
    RM_PXI = 16,
    RM_FS = 17,
    RM_DI = 18,
    RM_HID = 19,
    RM_CAM = 20,
    RM_PI = 21,
    RM_PM = 22,
    RM_PM_LOW = 23,
    RM_FSI = 24,
    RM_SRV = 25,
    RM_NDM = 26,
    RM_NWM = 27,
    RM_SOC = 28,
    RM_LDR = 29,
    RM_ACC = 30,
    RM_ROMFS = 31,
    RM_AM = 32,
    RM_HIO = 33,
    RM_UPDATER = 34,
    RM_MIC = 35,
    RM_FND = 36,
    RM_MP = 37,
    RM_MPWL = 38,
    RM_AC = 39,
    RM_HTTP = 40,
    RM_DSP = 41,
    RM_SND = 42,
    RM_DLP = 43,
    RM_HIO_LOW = 44,
    RM_CSND = 45,
    RM_SSL = 46,
    RM_AM_LOW = 47,
    RM_NEX = 48,
    RM_FRIENDS = 49,
    RM_RDT = 50,
    RM_APPLET = 51,
    RM_NIM = 52,
    RM_PTM = 53,
    RM_MIDI = 54,
    RM_MC = 55,
    RM_SWC = 56,
    RM_FATFS = 57,
    RM_NGC = 58,
    RM_CARD = 59,
    RM_CARDNOR = 60,
    RM_SDMC = 61,
    RM_BOSS = 62,
    RM_DBM = 63,
    RM_CONFIG = 64,
    RM_PS = 65,
    RM_CEC = 66,
    RM_IR = 67,
    RM_UDS = 68,
    RM_PL = 69,
    RM_CUP = 70,
    RM_GYROSCOPE = 71,
    RM_MCU = 72,
    RM_NS = 73,
    RM_NEWS = 74,
    RM_RO = 75,
    RM_GD = 76,
    RM_CARD_SPI = 77,
    RM_EC = 78,
    RM_WEB_BROWSER = 79,
    RM_TEST = 80,
    RM_ENC = 81,
    RM_PIA = 82,
    RM_ACT = 83,
    RM_VCTL = 84,
    RM_OLV = 85,
    RM_NEIA = 86,
    RM_NPNS = 87,
    RM_AVD = 90,
    RM_L2B = 91,
    RM_MVD = 92,
    RM_NFC = 93,
    RM_UART = 94,
    RM_SPM = 95,
    RM_QTM = 96,
    RM_NFP = 97,
    RM_APPLICATION = 254,
    RM_INVALIDRESVAL = 255,
}
pub const RD_SUCCESS: _bindgen_ty_4 = _bindgen_ty_4::RD_SUCCESS;
pub const RD_INVALID_RESULT_VALUE: _bindgen_ty_4 =
    _bindgen_ty_4::RD_INVALID_RESULT_VALUE;
pub const RD_TIMEOUT: _bindgen_ty_4 = _bindgen_ty_4::RD_TIMEOUT;
pub const RD_OUT_OF_RANGE: _bindgen_ty_4 = _bindgen_ty_4::RD_OUT_OF_RANGE;
pub const RD_ALREADY_EXISTS: _bindgen_ty_4 = _bindgen_ty_4::RD_ALREADY_EXISTS;
pub const RD_CANCEL_REQUESTED: _bindgen_ty_4 =
    _bindgen_ty_4::RD_CANCEL_REQUESTED;
pub const RD_NOT_FOUND: _bindgen_ty_4 = _bindgen_ty_4::RD_NOT_FOUND;
pub const RD_ALREADY_INITIALIZED: _bindgen_ty_4 =
    _bindgen_ty_4::RD_ALREADY_INITIALIZED;
pub const RD_NOT_INITIALIZED: _bindgen_ty_4 =
    _bindgen_ty_4::RD_NOT_INITIALIZED;
pub const RD_INVALID_HANDLE: _bindgen_ty_4 = _bindgen_ty_4::RD_INVALID_HANDLE;
pub const RD_INVALID_POINTER: _bindgen_ty_4 =
    _bindgen_ty_4::RD_INVALID_POINTER;
pub const RD_INVALID_ADDRESS: _bindgen_ty_4 =
    _bindgen_ty_4::RD_INVALID_ADDRESS;
pub const RD_NOT_IMPLEMENTED: _bindgen_ty_4 =
    _bindgen_ty_4::RD_NOT_IMPLEMENTED;
pub const RD_OUT_OF_MEMORY: _bindgen_ty_4 = _bindgen_ty_4::RD_OUT_OF_MEMORY;
pub const RD_MISALIGNED_SIZE: _bindgen_ty_4 =
    _bindgen_ty_4::RD_MISALIGNED_SIZE;
pub const RD_MISALIGNED_ADDRESS: _bindgen_ty_4 =
    _bindgen_ty_4::RD_MISALIGNED_ADDRESS;
pub const RD_BUSY: _bindgen_ty_4 = _bindgen_ty_4::RD_BUSY;
pub const RD_NO_DATA: _bindgen_ty_4 = _bindgen_ty_4::RD_NO_DATA;
pub const RD_INVALID_COMBINATION: _bindgen_ty_4 =
    _bindgen_ty_4::RD_INVALID_COMBINATION;
pub const RD_INVALID_ENUM_VALUE: _bindgen_ty_4 =
    _bindgen_ty_4::RD_INVALID_ENUM_VALUE;
pub const RD_INVALID_SIZE: _bindgen_ty_4 = _bindgen_ty_4::RD_INVALID_SIZE;
pub const RD_ALREADY_DONE: _bindgen_ty_4 = _bindgen_ty_4::RD_ALREADY_DONE;
pub const RD_NOT_AUTHORIZED: _bindgen_ty_4 = _bindgen_ty_4::RD_NOT_AUTHORIZED;
pub const RD_TOO_LARGE: _bindgen_ty_4 = _bindgen_ty_4::RD_TOO_LARGE;
pub const RD_INVALID_SELECTION: _bindgen_ty_4 =
    _bindgen_ty_4::RD_INVALID_SELECTION;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_4 {
    RD_SUCCESS = 0,
    RD_INVALID_RESULT_VALUE = 1023,
    RD_TIMEOUT = 1022,
    RD_OUT_OF_RANGE = 1021,
    RD_ALREADY_EXISTS = 1020,
    RD_CANCEL_REQUESTED = 1019,
    RD_NOT_FOUND = 1018,
    RD_ALREADY_INITIALIZED = 1017,
    RD_NOT_INITIALIZED = 1016,
    RD_INVALID_HANDLE = 1015,
    RD_INVALID_POINTER = 1014,
    RD_INVALID_ADDRESS = 1013,
    RD_NOT_IMPLEMENTED = 1012,
    RD_OUT_OF_MEMORY = 1011,
    RD_MISALIGNED_SIZE = 1010,
    RD_MISALIGNED_ADDRESS = 1009,
    RD_BUSY = 1008,
    RD_NO_DATA = 1007,
    RD_INVALID_COMBINATION = 1006,
    RD_INVALID_ENUM_VALUE = 1005,
    RD_INVALID_SIZE = 1004,
    RD_ALREADY_DONE = 1003,
    RD_NOT_AUTHORIZED = 1002,
    RD_TOO_LARGE = 1001,
    RD_INVALID_SELECTION = 1000,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum IPC_BufferRights {
    IPC_BUFFER_R = 2,
    IPC_BUFFER_W = 4,
    IPC_BUFFER_RW = 6,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum MemOp {
    MEMOP_FREE = 1,
    MEMOP_RESERVE = 2,
    MEMOP_ALLOC = 3,
    MEMOP_MAP = 4,
    MEMOP_UNMAP = 5,
    MEMOP_PROT = 6,
    MEMOP_REGION_APP = 256,
    MEMOP_REGION_SYSTEM = 512,
    MEMOP_REGION_BASE = 768,
    MEMOP_OP_MASK = 255,
    MEMOP_REGION_MASK = 3840,
    MEMOP_LINEAR_FLAG = 65536,
    MEMOP_ALLOC_LINEAR = 65539,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum MemState {
    MEMSTATE_FREE = 0,
    MEMSTATE_RESERVED = 1,
    MEMSTATE_IO = 2,
    MEMSTATE_STATIC = 3,
    MEMSTATE_CODE = 4,
    MEMSTATE_PRIVATE = 5,
    MEMSTATE_SHARED = 6,
    MEMSTATE_CONTINUOUS = 7,
    MEMSTATE_ALIASED = 8,
    MEMSTATE_ALIAS = 9,
    MEMSTATE_ALIASCODE = 10,
    MEMSTATE_LOCKED = 11,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum MemPerm {
    MEMPERM_READ = 1,
    MEMPERM_WRITE = 2,
    MEMPERM_EXECUTE = 4,
    MEMPERM_DONTCARE = 268435456,
}
#[repr(C)]
#[derive(Copy)]
pub struct MemInfo {
    pub base_addr: u32,
    pub size: u32,
    pub perm: u32,
    pub state: u32,
}
impl Clone for MemInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct PageInfo {
    pub flags: u32,
}
impl Clone for PageInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ArbitrationType {
    ARBITRATION_SIGNAL = 0,
    ARBITRATION_WAIT_IF_LESS_THAN = 1,
    ARBITRATION_DECREMENT_AND_WAIT_IF_LESS_THAN = 2,
    ARBITRATION_WAIT_IF_LESS_THAN_TIMEOUT = 3,
    ARBITRATION_DECREMENT_AND_WAIT_IF_LESS_THAN_TIMEOUT = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ResetType { RESET_ONESHOT = 0, RESET_STICKY = 1, RESET_PULSE = 2, }
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ThreadInfoType { THREADINFO_TYPE_UNKNOWN = 0, }
#[repr(C)]
#[derive(Copy)]
pub struct AttachProcessEvent {
    pub program_id: u64,
    pub process_name: [libc::c_char; 8usize],
    pub process_id: u32,
    pub other_flags: u32,
}
impl Clone for AttachProcessEvent {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ExitProcessEventReason {
    EXITPROCESS_EVENT_EXIT = 0,
    EXITPROCESS_EVENT_TERMINATE = 1,
    EXITPROCESS_EVENT_DEBUG_TERMINATE = 2,
}
#[repr(C)]
#[derive(Copy)]
pub struct ExitProcessEvent {
    pub reason: ExitProcessEventReason,
}
impl Clone for ExitProcessEvent {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct AttachThreadEvent {
    pub creator_thread_id: u32,
    pub thread_local_storage: u32,
    pub entry_point: u32,
}
impl Clone for AttachThreadEvent {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ExitThreadEventReason {
    EXITTHREAD_EVENT_EXIT = 0,
    EXITTHREAD_EVENT_TERMINATE = 1,
    EXITTHREAD_EVENT_EXIT_PROCESS = 2,
    EXITTHREAD_EVENT_TERMINATE_PROCESS = 3,
}
#[repr(C)]
#[derive(Copy)]
pub struct ExitThreadEvent {
    pub reason: ExitThreadEventReason,
}
impl Clone for ExitThreadEvent {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum UserBreakType {
    USERBREAK_PANIC = 0,
    USERBREAK_ASSERT = 1,
    USERBREAK_USER = 2,
    USERBREAK_LOAD_RO = 3,
    USERBREAK_UNLOAD_RO = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ExceptionEventType {
    EXCEVENT_UNDEFINED_INSTRUCTION = 0,
    EXCEVENT_PREFETCH_ABORT = 1,
    EXCEVENT_DATA_ABORT = 2,
    EXCEVENT_UNALIGNED_DATA_ACCESS = 3,
    EXCEVENT_ATTACH_BREAK = 4,
    EXCEVENT_STOP_POINT = 5,
    EXCEVENT_USER_BREAK = 6,
    EXCEVENT_DEBUGGER_BREAK = 7,
    EXCEVENT_UNDEFINED_SYSCALL = 8,
}
#[repr(C)]
#[derive(Copy)]
pub struct FaultExceptionEvent {
    pub fault_information: u32,
}
impl Clone for FaultExceptionEvent {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum StopPointType {
    STOPPOINT_SVC_FF = 0,
    STOPPOINT_BREAKPOINT = 1,
    STOPPOINT_WATCHPOINT = 2,
}
#[repr(C)]
#[derive(Copy)]
pub struct StopPointExceptionEvent {
    pub type_: StopPointType,
    pub fault_information: u32,
}
impl Clone for StopPointExceptionEvent {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct UserBreakExceptionEvent {
    pub type_: UserBreakType,
    pub croInfo: u32,
    pub croInfoSize: u32,
}
impl Clone for UserBreakExceptionEvent {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct DebuggerBreakExceptionEvent {
    pub thread_ids: [s32; 4usize],
}
impl Clone for DebuggerBreakExceptionEvent {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ExceptionEvent {
    pub type_: ExceptionEventType,
    pub address: u32,
    pub __bindgen_anon_1: ExceptionEvent__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub union ExceptionEvent__bindgen_ty_1 {
    pub fault: FaultExceptionEvent,
    pub stop_point: StopPointExceptionEvent,
    pub user_break: UserBreakExceptionEvent,
    pub debugger_break: DebuggerBreakExceptionEvent,
}
impl Clone for ExceptionEvent__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Clone for ExceptionEvent {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ScheduleInOutEvent {
    pub clock_tick: u64,
}
impl Clone for ScheduleInOutEvent {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct SyscallInOutEvent {
    pub clock_tick: u64,
    pub syscall: u32,
}
impl Clone for SyscallInOutEvent {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct OutputStringEvent {
    pub string_addr: u32,
    pub string_size: u32,
}
impl Clone for OutputStringEvent {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct MapEvent {
    pub mapped_addr: u32,
    pub mapped_size: u32,
    pub memperm: MemPerm,
    pub memstate: MemState,
}
impl Clone for MapEvent {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum DebugEventType {
    DBGEVENT_ATTACH_PROCESS = 0,
    DBGEVENT_ATTACH_THREAD = 1,
    DBGEVENT_EXIT_THREAD = 2,
    DBGEVENT_EXIT_PROCESS = 3,
    DBGEVENT_EXCEPTION = 4,
    DBGEVENT_DLL_LOAD = 5,
    DBGEVENT_DLL_UNLOAD = 6,
    DBGEVENT_SCHEDULE_IN = 7,
    DBGEVENT_SCHEDULE_OUT = 8,
    DBGEVENT_SYSCALL_IN = 9,
    DBGEVENT_SYSCALL_OUT = 10,
    DBGEVENT_OUTPUT_STRING = 11,
    DBGEVENT_MAP = 12,
}
#[repr(C)]
#[derive(Copy)]
pub struct DebugEventInfo {
    pub type_: DebugEventType,
    pub thread_id: u32,
    pub flags: u32,
    pub remnants: [u8; 4usize],
    pub __bindgen_anon_1: DebugEventInfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub union DebugEventInfo__bindgen_ty_1 {
    pub attach_process: AttachProcessEvent,
    pub attach_thread: AttachThreadEvent,
    pub exit_thread: ExitThreadEvent,
    pub exit_process: ExitProcessEvent,
    pub exception: ExceptionEvent,
    pub scheduler: ScheduleInOutEvent,
    pub syscall: SyscallInOutEvent,
    pub output_string: OutputStringEvent,
    pub map: MapEvent,
}
impl Clone for DebugEventInfo__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Clone for DebugEventInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum DebugFlags {
    DBG_INHIBIT_USER_CPU_EXCEPTION_HANDLERS = 1,
    DBG_SIGNAL_FAULT_EXCEPTION_EVENTS = 2,
    DBG_SIGNAL_SCHEDULE_EVENTS = 4,
    DBG_SIGNAL_SYSCALL_EVENTS = 8,
    DBG_SIGNAL_MAP_EVENTS = 16,
}
#[repr(C)]
#[derive(Copy)]
pub struct ThreadContext {
    pub cpu_registers: CpuRegisters,
    pub fpu_registers: FpuRegisters,
}
impl Clone for ThreadContext {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ThreadContextControlFlags {
    THREADCONTEXT_CONTROL_CPU_GPRS = 1,
    THREADCONTEXT_CONTROL_CPU_SPRS = 2,
    THREADCONTEXT_CONTROL_FPU_GPRS = 4,
    THREADCONTEXT_CONTROL_FPU_SPRS = 8,
    THREADCONTEXT_CONTROL_CPU_REGS = 3,
    THREADCONTEXT_CONTROL_FPU_REGS = 12,
    THREADCONTEXT_CONTROL_ALL = 15,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum DebugThreadParameter {
    DBGTHREAD_PARAMETER_PRIORITY = 0,
    DBGTHREAD_PARAMETER_SCHEDULING_MASK_LOW = 1,
    DBGTHREAD_PARAMETER_CPU_IDEAL = 2,
    DBGTHREAD_PARAMETER_CPU_CREATOR = 3,
}
#[repr(C)]
#[derive(Copy)]
pub struct CodeSetInfo {
    pub name: [u8; 8usize],
    pub unk1: u16,
    pub unk2: u16,
    pub unk3: u32,
    pub text_addr: u32,
    pub text_size: u32,
    pub ro_addr: u32,
    pub ro_size: u32,
    pub rw_addr: u32,
    pub rw_size: u32,
    pub text_size_total: u32,
    pub ro_size_total: u32,
    pub rw_size_total: u32,
    pub unk4: u32,
    pub program_id: u64,
}
impl Clone for CodeSetInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct StartupInfo {
    pub priority: libc::c_int,
    pub stack_size: u32,
    pub argc: libc::c_int,
    pub argv: *mut u16,
    pub envp: *mut u16,
}
impl Clone for StartupInfo {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn svcControlMemory(addr_out: *mut u32, addr0: u32, addr1: u32,
                            size: u32, op: MemOp, perm: MemPerm) -> Result;
}
extern "C" {
    pub fn svcControlProcessMemory(process: Handle, addr0: u32, addr1: u32,
                                   size: u32, type_: u32, perm: u32)
     -> Result;
}
extern "C" {
    pub fn svcCreateMemoryBlock(memblock: *mut Handle, addr: u32, size: u32,
                                my_perm: MemPerm, other_perm: MemPerm)
     -> Result;
}
extern "C" {
    pub fn svcMapMemoryBlock(memblock: Handle, addr: u32, my_perm: MemPerm,
                             other_perm: MemPerm) -> Result;
}
extern "C" {
    pub fn svcMapProcessMemory(process: Handle, destAddress: u32, size: u32)
     -> Result;
}
extern "C" {
    pub fn svcUnmapProcessMemory(process: Handle, destAddress: u32, size: u32)
     -> Result;
}
extern "C" {
    pub fn svcUnmapMemoryBlock(memblock: Handle, addr: u32) -> Result;
}
extern "C" {
    pub fn svcStartInterProcessDma(dma: *mut Handle, dstProcess: Handle,
                                   dst: *mut libc::c_void, srcProcess: Handle,
                                   src: *const libc::c_void, size: u32,
                                   dmaConfig: *mut libc::c_void) -> Result;
}
extern "C" {
    pub fn svcStopDma(dma: Handle) -> Result;
}
extern "C" {
    pub fn svcGetDmaState(dmaState: *mut libc::c_void, dma: Handle) -> Result;
}
extern "C" {
    pub fn svcQueryMemory(info: *mut MemInfo, out: *mut PageInfo, addr: u32)
     -> Result;
}
extern "C" {
    pub fn svcQueryProcessMemory(info: *mut MemInfo, out: *mut PageInfo,
                                 process: Handle, addr: u32) -> Result;
}
extern "C" {
    pub fn svcInvalidateProcessDataCache(process: Handle,
                                         addr: *mut libc::c_void, size: u32)
     -> Result;
}
extern "C" {
    pub fn svcStoreProcessDataCache(process: Handle, addr: *mut libc::c_void,
                                    size: u32) -> Result;
}
extern "C" {
    pub fn svcFlushProcessDataCache(process: Handle,
                                    addr: *const libc::c_void, size: u32)
     -> Result;
}
extern "C" {
    pub fn svcOpenProcess(process: *mut Handle, processId: u32) -> Result;
}
extern "C" {
    pub fn svcExitProcess();
}
extern "C" {
    pub fn svcTerminateProcess(process: Handle) -> Result;
}
extern "C" {
    pub fn svcGetProcessInfo(out: *mut s64, process: Handle, type_: u32)
     -> Result;
}
extern "C" {
    pub fn svcGetProcessId(out: *mut u32, handle: Handle) -> Result;
}
extern "C" {
    pub fn svcGetProcessList(processCount: *mut s32, processIds: *mut u32,
                             processIdMaxCount: s32) -> Result;
}
extern "C" {
    pub fn svcGetThreadList(threadCount: *mut s32, threadIds: *mut u32,
                            threadIdMaxCount: s32, process: Handle) -> Result;
}
extern "C" {
    pub fn svcCreatePort(portServer: *mut Handle, portClient: *mut Handle,
                         name: *const libc::c_char, maxSessions: s32)
     -> Result;
}
extern "C" {
    pub fn svcConnectToPort(out: *mut Handle, portName: *const libc::c_char)
     -> Result;
}
extern "C" {
    pub fn svcCreateCodeSet(out: *mut Handle, info: *const CodeSetInfo,
                            code_ptr: *mut libc::c_void,
                            ro_ptr: *mut libc::c_void,
                            data_ptr: *mut libc::c_void) -> Result;
}
extern "C" {
    pub fn svcCreateProcess(out: *mut Handle, codeset: Handle,
                            arm11kernelcaps: *const u32,
                            arm11kernelcaps_num: u32) -> Result;
}
extern "C" {
    pub fn svcGetProcessAffinityMask(affinitymask: *mut u8, process: Handle,
                                     processorcount: s32) -> Result;
}
extern "C" {
    pub fn svcSetProcessAffinityMask(process: Handle, affinitymask: *const u8,
                                     processorcount: s32) -> Result;
}
extern "C" {
    pub fn svcGetProcessIdealProcessor(processorid: *mut s32, process: Handle)
     -> Result;
}
extern "C" {
    pub fn svcSetProcessIdealProcessor(process: Handle, processorid: s32)
     -> Result;
}
extern "C" {
    pub fn svcRun(process: Handle, info: *const StartupInfo) -> Result;
}
extern "C" {
    pub fn svcCreateThread(thread: *mut Handle, entrypoint: ThreadFunc,
                           arg: u32, stack_top: *mut u32,
                           thread_priority: s32, processor_id: s32) -> Result;
}
extern "C" {
    pub fn svcOpenThread(thread: *mut Handle, process: Handle, threadId: u32)
     -> Result;
}
extern "C" {
    pub fn svcExitThread();
}
extern "C" {
    pub fn svcSleepThread(ns: s64);
}
extern "C" {
    pub fn svcGetThreadPriority(out: *mut s32, handle: Handle) -> Result;
}
extern "C" {
    pub fn svcSetThreadPriority(thread: Handle, prio: s32) -> Result;
}
extern "C" {
    pub fn svcGetThreadAffinityMask(affinitymask: *mut u8, thread: Handle,
                                    processorcount: s32) -> Result;
}
extern "C" {
    pub fn svcSetThreadAffinityMask(thread: Handle, affinitymask: *const u8,
                                    processorcount: s32) -> Result;
}
extern "C" {
    pub fn svcGetThreadIdealProcessor(processorid: *mut s32, thread: Handle)
     -> Result;
}
extern "C" {
    pub fn svcSetThreadIdealProcessor(thread: Handle, processorid: s32)
     -> Result;
}
extern "C" {
    pub fn svcGetProcessorID() -> s32;
}
extern "C" {
    pub fn svcGetThreadId(out: *mut u32, handle: Handle) -> Result;
}
extern "C" {
    pub fn svcGetResourceLimit(resourceLimit: *mut Handle, process: Handle)
     -> Result;
}
extern "C" {
    pub fn svcGetResourceLimitLimitValues(values: *mut s64,
                                          resourceLimit: Handle,
                                          names: *mut u32, nameCount: s32)
     -> Result;
}
extern "C" {
    pub fn svcGetResourceLimitCurrentValues(values: *mut s64,
                                            resourceLimit: Handle,
                                            names: *mut u32, nameCount: s32)
     -> Result;
}
extern "C" {
    pub fn svcSetProcessResourceLimits(process: Handle, resourceLimit: Handle)
     -> Result;
}
extern "C" {
    pub fn svcCreateResourceLimit(resourceLimit: *mut Handle) -> Result;
}
extern "C" {
    pub fn svcSetResourceLimitValues(resourceLimit: Handle, names: *const u32,
                                     values: *const s64, nameCount: s32)
     -> Result;
}
extern "C" {
    pub fn svcGetProcessIdOfThread(out: *mut u32, handle: Handle) -> Result;
}
extern "C" {
    pub fn svcGetThreadInfo(out: *mut s64, thread: Handle,
                            type_: ThreadInfoType) -> Result;
}
extern "C" {
    pub fn svcCreateMutex(mutex: *mut Handle, initially_locked: bool)
     -> Result;
}
extern "C" {
    pub fn svcReleaseMutex(handle: Handle) -> Result;
}
extern "C" {
    pub fn svcCreateSemaphore(semaphore: *mut Handle, initial_count: s32,
                              max_count: s32) -> Result;
}
extern "C" {
    pub fn svcReleaseSemaphore(count: *mut s32, semaphore: Handle,
                               release_count: s32) -> Result;
}
extern "C" {
    pub fn svcCreateEvent(event: *mut Handle, reset_type: ResetType)
     -> Result;
}
extern "C" {
    pub fn svcSignalEvent(handle: Handle) -> Result;
}
extern "C" {
    pub fn svcClearEvent(handle: Handle) -> Result;
}
extern "C" {
    pub fn svcWaitSynchronization(handle: Handle, nanoseconds: s64) -> Result;
}
extern "C" {
    pub fn svcWaitSynchronizationN(out: *mut s32, handles: *mut Handle,
                                   handles_num: s32, wait_all: bool,
                                   nanoseconds: s64) -> Result;
}
extern "C" {
    pub fn svcCreateAddressArbiter(arbiter: *mut Handle) -> Result;
}
extern "C" {
    pub fn svcArbitrateAddress(arbiter: Handle, addr: u32,
                               type_: ArbitrationType, value: s32,
                               nanoseconds: s64) -> Result;
}
extern "C" {
    pub fn svcSendSyncRequest(session: Handle) -> Result;
}
extern "C" {
    pub fn svcCreateSessionToPort(clientSession: *mut Handle,
                                  clientPort: Handle) -> Result;
}
extern "C" {
    pub fn svcCreateSession(serverSession: *mut Handle,
                            clientSession: *mut Handle) -> Result;
}
extern "C" {
    pub fn svcAcceptSession(session: *mut Handle, port: Handle) -> Result;
}
extern "C" {
    pub fn svcReplyAndReceive(index: *mut s32, handles: *mut Handle,
                              handleCount: s32, replyTarget: Handle)
     -> Result;
}
extern "C" {
    pub fn svcBindInterrupt(interruptId: u32, eventOrSemaphore: Handle,
                            priority: s32, isManualClear: bool) -> Result;
}
extern "C" {
    pub fn svcUnbindInterrupt(interruptId: u32, eventOrSemaphore: Handle)
     -> Result;
}
extern "C" {
    pub fn svcCreateTimer(timer: *mut Handle, reset_type: ResetType)
     -> Result;
}
extern "C" {
    pub fn svcSetTimer(timer: Handle, initial: s64, interval: s64) -> Result;
}
extern "C" {
    pub fn svcCancelTimer(timer: Handle) -> Result;
}
extern "C" {
    pub fn svcClearTimer(timer: Handle) -> Result;
}
extern "C" {
    pub fn svcGetSystemTick() -> u64;
}
extern "C" {
    pub fn svcCloseHandle(handle: Handle) -> Result;
}
extern "C" {
    pub fn svcDuplicateHandle(out: *mut Handle, original: Handle) -> Result;
}
extern "C" {
    pub fn svcGetHandleInfo(out: *mut s64, handle: Handle, param: u32)
     -> Result;
}
extern "C" {
    pub fn svcGetSystemInfo(out: *mut s64, type_: u32, param: s32) -> Result;
}
extern "C" {
    pub fn svcSetGpuProt(useApplicationRestriction: bool) -> Result;
}
extern "C" {
    pub fn svcSetWifiEnabled(enabled: bool) -> Result;
}
extern "C" {
    pub fn svcKernelSetState(type_: u32, ...) -> Result;
}
extern "C" {
    pub fn svcBreak(breakReason: UserBreakType);
}
extern "C" {
    pub fn svcBreakRO(breakReason: UserBreakType,
                      croInfo: *const libc::c_void, croInfoSize: u32);
}
extern "C" {
    pub fn svcOutputDebugString(str: *const libc::c_char, length: s32)
     -> Result;
}
extern "C" {
    pub fn svcDebugActiveProcess(debug: *mut Handle, processId: u32)
     -> Result;
}
extern "C" {
    pub fn svcBreakDebugProcess(debug: Handle) -> Result;
}
extern "C" {
    pub fn svcTerminateDebugProcess(debug: Handle) -> Result;
}
extern "C" {
    pub fn svcGetProcessDebugEvent(info: *mut DebugEventInfo, debug: Handle)
     -> Result;
}
extern "C" {
    pub fn svcContinueDebugEvent(debug: Handle, flags: DebugFlags) -> Result;
}
extern "C" {
    pub fn svcGetDebugThreadContext(context: *mut ThreadContext,
                                    debug: Handle, threadId: u32,
                                    controlFlags: ThreadContextControlFlags)
     -> Result;
}
extern "C" {
    pub fn svcSetDebugThreadContext(debug: Handle, threadId: u32,
                                    context: *mut ThreadContext,
                                    controlFlags: ThreadContextControlFlags)
     -> Result;
}
extern "C" {
    pub fn svcQueryDebugProcessMemory(info: *mut MemInfo, out: *mut PageInfo,
                                      debug: Handle, addr: u32) -> Result;
}
extern "C" {
    pub fn svcReadProcessMemory(buffer: *mut libc::c_void, debug: Handle,
                                addr: u32, size: u32) -> Result;
}
extern "C" {
    pub fn svcWriteProcessMemory(debug: Handle, buffer: *const libc::c_void,
                                 addr: u32, size: u32) -> Result;
}
extern "C" {
    pub fn svcSetHardwareBreakPoint(registerId: s32, control: u32, value: u32)
     -> Result;
}
extern "C" {
    pub fn svcGetDebugThreadParam(unused: *mut s64, out: *mut u32,
                                  debug: Handle, threadId: u32,
                                  parameter: DebugThreadParameter) -> Result;
}
extern "C" {
    pub fn svcBackdoor(callback:
                           ::core::option::Option<unsafe extern "C" fn()
                                                      -> s32>) -> Result;
}
extern "C" {
    pub fn srvInit() -> Result;
}
extern "C" {
    pub fn srvExit();
}
extern "C" {
    pub fn srvGetSessionHandle() -> *mut Handle;
}
extern "C" {
    pub fn srvGetServiceHandle(out: *mut Handle, name: *const libc::c_char)
     -> Result;
}
extern "C" {
    pub fn srvRegisterClient() -> Result;
}
extern "C" {
    pub fn srvEnableNotification(semaphoreOut: *mut Handle) -> Result;
}
extern "C" {
    pub fn srvRegisterService(out: *mut Handle, name: *const libc::c_char,
                              maxSessions: libc::c_int) -> Result;
}
extern "C" {
    pub fn srvUnregisterService(name: *const libc::c_char) -> Result;
}
extern "C" {
    pub fn srvGetServiceHandleDirect(out: *mut Handle,
                                     name: *const libc::c_char) -> Result;
}
extern "C" {
    pub fn srvRegisterPort(name: *const libc::c_char, clientHandle: Handle)
     -> Result;
}
extern "C" {
    pub fn srvUnregisterPort(name: *const libc::c_char) -> Result;
}
extern "C" {
    pub fn srvGetPort(out: *mut Handle, name: *const libc::c_char) -> Result;
}
extern "C" {
    pub fn srvSubscribe(notificationId: u32) -> Result;
}
extern "C" {
    pub fn srvUnsubscribe(notificationId: u32) -> Result;
}
extern "C" {
    pub fn srvReceiveNotification(notificationIdOut: *mut u32) -> Result;
}
extern "C" {
    pub fn srvPublishToSubscriber(notificationId: u32, flags: u32) -> Result;
}
extern "C" {
    pub fn srvPublishAndGetSubscriber(processIdCountOut: *mut u32,
                                      processIdsOut: *mut u32,
                                      notificationId: u32) -> Result;
}
extern "C" {
    pub fn srvIsServiceRegistered(registeredOut: *mut bool,
                                  name: *const libc::c_char) -> Result;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ERRF_ErrType {
    ERRF_ERRTYPE_GENERIC = 0,
    ERRF_ERRTYPE_MEM_CORRUPT = 1,
    ERRF_ERRTYPE_CARD_REMOVED = 2,
    ERRF_ERRTYPE_EXCEPTION = 3,
    ERRF_ERRTYPE_FAILURE = 4,
    ERRF_ERRTYPE_LOGGED = 5,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ERRF_ExceptionType {
    ERRF_EXCEPTION_PREFETCH_ABORT = 0,
    ERRF_EXCEPTION_DATA_ABORT = 1,
    ERRF_EXCEPTION_UNDEFINED = 2,
    ERRF_EXCEPTION_VFP = 3,
}
#[repr(C)]
#[derive(Copy)]
pub struct ERRF_ExceptionInfo {
    pub type_: ERRF_ExceptionType,
    pub reserved: [u8; 3usize],
    pub fsr: u32,
    pub far: u32,
    pub fpexc: u32,
    pub fpinst: u32,
    pub fpinst2: u32,
}
impl Clone for ERRF_ExceptionInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ERRF_ExceptionData {
    pub excep: ERRF_ExceptionInfo,
    pub regs: CpuRegisters,
}
impl Clone for ERRF_ExceptionData {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct ERRF_FatalErrInfo {
    pub type_: ERRF_ErrType,
    pub revHigh: u8,
    pub revLow: u16,
    pub resCode: u32,
    pub pcAddr: u32,
    pub procId: u32,
    pub titleId: u64,
    pub appTitleId: u64,
    pub data: ERRF_FatalErrInfo__bindgen_ty_1,
}
#[repr(C)]
pub union ERRF_FatalErrInfo__bindgen_ty_1 {
    pub exception_data: ERRF_ExceptionData,
    pub failure_mesg: [libc::c_char; 96usize],
}
extern "C" {
    pub fn errfInit() -> Result;
}
extern "C" {
    pub fn errfExit();
}
extern "C" {
    pub fn errfGetSessionHandle() -> *mut Handle;
}
extern "C" {
    pub fn ERRF_Throw(error: *const ERRF_FatalErrInfo) -> Result;
}
extern "C" {
    pub fn ERRF_ThrowResult(failure: Result) -> Result;
}
extern "C" {
    pub fn ERRF_ThrowResultWithMessage(failure: Result,
                                       message: *const libc::c_char)
     -> Result;
}
extern "C" {
    pub fn ERRF_ExceptionHandler(excep: *mut ERRF_ExceptionInfo,
                                 regs: *mut CpuRegisters);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum MemRegion {
    MEMREGION_ALL = 0,
    MEMREGION_APPLICATION = 1,
    MEMREGION_SYSTEM = 2,
    MEMREGION_BASE = 3,
}
#[repr(C)]
#[derive(Copy)]
pub struct TickCounter {
    pub elapsed: u64,
    pub reference: u64,
}
impl Clone for TickCounter {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct OS_VersionBin {
    pub build: u8,
    pub minor: u8,
    pub mainver: u8,
    pub reserved_x3: u8,
    pub region: libc::c_char,
    pub reserved_x5: [u8; 3usize],
}
impl Clone for OS_VersionBin {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn osConvertVirtToPhys(vaddr: *const libc::c_void) -> u32;
}
extern "C" {
    pub fn osConvertOldLINEARMemToNew(vaddr: *const libc::c_void)
     -> *mut libc::c_void;
}
extern "C" {
    pub fn osStrError(error: u32) -> *const libc::c_char;
}
extern "C" {
    pub fn osGetMemRegionUsed(region: MemRegion) -> s64;
}
extern "C" {
    pub fn osGetTime() -> u64;
}
extern "C" {
    pub fn osTickCounterRead(cnt: *mut TickCounter) -> f64;
}
extern "C" {
    pub fn osSetSpeedupEnable(enable: bool);
}
extern "C" {
    pub fn osGetSystemVersionData(nver_versionbin: *mut OS_VersionBin,
                                  cver_versionbin: *mut OS_VersionBin)
     -> Result;
}
extern "C" {
    pub fn osGetSystemVersionDataString(nver_versionbin: *mut OS_VersionBin,
                                        cver_versionbin: *mut OS_VersionBin,
                                        sysverstr: *mut libc::c_char,
                                        sysverstr_maxsize: u32) -> Result;
}
pub type _LOCK_T = i32;
#[repr(C)]
#[derive(Copy)]
pub struct __lock_t {
    pub lock: _LOCK_T,
    pub thread_tag: u32,
    pub counter: u32,
}
impl Clone for __lock_t {
    fn clone(&self) -> Self { *self }
}
pub type _LOCK_RECURSIVE_T = __lock_t;
extern "C" {
    pub fn __libc_lock_init(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __libc_lock_init_recursive(lock: *mut _LOCK_RECURSIVE_T);
}
extern "C" {
    pub fn __libc_lock_close(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __libc_lock_close_recursive(lock: *mut _LOCK_RECURSIVE_T);
}
extern "C" {
    pub fn __libc_lock_acquire(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __libc_lock_acquire_recursive(lock: *mut _LOCK_RECURSIVE_T);
}
extern "C" {
    pub fn __libc_lock_release(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __libc_lock_release_recursive(lock: *mut _LOCK_RECURSIVE_T);
}
extern "C" {
    pub fn __libc_lock_try_acquire(lock: *mut _LOCK_T) -> libc::c_int;
}
extern "C" {
    pub fn __libc_lock_try_acquire_recursive(lock: *mut _LOCK_RECURSIVE_T)
     -> libc::c_int;
}
pub type LightLock = _LOCK_T;
pub type RecursiveLock = _LOCK_RECURSIVE_T;
#[repr(C)]
#[derive(Copy)]
pub struct LightEvent {
    pub state: s32,
    pub lock: LightLock,
}
impl Clone for LightEvent {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn __sync_get_arbiter() -> Handle;
}
extern "C" {
    pub fn LightLock_Init(lock: *mut LightLock);
}
extern "C" {
    pub fn LightLock_Lock(lock: *mut LightLock);
}
extern "C" {
    pub fn LightLock_TryLock(lock: *mut LightLock) -> libc::c_int;
}
extern "C" {
    pub fn LightLock_Unlock(lock: *mut LightLock);
}
extern "C" {
    pub fn RecursiveLock_Init(lock: *mut RecursiveLock);
}
extern "C" {
    pub fn RecursiveLock_Lock(lock: *mut RecursiveLock);
}
extern "C" {
    pub fn RecursiveLock_TryLock(lock: *mut RecursiveLock) -> libc::c_int;
}
extern "C" {
    pub fn RecursiveLock_Unlock(lock: *mut RecursiveLock);
}
extern "C" {
    pub fn LightEvent_Init(event: *mut LightEvent, reset_type: ResetType);
}
extern "C" {
    pub fn LightEvent_Clear(event: *mut LightEvent);
}
extern "C" {
    pub fn LightEvent_Pulse(event: *mut LightEvent);
}
extern "C" {
    pub fn LightEvent_Signal(event: *mut LightEvent);
}
extern "C" {
    pub fn LightEvent_TryWait(event: *mut LightEvent) -> libc::c_int;
}
extern "C" {
    pub fn LightEvent_Wait(event: *mut LightEvent);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Thread_tag {
    _unused: [u8; 0],
}
pub type Thread = *mut Thread_tag;
pub type ExceptionHandler =
    ::core::option::Option<unsafe extern "C" fn(excep:
                                                    *mut ERRF_ExceptionInfo,
                                                regs: *mut CpuRegisters)>;
extern "C" {
    pub fn threadCreate(entrypoint: ThreadFunc, arg: *mut libc::c_void,
                        stack_size: usize, prio: libc::c_int,
                        affinity: libc::c_int, detached: bool) -> Thread;
}
extern "C" {
    pub fn threadGetHandle(thread: Thread) -> Handle;
}
extern "C" {
    pub fn threadGetExitCode(thread: Thread) -> libc::c_int;
}
extern "C" {
    pub fn threadFree(thread: Thread);
}
extern "C" {
    pub fn threadJoin(thread: Thread, timeout_ns: u64) -> Result;
}
extern "C" {
    pub fn threadDetach(thread: Thread);
}
extern "C" {
    pub fn threadGetCurrent() -> Thread;
}
extern "C" {
    pub fn threadExit(rc: libc::c_int);
}
#[repr(C)]
#[derive(Copy)]
pub struct GSPGPU_FramebufferInfo {
    pub active_framebuf: u32,
    pub framebuf0_vaddr: *mut u32,
    pub framebuf1_vaddr: *mut u32,
    pub framebuf_widthbytesize: u32,
    pub format: u32,
    pub framebuf_dispselect: u32,
    pub unk: u32,
}
impl Clone for GSPGPU_FramebufferInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GSPGPU_FramebufferFormats {
    GSP_RGBA8_OES = 0,
    GSP_BGR8_OES = 1,
    GSP_RGB565_OES = 2,
    GSP_RGB5_A1_OES = 3,
    GSP_RGBA4_OES = 4,
}
#[repr(C)]
#[derive(Copy)]
pub struct GSPGPU_CaptureInfoEntry {
    pub framebuf0_vaddr: *mut u32,
    pub framebuf1_vaddr: *mut u32,
    pub format: u32,
    pub framebuf_widthbytesize: u32,
}
impl Clone for GSPGPU_CaptureInfoEntry {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct GSPGPU_CaptureInfo {
    pub screencapture: [GSPGPU_CaptureInfoEntry; 2usize],
}
impl Clone for GSPGPU_CaptureInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GSPGPU_Event {
    GSPGPU_EVENT_PSC0 = 0,
    GSPGPU_EVENT_PSC1 = 1,
    GSPGPU_EVENT_VBlank0 = 2,
    GSPGPU_EVENT_VBlank1 = 3,
    GSPGPU_EVENT_PPF = 4,
    GSPGPU_EVENT_P3D = 5,
    GSPGPU_EVENT_DMA = 6,
    GSPGPU_EVENT_MAX = 7,
}
extern "C" {
    pub fn gspInit() -> Result;
}
extern "C" {
    pub fn gspExit();
}
extern "C" {
    pub fn gspSetEventCallback(id: GSPGPU_Event, cb: ThreadFunc,
                               data: *mut libc::c_void, oneShot: bool);
}
extern "C" {
    pub fn gspInitEventHandler(gspEvent: Handle, gspSharedMem: *mut vu8,
                               gspThreadId: u8) -> Result;
}
extern "C" {
    pub fn gspExitEventHandler();
}
extern "C" {
    pub fn gspWaitForEvent(id: GSPGPU_Event, nextEvent: bool);
}
extern "C" {
    pub fn gspWaitForAnyEvent() -> GSPGPU_Event;
}
extern "C" {
    pub fn gspSubmitGxCommand(sharedGspCmdBuf: *mut u32, gxCommand: *mut u32)
     -> Result;
}
extern "C" {
    pub fn GSPGPU_AcquireRight(flags: u8) -> Result;
}
extern "C" {
    pub fn GSPGPU_ReleaseRight() -> Result;
}
extern "C" {
    pub fn GSPGPU_ImportDisplayCaptureInfo(captureinfo:
                                               *mut GSPGPU_CaptureInfo)
     -> Result;
}
extern "C" {
    pub fn GSPGPU_SaveVramSysArea() -> Result;
}
extern "C" {
    pub fn GSPGPU_RestoreVramSysArea() -> Result;
}
extern "C" {
    pub fn GSPGPU_SetLcdForceBlack(flags: u8) -> Result;
}
extern "C" {
    pub fn GSPGPU_SetBufferSwap(screenid: u32,
                                framebufinfo: *mut GSPGPU_FramebufferInfo)
     -> Result;
}
extern "C" {
    pub fn GSPGPU_FlushDataCache(adr: *const libc::c_void, size: u32)
     -> Result;
}
extern "C" {
    pub fn GSPGPU_InvalidateDataCache(adr: *const libc::c_void, size: u32)
     -> Result;
}
extern "C" {
    pub fn GSPGPU_WriteHWRegs(regAddr: u32, data: *mut u32, size: u8)
     -> Result;
}
extern "C" {
    pub fn GSPGPU_WriteHWRegsWithMask(regAddr: u32, data: *mut u32,
                                      datasize: u8, maskdata: *mut u32,
                                      masksize: u8) -> Result;
}
extern "C" {
    pub fn GSPGPU_ReadHWRegs(regAddr: u32, data: *mut u32, size: u8)
     -> Result;
}
extern "C" {
    pub fn GSPGPU_RegisterInterruptRelayQueue(eventHandle: Handle, flags: u32,
                                              outMemHandle: *mut Handle,
                                              threadID: *mut u8) -> Result;
}
extern "C" {
    pub fn GSPGPU_UnregisterInterruptRelayQueue() -> Result;
}
extern "C" {
    pub fn GSPGPU_TriggerCmdReqQueue() -> Result;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum gfxScreen_t { GFX_TOP = 0, GFX_BOTTOM = 1, }
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum gfx3dSide_t { GFX_LEFT = 0, GFX_RIGHT = 1, }
extern "C" {
    pub fn gfxInitDefault();
}
extern "C" {
    pub fn gfxInit(topFormat: GSPGPU_FramebufferFormats,
                   bottomFormat: GSPGPU_FramebufferFormats,
                   vrambuffers: bool);
}
extern "C" {
    pub fn gfxExit();
}
extern "C" {
    pub fn gfxSet3D(enable: bool);
}
extern "C" {
    pub fn gfxIs3D() -> bool;
}
extern "C" {
    pub fn gfxSetScreenFormat(screen: gfxScreen_t,
                              format: GSPGPU_FramebufferFormats);
}
extern "C" {
    pub fn gfxGetScreenFormat(screen: gfxScreen_t)
     -> GSPGPU_FramebufferFormats;
}
extern "C" {
    pub fn gfxSetDoubleBuffering(screen: gfxScreen_t, doubleBuffering: bool);
}
extern "C" {
    pub fn gfxFlushBuffers();
}
extern "C" {
    pub fn gfxConfigScreen(scr: gfxScreen_t, immediate: bool);
}
extern "C" {
    pub fn gfxSwapBuffers();
}
extern "C" {
    pub fn gfxSwapBuffersGpu();
}
extern "C" {
    pub fn gfxGetFramebuffer(screen: gfxScreen_t, side: gfx3dSide_t,
                             width: *mut u16, height: *mut u16) -> *mut u8;
}
extern "C" {
    pub static mut gfxTopLeftFramebuffers: [*mut u8; 2usize];
}
extern "C" {
    pub static mut gfxTopRightFramebuffers: [*mut u8; 2usize];
}
extern "C" {
    pub static mut gfxBottomFramebuffers: [*mut u8; 2usize];
}
pub type ConsolePrint =
    ::core::option::Option<unsafe extern "C" fn(con: *mut libc::c_void,
                                                c: libc::c_int) -> bool>;
#[repr(C)]
#[derive(Copy)]
pub struct ConsoleFont {
    pub gfx: *mut u8,
    pub asciiOffset: u16,
    pub numChars: u16,
}
impl Clone for ConsoleFont {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct PrintConsole {
    pub font: ConsoleFont,
    pub frameBuffer: *mut u16,
    pub cursorX: libc::c_int,
    pub cursorY: libc::c_int,
    pub prevCursorX: libc::c_int,
    pub prevCursorY: libc::c_int,
    pub consoleWidth: libc::c_int,
    pub consoleHeight: libc::c_int,
    pub windowX: libc::c_int,
    pub windowY: libc::c_int,
    pub windowWidth: libc::c_int,
    pub windowHeight: libc::c_int,
    pub tabSize: libc::c_int,
    pub fg: libc::c_int,
    pub bg: libc::c_int,
    pub flags: libc::c_int,
    pub PrintChar: ConsolePrint,
    pub consoleInitialised: bool,
}
impl Clone for PrintConsole {
    fn clone(&self) -> Self { *self }
}
pub const debugDevice_3DMOO: debugDevice = debugDevice::debugDevice_SVC;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum debugDevice {
    debugDevice_NULL = 0,
    debugDevice_SVC = 1,
    debugDevice_CONSOLE = 2,
}
extern "C" {
    pub fn consoleSetFont(console: *mut PrintConsole, font: *mut ConsoleFont);
}
extern "C" {
    pub fn consoleSetWindow(console: *mut PrintConsole, x: libc::c_int,
                            y: libc::c_int, width: libc::c_int,
                            height: libc::c_int);
}
extern "C" {
    pub fn consoleGetDefault() -> *mut PrintConsole;
}
extern "C" {
    pub fn consoleSelect(console: *mut PrintConsole) -> *mut PrintConsole;
}
extern "C" {
    pub fn consoleInit(screen: gfxScreen_t, console: *mut PrintConsole)
     -> *mut PrintConsole;
}
extern "C" {
    pub fn consoleDebugInit(device: debugDevice);
}
extern "C" {
    pub fn consoleClear();
}
pub const RUNFLAG_APTWORKAROUND: _bindgen_ty_5 =
    _bindgen_ty_5::RUNFLAG_APTWORKAROUND;
pub const RUNFLAG_APTREINIT: _bindgen_ty_5 = _bindgen_ty_5::RUNFLAG_APTREINIT;
pub const RUNFLAG_APTCHAINLOAD: _bindgen_ty_5 =
    _bindgen_ty_5::RUNFLAG_APTCHAINLOAD;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_5 {
    RUNFLAG_APTWORKAROUND = 1,
    RUNFLAG_APTREINIT = 2,
    RUNFLAG_APTCHAINLOAD = 4,
}
extern "C" {
    pub fn envGetHandle(name: *const libc::c_char) -> Handle;
}
pub type _off_t = __int64_t;
pub type _fpos_t = __int64_t;
pub type __ino_t = __uint32_t;
pub type __dev_t = __uint32_t;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = libc::c_int;
pub type __blkcnt_t = libc::c_long;
pub type __blksize_t = libc::c_long;
pub type __fsblkcnt_t = __uint64_t;
pub type __fsfilcnt_t = __uint32_t;
pub type __pid_t = libc::c_int;
pub type __uid_t = libc::c_ushort;
pub type __gid_t = libc::c_ushort;
pub type __id_t = __uint32_t;
pub type __mode_t = __uint32_t;
pub type _off64_t = libc::c_longlong;
pub type __off_t = _off_t;
pub type __loff_t = _off64_t;
pub type __key_t = libc::c_long;
pub type __size_t = libc::c_uint;
pub type _ssize_t = libc::c_int;
pub type __ssize_t = _ssize_t;
pub type wint_t = libc::c_int;
#[repr(C)]
#[derive(Copy)]
pub struct _mbstate_t {
    pub __count: libc::c_int,
    pub __value: _mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub union _mbstate_t__bindgen_ty_1 {
    pub __wch: wint_t,
    pub __wchb: [libc::c_uchar; 4usize],
}
impl Clone for _mbstate_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Clone for _mbstate_t {
    fn clone(&self) -> Self { *self }
}
pub type _flock_t = _LOCK_RECURSIVE_T;
pub type _iconv_t = *mut libc::c_void;
pub type __clock_t = libc::c_ulong;
pub type __time_t = libc::c_long;
pub type __clockid_t = libc::c_ulong;
pub type __timer_t = libc::c_ulong;
pub type __sa_family_t = __uint8_t;
pub type __socklen_t = __uint32_t;
pub type __nlink_t = libc::c_ushort;
pub type __suseconds_t = libc::c_long;
pub type __useconds_t = libc::c_ulong;
pub type __sigset_t = libc::c_ulong;
pub type suseconds_t = __suseconds_t;
pub type time_t = libc::c_long;
#[repr(C)]
#[derive(Copy)]
pub struct timeval {
    pub tv_sec: time_t,
    pub tv_usec: suseconds_t,
}
impl Clone for timeval {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: libc::c_long,
}
impl Clone for timespec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
impl Clone for itimerspec {
    fn clone(&self) -> Self { *self }
}
pub type sigset_t = __sigset_t;
pub type fd_mask = libc::c_ulong;
#[repr(C)]
#[derive(Copy)]
pub struct _types_fd_set {
    pub fds_bits: [fd_mask; 2usize],
}
impl Clone for _types_fd_set {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn select(__n: libc::c_int, __readfds: *mut _types_fd_set,
                  __writefds: *mut _types_fd_set,
                  __exceptfds: *mut _types_fd_set, __timeout: *mut timeval)
     -> libc::c_int;
}
extern "C" {
    pub fn pselect(__n: libc::c_int, __readfds: *mut _types_fd_set,
                   __writefds: *mut _types_fd_set,
                   __exceptfds: *mut _types_fd_set,
                   __timeout: *const timespec, __set: *const sigset_t)
     -> libc::c_int;
}
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type u_char = libc::c_uchar;
pub type u_short = libc::c_ushort;
pub type u_int = libc::c_uint;
pub type u_long = libc::c_ulong;
pub type ushort = libc::c_ushort;
pub type uint = libc::c_uint;
pub type ulong = libc::c_ulong;
pub type blkcnt_t = __blkcnt_t;
pub type blksize_t = __blksize_t;
pub type clock_t = libc::c_ulong;
pub type daddr_t = libc::c_long;
pub type caddr_t = *mut libc::c_char;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type id_t = __id_t;
pub type ino_t = __ino_t;
pub type off_t = __off_t;
pub type dev_t = __dev_t;
pub type uid_t = __uid_t;
pub type gid_t = __gid_t;
pub type pid_t = __pid_t;
pub type key_t = __key_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub type useconds_t = __useconds_t;
pub type sbintime_t = __int64_t;
extern "C" {
    pub fn decode_utf8(out: *mut u32, in_: *const u8) -> isize;
}
extern "C" {
    pub fn decode_utf16(out: *mut u32, in_: *const u16) -> isize;
}
extern "C" {
    pub fn encode_utf8(out: *mut u8, in_: u32) -> isize;
}
extern "C" {
    pub fn encode_utf16(out: *mut u16, in_: u32) -> isize;
}
extern "C" {
    pub fn utf8_to_utf16(out: *mut u16, in_: *const u8, len: usize) -> isize;
}
extern "C" {
    pub fn utf8_to_utf32(out: *mut u32, in_: *const u8, len: usize) -> isize;
}
extern "C" {
    pub fn utf16_to_utf8(out: *mut u8, in_: *const u16, len: usize) -> isize;
}
extern "C" {
    pub fn utf16_to_utf32(out: *mut u32, in_: *const u16, len: usize)
     -> isize;
}
extern "C" {
    pub fn utf32_to_utf8(out: *mut u8, in_: *const u32, len: usize) -> isize;
}
extern "C" {
    pub fn utf32_to_utf16(out: *mut u16, in_: *const u32, len: usize)
     -> isize;
}
extern "C" {
    pub fn linearAlloc(size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn linearMemAlign(size: usize, alignment: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn linearRealloc(mem: *mut libc::c_void, size: usize)
     -> *mut libc::c_void;
}
extern "C" {
    pub fn linearGetSize(mem: *mut libc::c_void) -> usize;
}
extern "C" {
    pub fn linearFree(mem: *mut libc::c_void);
}
extern "C" {
    pub fn linearSpaceFree() -> u32;
}
extern "C" {
    pub fn mappableAlloc(size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn mappableGetSize(mem: *mut libc::c_void) -> usize;
}
extern "C" {
    pub fn mappableFree(mem: *mut libc::c_void);
}
extern "C" {
    pub fn mappableSpaceFree() -> u32;
}
extern "C" {
    pub fn vramAlloc(size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn vramMemAlign(size: usize, alignment: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn vramRealloc(mem: *mut libc::c_void, size: usize)
     -> *mut libc::c_void;
}
extern "C" {
    pub fn vramGetSize(mem: *mut libc::c_void) -> usize;
}
extern "C" {
    pub fn vramFree(mem: *mut libc::c_void);
}
extern "C" {
    pub fn vramSpaceFree() -> u32;
}
extern "C" {
    pub fn acInit() -> Result;
}
extern "C" {
    pub fn acExit();
}
extern "C" {
    pub fn acWaitInternetConnection() -> Result;
}
extern "C" {
    pub fn ACU_GetWifiStatus(out: *mut u32) -> Result;
}
pub const FS_OPEN_READ: _bindgen_ty_6 = _bindgen_ty_6::FS_OPEN_READ;
pub const FS_OPEN_WRITE: _bindgen_ty_6 = _bindgen_ty_6::FS_OPEN_WRITE;
pub const FS_OPEN_CREATE: _bindgen_ty_6 = _bindgen_ty_6::FS_OPEN_CREATE;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_6 {
    FS_OPEN_READ = 1,
    FS_OPEN_WRITE = 2,
    FS_OPEN_CREATE = 4,
}
pub const FS_WRITE_FLUSH: _bindgen_ty_7 = _bindgen_ty_7::FS_WRITE_FLUSH;
pub const FS_WRITE_UPDATE_TIME: _bindgen_ty_7 =
    _bindgen_ty_7::FS_WRITE_UPDATE_TIME;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_7 { FS_WRITE_FLUSH = 1, FS_WRITE_UPDATE_TIME = 256, }
pub const FS_ATTRIBUTE_DIRECTORY: _bindgen_ty_8 =
    _bindgen_ty_8::FS_ATTRIBUTE_DIRECTORY;
pub const FS_ATTRIBUTE_HIDDEN: _bindgen_ty_8 =
    _bindgen_ty_8::FS_ATTRIBUTE_HIDDEN;
pub const FS_ATTRIBUTE_ARCHIVE: _bindgen_ty_8 =
    _bindgen_ty_8::FS_ATTRIBUTE_ARCHIVE;
pub const FS_ATTRIBUTE_READ_ONLY: _bindgen_ty_8 =
    _bindgen_ty_8::FS_ATTRIBUTE_READ_ONLY;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_8 {
    FS_ATTRIBUTE_DIRECTORY = 1,
    FS_ATTRIBUTE_HIDDEN = 256,
    FS_ATTRIBUTE_ARCHIVE = 65536,
    FS_ATTRIBUTE_READ_ONLY = 16777216,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum FS_MediaType {
    MEDIATYPE_NAND = 0,
    MEDIATYPE_SD = 1,
    MEDIATYPE_GAME_CARD = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum FS_SystemMediaType {
    SYSTEM_MEDIATYPE_CTR_NAND = 0,
    SYSTEM_MEDIATYPE_TWL_NAND = 1,
    SYSTEM_MEDIATYPE_SD = 2,
    SYSTEM_MEDIATYPE_TWL_PHOTO = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum FS_ArchiveID {
    ARCHIVE_ROMFS = 3,
    ARCHIVE_SAVEDATA = 4,
    ARCHIVE_EXTDATA = 6,
    ARCHIVE_SHARED_EXTDATA = 7,
    ARCHIVE_SYSTEM_SAVEDATA = 8,
    ARCHIVE_SDMC = 9,
    ARCHIVE_SDMC_WRITE_ONLY = 10,
    ARCHIVE_BOSS_EXTDATA = 305419896,
    ARCHIVE_CARD_SPIFS = 305419897,
    ARCHIVE_EXTDATA_AND_BOSS_EXTDATA = 305419899,
    ARCHIVE_SYSTEM_SAVEDATA2 = 305419900,
    ARCHIVE_NAND_RW = 305419901,
    ARCHIVE_NAND_RO = 305419902,
    ARCHIVE_NAND_RO_WRITE_ACCESS = 305419903,
    ARCHIVE_SAVEDATA_AND_CONTENT = 591751050,
    ARCHIVE_SAVEDATA_AND_CONTENT2 = 591751054,
    ARCHIVE_NAND_CTR_FS = 1450741931,
    ARCHIVE_TWL_PHOTO = 1450741932,
    ARCHIVE_TWL_SOUND = 1450741933,
    ARCHIVE_NAND_TWL_FS = 1450741934,
    ARCHIVE_NAND_W_FS = 1450741935,
    ARCHIVE_GAMECARD_SAVEDATA = 1450741937,
    ARCHIVE_USER_SAVEDATA = 1450741938,
    ARCHIVE_DEMO_SAVEDATA = 1450741940,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum FS_PathType {
    PATH_INVALID = 0,
    PATH_EMPTY = 1,
    PATH_BINARY = 2,
    PATH_ASCII = 3,
    PATH_UTF16 = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum FS_SecureValueSlot { SECUREVALUE_SLOT_SD = 4096, }
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum FS_CardSpiBaudRate {
    BAUDRATE_512KHZ = 0,
    BAUDRATE_1MHZ = 1,
    BAUDRATE_2MHZ = 2,
    BAUDRATE_4MHZ = 3,
    BAUDRATE_8MHZ = 4,
    BAUDRATE_16MHZ = 5,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum FS_CardSpiBusMode { BUSMODE_1BIT = 0, BUSMODE_4BIT = 1, }
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum FS_SpecialContentType {
    SPECIALCONTENT_UPDATE = 1,
    SPECIALCONTENT_MANUAL = 2,
    SPECIALCONTENT_DLP_CHILD = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum FS_CardType { CARD_CTR = 0, CARD_TWL = 1, }
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum FS_Action { FS_ACTION_UNKNOWN = 0, }
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum FS_ArchiveAction {
    ARCHIVE_ACTION_COMMIT_SAVE_DATA = 0,
    ARCHIVE_ACTION_GET_TIMESTAMP = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum FS_SecureSaveAction {
    SECURESAVE_ACTION_DELETE = 0,
    SECURESAVE_ACTION_FORMAT = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum FS_FileAction { FILE_ACTION_UNKNOWN = 0, }
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum FS_DirectoryAction { DIRECTORY_ACTION_UNKNOWN = 0, }
#[repr(C)]
pub struct FS_DirectoryEntry {
    pub name: [u16; 262usize],
    pub shortName: [libc::c_char; 10usize],
    pub shortExt: [libc::c_char; 4usize],
    pub valid: u8,
    pub reserved: u8,
    pub attributes: u32,
    pub fileSize: u64,
}
#[repr(C)]
#[derive(Copy)]
pub struct FS_ArchiveResource {
    pub sectorSize: u32,
    pub clusterSize: u32,
    pub totalClusters: u32,
    pub freeClusters: u32,
}
impl Clone for FS_ArchiveResource {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct FS_ProgramInfo {
    pub programId: u64,
    pub _bitfield_1: u8,
    pub padding: [u8; 7usize],
}
impl Clone for FS_ProgramInfo {
    fn clone(&self) -> Self { *self }
}
impl FS_ProgramInfo {
    #[inline]
    pub fn mediaType(&self) -> FS_MediaType {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 255u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::core::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_mediaType(&mut self, val: FS_MediaType) {
        let mask = 255u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub const fn new_bitfield_1(mediaType: FS_MediaType) -> u8 {
        ({ 0 } | ((mediaType as u32 as u8) << 0usize) & (255u64 as u8))
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct FS_ProductInfo {
    pub productCode: [libc::c_char; 16usize],
    pub companyCode: [libc::c_char; 2usize],
    pub remasterVersion: u16,
}
impl Clone for FS_ProductInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct FS_IntegrityVerificationSeed {
    pub aesCbcMac: [u8; 16usize],
    pub movableSed: [u8; 288usize],
}
#[repr(C, packed)]
#[derive(Copy)]
pub struct FS_ExtSaveDataInfo {
    pub _bitfield_1: u8,
    pub unknown: u8,
    pub reserved1: u16,
    pub saveId: u64,
    pub reserved2: u32,
}
impl Clone for FS_ExtSaveDataInfo {
    fn clone(&self) -> Self { *self }
}
impl FS_ExtSaveDataInfo {
    #[inline]
    pub fn mediaType(&self) -> FS_MediaType {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 255u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::core::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_mediaType(&mut self, val: FS_MediaType) {
        let mask = 255u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub const fn new_bitfield_1(mediaType: FS_MediaType) -> u8 {
        ({ 0 } | ((mediaType as u32 as u8) << 0usize) & (255u64 as u8))
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct FS_SystemSaveDataInfo {
    pub _bitfield_1: u8,
    pub unknown: u8,
    pub reserved: u16,
    pub saveId: u32,
}
impl Clone for FS_SystemSaveDataInfo {
    fn clone(&self) -> Self { *self }
}
impl FS_SystemSaveDataInfo {
    #[inline]
    pub fn mediaType(&self) -> FS_MediaType {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 255u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::core::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_mediaType(&mut self, val: FS_MediaType) {
        let mask = 255u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub const fn new_bitfield_1(mediaType: FS_MediaType) -> u8 {
        ({ 0 } | ((mediaType as u32 as u8) << 0usize) & (255u64 as u8))
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct FS_DeviceMoveContext {
    pub ivs: [u8; 16usize],
    pub encryptParameter: [u8; 16usize],
}
impl Clone for FS_DeviceMoveContext {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct FS_Path {
    pub type_: FS_PathType,
    pub size: u32,
    pub data: *const libc::c_void,
}
impl Clone for FS_Path {
    fn clone(&self) -> Self { *self }
}
pub type FS_Archive = u64;
extern "C" {
    pub fn fsInit() -> Result;
}
extern "C" {
    pub fn fsExit();
}
extern "C" {
    pub fn fsUseSession(session: Handle);
}
extern "C" {
    pub fn fsEndUseSession();
}
extern "C" {
    pub fn fsExemptFromSession(archive: FS_Archive);
}
extern "C" {
    pub fn fsUnexemptFromSession(archive: FS_Archive);
}
extern "C" {
    pub fn fsMakePath(type_: FS_PathType, path: *const libc::c_void)
     -> FS_Path;
}
extern "C" {
    pub fn fsGetSessionHandle() -> *mut Handle;
}
extern "C" {
    pub fn FSUSER_Control(action: FS_Action, input: *mut libc::c_void,
                          inputSize: u32, output: *mut libc::c_void,
                          outputSize: u32) -> Result;
}
extern "C" {
    pub fn FSUSER_Initialize(session: Handle) -> Result;
}
extern "C" {
    pub fn FSUSER_OpenFile(out: *mut Handle, archive: FS_Archive,
                           path: FS_Path, openFlags: u32, attributes: u32)
     -> Result;
}
extern "C" {
    pub fn FSUSER_OpenFileDirectly(out: *mut Handle, archiveId: FS_ArchiveID,
                                   archivePath: FS_Path, filePath: FS_Path,
                                   openFlags: u32, attributes: u32) -> Result;
}
extern "C" {
    pub fn FSUSER_DeleteFile(archive: FS_Archive, path: FS_Path) -> Result;
}
extern "C" {
    pub fn FSUSER_RenameFile(srcArchive: FS_Archive, srcPath: FS_Path,
                             dstArchive: FS_Archive, dstPath: FS_Path)
     -> Result;
}
extern "C" {
    pub fn FSUSER_DeleteDirectory(archive: FS_Archive, path: FS_Path)
     -> Result;
}
extern "C" {
    pub fn FSUSER_DeleteDirectoryRecursively(archive: FS_Archive,
                                             path: FS_Path) -> Result;
}
extern "C" {
    pub fn FSUSER_CreateFile(archive: FS_Archive, path: FS_Path,
                             attributes: u32, fileSize: u64) -> Result;
}
extern "C" {
    pub fn FSUSER_CreateDirectory(archive: FS_Archive, path: FS_Path,
                                  attributes: u32) -> Result;
}
extern "C" {
    pub fn FSUSER_RenameDirectory(srcArchive: FS_Archive, srcPath: FS_Path,
                                  dstArchive: FS_Archive, dstPath: FS_Path)
     -> Result;
}
extern "C" {
    pub fn FSUSER_OpenDirectory(out: *mut Handle, archive: FS_Archive,
                                path: FS_Path) -> Result;
}
extern "C" {
    pub fn FSUSER_OpenArchive(archive: *mut FS_Archive, id: FS_ArchiveID,
                              path: FS_Path) -> Result;
}
extern "C" {
    pub fn FSUSER_ControlArchive(archive: FS_Archive,
                                 action: FS_ArchiveAction,
                                 input: *mut libc::c_void, inputSize: u32,
                                 output: *mut libc::c_void, outputSize: u32)
     -> Result;
}
extern "C" {
    pub fn FSUSER_CloseArchive(archive: FS_Archive) -> Result;
}
extern "C" {
    pub fn FSUSER_GetFreeBytes(freeBytes: *mut u64, archive: FS_Archive)
     -> Result;
}
extern "C" {
    pub fn FSUSER_GetCardType(type_: *mut FS_CardType) -> Result;
}
extern "C" {
    pub fn FSUSER_GetSdmcArchiveResource(archiveResource:
                                             *mut FS_ArchiveResource)
     -> Result;
}
extern "C" {
    pub fn FSUSER_GetNandArchiveResource(archiveResource:
                                             *mut FS_ArchiveResource)
     -> Result;
}
extern "C" {
    pub fn FSUSER_GetSdmcFatfsError(error: *mut u32) -> Result;
}
extern "C" {
    pub fn FSUSER_IsSdmcDetected(detected: *mut bool) -> Result;
}
extern "C" {
    pub fn FSUSER_IsSdmcWritable(writable: *mut bool) -> Result;
}
extern "C" {
    pub fn FSUSER_GetSdmcCid(out: *mut u8, length: u32) -> Result;
}
extern "C" {
    pub fn FSUSER_GetNandCid(out: *mut u8, length: u32) -> Result;
}
extern "C" {
    pub fn FSUSER_GetSdmcSpeedInfo(speedInfo: *mut u32) -> Result;
}
extern "C" {
    pub fn FSUSER_GetNandSpeedInfo(speedInfo: *mut u32) -> Result;
}
extern "C" {
    pub fn FSUSER_GetSdmcLog(out: *mut u8, length: u32) -> Result;
}
extern "C" {
    pub fn FSUSER_GetNandLog(out: *mut u8, length: u32) -> Result;
}
extern "C" {
    pub fn FSUSER_ClearSdmcLog() -> Result;
}
extern "C" {
    pub fn FSUSER_ClearNandLog() -> Result;
}
extern "C" {
    pub fn FSUSER_CardSlotIsInserted(inserted: *mut bool) -> Result;
}
extern "C" {
    pub fn FSUSER_CardSlotPowerOn(status: *mut bool) -> Result;
}
extern "C" {
    pub fn FSUSER_CardSlotPowerOff(status: *mut bool) -> Result;
}
extern "C" {
    pub fn FSUSER_CardSlotGetCardIFPowerStatus(status: *mut bool) -> Result;
}
extern "C" {
    pub fn FSUSER_CardNorDirectCommand(commandId: u8) -> Result;
}
extern "C" {
    pub fn FSUSER_CardNorDirectCommandWithAddress(commandId: u8, address: u32)
     -> Result;
}
extern "C" {
    pub fn FSUSER_CardNorDirectRead(commandId: u8, size: u32, output: *mut u8)
     -> Result;
}
extern "C" {
    pub fn FSUSER_CardNorDirectReadWithAddress(commandId: u8, address: u32,
                                               size: u32, output: *mut u8)
     -> Result;
}
extern "C" {
    pub fn FSUSER_CardNorDirectWrite(commandId: u8, size: u32, input: *mut u8)
     -> Result;
}
extern "C" {
    pub fn FSUSER_CardNorDirectWriteWithAddress(commandId: u8, address: u32,
                                                size: u32, input: *mut u8)
     -> Result;
}
extern "C" {
    pub fn FSUSER_CardNorDirectRead_4xIO(commandId: u8, address: u32,
                                         size: u32, output: *mut u8)
     -> Result;
}
extern "C" {
    pub fn FSUSER_CardNorDirectCpuWriteWithoutVerify(address: u32, size: u32,
                                                     input: *mut u8)
     -> Result;
}
extern "C" {
    pub fn FSUSER_CardNorDirectSectorEraseWithoutVerify(address: u32)
     -> Result;
}
extern "C" {
    pub fn FSUSER_GetProductInfo(info: *mut FS_ProductInfo, processId: u32)
     -> Result;
}
extern "C" {
    pub fn FSUSER_GetProgramLaunchInfo(info: *mut FS_ProgramInfo,
                                       processId: u32) -> Result;
}
extern "C" {
    pub fn FSUSER_SetCardSpiBaudRate(baudRate: FS_CardSpiBaudRate) -> Result;
}
extern "C" {
    pub fn FSUSER_SetCardSpiBusMode(busMode: FS_CardSpiBusMode) -> Result;
}
extern "C" {
    pub fn FSUSER_SendInitializeInfoTo9() -> Result;
}
extern "C" {
    pub fn FSUSER_GetSpecialContentIndex(index: *mut u16,
                                         mediaType: FS_MediaType,
                                         programId: u64,
                                         type_: FS_SpecialContentType)
     -> Result;
}
extern "C" {
    pub fn FSUSER_GetLegacyRomHeader(mediaType: FS_MediaType, programId: u64,
                                     header: *mut u8) -> Result;
}
extern "C" {
    pub fn FSUSER_GetLegacyBannerData(mediaType: FS_MediaType, programId: u64,
                                      banner: *mut u8) -> Result;
}
extern "C" {
    pub fn FSUSER_CheckAuthorityToAccessExtSaveData(access: *mut bool,
                                                    mediaType: FS_MediaType,
                                                    saveId: u64,
                                                    processId: u32) -> Result;
}
extern "C" {
    pub fn FSUSER_QueryTotalQuotaSize(quotaSize: *mut u64, directories: u32,
                                      files: u32, fileSizeCount: u32,
                                      fileSizes: *mut u64) -> Result;
}
extern "C" {
    pub fn FSUSER_AbnegateAccessRight(accessRight: u32) -> Result;
}
extern "C" {
    pub fn FSUSER_DeleteSdmcRoot() -> Result;
}
extern "C" {
    pub fn FSUSER_DeleteAllExtSaveDataOnNand() -> Result;
}
extern "C" {
    pub fn FSUSER_InitializeCtrFileSystem() -> Result;
}
extern "C" {
    pub fn FSUSER_CreateSeed() -> Result;
}
extern "C" {
    pub fn FSUSER_GetFormatInfo(totalSize: *mut u32, directories: *mut u32,
                                files: *mut u32, duplicateData: *mut bool,
                                archiveId: FS_ArchiveID, path: FS_Path)
     -> Result;
}
extern "C" {
    pub fn FSUSER_GetLegacyRomHeader2(headerSize: u32,
                                      mediaType: FS_MediaType, programId: u64,
                                      header: *mut u8) -> Result;
}
extern "C" {
    pub fn FSUSER_GetSdmcCtrRootPath(out: *mut u8, length: u32) -> Result;
}
extern "C" {
    pub fn FSUSER_GetArchiveResource(archiveResource: *mut FS_ArchiveResource,
                                     mediaType: FS_SystemMediaType) -> Result;
}
extern "C" {
    pub fn FSUSER_ExportIntegrityVerificationSeed(seed:
                                                      *mut FS_IntegrityVerificationSeed)
     -> Result;
}
extern "C" {
    pub fn FSUSER_ImportIntegrityVerificationSeed(seed:
                                                      *mut FS_IntegrityVerificationSeed)
     -> Result;
}
extern "C" {
    pub fn FSUSER_FormatSaveData(archiveId: FS_ArchiveID, path: FS_Path,
                                 blocks: u32, directories: u32, files: u32,
                                 directoryBuckets: u32, fileBuckets: u32,
                                 duplicateData: bool) -> Result;
}
extern "C" {
    pub fn FSUSER_GetLegacySubBannerData(bannerSize: u32,
                                         mediaType: FS_MediaType,
                                         programId: u64, banner: *mut u8)
     -> Result;
}
extern "C" {
    pub fn FSUSER_UpdateSha256Context(data: *const libc::c_void,
                                      inputSize: u32, hash: *mut u8)
     -> Result;
}
extern "C" {
    pub fn FSUSER_ReadSpecialFile(bytesRead: *mut u32, fileOffset: u64,
                                  size: u32, data: *mut u8) -> Result;
}
extern "C" {
    pub fn FSUSER_GetSpecialFileSize(fileSize: *mut u64) -> Result;
}
extern "C" {
    pub fn FSUSER_CreateExtSaveData(info: FS_ExtSaveDataInfo,
                                    directories: u32, files: u32,
                                    sizeLimit: u64, smdhSize: u32,
                                    smdh: *mut u8) -> Result;
}
extern "C" {
    pub fn FSUSER_DeleteExtSaveData(info: FS_ExtSaveDataInfo) -> Result;
}
extern "C" {
    pub fn FSUSER_ReadExtSaveDataIcon(bytesRead: *mut u32,
                                      info: FS_ExtSaveDataInfo, smdhSize: u32,
                                      smdh: *mut u8) -> Result;
}
extern "C" {
    pub fn FSUSER_GetExtDataBlockSize(totalBlocks: *mut u64,
                                      freeBlocks: *mut u64,
                                      blockSize: *mut u32,
                                      info: FS_ExtSaveDataInfo) -> Result;
}
extern "C" {
    pub fn FSUSER_EnumerateExtSaveData(idsWritten: *mut u32, idsSize: u32,
                                       mediaType: FS_MediaType, idSize: u32,
                                       shared: bool, ids: *mut u8) -> Result;
}
extern "C" {
    pub fn FSUSER_CreateSystemSaveData(info: FS_SystemSaveDataInfo,
                                       totalSize: u32, blockSize: u32,
                                       directories: u32, files: u32,
                                       directoryBuckets: u32,
                                       fileBuckets: u32, duplicateData: bool)
     -> Result;
}
extern "C" {
    pub fn FSUSER_DeleteSystemSaveData(info: FS_SystemSaveDataInfo) -> Result;
}
extern "C" {
    pub fn FSUSER_StartDeviceMoveAsSource(context: *mut FS_DeviceMoveContext)
     -> Result;
}
extern "C" {
    pub fn FSUSER_StartDeviceMoveAsDestination(context: FS_DeviceMoveContext,
                                               clear: bool) -> Result;
}
extern "C" {
    pub fn FSUSER_SetArchivePriority(archive: FS_Archive, priority: u32)
     -> Result;
}
extern "C" {
    pub fn FSUSER_GetArchivePriority(priority: *mut u32, archive: FS_Archive)
     -> Result;
}
extern "C" {
    pub fn FSUSER_SetCtrCardLatencyParameter(latency: u64,
                                             emulateEndurance: bool)
     -> Result;
}
extern "C" {
    pub fn FSUSER_SwitchCleanupInvalidSaveData(enable: bool) -> Result;
}
extern "C" {
    pub fn FSUSER_EnumerateSystemSaveData(idsWritten: *mut u32, idsSize: u32,
                                          ids: *mut u32) -> Result;
}
extern "C" {
    pub fn FSUSER_InitializeWithSdkVersion(session: Handle, version: u32)
     -> Result;
}
extern "C" {
    pub fn FSUSER_SetPriority(priority: u32) -> Result;
}
extern "C" {
    pub fn FSUSER_GetPriority(priority: *mut u32) -> Result;
}
extern "C" {
    pub fn FSUSER_SetSaveDataSecureValue(value: u64, slot: FS_SecureValueSlot,
                                         titleUniqueId: u32,
                                         titleVariation: u8) -> Result;
}
extern "C" {
    pub fn FSUSER_GetSaveDataSecureValue(exists: *mut bool, value: *mut u64,
                                         slot: FS_SecureValueSlot,
                                         titleUniqueId: u32,
                                         titleVariation: u8) -> Result;
}
extern "C" {
    pub fn FSUSER_ControlSecureSave(action: FS_SecureSaveAction,
                                    input: *mut libc::c_void, inputSize: u32,
                                    output: *mut libc::c_void,
                                    outputSize: u32) -> Result;
}
extern "C" {
    pub fn FSUSER_GetMediaType(mediaType: *mut FS_MediaType) -> Result;
}
extern "C" {
    pub fn FSFILE_Control(handle: Handle, action: FS_FileAction,
                          input: *mut libc::c_void, inputSize: u32,
                          output: *mut libc::c_void, outputSize: u32)
     -> Result;
}
extern "C" {
    pub fn FSFILE_OpenSubFile(handle: Handle, subFile: *mut Handle,
                              offset: u64, size: u64) -> Result;
}
extern "C" {
    pub fn FSFILE_Read(handle: Handle, bytesRead: *mut u32, offset: u64,
                       buffer: *mut libc::c_void, size: u32) -> Result;
}
extern "C" {
    pub fn FSFILE_Write(handle: Handle, bytesWritten: *mut u32, offset: u64,
                        buffer: *const libc::c_void, size: u32, flags: u32)
     -> Result;
}
extern "C" {
    pub fn FSFILE_GetSize(handle: Handle, size: *mut u64) -> Result;
}
extern "C" {
    pub fn FSFILE_SetSize(handle: Handle, size: u64) -> Result;
}
extern "C" {
    pub fn FSFILE_GetAttributes(handle: Handle, attributes: *mut u32)
     -> Result;
}
extern "C" {
    pub fn FSFILE_SetAttributes(handle: Handle, attributes: u32) -> Result;
}
extern "C" {
    pub fn FSFILE_Close(handle: Handle) -> Result;
}
extern "C" {
    pub fn FSFILE_Flush(handle: Handle) -> Result;
}
extern "C" {
    pub fn FSFILE_SetPriority(handle: Handle, priority: u32) -> Result;
}
extern "C" {
    pub fn FSFILE_GetPriority(handle: Handle, priority: *mut u32) -> Result;
}
extern "C" {
    pub fn FSFILE_OpenLinkFile(handle: Handle, linkFile: *mut Handle)
     -> Result;
}
extern "C" {
    pub fn FSDIR_Control(handle: Handle, action: FS_DirectoryAction,
                         input: *mut libc::c_void, inputSize: u32,
                         output: *mut libc::c_void, outputSize: u32)
     -> Result;
}
extern "C" {
    pub fn FSDIR_Read(handle: Handle, entriesRead: *mut u32, entryCount: u32,
                      entries: *mut FS_DirectoryEntry) -> Result;
}
extern "C" {
    pub fn FSDIR_Close(handle: Handle) -> Result;
}
extern "C" {
    pub fn FSDIR_SetPriority(handle: Handle, priority: u32) -> Result;
}
extern "C" {
    pub fn FSDIR_GetPriority(handle: Handle, priority: *mut u32) -> Result;
}
#[repr(C)]
#[derive(Copy)]
pub struct AM_TitleEntry {
    pub titleID: u64,
    pub size: u64,
    pub version: u16,
    pub unk: [u8; 6usize],
}
impl Clone for AM_TitleEntry {
    fn clone(&self) -> Self { *self }
}
pub const AM_STATUS_MASK_INSTALLING: _bindgen_ty_9 =
    _bindgen_ty_9::AM_STATUS_MASK_INSTALLING;
pub const AM_STATUS_MASK_AWAITING_FINALIZATION: _bindgen_ty_9 =
    _bindgen_ty_9::AM_STATUS_MASK_AWAITING_FINALIZATION;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_9 {
    AM_STATUS_MASK_INSTALLING = 1,
    AM_STATUS_MASK_AWAITING_FINALIZATION = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AM_InstallStatus {
    AM_STATUS_ABORTED = 2,
    AM_STATUS_SAVED = 3,
    AM_STATUS_INSTALL_IN_PROGRESS = 2050,
    AM_STATUS_AWAITING_FINALIZATION = 2051,
}
#[repr(C)]
#[derive(Copy)]
pub struct AM_PendingTitleEntry {
    pub titleId: u64,
    pub version: u16,
    pub status: u16,
    pub titleType: u32,
    pub unk: [u8; 8usize],
}
impl Clone for AM_PendingTitleEntry {
    fn clone(&self) -> Self { *self }
}
pub const AM_DELETE_PENDING_NON_SYSTEM: _bindgen_ty_10 =
    _bindgen_ty_10::AM_DELETE_PENDING_NON_SYSTEM;
pub const AM_DELETE_PENDING_SYSTEM: _bindgen_ty_10 =
    _bindgen_ty_10::AM_DELETE_PENDING_SYSTEM;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_10 {
    AM_DELETE_PENDING_NON_SYSTEM = 1,
    AM_DELETE_PENDING_SYSTEM = 2,
}
#[repr(C)]
#[derive(Copy)]
pub struct AM_TWLPartitionInfo {
    pub capacity: u64,
    pub freeSpace: u64,
    pub titlesCapacity: u64,
    pub titlesFreeSpace: u64,
}
impl Clone for AM_TWLPartitionInfo {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn amInit() -> Result;
}
extern "C" {
    pub fn amAppInit() -> Result;
}
extern "C" {
    pub fn amExit();
}
extern "C" {
    pub fn amGetSessionHandle() -> *mut Handle;
}
extern "C" {
    pub fn AM_GetTitleCount(mediatype: FS_MediaType, count: *mut u32)
     -> Result;
}
extern "C" {
    pub fn AM_GetTitleList(titlesRead: *mut u32, mediatype: FS_MediaType,
                           titleCount: u32, titleIds: *mut u64) -> Result;
}
extern "C" {
    pub fn AM_GetTitleInfo(mediatype: FS_MediaType, titleCount: u32,
                           titleIds: *mut u64, titleInfo: *mut AM_TitleEntry)
     -> Result;
}
extern "C" {
    pub fn AM_GetTicketCount(count: *mut u32) -> Result;
}
extern "C" {
    pub fn AM_GetTicketList(ticketsRead: *mut u32, ticketCount: u32,
                            skip: u32, ticketIds: *mut u64) -> Result;
}
extern "C" {
    pub fn AM_GetPendingTitleCount(count: *mut u32, mediatype: FS_MediaType,
                                   statusMask: u32) -> Result;
}
extern "C" {
    pub fn AM_GetPendingTitleList(titlesRead: *mut u32, titleCount: u32,
                                  mediatype: FS_MediaType, statusMask: u32,
                                  titleIds: *mut u64) -> Result;
}
extern "C" {
    pub fn AM_GetPendingTitleInfo(titleCount: u32, mediatype: FS_MediaType,
                                  titleIds: *mut u64,
                                  titleInfo: *mut AM_PendingTitleEntry)
     -> Result;
}
extern "C" {
    pub fn AM_GetDeviceId(deviceID: *mut u32) -> Result;
}
extern "C" {
    pub fn AM_ExportTwlBackup(titleID: u64, operation: u8,
                              workbuf: *mut libc::c_void, workbuf_size: u32,
                              filepath: *const libc::c_char) -> Result;
}
extern "C" {
    pub fn AM_ImportTwlBackup(filehandle: Handle, operation: u8,
                              buffer: *mut libc::c_void, size: u32) -> Result;
}
extern "C" {
    pub fn AM_ReadTwlBackupInfo(filehandle: Handle,
                                outinfo: *mut libc::c_void, outinfo_size: u32,
                                workbuf: *mut libc::c_void, workbuf_size: u32,
                                banner: *mut libc::c_void, banner_size: u32)
     -> Result;
}
extern "C" {
    pub fn AM_GetTWLPartitionInfo(info: *mut AM_TWLPartitionInfo) -> Result;
}
extern "C" {
    pub fn AM_StartCiaInstall(mediatype: FS_MediaType, ciaHandle: *mut Handle)
     -> Result;
}
extern "C" {
    pub fn AM_StartDlpChildCiaInstall(ciaHandle: *mut Handle) -> Result;
}
extern "C" {
    pub fn AM_CancelCIAInstall(ciaHandle: Handle) -> Result;
}
extern "C" {
    pub fn AM_FinishCiaInstall(ciaHandle: Handle) -> Result;
}
extern "C" {
    pub fn AM_FinishCiaInstallWithoutCommit(ciaHandle: Handle) -> Result;
}
extern "C" {
    pub fn AM_CommitImportPrograms(mediaType: FS_MediaType, titleCount: u32,
                                   temp: bool, titleIds: *const u64)
     -> Result;
}
extern "C" {
    pub fn AM_DeleteTitle(mediatype: FS_MediaType, titleID: u64) -> Result;
}
extern "C" {
    pub fn AM_DeleteAppTitle(mediatype: FS_MediaType, titleID: u64) -> Result;
}
extern "C" {
    pub fn AM_DeleteTicket(ticketId: u64) -> Result;
}
extern "C" {
    pub fn AM_DeletePendingTitle(mediatype: FS_MediaType, titleId: u64)
     -> Result;
}
extern "C" {
    pub fn AM_DeletePendingTitles(mediatype: FS_MediaType, flags: u32)
     -> Result;
}
extern "C" {
    pub fn AM_DeleteAllPendingTitles(mediatype: FS_MediaType) -> Result;
}
extern "C" {
    pub fn AM_InstallNativeFirm() -> Result;
}
extern "C" {
    pub fn AM_InstallFirm(titleID: u64) -> Result;
}
extern "C" {
    pub fn AM_GetTitleProductCode(mediatype: FS_MediaType, titleId: u64,
                                  productCode: *mut libc::c_char) -> Result;
}
extern "C" {
    pub fn AM_GetTitleExtDataId(extDataId: *mut u64, mediatype: FS_MediaType,
                                titleId: u64) -> Result;
}
extern "C" {
    pub fn AM_GetCiaFileInfo(mediatype: FS_MediaType,
                             titleEntry: *mut AM_TitleEntry,
                             fileHandle: Handle) -> Result;
}
extern "C" {
    pub fn AM_GetCiaIcon(icon: *mut libc::c_void, fileHandle: Handle)
     -> Result;
}
extern "C" {
    pub fn AM_GetCiaDependencies(dependencies: *mut u64, fileHandle: Handle)
     -> Result;
}
extern "C" {
    pub fn AM_GetCiaMetaOffset(metaOffset: *mut u64, fileHandle: Handle)
     -> Result;
}
extern "C" {
    pub fn AM_GetCiaCoreVersion(coreVersion: *mut u32, fileHandle: Handle)
     -> Result;
}
extern "C" {
    pub fn AM_GetCiaRequiredSpace(requiredSpace: *mut u64,
                                  mediaType: FS_MediaType, fileHandle: Handle)
     -> Result;
}
extern "C" {
    pub fn AM_GetCiaMetaSection(meta: *mut libc::c_void, size: u32,
                                fileHandle: Handle) -> Result;
}
extern "C" {
    pub fn AM_InitializeExternalTitleDatabase(overwrite: bool) -> Result;
}
extern "C" {
    pub fn AM_QueryAvailableExternalTitleDatabase(available: *mut bool)
     -> Result;
}
extern "C" {
    pub fn AM_InstallTicketBegin(ticketHandle: *mut Handle) -> Result;
}
extern "C" {
    pub fn AM_InstallTicketAbort(ticketHandle: Handle) -> Result;
}
extern "C" {
    pub fn AM_InstallTicketFinish(ticketHandle: Handle) -> Result;
}
extern "C" {
    pub fn AM_InstallTitleBegin(mediaType: FS_MediaType, titleId: u64,
                                unk: bool) -> Result;
}
extern "C" {
    pub fn AM_InstallTitleStop() -> Result;
}
extern "C" {
    pub fn AM_InstallTitleResume(mediaType: FS_MediaType, titleId: u64)
     -> Result;
}
extern "C" {
    pub fn AM_InstallTitleAbort() -> Result;
}
extern "C" {
    pub fn AM_InstallTitleFinish() -> Result;
}
extern "C" {
    pub fn AM_CommitImportTitles(mediaType: FS_MediaType, titleCount: u32,
                                 temp: bool, titleIds: *const u64) -> Result;
}
extern "C" {
    pub fn AM_InstallTmdBegin(tmdHandle: *mut Handle) -> Result;
}
extern "C" {
    pub fn AM_InstallTmdAbort(tmdHandle: Handle) -> Result;
}
extern "C" {
    pub fn AM_InstallTmdFinish(tmdHandle: Handle, unk: bool) -> Result;
}
extern "C" {
    pub fn AM_CreateImportContentContexts(contentCount: u32,
                                          contentIndices: *mut u16) -> Result;
}
extern "C" {
    pub fn AM_InstallContentBegin(contentHandle: *mut Handle, index: u16)
     -> Result;
}
extern "C" {
    pub fn AM_InstallContentStop(contentHandle: Handle) -> Result;
}
extern "C" {
    pub fn AM_InstallContentResume(contentHandle: *mut Handle,
                                   resumeOffset: *mut u64, index: u16)
     -> Result;
}
extern "C" {
    pub fn AM_InstallContentCancel(contentHandle: Handle) -> Result;
}
extern "C" {
    pub fn AM_InstallContentFinish(contentHandle: Handle) -> Result;
}
extern "C" {
    pub fn AM_ImportCertificates(cert1Size: u32, cert1: *mut libc::c_void,
                                 cert2Size: u32, cert2: *mut libc::c_void,
                                 cert3Size: u32, cert3: *mut libc::c_void,
                                 cert4Size: u32, cert4: *mut libc::c_void)
     -> Result;
}
extern "C" {
    pub fn AM_ImportCertificate(certSize: u32, cert: *mut libc::c_void)
     -> Result;
}
extern "C" {
    pub fn AM_CommitImportTitlesAndUpdateFirmwareAuto(mediaType: FS_MediaType,
                                                      titleCount: u32,
                                                      temp: bool,
                                                      titleIds: *mut u64)
     -> Result;
}
extern "C" {
    pub fn AM_DeleteAllDemoLaunchInfos() -> Result;
}
extern "C" {
    pub fn ampxiInit(servhandle: Handle) -> Result;
}
extern "C" {
    pub fn ampxiExit();
}
extern "C" {
    pub fn AMPXI_WriteTWLSavedata(titleid: u64, buffer: *mut u8, size: u32,
                                  image_filepos: u32, section_type: u8,
                                  operation: u8) -> Result;
}
extern "C" {
    pub fn AMPXI_InstallTitlesFinish(mediaType: FS_MediaType, db: u8,
                                     titlecount: u32, tidlist: *mut u64)
     -> Result;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum NS_APPID {
    APPID_NONE = 0,
    APPID_HOMEMENU = 257,
    APPID_CAMERA = 272,
    APPID_FRIENDS_LIST = 274,
    APPID_GAME_NOTES = 275,
    APPID_WEB = 276,
    APPID_INSTRUCTION_MANUAL = 277,
    APPID_NOTIFICATIONS = 278,
    APPID_MIIVERSE = 279,
    APPID_MIIVERSE_POSTING = 280,
    APPID_AMIIBO_SETTINGS = 281,
    APPID_APPLICATION = 768,
    APPID_ESHOP = 769,
    APPID_SOFTWARE_KEYBOARD = 1025,
    APPID_APPLETED = 1026,
    APPID_PNOTE_AP = 1028,
    APPID_SNOTE_AP = 1029,
    APPID_ERROR = 1030,
    APPID_MINT = 1031,
    APPID_EXTRAPAD = 1032,
    APPID_MEMOLIB = 1033,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum APT_AppletPos {
    APTPOS_NONE = -1,
    APTPOS_APP = 0,
    APTPOS_APPLIB = 1,
    APTPOS_SYS = 2,
    APTPOS_SYSLIB = 3,
    APTPOS_RESIDENT = 4,
}
pub type APT_AppletAttr = u8;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum APT_QueryReply {
    APTREPLY_REJECT = 0,
    APTREPLY_ACCEPT = 1,
    APTREPLY_LATER = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum APT_Signal {
    APTSIGNAL_NONE = 0,
    APTSIGNAL_HOMEBUTTON = 1,
    APTSIGNAL_HOMEBUTTON2 = 2,
    APTSIGNAL_SLEEP_QUERY = 3,
    APTSIGNAL_SLEEP_CANCEL = 4,
    APTSIGNAL_SLEEP_ENTER = 5,
    APTSIGNAL_SLEEP_WAKEUP = 6,
    APTSIGNAL_SHUTDOWN = 7,
    APTSIGNAL_POWERBUTTON = 8,
    APTSIGNAL_POWERBUTTON2 = 9,
    APTSIGNAL_TRY_SLEEP = 10,
    APTSIGNAL_ORDERTOCLOSE = 11,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum APT_Command {
    APTCMD_NONE = 0,
    APTCMD_WAKEUP = 1,
    APTCMD_REQUEST = 2,
    APTCMD_RESPONSE = 3,
    APTCMD_EXIT = 4,
    APTCMD_MESSAGE = 5,
    APTCMD_HOMEBUTTON_ONCE = 6,
    APTCMD_HOMEBUTTON_TWICE = 7,
    APTCMD_DSP_SLEEP = 8,
    APTCMD_DSP_WAKEUP = 9,
    APTCMD_WAKEUP_EXIT = 10,
    APTCMD_WAKEUP_PAUSE = 11,
    APTCMD_WAKEUP_CANCEL = 12,
    APTCMD_WAKEUP_CANCELALL = 13,
    APTCMD_WAKEUP_POWERBUTTON = 14,
    APTCMD_WAKEUP_JUMPTOHOME = 15,
    APTCMD_SYSAPPLET_REQUEST = 16,
    APTCMD_WAKEUP_LAUNCHAPP = 17,
}
#[repr(C)]
#[derive(Copy)]
pub struct aptCaptureBufInfo {
    pub size: u32,
    pub is3D: u32,
    pub top: aptCaptureBufInfo__bindgen_ty_1,
    pub bottom: aptCaptureBufInfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub struct aptCaptureBufInfo__bindgen_ty_1 {
    pub leftOffset: u32,
    pub rightOffset: u32,
    pub format: u32,
}
impl Clone for aptCaptureBufInfo__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Clone for aptCaptureBufInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum APT_HookType {
    APTHOOK_ONSUSPEND = 0,
    APTHOOK_ONRESTORE = 1,
    APTHOOK_ONSLEEP = 2,
    APTHOOK_ONWAKEUP = 3,
    APTHOOK_ONEXIT = 4,
    APTHOOK_COUNT = 5,
}
pub type aptHookFn =
    ::core::option::Option<unsafe extern "C" fn(hook: APT_HookType,
                                                param: *mut libc::c_void)>;
#[repr(C)]
#[derive(Copy)]
pub struct tag_aptHookCookie {
    pub next: *mut tag_aptHookCookie,
    pub callback: aptHookFn,
    pub param: *mut libc::c_void,
}
impl Clone for tag_aptHookCookie {
    fn clone(&self) -> Self { *self }
}
pub type aptHookCookie = tag_aptHookCookie;
pub type aptMessageCb =
    ::core::option::Option<unsafe extern "C" fn(user: *mut libc::c_void,
                                                sender: NS_APPID,
                                                msg: *mut libc::c_void,
                                                msgsize: usize)>;
extern "C" {
    pub fn aptInit() -> Result;
}
extern "C" {
    pub fn aptExit();
}
extern "C" {
    pub fn aptSendCommand(aptcmdbuf: *mut u32) -> Result;
}
extern "C" {
    pub fn aptIsSleepAllowed() -> bool;
}
extern "C" {
    pub fn aptSetSleepAllowed(allowed: bool);
}
extern "C" {
    pub fn aptMainLoop() -> bool;
}
extern "C" {
    pub fn aptHook(cookie: *mut aptHookCookie, callback: aptHookFn,
                   param: *mut libc::c_void);
}
extern "C" {
    pub fn aptUnhook(cookie: *mut aptHookCookie);
}
extern "C" {
    pub fn aptSetMessageCallback(callback: aptMessageCb,
                                 user: *mut libc::c_void);
}
extern "C" {
    pub fn aptLaunchLibraryApplet(appId: NS_APPID, buf: *mut libc::c_void,
                                  bufsize: usize, handle: Handle) -> bool;
}
extern "C" {
    pub fn aptSetChainloader(programID: u64, mediatype: u8);
}
extern "C" {
    pub fn APT_GetLockHandle(flags: u16, lockHandle: *mut Handle) -> Result;
}
extern "C" {
    pub fn APT_Initialize(appId: NS_APPID, attr: APT_AppletAttr,
                          signalEvent: *mut Handle, resumeEvent: *mut Handle)
     -> Result;
}
extern "C" {
    pub fn APT_Finalize(appId: NS_APPID) -> Result;
}
extern "C" {
    pub fn APT_HardwareResetAsync() -> Result;
}
extern "C" {
    pub fn APT_Enable(attr: APT_AppletAttr) -> Result;
}
extern "C" {
    pub fn APT_GetAppletManInfo(inpos: APT_AppletPos,
                                outpos: *mut APT_AppletPos,
                                req_appid: *mut NS_APPID,
                                menu_appid: *mut NS_APPID,
                                active_appid: *mut NS_APPID) -> Result;
}
extern "C" {
    pub fn APT_GetAppletInfo(appID: NS_APPID, pProgramID: *mut u64,
                             pMediaType: *mut u8, pRegistered: *mut bool,
                             pLoadState: *mut bool,
                             pAttributes: *mut APT_AppletAttr) -> Result;
}
extern "C" {
    pub fn APT_GetAppletProgramInfo(id: u32, flags: u32,
                                    titleversion: *mut u16) -> Result;
}
extern "C" {
    pub fn APT_GetProgramID(pProgramID: *mut u64) -> Result;
}
extern "C" {
    pub fn APT_PrepareToJumpToHomeMenu() -> Result;
}
extern "C" {
    pub fn APT_JumpToHomeMenu(param: *const libc::c_void, paramSize: usize,
                              handle: Handle) -> Result;
}
extern "C" {
    pub fn APT_PrepareToJumpToApplication(exiting: bool) -> Result;
}
extern "C" {
    pub fn APT_JumpToApplication(param: *const libc::c_void, paramSize: usize,
                                 handle: Handle) -> Result;
}
extern "C" {
    pub fn APT_IsRegistered(appID: NS_APPID, out: *mut bool) -> Result;
}
extern "C" {
    pub fn APT_InquireNotification(appID: u32, signalType: *mut APT_Signal)
     -> Result;
}
extern "C" {
    pub fn APT_NotifyToWait(appID: NS_APPID) -> Result;
}
extern "C" {
    pub fn APT_AppletUtility(id: libc::c_int, out: *mut libc::c_void,
                             outSize: usize, in_: *const libc::c_void,
                             inSize: usize) -> Result;
}
extern "C" {
    pub fn APT_SleepIfShellClosed() -> Result;
}
extern "C" {
    pub fn APT_TryLockTransition(transition: u32, succeeded: *mut bool)
     -> Result;
}
extern "C" {
    pub fn APT_UnlockTransition(transition: u32) -> Result;
}
extern "C" {
    pub fn APT_GlanceParameter(appID: NS_APPID, buffer: *mut libc::c_void,
                               bufferSize: usize, sender: *mut NS_APPID,
                               command: *mut APT_Command,
                               actualSize: *mut usize, parameter: *mut Handle)
     -> Result;
}
extern "C" {
    pub fn APT_ReceiveParameter(appID: NS_APPID, buffer: *mut libc::c_void,
                                bufferSize: usize, sender: *mut NS_APPID,
                                command: *mut APT_Command,
                                actualSize: *mut usize,
                                parameter: *mut Handle) -> Result;
}
extern "C" {
    pub fn APT_SendParameter(source: NS_APPID, dest: NS_APPID,
                             command: APT_Command,
                             buffer: *const libc::c_void, bufferSize: u32,
                             parameter: Handle) -> Result;
}
extern "C" {
    pub fn APT_CancelParameter(source: NS_APPID, dest: NS_APPID,
                               success: *mut bool) -> Result;
}
extern "C" {
    pub fn APT_SendCaptureBufferInfo(captureBuf: *const aptCaptureBufInfo)
     -> Result;
}
extern "C" {
    pub fn APT_ReplySleepQuery(appID: NS_APPID, reply: APT_QueryReply)
     -> Result;
}
extern "C" {
    pub fn APT_ReplySleepNotificationComplete(appID: NS_APPID) -> Result;
}
extern "C" {
    pub fn APT_PrepareToCloseApplication(cancelPreload: bool) -> Result;
}
extern "C" {
    pub fn APT_CloseApplication(param: *const libc::c_void, paramSize: usize,
                                handle: Handle) -> Result;
}
extern "C" {
    pub fn APT_SetAppCpuTimeLimit(percent: u32) -> Result;
}
extern "C" {
    pub fn APT_GetAppCpuTimeLimit(percent: *mut u32) -> Result;
}
extern "C" {
    pub fn APT_CheckNew3DS(out: *mut bool) -> Result;
}
extern "C" {
    pub fn APT_PrepareToDoApplicationJump(flags: u8, programID: u64,
                                          mediatype: u8) -> Result;
}
extern "C" {
    pub fn APT_DoApplicationJump(param: *const libc::c_void, paramSize: usize,
                                 hmac: *const libc::c_void) -> Result;
}
extern "C" {
    pub fn APT_PrepareToStartLibraryApplet(appID: NS_APPID) -> Result;
}
extern "C" {
    pub fn APT_StartLibraryApplet(appID: NS_APPID, param: *const libc::c_void,
                                  paramSize: usize, handle: Handle) -> Result;
}
extern "C" {
    pub fn APT_PrepareToStartSystemApplet(appID: NS_APPID) -> Result;
}
extern "C" {
    pub fn APT_StartSystemApplet(appID: NS_APPID, param: *const libc::c_void,
                                 paramSize: usize, handle: Handle) -> Result;
}
extern "C" {
    pub fn APT_GetSharedFont(fontHandle: *mut Handle, mapAddr: *mut u32)
     -> Result;
}
extern "C" {
    pub fn APT_ReceiveDeliverArg(param: *const libc::c_void, paramSize: usize,
                                 hmac: *const libc::c_void, sender: *mut u64,
                                 received: *mut bool) -> Result;
}
#[repr(C)]
pub struct bossContext {
    pub property: [u32; 7usize],
    pub url: [libc::c_char; 512usize],
    pub property_x8: u32,
    pub property_x9: u8,
    pub property_xa: [u8; 256usize],
    pub property_xb: [u8; 512usize],
    pub property_xd: [libc::c_char; 864usize],
    pub property_xe: u32,
    pub property_xf: [u32; 3usize],
    pub property_x10: u8,
    pub property_x11: u8,
    pub property_x12: u8,
    pub property_x13: u32,
    pub property_x14: u32,
    pub property_x15: [u8; 64usize],
    pub property_x16: u32,
    pub property_x3b: u32,
    pub property_x3e: [u8; 512usize],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum bossTaskStatus {
    BOSSTASKSTATUS_STARTED = 2,
    BOSSTASKSTATUS_ERROR = 7,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum bossNsDataHeaderInfoTypes {
    bossNsDataHeaderInfoType_ContentSize = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum bossNsDataHeaderInfoTypeSizes {
    bossNsDataHeaderInfoTypeSize_ContentSize = 4,
}
extern "C" {
    pub fn bossInit(programID: u64, force_user: bool) -> Result;
}
extern "C" {
    pub fn bossReinit(programID: u64) -> Result;
}
extern "C" {
    pub fn bossExit();
}
extern "C" {
    pub fn bossGetSessionHandle() -> Handle;
}
extern "C" {
    pub fn bossSetStorageInfo(extdataID: u64, boss_size: u32, mediaType: u8)
     -> Result;
}
extern "C" {
    pub fn bossUnregisterStorage() -> Result;
}
extern "C" {
    pub fn bossRegisterTask(taskID: *const libc::c_char, unk0: u8, unk1: u8)
     -> Result;
}
extern "C" {
    pub fn bossSendProperty(PropertyID: u16, buf: *const libc::c_void,
                            size: u32) -> Result;
}
extern "C" {
    pub fn bossDeleteNsData(NsDataId: u32) -> Result;
}
extern "C" {
    pub fn bossGetNsDataHeaderInfo(NsDataId: u32, type_: u8,
                                   buffer: *mut libc::c_void, size: u32)
     -> Result;
}
extern "C" {
    pub fn bossReadNsData(NsDataId: u32, offset: u64,
                          buffer: *mut libc::c_void, size: u32,
                          transfer_total: *mut u32, unk_out: *mut u32)
     -> Result;
}
extern "C" {
    pub fn bossStartTaskImmediate(taskID: *const libc::c_char) -> Result;
}
extern "C" {
    pub fn bossStartBgImmediate(taskID: *const libc::c_char) -> Result;
}
extern "C" {
    pub fn bossDeleteTask(taskID: *const libc::c_char, unk: u32) -> Result;
}
extern "C" {
    pub fn bossGetTaskState(taskID: *const libc::c_char, inval: s8,
                            status: *mut u8, out1: *mut u32, out2: *mut u8)
     -> Result;
}
extern "C" {
    pub fn bossGetTaskProperty0(taskID: *const libc::c_char, out: *mut u8)
     -> Result;
}
extern "C" {
    pub fn bossSetupContextDefault(ctx: *mut bossContext,
                                   seconds_interval: u32,
                                   url: *const libc::c_char);
}
extern "C" {
    pub fn bossSendContextConfig(ctx: *mut bossContext) -> Result;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum Y2RU_InputFormat {
    INPUT_YUV422_INDIV_8 = 0,
    INPUT_YUV420_INDIV_8 = 1,
    INPUT_YUV422_INDIV_16 = 2,
    INPUT_YUV420_INDIV_16 = 3,
    INPUT_YUV422_BATCH = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum Y2RU_OutputFormat {
    OUTPUT_RGB_32 = 0,
    OUTPUT_RGB_24 = 1,
    OUTPUT_RGB_16_555 = 2,
    OUTPUT_RGB_16_565 = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum Y2RU_Rotation {
    ROTATION_NONE = 0,
    ROTATION_CLOCKWISE_90 = 1,
    ROTATION_CLOCKWISE_180 = 2,
    ROTATION_CLOCKWISE_270 = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum Y2RU_BlockAlignment { BLOCK_LINE = 0, BLOCK_8_BY_8 = 1, }
#[repr(C)]
#[derive(Copy)]
pub struct Y2RU_ColorCoefficients {
    pub rgb_Y: u16,
    pub r_V: u16,
    pub g_V: u16,
    pub g_U: u16,
    pub b_U: u16,
    pub r_offset: u16,
    pub g_offset: u16,
    pub b_offset: u16,
}
impl Clone for Y2RU_ColorCoefficients {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum Y2RU_StandardCoefficient {
    COEFFICIENT_ITU_R_BT_601 = 0,
    COEFFICIENT_ITU_R_BT_709 = 1,
    COEFFICIENT_ITU_R_BT_601_SCALING = 2,
    COEFFICIENT_ITU_R_BT_709_SCALING = 3,
}
#[repr(C)]
#[derive(Copy)]
pub struct Y2RU_ConversionParams {
    pub _bitfield_1: [u8; 4usize],
    pub input_line_width: s16,
    pub input_lines: s16,
    pub _bitfield_2: u8,
    pub unused: u8,
    pub alpha: u16,
    pub __bindgen_align: [u32; 0usize],
}
impl Clone for Y2RU_ConversionParams {
    fn clone(&self) -> Self { *self }
}
impl Y2RU_ConversionParams {
    #[inline]
    pub fn input_format(&self) -> Y2RU_InputFormat {
        let mut unit_field_val: u32 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u32
                                                 as *mut u8,
                                             ::core::mem::size_of::<u32>())
        };
        let mask = 255u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::core::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_input_format(&mut self, val: Y2RU_InputFormat) {
        let mask = 255u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u32
                                                 as *mut u8,
                                             ::core::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn output_format(&self) -> Y2RU_OutputFormat {
        let mut unit_field_val: u32 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u32
                                                 as *mut u8,
                                             ::core::mem::size_of::<u32>())
        };
        let mask = 65280u64 as u32;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::core::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_output_format(&mut self, val: Y2RU_OutputFormat) {
        let mask = 65280u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u32
                                                 as *mut u8,
                                             ::core::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn rotation(&self) -> Y2RU_Rotation {
        let mut unit_field_val: u32 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u32
                                                 as *mut u8,
                                             ::core::mem::size_of::<u32>())
        };
        let mask = 16711680u64 as u32;
        let val = (unit_field_val & mask) >> 16usize;
        unsafe { ::core::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_rotation(&mut self, val: Y2RU_Rotation) {
        let mask = 16711680u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u32
                                                 as *mut u8,
                                             ::core::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 16usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn block_alignment(&self) -> Y2RU_BlockAlignment {
        let mut unit_field_val: u32 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u32
                                                 as *mut u8,
                                             ::core::mem::size_of::<u32>())
        };
        let mask = 4278190080u64 as u32;
        let val = (unit_field_val & mask) >> 24usize;
        unsafe { ::core::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_block_alignment(&mut self, val: Y2RU_BlockAlignment) {
        let mask = 4278190080u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u32
                                                 as *mut u8,
                                             ::core::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 24usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub const fn new_bitfield_1(input_format: Y2RU_InputFormat,
                                output_format: Y2RU_OutputFormat,
                                rotation: Y2RU_Rotation,
                                block_alignment: Y2RU_BlockAlignment) -> u32 {
        ({
             ({
                  ({
                       ({ 0 } |
                            ((input_format as u32 as u32) << 0usize) &
                                (255u64 as u32))
                   } |
                       ((output_format as u32 as u32) << 8usize) &
                           (65280u64 as u32))
              } |
                  ((rotation as u32 as u32) << 16usize) &
                      (16711680u64 as u32))
         } |
             ((block_alignment as u32 as u32) << 24usize) &
                 (4278190080u64 as u32))
    }
    #[inline]
    pub fn standard_coefficient(&self) -> Y2RU_StandardCoefficient {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_2 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 255u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::core::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_standard_coefficient(&mut self,
                                    val: Y2RU_StandardCoefficient) {
        let mask = 255u64 as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_2 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_2 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub const fn new_bitfield_2(standard_coefficient:
                                    Y2RU_StandardCoefficient) -> u8 {
        ({ 0 } |
             ((standard_coefficient as u32 as u8) << 0usize) & (255u64 as u8))
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct Y2RU_DitheringWeightParams {
    pub w0_xEven_yEven: u16,
    pub w0_xOdd_yEven: u16,
    pub w0_xEven_yOdd: u16,
    pub w0_xOdd_yOdd: u16,
    pub w1_xEven_yEven: u16,
    pub w1_xOdd_yEven: u16,
    pub w1_xEven_yOdd: u16,
    pub w1_xOdd_yOdd: u16,
    pub w2_xEven_yEven: u16,
    pub w2_xOdd_yEven: u16,
    pub w2_xEven_yOdd: u16,
    pub w2_xOdd_yOdd: u16,
    pub w3_xEven_yEven: u16,
    pub w3_xOdd_yEven: u16,
    pub w3_xEven_yOdd: u16,
    pub w3_xOdd_yOdd: u16,
}
impl Clone for Y2RU_DitheringWeightParams {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn y2rInit() -> Result;
}
extern "C" {
    pub fn y2rExit();
}
extern "C" {
    pub fn Y2RU_SetInputFormat(format: Y2RU_InputFormat) -> Result;
}
extern "C" {
    pub fn Y2RU_GetInputFormat(format: *mut Y2RU_InputFormat) -> Result;
}
extern "C" {
    pub fn Y2RU_SetOutputFormat(format: Y2RU_OutputFormat) -> Result;
}
extern "C" {
    pub fn Y2RU_GetOutputFormat(format: *mut Y2RU_OutputFormat) -> Result;
}
extern "C" {
    pub fn Y2RU_SetRotation(rotation: Y2RU_Rotation) -> Result;
}
extern "C" {
    pub fn Y2RU_GetRotation(rotation: *mut Y2RU_Rotation) -> Result;
}
extern "C" {
    pub fn Y2RU_SetBlockAlignment(alignment: Y2RU_BlockAlignment) -> Result;
}
extern "C" {
    pub fn Y2RU_GetBlockAlignment(alignment: *mut Y2RU_BlockAlignment)
     -> Result;
}
extern "C" {
    pub fn Y2RU_SetSpacialDithering(enable: bool) -> Result;
}
extern "C" {
    pub fn Y2RU_GetSpacialDithering(enabled: *mut bool) -> Result;
}
extern "C" {
    pub fn Y2RU_SetTemporalDithering(enable: bool) -> Result;
}
extern "C" {
    pub fn Y2RU_GetTemporalDithering(enabled: *mut bool) -> Result;
}
extern "C" {
    pub fn Y2RU_SetInputLineWidth(line_width: u16) -> Result;
}
extern "C" {
    pub fn Y2RU_GetInputLineWidth(line_width: *mut u16) -> Result;
}
extern "C" {
    pub fn Y2RU_SetInputLines(num_lines: u16) -> Result;
}
extern "C" {
    pub fn Y2RU_GetInputLines(num_lines: *mut u16) -> Result;
}
extern "C" {
    pub fn Y2RU_SetCoefficients(coefficients: *const Y2RU_ColorCoefficients)
     -> Result;
}
extern "C" {
    pub fn Y2RU_GetCoefficients(coefficients: *mut Y2RU_ColorCoefficients)
     -> Result;
}
extern "C" {
    pub fn Y2RU_SetStandardCoefficient(coefficient: Y2RU_StandardCoefficient)
     -> Result;
}
extern "C" {
    pub fn Y2RU_GetStandardCoefficient(coefficients:
                                           *mut Y2RU_ColorCoefficients,
                                       standardCoeff:
                                           Y2RU_StandardCoefficient)
     -> Result;
}
extern "C" {
    pub fn Y2RU_SetAlpha(alpha: u16) -> Result;
}
extern "C" {
    pub fn Y2RU_GetAlpha(alpha: *mut u16) -> Result;
}
extern "C" {
    pub fn Y2RU_SetTransferEndInterrupt(should_interrupt: bool) -> Result;
}
extern "C" {
    pub fn Y2RU_GetTransferEndInterrupt(should_interrupt: *mut bool)
     -> Result;
}
extern "C" {
    pub fn Y2RU_GetTransferEndEvent(end_event: *mut Handle) -> Result;
}
extern "C" {
    pub fn Y2RU_SetSendingY(src_buf: *const libc::c_void, image_size: u32,
                            transfer_unit: s16, transfer_gap: s16) -> Result;
}
extern "C" {
    pub fn Y2RU_SetSendingU(src_buf: *const libc::c_void, image_size: u32,
                            transfer_unit: s16, transfer_gap: s16) -> Result;
}
extern "C" {
    pub fn Y2RU_SetSendingV(src_buf: *const libc::c_void, image_size: u32,
                            transfer_unit: s16, transfer_gap: s16) -> Result;
}
extern "C" {
    pub fn Y2RU_SetSendingYUYV(src_buf: *const libc::c_void, image_size: u32,
                               transfer_unit: s16, transfer_gap: s16)
     -> Result;
}
extern "C" {
    pub fn Y2RU_SetReceiving(dst_buf: *mut libc::c_void, image_size: u32,
                             transfer_unit: s16, transfer_gap: s16) -> Result;
}
extern "C" {
    pub fn Y2RU_IsDoneSendingY(is_done: *mut bool) -> Result;
}
extern "C" {
    pub fn Y2RU_IsDoneSendingU(is_done: *mut bool) -> Result;
}
extern "C" {
    pub fn Y2RU_IsDoneSendingV(is_done: *mut bool) -> Result;
}
extern "C" {
    pub fn Y2RU_IsDoneSendingYUYV(is_done: *mut bool) -> Result;
}
extern "C" {
    pub fn Y2RU_IsDoneReceiving(is_done: *mut bool) -> Result;
}
extern "C" {
    pub fn Y2RU_SetDitheringWeightParams(params:
                                             *const Y2RU_DitheringWeightParams)
     -> Result;
}
extern "C" {
    pub fn Y2RU_GetDitheringWeightParams(params:
                                             *mut Y2RU_DitheringWeightParams)
     -> Result;
}
extern "C" {
    pub fn Y2RU_SetConversionParams(params: *const Y2RU_ConversionParams)
     -> Result;
}
extern "C" {
    pub fn Y2RU_StartConversion() -> Result;
}
extern "C" {
    pub fn Y2RU_StopConversion() -> Result;
}
extern "C" {
    pub fn Y2RU_IsBusyConversion(is_busy: *mut bool) -> Result;
}
extern "C" {
    pub fn Y2RU_PingProcess(ping: *mut u8) -> Result;
}
extern "C" {
    pub fn Y2RU_DriverInitialize() -> Result;
}
extern "C" {
    pub fn Y2RU_DriverFinalize() -> Result;
}
pub const PORT_NONE: _bindgen_ty_11 = _bindgen_ty_11::PORT_NONE;
pub const PORT_CAM1: _bindgen_ty_11 = _bindgen_ty_11::PORT_CAM1;
pub const PORT_CAM2: _bindgen_ty_11 = _bindgen_ty_11::PORT_CAM2;
pub const PORT_BOTH: _bindgen_ty_11 = _bindgen_ty_11::PORT_BOTH;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_11 {
    PORT_NONE = 0,
    PORT_CAM1 = 1,
    PORT_CAM2 = 2,
    PORT_BOTH = 3,
}
pub const SELECT_NONE: _bindgen_ty_12 = _bindgen_ty_12::SELECT_NONE;
pub const SELECT_OUT1: _bindgen_ty_12 = _bindgen_ty_12::SELECT_OUT1;
pub const SELECT_IN1: _bindgen_ty_12 = _bindgen_ty_12::SELECT_IN1;
pub const SELECT_OUT2: _bindgen_ty_12 = _bindgen_ty_12::SELECT_OUT2;
pub const SELECT_IN1_OUT1: _bindgen_ty_12 = _bindgen_ty_12::SELECT_IN1_OUT1;
pub const SELECT_OUT1_OUT2: _bindgen_ty_12 = _bindgen_ty_12::SELECT_OUT1_OUT2;
pub const SELECT_IN1_OUT2: _bindgen_ty_12 = _bindgen_ty_12::SELECT_IN1_OUT2;
pub const SELECT_ALL: _bindgen_ty_12 = _bindgen_ty_12::SELECT_ALL;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_12 {
    SELECT_NONE = 0,
    SELECT_OUT1 = 1,
    SELECT_IN1 = 2,
    SELECT_OUT2 = 4,
    SELECT_IN1_OUT1 = 3,
    SELECT_OUT1_OUT2 = 5,
    SELECT_IN1_OUT2 = 6,
    SELECT_ALL = 7,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CAMU_Context {
    CONTEXT_NONE = 0,
    CONTEXT_A = 1,
    CONTEXT_B = 2,
    CONTEXT_BOTH = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CAMU_Flip {
    FLIP_NONE = 0,
    FLIP_HORIZONTAL = 1,
    FLIP_VERTICAL = 2,
    FLIP_REVERSE = 3,
}
pub const SIZE_CTR_BOTTOM_LCD: CAMU_Size = CAMU_Size::SIZE_QVGA;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CAMU_Size {
    SIZE_VGA = 0,
    SIZE_QVGA = 1,
    SIZE_QQVGA = 2,
    SIZE_CIF = 3,
    SIZE_QCIF = 4,
    SIZE_DS_LCD = 5,
    SIZE_DS_LCDx4 = 6,
    SIZE_CTR_TOP_LCD = 7,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CAMU_FrameRate {
    FRAME_RATE_15 = 0,
    FRAME_RATE_15_TO_5 = 1,
    FRAME_RATE_15_TO_2 = 2,
    FRAME_RATE_10 = 3,
    FRAME_RATE_8_5 = 4,
    FRAME_RATE_5 = 5,
    FRAME_RATE_20 = 6,
    FRAME_RATE_20_TO_5 = 7,
    FRAME_RATE_30 = 8,
    FRAME_RATE_30_TO_5 = 9,
    FRAME_RATE_15_TO_10 = 10,
    FRAME_RATE_20_TO_10 = 11,
    FRAME_RATE_30_TO_10 = 12,
}
pub const WHITE_BALANCE_NORMAL: CAMU_WhiteBalance =
    CAMU_WhiteBalance::WHITE_BALANCE_AUTO;
pub const WHITE_BALANCE_TUNGSTEN: CAMU_WhiteBalance =
    CAMU_WhiteBalance::WHITE_BALANCE_3200K;
pub const WHITE_BALANCE_WHITE_FLUORESCENT_LIGHT: CAMU_WhiteBalance =
    CAMU_WhiteBalance::WHITE_BALANCE_4150K;
pub const WHITE_BALANCE_DAYLIGHT: CAMU_WhiteBalance =
    CAMU_WhiteBalance::WHITE_BALANCE_5200K;
pub const WHITE_BALANCE_CLOUDY: CAMU_WhiteBalance =
    CAMU_WhiteBalance::WHITE_BALANCE_6000K;
pub const WHITE_BALANCE_HORIZON: CAMU_WhiteBalance =
    CAMU_WhiteBalance::WHITE_BALANCE_6000K;
pub const WHITE_BALANCE_SHADE: CAMU_WhiteBalance =
    CAMU_WhiteBalance::WHITE_BALANCE_7000K;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CAMU_WhiteBalance {
    WHITE_BALANCE_AUTO = 0,
    WHITE_BALANCE_3200K = 1,
    WHITE_BALANCE_4150K = 2,
    WHITE_BALANCE_5200K = 3,
    WHITE_BALANCE_6000K = 4,
    WHITE_BALANCE_7000K = 5,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CAMU_PhotoMode {
    PHOTO_MODE_NORMAL = 0,
    PHOTO_MODE_PORTRAIT = 1,
    PHOTO_MODE_LANDSCAPE = 2,
    PHOTO_MODE_NIGHTVIEW = 3,
    PHOTO_MODE_LETTER = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CAMU_Effect {
    EFFECT_NONE = 0,
    EFFECT_MONO = 1,
    EFFECT_SEPIA = 2,
    EFFECT_NEGATIVE = 3,
    EFFECT_NEGAFILM = 4,
    EFFECT_SEPIA01 = 5,
}
pub const CONTRAST_LOW: CAMU_Contrast = CAMU_Contrast::CONTRAST_PATTERN_05;
pub const CONTRAST_NORMAL: CAMU_Contrast = CAMU_Contrast::CONTRAST_PATTERN_06;
pub const CONTRAST_HIGH: CAMU_Contrast = CAMU_Contrast::CONTRAST_PATTERN_07;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CAMU_Contrast {
    CONTRAST_PATTERN_01 = 0,
    CONTRAST_PATTERN_02 = 1,
    CONTRAST_PATTERN_03 = 2,
    CONTRAST_PATTERN_04 = 3,
    CONTRAST_PATTERN_05 = 4,
    CONTRAST_PATTERN_06 = 5,
    CONTRAST_PATTERN_07 = 6,
    CONTRAST_PATTERN_08 = 7,
    CONTRAST_PATTERN_09 = 8,
    CONTRAST_PATTERN_10 = 9,
    CONTRAST_PATTERN_11 = 10,
}
pub const LENS_CORRECTION_DARK: CAMU_LensCorrection =
    CAMU_LensCorrection::LENS_CORRECTION_OFF;
pub const LENS_CORRECTION_NORMAL: CAMU_LensCorrection =
    CAMU_LensCorrection::LENS_CORRECTION_ON_70;
pub const LENS_CORRECTION_BRIGHT: CAMU_LensCorrection =
    CAMU_LensCorrection::LENS_CORRECTION_ON_90;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CAMU_LensCorrection {
    LENS_CORRECTION_OFF = 0,
    LENS_CORRECTION_ON_70 = 1,
    LENS_CORRECTION_ON_90 = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CAMU_OutputFormat { OUTPUT_YUV_422 = 0, OUTPUT_RGB_565 = 1, }
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CAMU_ShutterSoundType {
    SHUTTER_SOUND_TYPE_NORMAL = 0,
    SHUTTER_SOUND_TYPE_MOVIE = 1,
    SHUTTER_SOUND_TYPE_MOVIE_END = 2,
}
#[repr(C)]
#[derive(Copy)]
pub struct CAMU_ImageQualityCalibrationData {
    pub aeBaseTarget: s16,
    pub kRL: s16,
    pub kGL: s16,
    pub kBL: s16,
    pub ccmPosition: s16,
    pub awbCcmL9Right: u16,
    pub awbCcmL9Left: u16,
    pub awbCcmL10Right: u16,
    pub awbCcmL10Left: u16,
    pub awbX0Right: u16,
    pub awbX0Left: u16,
}
impl Clone for CAMU_ImageQualityCalibrationData {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct CAMU_StereoCameraCalibrationData {
    pub isValidRotationXY: u8,
    pub padding: [u8; 3usize],
    pub scale: f32,
    pub rotationZ: f32,
    pub translationX: f32,
    pub translationY: f32,
    pub rotationX: f32,
    pub rotationY: f32,
    pub angleOfViewRight: f32,
    pub angleOfViewLeft: f32,
    pub distanceToChart: f32,
    pub distanceCameras: f32,
    pub imageWidth: s16,
    pub imageHeight: s16,
    pub reserved: [u8; 16usize],
}
impl Clone for CAMU_StereoCameraCalibrationData {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct CAMU_PackageParameterCameraSelect {
    pub camera: u8,
    pub exposure: s8,
    pub whiteBalance: u8,
    pub sharpness: s8,
    pub autoExposureOn: u8,
    pub autoWhiteBalanceOn: u8,
    pub frameRate: u8,
    pub photoMode: u8,
    pub contrast: u8,
    pub lensCorrection: u8,
    pub noiseFilterOn: u8,
    pub padding: u8,
    pub autoExposureWindowX: s16,
    pub autoExposureWindowY: s16,
    pub autoExposureWindowWidth: s16,
    pub autoExposureWindowHeight: s16,
    pub autoWhiteBalanceWindowX: s16,
    pub autoWhiteBalanceWindowY: s16,
    pub autoWhiteBalanceWindowWidth: s16,
    pub autoWhiteBalanceWindowHeight: s16,
}
impl Clone for CAMU_PackageParameterCameraSelect {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct CAMU_PackageParameterContext {
    pub camera: u8,
    pub context: u8,
    pub flip: u8,
    pub effect: u8,
    pub size: u8,
}
impl Clone for CAMU_PackageParameterContext {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct CAMU_PackageParameterContextDetail {
    pub camera: u8,
    pub context: u8,
    pub flip: u8,
    pub effect: u8,
    pub width: s16,
    pub height: s16,
    pub cropX0: s16,
    pub cropY0: s16,
    pub cropX1: s16,
    pub cropY1: s16,
}
impl Clone for CAMU_PackageParameterContextDetail {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn camInit() -> Result;
}
extern "C" {
    pub fn camExit();
}
extern "C" {
    pub fn CAMU_StartCapture(port: u32) -> Result;
}
extern "C" {
    pub fn CAMU_StopCapture(port: u32) -> Result;
}
extern "C" {
    pub fn CAMU_IsBusy(busy: *mut bool, port: u32) -> Result;
}
extern "C" {
    pub fn CAMU_ClearBuffer(port: u32) -> Result;
}
extern "C" {
    pub fn CAMU_GetVsyncInterruptEvent(event: *mut Handle, port: u32)
     -> Result;
}
extern "C" {
    pub fn CAMU_GetBufferErrorInterruptEvent(event: *mut Handle, port: u32)
     -> Result;
}
extern "C" {
    pub fn CAMU_SetReceiving(event: *mut Handle, dst: *mut libc::c_void,
                             port: u32, imageSize: u32, transferUnit: s16)
     -> Result;
}
extern "C" {
    pub fn CAMU_IsFinishedReceiving(finishedReceiving: *mut bool, port: u32)
     -> Result;
}
extern "C" {
    pub fn CAMU_SetTransferLines(port: u32, lines: s16, width: s16,
                                 height: s16) -> Result;
}
extern "C" {
    pub fn CAMU_GetMaxLines(maxLines: *mut s16, width: s16, height: s16)
     -> Result;
}
extern "C" {
    pub fn CAMU_SetTransferBytes(port: u32, bytes: u32, width: s16,
                                 height: s16) -> Result;
}
extern "C" {
    pub fn CAMU_GetTransferBytes(transferBytes: *mut u32, port: u32)
     -> Result;
}
extern "C" {
    pub fn CAMU_GetMaxBytes(maxBytes: *mut u32, width: s16, height: s16)
     -> Result;
}
extern "C" {
    pub fn CAMU_SetTrimming(port: u32, trimming: bool) -> Result;
}
extern "C" {
    pub fn CAMU_IsTrimming(trimming: *mut bool, port: u32) -> Result;
}
extern "C" {
    pub fn CAMU_SetTrimmingParams(port: u32, xStart: s16, yStart: s16,
                                  xEnd: s16, yEnd: s16) -> Result;
}
extern "C" {
    pub fn CAMU_GetTrimmingParams(xStart: *mut s16, yStart: *mut s16,
                                  xEnd: *mut s16, yEnd: *mut s16, port: u32)
     -> Result;
}
extern "C" {
    pub fn CAMU_SetTrimmingParamsCenter(port: u32, trimWidth: s16,
                                        trimHeight: s16, camWidth: s16,
                                        camHeight: s16) -> Result;
}
extern "C" {
    pub fn CAMU_Activate(select: u32) -> Result;
}
extern "C" {
    pub fn CAMU_SwitchContext(select: u32, context: CAMU_Context) -> Result;
}
extern "C" {
    pub fn CAMU_SetExposure(select: u32, exposure: s8) -> Result;
}
extern "C" {
    pub fn CAMU_SetWhiteBalance(select: u32, whiteBalance: CAMU_WhiteBalance)
     -> Result;
}
extern "C" {
    pub fn CAMU_SetWhiteBalanceWithoutBaseUp(select: u32,
                                             whiteBalance: CAMU_WhiteBalance)
     -> Result;
}
extern "C" {
    pub fn CAMU_SetSharpness(select: u32, sharpness: s8) -> Result;
}
extern "C" {
    pub fn CAMU_SetAutoExposure(select: u32, autoExposure: bool) -> Result;
}
extern "C" {
    pub fn CAMU_IsAutoExposure(autoExposure: *mut bool, select: u32)
     -> Result;
}
extern "C" {
    pub fn CAMU_SetAutoWhiteBalance(select: u32, autoWhiteBalance: bool)
     -> Result;
}
extern "C" {
    pub fn CAMU_IsAutoWhiteBalance(autoWhiteBalance: *mut bool, select: u32)
     -> Result;
}
extern "C" {
    pub fn CAMU_FlipImage(select: u32, flip: CAMU_Flip, context: CAMU_Context)
     -> Result;
}
extern "C" {
    pub fn CAMU_SetDetailSize(select: u32, width: s16, height: s16,
                              cropX0: s16, cropY0: s16, cropX1: s16,
                              cropY1: s16, context: CAMU_Context) -> Result;
}
extern "C" {
    pub fn CAMU_SetSize(select: u32, size: CAMU_Size, context: CAMU_Context)
     -> Result;
}
extern "C" {
    pub fn CAMU_SetFrameRate(select: u32, frameRate: CAMU_FrameRate)
     -> Result;
}
extern "C" {
    pub fn CAMU_SetPhotoMode(select: u32, photoMode: CAMU_PhotoMode)
     -> Result;
}
extern "C" {
    pub fn CAMU_SetEffect(select: u32, effect: CAMU_Effect,
                          context: CAMU_Context) -> Result;
}
extern "C" {
    pub fn CAMU_SetContrast(select: u32, contrast: CAMU_Contrast) -> Result;
}
extern "C" {
    pub fn CAMU_SetLensCorrection(select: u32,
                                  lensCorrection: CAMU_LensCorrection)
     -> Result;
}
extern "C" {
    pub fn CAMU_SetOutputFormat(select: u32, format: CAMU_OutputFormat,
                                context: CAMU_Context) -> Result;
}
extern "C" {
    pub fn CAMU_SetAutoExposureWindow(select: u32, x: s16, y: s16, width: s16,
                                      height: s16) -> Result;
}
extern "C" {
    pub fn CAMU_SetAutoWhiteBalanceWindow(select: u32, x: s16, y: s16,
                                          width: s16, height: s16) -> Result;
}
extern "C" {
    pub fn CAMU_SetNoiseFilter(select: u32, noiseFilter: bool) -> Result;
}
extern "C" {
    pub fn CAMU_SynchronizeVsyncTiming(select1: u32, select2: u32) -> Result;
}
extern "C" {
    pub fn CAMU_GetLatestVsyncTiming(timing: *mut s64, port: u32, past: u32)
     -> Result;
}
extern "C" {
    pub fn CAMU_GetStereoCameraCalibrationData(data:
                                                   *mut CAMU_StereoCameraCalibrationData)
     -> Result;
}
extern "C" {
    pub fn CAMU_SetStereoCameraCalibrationData(data:
                                                   CAMU_StereoCameraCalibrationData)
     -> Result;
}
extern "C" {
    pub fn CAMU_WriteRegisterI2c(select: u32, addr: u16, data: u16) -> Result;
}
extern "C" {
    pub fn CAMU_WriteMcuVariableI2c(select: u32, addr: u16, data: u16)
     -> Result;
}
extern "C" {
    pub fn CAMU_ReadRegisterI2cExclusive(data: *mut u16, select: u32,
                                         addr: u16) -> Result;
}
extern "C" {
    pub fn CAMU_ReadMcuVariableI2cExclusive(data: *mut u16, select: u32,
                                            addr: u16) -> Result;
}
extern "C" {
    pub fn CAMU_SetImageQualityCalibrationData(data:
                                                   CAMU_ImageQualityCalibrationData)
     -> Result;
}
extern "C" {
    pub fn CAMU_GetImageQualityCalibrationData(data:
                                                   *mut CAMU_ImageQualityCalibrationData)
     -> Result;
}
extern "C" {
    pub fn CAMU_SetPackageParameterWithoutContext(param:
                                                      CAMU_PackageParameterCameraSelect)
     -> Result;
}
extern "C" {
    pub fn CAMU_SetPackageParameterWithContext(param:
                                                   CAMU_PackageParameterContext)
     -> Result;
}
extern "C" {
    pub fn CAMU_SetPackageParameterWithContextDetail(param:
                                                         CAMU_PackageParameterContextDetail)
     -> Result;
}
extern "C" {
    pub fn CAMU_GetSuitableY2rStandardCoefficient(coefficient:
                                                      *mut Y2RU_StandardCoefficient)
     -> Result;
}
extern "C" {
    pub fn CAMU_PlayShutterSound(sound: CAMU_ShutterSoundType) -> Result;
}
extern "C" {
    pub fn CAMU_DriverInitialize() -> Result;
}
extern "C" {
    pub fn CAMU_DriverFinalize() -> Result;
}
extern "C" {
    pub fn CAMU_GetActivatedCamera(select: *mut u32) -> Result;
}
extern "C" {
    pub fn CAMU_GetSleepCamera(select: *mut u32) -> Result;
}
extern "C" {
    pub fn CAMU_SetSleepCamera(select: u32) -> Result;
}
extern "C" {
    pub fn CAMU_SetBrightnessSynchronization(brightnessSynchronization: bool)
     -> Result;
}
extern "C" {
    pub fn cfgnorInit(value: u8) -> Result;
}
extern "C" {
    pub fn cfgnorExit();
}
extern "C" {
    pub fn cfgnorDumpFlash(buf: *mut u32, size: u32) -> Result;
}
extern "C" {
    pub fn cfgnorWriteFlash(buf: *mut u32, size: u32) -> Result;
}
extern "C" {
    pub fn CFGNOR_Initialize(value: u8) -> Result;
}
extern "C" {
    pub fn CFGNOR_Shutdown() -> Result;
}
extern "C" {
    pub fn CFGNOR_ReadData(offset: u32, buf: *mut u32, size: u32) -> Result;
}
extern "C" {
    pub fn CFGNOR_WriteData(offset: u32, buf: *mut u32, size: u32) -> Result;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CFG_Region {
    CFG_REGION_JPN = 0,
    CFG_REGION_USA = 1,
    CFG_REGION_EUR = 2,
    CFG_REGION_AUS = 3,
    CFG_REGION_CHN = 4,
    CFG_REGION_KOR = 5,
    CFG_REGION_TWN = 6,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CFG_Language {
    CFG_LANGUAGE_JP = 0,
    CFG_LANGUAGE_EN = 1,
    CFG_LANGUAGE_FR = 2,
    CFG_LANGUAGE_DE = 3,
    CFG_LANGUAGE_IT = 4,
    CFG_LANGUAGE_ES = 5,
    CFG_LANGUAGE_ZH = 6,
    CFG_LANGUAGE_KO = 7,
    CFG_LANGUAGE_NL = 8,
    CFG_LANGUAGE_PT = 9,
    CFG_LANGUAGE_RU = 10,
    CFG_LANGUAGE_TW = 11,
}
extern "C" {
    pub fn cfguInit() -> Result;
}
extern "C" {
    pub fn cfguExit();
}
extern "C" {
    pub fn CFGU_SecureInfoGetRegion(region: *mut u8) -> Result;
}
extern "C" {
    pub fn CFGU_GenHashConsoleUnique(appIDSalt: u32, hash: *mut u64)
     -> Result;
}
extern "C" {
    pub fn CFGU_GetRegionCanadaUSA(value: *mut u8) -> Result;
}
extern "C" {
    pub fn CFGU_GetSystemModel(model: *mut u8) -> Result;
}
extern "C" {
    pub fn CFGU_GetModelNintendo2DS(value: *mut u8) -> Result;
}
extern "C" {
    pub fn CFGU_GetCountryCodeString(code: u16, string: *mut u16) -> Result;
}
extern "C" {
    pub fn CFGU_GetCountryCodeID(string: u16, code: *mut u16) -> Result;
}
extern "C" {
    pub fn CFGU_GetConfigInfoBlk2(size: u32, blkID: u32, outData: *mut u8)
     -> Result;
}
extern "C" {
    pub fn CFG_GetConfigInfoBlk4(size: u32, blkID: u32, outData: *mut u8)
     -> Result;
}
extern "C" {
    pub fn CFG_GetConfigInfoBlk8(size: u32, blkID: u32, outData: *mut u8)
     -> Result;
}
extern "C" {
    pub fn CFG_SetConfigInfoBlk4(size: u32, blkID: u32, inData: *mut u8)
     -> Result;
}
extern "C" {
    pub fn CFG_SetConfigInfoBlk8(size: u32, blkID: u32, inData: *mut u8)
     -> Result;
}
extern "C" {
    pub fn CFG_UpdateConfigNANDSavegame() -> Result;
}
extern "C" {
    pub fn CFGU_GetSystemLanguage(language: *mut u8) -> Result;
}
pub const CSND_ENCODING_PCM8: _bindgen_ty_13 =
    _bindgen_ty_13::CSND_ENCODING_PCM8;
pub const CSND_ENCODING_PCM16: _bindgen_ty_13 =
    _bindgen_ty_13::CSND_ENCODING_PCM16;
pub const CSND_ENCODING_ADPCM: _bindgen_ty_13 =
    _bindgen_ty_13::CSND_ENCODING_ADPCM;
pub const CSND_ENCODING_PSG: _bindgen_ty_13 =
    _bindgen_ty_13::CSND_ENCODING_PSG;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_13 {
    CSND_ENCODING_PCM8 = 0,
    CSND_ENCODING_PCM16 = 1,
    CSND_ENCODING_ADPCM = 2,
    CSND_ENCODING_PSG = 3,
}
pub const CSND_LOOPMODE_MANUAL: _bindgen_ty_14 =
    _bindgen_ty_14::CSND_LOOPMODE_MANUAL;
pub const CSND_LOOPMODE_NORMAL: _bindgen_ty_14 =
    _bindgen_ty_14::CSND_LOOPMODE_NORMAL;
pub const CSND_LOOPMODE_ONESHOT: _bindgen_ty_14 =
    _bindgen_ty_14::CSND_LOOPMODE_ONESHOT;
pub const CSND_LOOPMODE_NORELOAD: _bindgen_ty_14 =
    _bindgen_ty_14::CSND_LOOPMODE_NORELOAD;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_14 {
    CSND_LOOPMODE_MANUAL = 0,
    CSND_LOOPMODE_NORMAL = 1,
    CSND_LOOPMODE_ONESHOT = 2,
    CSND_LOOPMODE_NORELOAD = 3,
}
pub const SOUND_LINEAR_INTERP: _bindgen_ty_15 =
    _bindgen_ty_15::SOUND_LINEAR_INTERP;
pub const SOUND_REPEAT: _bindgen_ty_15 = _bindgen_ty_15::SOUND_REPEAT;
pub const SOUND_ONE_SHOT: _bindgen_ty_15 = _bindgen_ty_15::SOUND_ONE_SHOT;
pub const SOUND_FORMAT_8BIT: _bindgen_ty_15 =
    _bindgen_ty_15::SOUND_FORMAT_8BIT;
pub const SOUND_FORMAT_16BIT: _bindgen_ty_15 =
    _bindgen_ty_15::SOUND_FORMAT_16BIT;
pub const SOUND_FORMAT_ADPCM: _bindgen_ty_15 =
    _bindgen_ty_15::SOUND_FORMAT_ADPCM;
pub const SOUND_FORMAT_PSG: _bindgen_ty_15 = _bindgen_ty_15::SOUND_FORMAT_PSG;
pub const SOUND_ENABLE: _bindgen_ty_15 = _bindgen_ty_15::SOUND_ENABLE;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_15 {
    SOUND_LINEAR_INTERP = 64,
    SOUND_REPEAT = 1024,
    SOUND_ONE_SHOT = 2048,
    SOUND_FORMAT_8BIT = 0,
    SOUND_FORMAT_16BIT = 4096,
    SOUND_FORMAT_ADPCM = 8192,
    SOUND_FORMAT_PSG = 12288,
    SOUND_ENABLE = 16384,
}
pub const CAPTURE_REPEAT: _bindgen_ty_16 = _bindgen_ty_16::CAPTURE_REPEAT;
pub const CAPTURE_ONE_SHOT: _bindgen_ty_16 = _bindgen_ty_16::CAPTURE_ONE_SHOT;
pub const CAPTURE_FORMAT_16BIT: _bindgen_ty_16 =
    _bindgen_ty_16::CAPTURE_REPEAT;
pub const CAPTURE_FORMAT_8BIT: _bindgen_ty_16 =
    _bindgen_ty_16::CAPTURE_FORMAT_8BIT;
pub const CAPTURE_ENABLE: _bindgen_ty_16 = _bindgen_ty_16::CAPTURE_ENABLE;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_16 {
    CAPTURE_REPEAT = 0,
    CAPTURE_ONE_SHOT = 1,
    CAPTURE_FORMAT_8BIT = 2,
    CAPTURE_ENABLE = 32768,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CSND_DutyCycle {
    DutyCycle_0 = 7,
    DutyCycle_12 = 0,
    DutyCycle_25 = 1,
    DutyCycle_37 = 2,
    DutyCycle_50 = 3,
    DutyCycle_62 = 4,
    DutyCycle_75 = 5,
    DutyCycle_87 = 6,
}
#[repr(C)]
#[derive(Copy)]
pub union CSND_ChnInfo {
    pub value: [u32; 3usize],
    pub __bindgen_anon_1: CSND_ChnInfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub struct CSND_ChnInfo__bindgen_ty_1 {
    pub active: u8,
    pub _pad1: u8,
    pub _pad2: u16,
    pub adpcmSample: s16,
    pub adpcmIndex: u8,
    pub _pad3: u8,
    pub unknownZero: u32,
}
impl Clone for CSND_ChnInfo__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Clone for CSND_ChnInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union CSND_CapInfo {
    pub value: [u32; 2usize],
    pub __bindgen_anon_1: CSND_CapInfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub struct CSND_CapInfo__bindgen_ty_1 {
    pub active: u8,
    pub _pad1: u8,
    pub _pad2: u16,
    pub unknownZero: u32,
}
impl Clone for CSND_CapInfo__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Clone for CSND_CapInfo {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub static mut csndSharedMem: *mut vu32;
}
extern "C" {
    pub static mut csndSharedMemSize: u32;
}
extern "C" {
    pub static mut csndChannels: u32;
}
extern "C" {
    pub fn CSND_AcquireCapUnit(capUnit: *mut u32) -> Result;
}
extern "C" {
    pub fn CSND_ReleaseCapUnit(capUnit: u32) -> Result;
}
extern "C" {
    pub fn CSND_FlushDataCache(adr: *const libc::c_void, size: u32) -> Result;
}
extern "C" {
    pub fn CSND_StoreDataCache(adr: *const libc::c_void, size: u32) -> Result;
}
extern "C" {
    pub fn CSND_InvalidateDataCache(adr: *const libc::c_void, size: u32)
     -> Result;
}
extern "C" {
    pub fn CSND_Reset() -> Result;
}
extern "C" {
    pub fn csndInit() -> Result;
}
extern "C" {
    pub fn csndExit();
}
extern "C" {
    pub fn csndAddCmd(cmdid: libc::c_int) -> *mut u32;
}
extern "C" {
    pub fn csndWriteCmd(cmdid: libc::c_int, cmdparams: *mut u8);
}
extern "C" {
    pub fn csndExecCmds(waitDone: bool) -> Result;
}
extern "C" {
    pub fn CSND_SetPlayStateR(channel: u32, value: u32);
}
extern "C" {
    pub fn CSND_SetPlayState(channel: u32, value: u32);
}
extern "C" {
    pub fn CSND_SetEncoding(channel: u32, value: u32);
}
extern "C" {
    pub fn CSND_SetBlock(channel: u32, block: libc::c_int, physaddr: u32,
                         size: u32);
}
extern "C" {
    pub fn CSND_SetLooping(channel: u32, value: u32);
}
extern "C" {
    pub fn CSND_SetBit7(channel: u32, set: bool);
}
extern "C" {
    pub fn CSND_SetInterp(channel: u32, interp: bool);
}
extern "C" {
    pub fn CSND_SetDuty(channel: u32, duty: CSND_DutyCycle);
}
extern "C" {
    pub fn CSND_SetTimer(channel: u32, timer: u32);
}
extern "C" {
    pub fn CSND_SetVol(channel: u32, chnVolumes: u32, capVolumes: u32);
}
extern "C" {
    pub fn CSND_SetAdpcmState(channel: u32, block: libc::c_int,
                              sample: libc::c_int, index: libc::c_int);
}
extern "C" {
    pub fn CSND_SetAdpcmReload(channel: u32, reload: bool);
}
extern "C" {
    pub fn CSND_SetChnRegs(flags: u32, physaddr0: u32, physaddr1: u32,
                           totalbytesize: u32, chnVolumes: u32,
                           capVolumes: u32);
}
extern "C" {
    pub fn CSND_SetChnRegsPSG(flags: u32, chnVolumes: u32, capVolumes: u32,
                              duty: CSND_DutyCycle);
}
extern "C" {
    pub fn CSND_SetChnRegsNoise(flags: u32, chnVolumes: u32, capVolumes: u32);
}
extern "C" {
    pub fn CSND_CapEnable(capUnit: u32, enable: bool);
}
extern "C" {
    pub fn CSND_CapSetRepeat(capUnit: u32, repeat: bool);
}
extern "C" {
    pub fn CSND_CapSetFormat(capUnit: u32, eightbit: bool);
}
extern "C" {
    pub fn CSND_CapSetBit2(capUnit: u32, set: bool);
}
extern "C" {
    pub fn CSND_CapSetTimer(capUnit: u32, timer: u32);
}
extern "C" {
    pub fn CSND_CapSetBuffer(capUnit: u32, addr: u32, size: u32);
}
extern "C" {
    pub fn CSND_SetCapRegs(capUnit: u32, flags: u32, addr: u32, size: u32);
}
extern "C" {
    pub fn CSND_SetDspFlags(waitDone: bool) -> Result;
}
extern "C" {
    pub fn CSND_UpdateInfo(waitDone: bool) -> Result;
}
extern "C" {
    pub fn csndPlaySound(chn: libc::c_int, flags: u32, sampleRate: u32,
                         vol: f32, pan: f32, data0: *mut libc::c_void,
                         data1: *mut libc::c_void, size: u32) -> Result;
}
extern "C" {
    pub fn csndGetDspFlags(outSemFlags: *mut u32, outIrqFlags: *mut u32);
}
extern "C" {
    pub fn csndGetChnInfo(channel: u32) -> *mut CSND_ChnInfo;
}
extern "C" {
    pub fn csndGetCapInfo(capUnit: u32) -> *mut CSND_CapInfo;
}
extern "C" {
    pub fn csndGetState(channel: u32, out: *mut CSND_ChnInfo) -> Result;
}
extern "C" {
    pub fn csndIsPlaying(channel: u32, status: *mut u8) -> Result;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum DSP_InterruptType { DSP_INTERRUPT_PIPE = 2, }
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum DSP_PipeDirection { DSP_PIPE_INPUT = 0, DSP_PIPE_OUTPUT = 1, }
extern "C" {
    pub fn dspInit() -> Result;
}
extern "C" {
    pub fn dspExit();
}
extern "C" {
    pub fn DSP_GetHeadphoneStatus(is_inserted: *mut bool) -> Result;
}
extern "C" {
    pub fn DSP_FlushDataCache(address: *const libc::c_void, size: u32)
     -> Result;
}
extern "C" {
    pub fn DSP_InvalidateDataCache(address: *const libc::c_void, size: u32)
     -> Result;
}
extern "C" {
    pub fn DSP_GetSemaphoreHandle(semaphore: *mut Handle) -> Result;
}
extern "C" {
    pub fn DSP_SetSemaphore(value: u16) -> Result;
}
extern "C" {
    pub fn DSP_SetSemaphoreMask(mask: u16) -> Result;
}
extern "C" {
    pub fn DSP_LoadComponent(component: *const libc::c_void, size: u32,
                             prog_mask: u16, data_mask: u16,
                             is_loaded: *mut bool) -> Result;
}
extern "C" {
    pub fn DSP_UnloadComponent() -> Result;
}
extern "C" {
    pub fn DSP_RegisterInterruptEvents(handle: Handle, interrupt: u32,
                                       channel: u32) -> Result;
}
extern "C" {
    pub fn DSP_ReadPipeIfPossible(channel: u32, peer: u32,
                                  buffer: *mut libc::c_void, length: u16,
                                  length_read: *mut u16) -> Result;
}
extern "C" {
    pub fn DSP_WriteProcessPipe(channel: u32, buffer: *const libc::c_void,
                                length: u32) -> Result;
}
extern "C" {
    pub fn DSP_ConvertProcessAddressFromDspDram(dsp_address: u32,
                                                arm_address: *mut u32)
     -> Result;
}
extern "C" {
    pub fn DSP_RecvData(regNo: u16, value: *mut u16) -> Result;
}
extern "C" {
    pub fn DSP_RecvDataIsReady(regNo: u16, is_ready: *mut bool) -> Result;
}
extern "C" {
    pub fn DSP_SendData(regNo: u16, value: u16) -> Result;
}
extern "C" {
    pub fn DSP_SendDataIsEmpty(regNo: u16, is_empty: *mut bool) -> Result;
}
pub const GSPLCD_SCREEN_TOP: _bindgen_ty_17 =
    _bindgen_ty_17::GSPLCD_SCREEN_TOP;
pub const GSPLCD_SCREEN_BOTTOM: _bindgen_ty_17 =
    _bindgen_ty_17::GSPLCD_SCREEN_BOTTOM;
pub const GSPLCD_SCREEN_BOTH: _bindgen_ty_17 =
    _bindgen_ty_17::GSPLCD_SCREEN_BOTH;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_17 {
    GSPLCD_SCREEN_TOP = 1,
    GSPLCD_SCREEN_BOTTOM = 2,
    GSPLCD_SCREEN_BOTH = 3,
}
extern "C" {
    pub fn gspLcdInit() -> Result;
}
extern "C" {
    pub fn gspLcdExit();
}
extern "C" {
    pub fn GSPLCD_PowerOnBacklight(screen: u32) -> Result;
}
extern "C" {
    pub fn GSPLCD_PowerOffBacklight(screen: u32) -> Result;
}
extern "C" {
    pub fn GSPLCD_GetVendors(vendors: *mut u8) -> Result;
}
extern "C" {
    pub fn GSPLCD_GetBrightness(screen: u32, brightness: *mut u32) -> Result;
}
pub const KEY_A: _bindgen_ty_18 = _bindgen_ty_18::KEY_A;
pub const KEY_B: _bindgen_ty_18 = _bindgen_ty_18::KEY_B;
pub const KEY_SELECT: _bindgen_ty_18 = _bindgen_ty_18::KEY_SELECT;
pub const KEY_START: _bindgen_ty_18 = _bindgen_ty_18::KEY_START;
pub const KEY_DRIGHT: _bindgen_ty_18 = _bindgen_ty_18::KEY_DRIGHT;
pub const KEY_DLEFT: _bindgen_ty_18 = _bindgen_ty_18::KEY_DLEFT;
pub const KEY_DUP: _bindgen_ty_18 = _bindgen_ty_18::KEY_DUP;
pub const KEY_DDOWN: _bindgen_ty_18 = _bindgen_ty_18::KEY_DDOWN;
pub const KEY_R: _bindgen_ty_18 = _bindgen_ty_18::KEY_R;
pub const KEY_L: _bindgen_ty_18 = _bindgen_ty_18::KEY_L;
pub const KEY_X: _bindgen_ty_18 = _bindgen_ty_18::KEY_X;
pub const KEY_Y: _bindgen_ty_18 = _bindgen_ty_18::KEY_Y;
pub const KEY_ZL: _bindgen_ty_18 = _bindgen_ty_18::KEY_ZL;
pub const KEY_ZR: _bindgen_ty_18 = _bindgen_ty_18::KEY_ZR;
pub const KEY_TOUCH: _bindgen_ty_18 = _bindgen_ty_18::KEY_TOUCH;
pub const KEY_CSTICK_RIGHT: _bindgen_ty_18 = _bindgen_ty_18::KEY_CSTICK_RIGHT;
pub const KEY_CSTICK_LEFT: _bindgen_ty_18 = _bindgen_ty_18::KEY_CSTICK_LEFT;
pub const KEY_CSTICK_UP: _bindgen_ty_18 = _bindgen_ty_18::KEY_CSTICK_UP;
pub const KEY_CSTICK_DOWN: _bindgen_ty_18 = _bindgen_ty_18::KEY_CSTICK_DOWN;
pub const KEY_CPAD_RIGHT: _bindgen_ty_18 = _bindgen_ty_18::KEY_CPAD_RIGHT;
pub const KEY_CPAD_LEFT: _bindgen_ty_18 = _bindgen_ty_18::KEY_CPAD_LEFT;
pub const KEY_CPAD_UP: _bindgen_ty_18 = _bindgen_ty_18::KEY_CPAD_UP;
pub const KEY_CPAD_DOWN: _bindgen_ty_18 = _bindgen_ty_18::KEY_CPAD_DOWN;
pub const KEY_UP: _bindgen_ty_18 = _bindgen_ty_18::KEY_UP;
pub const KEY_DOWN: _bindgen_ty_18 = _bindgen_ty_18::KEY_DOWN;
pub const KEY_LEFT: _bindgen_ty_18 = _bindgen_ty_18::KEY_LEFT;
pub const KEY_RIGHT: _bindgen_ty_18 = _bindgen_ty_18::KEY_RIGHT;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_18 {
    KEY_A = 1,
    KEY_B = 2,
    KEY_SELECT = 4,
    KEY_START = 8,
    KEY_DRIGHT = 16,
    KEY_DLEFT = 32,
    KEY_DUP = 64,
    KEY_DDOWN = 128,
    KEY_R = 256,
    KEY_L = 512,
    KEY_X = 1024,
    KEY_Y = 2048,
    KEY_ZL = 16384,
    KEY_ZR = 32768,
    KEY_TOUCH = 1048576,
    KEY_CSTICK_RIGHT = 16777216,
    KEY_CSTICK_LEFT = 33554432,
    KEY_CSTICK_UP = 67108864,
    KEY_CSTICK_DOWN = 134217728,
    KEY_CPAD_RIGHT = 268435456,
    KEY_CPAD_LEFT = 536870912,
    KEY_CPAD_UP = 1073741824,
    KEY_CPAD_DOWN = 2147483648,
    KEY_UP = 1073741888,
    KEY_DOWN = 2147483776,
    KEY_LEFT = 536870944,
    KEY_RIGHT = 268435472,
}
#[repr(C)]
#[derive(Copy)]
pub struct touchPosition {
    pub px: u16,
    pub py: u16,
}
impl Clone for touchPosition {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct circlePosition {
    pub dx: s16,
    pub dy: s16,
}
impl Clone for circlePosition {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct accelVector {
    pub x: s16,
    pub y: s16,
    pub z: s16,
}
impl Clone for accelVector {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct angularRate {
    pub x: s16,
    pub z: s16,
    pub y: s16,
}
impl Clone for angularRate {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum HID_Event {
    HIDEVENT_PAD0 = 0,
    HIDEVENT_PAD1 = 1,
    HIDEVENT_Accel = 2,
    HIDEVENT_Gyro = 3,
    HIDEVENT_DebugPad = 4,
    HIDEVENT_MAX = 5,
}
extern "C" {
    pub static mut hidMemHandle: Handle;
}
extern "C" {
    pub static mut hidSharedMem: *mut vu32;
}
extern "C" {
    pub fn hidInit() -> Result;
}
extern "C" {
    pub fn hidExit();
}
extern "C" {
    pub fn hidScanInput();
}
extern "C" {
    pub fn hidKeysHeld() -> u32;
}
extern "C" {
    pub fn hidKeysDown() -> u32;
}
extern "C" {
    pub fn hidKeysUp() -> u32;
}
extern "C" {
    pub fn hidTouchRead(pos: *mut touchPosition);
}
extern "C" {
    pub fn hidCircleRead(pos: *mut circlePosition);
}
extern "C" {
    pub fn hidAccelRead(vector: *mut accelVector);
}
extern "C" {
    pub fn hidGyroRead(rate: *mut angularRate);
}
extern "C" {
    pub fn hidWaitForEvent(id: HID_Event, nextEvent: bool);
}
extern "C" {
    pub fn HIDUSER_GetHandles(outMemHandle: *mut Handle,
                              eventpad0: *mut Handle, eventpad1: *mut Handle,
                              eventaccel: *mut Handle, eventgyro: *mut Handle,
                              eventdebugpad: *mut Handle) -> Result;
}
extern "C" {
    pub fn HIDUSER_EnableAccelerometer() -> Result;
}
extern "C" {
    pub fn HIDUSER_DisableAccelerometer() -> Result;
}
extern "C" {
    pub fn HIDUSER_EnableGyroscope() -> Result;
}
extern "C" {
    pub fn HIDUSER_DisableGyroscope() -> Result;
}
extern "C" {
    pub fn HIDUSER_GetGyroscopeRawToDpsCoefficient(coeff: *mut f32) -> Result;
}
extern "C" {
    pub fn HIDUSER_GetSoundVolume(volume: *mut u8) -> Result;
}
extern "C" {
    pub static mut irrstMemHandle: Handle;
}
extern "C" {
    pub static mut irrstSharedMem: *mut vu32;
}
extern "C" {
    pub fn irrstInit() -> Result;
}
extern "C" {
    pub fn irrstExit();
}
extern "C" {
    pub fn irrstScanInput();
}
extern "C" {
    pub fn irrstKeysHeld() -> u32;
}
extern "C" {
    pub fn irrstCstickRead(pos: *mut circlePosition);
}
extern "C" {
    pub fn irrstWaitForEvent(nextEvent: bool);
}
extern "C" {
    pub fn IRRST_GetHandles(outMemHandle: *mut Handle,
                            outEventHandle: *mut Handle) -> Result;
}
extern "C" {
    pub fn IRRST_Initialize(unk1: u32, unk2: u8) -> Result;
}
extern "C" {
    pub fn IRRST_Shutdown() -> Result;
}
#[repr(C)]
#[derive(Copy)]
pub struct sslcContext {
    pub servhandle: Handle,
    pub sslchandle: u32,
    pub sharedmem_handle: Handle,
}
impl Clone for sslcContext {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SSLC_DefaultRootCert {
    SSLC_DefaultRootCert_Nintendo_CA = 1,
    SSLC_DefaultRootCert_Nintendo_CA_G2 = 2,
    SSLC_DefaultRootCert_Nintendo_CA_G3 = 3,
    SSLC_DefaultRootCert_Nintendo_Class2_CA = 4,
    SSLC_DefaultRootCert_Nintendo_Class2_CA_G2 = 5,
    SSLC_DefaultRootCert_Nintendo_Class2_CA_G3 = 6,
    SSLC_DefaultRootCert_CyberTrust = 7,
    SSLC_DefaultRootCert_AddTrust_External_CA = 8,
    SSLC_DefaultRootCert_COMODO = 9,
    SSLC_DefaultRootCert_USERTrust = 10,
    SSLC_DefaultRootCert_DigiCert_EV = 11,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SSLC_DefaultClientCert { SSLC_DefaultClientCert_ClCertA = 64, }
pub const SSLCOPT_Default: _bindgen_ty_19 = _bindgen_ty_19::SSLCOPT_Default;
pub const SSLCOPT_DisableVerify: _bindgen_ty_19 =
    _bindgen_ty_19::SSLCOPT_DisableVerify;
pub const SSLCOPT_TLSv10: _bindgen_ty_19 = _bindgen_ty_19::SSLCOPT_TLSv10;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_19 {
    SSLCOPT_Default = 0,
    SSLCOPT_DisableVerify = 512,
    SSLCOPT_TLSv10 = 2048,
}
extern "C" {
    pub fn sslcInit(session_handle: Handle) -> Result;
}
extern "C" {
    pub fn sslcExit();
}
extern "C" {
    pub fn sslcCreateRootCertChain(RootCertChain_contexthandle: *mut u32)
     -> Result;
}
extern "C" {
    pub fn sslcDestroyRootCertChain(RootCertChain_contexthandle: u32)
     -> Result;
}
extern "C" {
    pub fn sslcAddTrustedRootCA(RootCertChain_contexthandle: u32,
                                cert: *const u8, certsize: u32,
                                cert_contexthandle: *mut u32) -> Result;
}
extern "C" {
    pub fn sslcRootCertChainAddDefaultCert(RootCertChain_contexthandle: u32,
                                           certID: SSLC_DefaultRootCert,
                                           cert_contexthandle: *mut u32)
     -> Result;
}
extern "C" {
    pub fn sslcRootCertChainRemoveCert(RootCertChain_contexthandle: u32,
                                       cert_contexthandle: u32) -> Result;
}
extern "C" {
    pub fn sslcCreate8CertChain(CertChain_contexthandle: *mut u32) -> Result;
}
extern "C" {
    pub fn sslcDestroy8CertChain(CertChain_contexthandle: u32) -> Result;
}
extern "C" {
    pub fn sslc8CertChainAddCert(CertChain_contexthandle: u32,
                                 cert: *const u8, certsize: u32,
                                 cert_contexthandle: *mut u32) -> Result;
}
extern "C" {
    pub fn sslc8CertChainAddDefaultCert(CertChain_contexthandle: u32,
                                        certID: u8,
                                        cert_contexthandle: *mut u32)
     -> Result;
}
extern "C" {
    pub fn sslc8CertChainRemoveCert(CertChain_contexthandle: u32,
                                    cert_contexthandle: u32) -> Result;
}
extern "C" {
    pub fn sslcOpenClientCertContext(cert: *const u8, certsize: u32,
                                     key: *const u8, keysize: u32,
                                     ClientCert_contexthandle: *mut u32)
     -> Result;
}
extern "C" {
    pub fn sslcOpenDefaultClientCertContext(certID: SSLC_DefaultClientCert,
                                            ClientCert_contexthandle:
                                                *mut u32) -> Result;
}
extern "C" {
    pub fn sslcCloseClientCertContext(ClientCert_contexthandle: u32)
     -> Result;
}
extern "C" {
    pub fn sslcSeedRNG() -> Result;
}
extern "C" {
    pub fn sslcGenerateRandomData(buf: *mut u8, size: u32) -> Result;
}
extern "C" {
    pub fn sslcCreateContext(context: *mut sslcContext, sockfd: libc::c_int,
                             input_opt: u32, hostname: *const libc::c_char)
     -> Result;
}
extern "C" {
    pub fn sslcDestroyContext(context: *mut sslcContext) -> Result;
}
extern "C" {
    pub fn sslcStartConnection(context: *mut sslcContext,
                               internal_retval: *mut libc::c_int,
                               out: *mut u32) -> Result;
}
extern "C" {
    pub fn sslcRead(context: *mut sslcContext, buf: *mut libc::c_void,
                    len: usize, peek: bool) -> Result;
}
extern "C" {
    pub fn sslcWrite(context: *mut sslcContext, buf: *const libc::c_void,
                     len: usize) -> Result;
}
extern "C" {
    pub fn sslcContextSetRootCertChain(context: *mut sslcContext, handle: u32)
     -> Result;
}
extern "C" {
    pub fn sslcContextSetClientCert(context: *mut sslcContext, handle: u32)
     -> Result;
}
extern "C" {
    pub fn sslcContextSetHandle8(context: *mut sslcContext, handle: u32)
     -> Result;
}
extern "C" {
    pub fn sslcContextClearOpt(context: *mut sslcContext, bitmask: u32)
     -> Result;
}
extern "C" {
    pub fn sslcContextGetProtocolCipher(context: *mut sslcContext,
                                        outprotocols: *mut libc::c_char,
                                        outprotocols_maxsize: u32,
                                        outcipher: *mut libc::c_char,
                                        outcipher_maxsize: u32) -> Result;
}
extern "C" {
    pub fn sslcContextGetState(context: *mut sslcContext, out: *mut u32)
     -> Result;
}
extern "C" {
    pub fn sslcContextInitSharedmem(context: *mut sslcContext, buf: *mut u8,
                                    size: u32) -> Result;
}
extern "C" {
    pub fn sslcAddCert(context: *mut sslcContext, buf: *const u8, size: u32)
     -> Result;
}
#[repr(C)]
#[derive(Copy)]
pub struct httpcContext {
    pub servhandle: Handle,
    pub httphandle: u32,
}
impl Clone for httpcContext {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum HTTPC_RequestMethod {
    HTTPC_METHOD_GET = 1,
    HTTPC_METHOD_POST = 2,
    HTTPC_METHOD_HEAD = 3,
    HTTPC_METHOD_PUT = 4,
    HTTPC_METHOD_DELETE = 5,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum HTTPC_RequestStatus {
    HTTPC_STATUS_REQUEST_IN_PROGRESS = 5,
    HTTPC_STATUS_DOWNLOAD_READY = 7,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum HTTPC_KeepAlive {
    HTTPC_KEEPALIVE_DISABLED = 0,
    HTTPC_KEEPALIVE_ENABLED = 1,
}
extern "C" {
    pub fn httpcInit(sharedmem_size: u32) -> Result;
}
extern "C" {
    pub fn httpcExit();
}
extern "C" {
    pub fn httpcOpenContext(context: *mut httpcContext,
                            method: HTTPC_RequestMethod,
                            url: *const libc::c_char, use_defaultproxy: u32)
     -> Result;
}
extern "C" {
    pub fn httpcCloseContext(context: *mut httpcContext) -> Result;
}
extern "C" {
    pub fn httpcCancelConnection(context: *mut httpcContext) -> Result;
}
extern "C" {
    pub fn httpcAddRequestHeaderField(context: *mut httpcContext,
                                      name: *const libc::c_char,
                                      value: *const libc::c_char) -> Result;
}
extern "C" {
    pub fn httpcAddPostDataAscii(context: *mut httpcContext,
                                 name: *const libc::c_char,
                                 value: *const libc::c_char) -> Result;
}
extern "C" {
    pub fn httpcAddPostDataBinary(context: *mut httpcContext,
                                  name: *const libc::c_char, value: *const u8,
                                  len: u32) -> Result;
}
extern "C" {
    pub fn httpcAddPostDataRaw(context: *mut httpcContext, data: *const u32,
                               len: u32) -> Result;
}
extern "C" {
    pub fn httpcBeginRequest(context: *mut httpcContext) -> Result;
}
extern "C" {
    pub fn httpcReceiveData(context: *mut httpcContext, buffer: *mut u8,
                            size: u32) -> Result;
}
extern "C" {
    pub fn httpcReceiveDataTimeout(context: *mut httpcContext,
                                   buffer: *mut u8, size: u32, timeout: u64)
     -> Result;
}
extern "C" {
    pub fn httpcGetRequestState(context: *mut httpcContext,
                                out: *mut HTTPC_RequestStatus) -> Result;
}
extern "C" {
    pub fn httpcGetDownloadSizeState(context: *mut httpcContext,
                                     downloadedsize: *mut u32,
                                     contentsize: *mut u32) -> Result;
}
extern "C" {
    pub fn httpcGetResponseStatusCode(context: *mut httpcContext,
                                      out: *mut u32) -> Result;
}
extern "C" {
    pub fn httpcGetResponseStatusCodeTimeout(context: *mut httpcContext,
                                             out: *mut u32, timeout: u64)
     -> Result;
}
extern "C" {
    pub fn httpcGetResponseHeader(context: *mut httpcContext,
                                  name: *const libc::c_char,
                                  value: *mut libc::c_char,
                                  valuebuf_maxsize: u32) -> Result;
}
extern "C" {
    pub fn httpcAddTrustedRootCA(context: *mut httpcContext, cert: *const u8,
                                 certsize: u32) -> Result;
}
extern "C" {
    pub fn httpcAddDefaultCert(context: *mut httpcContext,
                               certID: SSLC_DefaultRootCert) -> Result;
}
extern "C" {
    pub fn httpcSelectRootCertChain(context: *mut httpcContext,
                                    RootCertChain_contexthandle: u32)
     -> Result;
}
extern "C" {
    pub fn httpcSetClientCert(context: *mut httpcContext, cert: *const u8,
                              certsize: u32, privk: *const u8,
                              privk_size: u32) -> Result;
}
extern "C" {
    pub fn httpcSetClientCertDefault(context: *mut httpcContext,
                                     certID: SSLC_DefaultClientCert)
     -> Result;
}
extern "C" {
    pub fn httpcSetClientCertContext(context: *mut httpcContext,
                                     ClientCert_contexthandle: u32) -> Result;
}
extern "C" {
    pub fn httpcSetSSLOpt(context: *mut httpcContext, options: u32) -> Result;
}
extern "C" {
    pub fn httpcSetSSLClearOpt(context: *mut httpcContext, options: u32)
     -> Result;
}
extern "C" {
    pub fn httpcCreateRootCertChain(RootCertChain_contexthandle: *mut u32)
     -> Result;
}
extern "C" {
    pub fn httpcDestroyRootCertChain(RootCertChain_contexthandle: u32)
     -> Result;
}
extern "C" {
    pub fn httpcRootCertChainAddCert(RootCertChain_contexthandle: u32,
                                     cert: *const u8, certsize: u32,
                                     cert_contexthandle: *mut u32) -> Result;
}
extern "C" {
    pub fn httpcRootCertChainAddDefaultCert(RootCertChain_contexthandle: u32,
                                            certID: SSLC_DefaultRootCert,
                                            cert_contexthandle: *mut u32)
     -> Result;
}
extern "C" {
    pub fn httpcRootCertChainRemoveCert(RootCertChain_contexthandle: u32,
                                        cert_contexthandle: u32) -> Result;
}
extern "C" {
    pub fn httpcOpenClientCertContext(cert: *const u8, certsize: u32,
                                      privk: *const u8, privk_size: u32,
                                      ClientCert_contexthandle: *mut u32)
     -> Result;
}
extern "C" {
    pub fn httpcOpenDefaultClientCertContext(certID: SSLC_DefaultClientCert,
                                             ClientCert_contexthandle:
                                                 *mut u32) -> Result;
}
extern "C" {
    pub fn httpcCloseClientCertContext(ClientCert_contexthandle: u32)
     -> Result;
}
extern "C" {
    pub fn httpcDownloadData(context: *mut httpcContext, buffer: *mut u8,
                             size: u32, downloadedsize: *mut u32) -> Result;
}
extern "C" {
    pub fn httpcSetKeepAlive(context: *mut httpcContext,
                             option: HTTPC_KeepAlive) -> Result;
}
#[repr(C)]
#[derive(Copy)]
pub struct udsNodeInfo {
    pub uds_friendcodeseed: u64,
    pub __bindgen_anon_1: udsNodeInfo__bindgen_ty_1,
    pub NetworkNodeID: u16,
    pub pad_x22: u16,
    pub word_x24: u32,
}
#[repr(C)]
#[derive(Copy)]
pub union udsNodeInfo__bindgen_ty_1 {
    pub usercfg: [u8; 24usize],
    pub __bindgen_anon_1: udsNodeInfo__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub struct udsNodeInfo__bindgen_ty_1__bindgen_ty_1 {
    pub username: [u16; 10usize],
    pub unk_x1c: u16,
    pub flag: u8,
    pub pad_x1f: u8,
}
impl Clone for udsNodeInfo__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Clone for udsNodeInfo__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Clone for udsNodeInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct udsConnectionStatus {
    pub status: u32,
    pub unk_x4: u32,
    pub cur_NetworkNodeID: u16,
    pub unk_xa: u16,
    pub unk_xc: [u32; 8usize],
    pub total_nodes: u8,
    pub max_nodes: u8,
    pub node_bitmask: u16,
}
impl Clone for udsConnectionStatus {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct udsNetworkStruct {
    pub host_macaddress: [u8; 6usize],
    pub channel: u8,
    pub pad_x7: u8,
    pub initialized_flag: u8,
    pub unk_x9: [u8; 3usize],
    pub oui_value: [u8; 3usize],
    pub oui_type: u8,
    pub wlancommID: u32,
    pub id8: u8,
    pub unk_x15: u8,
    pub attributes: u16,
    pub networkID: u32,
    pub total_nodes: u8,
    pub max_nodes: u8,
    pub unk_x1e: u8,
    pub unk_x1f: u8,
    pub unk_x20: [u8; 31usize],
    pub appdata_size: u8,
    pub appdata: [u8; 200usize],
}
#[repr(C)]
#[derive(Copy)]
pub struct udsBindContext {
    pub BindNodeID: u32,
    pub event: Handle,
    pub spectator: bool,
}
impl Clone for udsBindContext {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct nwmScanInputStruct {
    pub unk_x0: u16,
    pub unk_x2: u16,
    pub unk_x4: u16,
    pub unk_x6: u16,
    pub mac_address: [u8; 6usize],
    pub unk_xe: [u8; 38usize],
}
#[repr(C)]
#[derive(Copy)]
pub struct nwmBeaconDataReplyHeader {
    pub maxsize: u32,
    pub size: u32,
    pub total_entries: u32,
}
impl Clone for nwmBeaconDataReplyHeader {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct nwmBeaconDataReplyEntry {
    pub size: u32,
    pub unk_x4: u8,
    pub channel: u8,
    pub unk_x6: u8,
    pub unk_x7: u8,
    pub mac_address: [u8; 6usize],
    pub unk_xe: [u8; 6usize],
    pub unk_x14: u32,
    pub val_x1c: u32,
}
impl Clone for nwmBeaconDataReplyEntry {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct udsNetworkScanInfo {
    pub datareply_entry: nwmBeaconDataReplyEntry,
    pub network: udsNetworkStruct,
    pub nodes: [udsNodeInfo; 16usize],
}
pub const UDSNETATTR_DisableConnectSpectators: _bindgen_ty_20 =
    _bindgen_ty_20::UDSNETATTR_DisableConnectSpectators;
pub const UDSNETATTR_DisableConnectClients: _bindgen_ty_20 =
    _bindgen_ty_20::UDSNETATTR_DisableConnectClients;
pub const UDSNETATTR_x4: _bindgen_ty_20 = _bindgen_ty_20::UDSNETATTR_x4;
pub const UDSNETATTR_Default: _bindgen_ty_20 =
    _bindgen_ty_20::UDSNETATTR_Default;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_20 {
    UDSNETATTR_DisableConnectSpectators = 1,
    UDSNETATTR_DisableConnectClients = 2,
    UDSNETATTR_x4 = 4,
    UDSNETATTR_Default = 32768,
}
pub const UDS_SENDFLAG_Default: _bindgen_ty_21 =
    _bindgen_ty_21::UDS_SENDFLAG_Default;
pub const UDS_SENDFLAG_Broadcast: _bindgen_ty_21 =
    _bindgen_ty_21::UDS_SENDFLAG_Broadcast;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_21 {
    UDS_SENDFLAG_Default = 1,
    UDS_SENDFLAG_Broadcast = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum udsConnectionType {
    UDSCONTYPE_Client = 1,
    UDSCONTYPE_Spectator = 2,
}
extern "C" {
    pub fn udsInit(sharedmem_size: usize, username: *const libc::c_char)
     -> Result;
}
extern "C" {
    pub fn udsExit();
}
extern "C" {
    pub fn udsGenerateNodeInfo(nodeinfo: *mut udsNodeInfo,
                               username: *const libc::c_char) -> Result;
}
extern "C" {
    pub fn udsGetNodeInfoUsername(nodeinfo: *const udsNodeInfo,
                                  username: *mut libc::c_char) -> Result;
}
extern "C" {
    pub fn udsCheckNodeInfoInitialized(nodeinfo: *const udsNodeInfo) -> bool;
}
extern "C" {
    pub fn udsGenerateDefaultNetworkStruct(network: *mut udsNetworkStruct,
                                           wlancommID: u32, id8: u8,
                                           max_nodes: u8);
}
extern "C" {
    pub fn udsScanBeacons(outbuf: *mut libc::c_void, maxsize: usize,
                          networks: *mut *mut udsNetworkScanInfo,
                          total_networks: *mut usize, wlancommID: u32,
                          id8: u8, host_macaddress: *const u8,
                          connected: bool) -> Result;
}
extern "C" {
    pub fn udsSetApplicationData(buf: *const libc::c_void, size: usize)
     -> Result;
}
extern "C" {
    pub fn udsGetApplicationData(buf: *mut libc::c_void, size: usize,
                                 actual_size: *mut usize) -> Result;
}
extern "C" {
    pub fn udsGetNetworkStructApplicationData(network:
                                                  *const udsNetworkStruct,
                                              buf: *mut libc::c_void,
                                              size: usize,
                                              actual_size: *mut usize)
     -> Result;
}
extern "C" {
    pub fn udsBind(bindcontext: *mut udsBindContext, NetworkNodeID: u16,
                   spectator: bool, data_channel: u8, recv_buffer_size: u32)
     -> Result;
}
extern "C" {
    pub fn udsUnbind(bindcontext: *mut udsBindContext) -> Result;
}
extern "C" {
    pub fn udsWaitDataAvailable(bindcontext: *const udsBindContext,
                                nextEvent: bool, wait: bool) -> bool;
}
extern "C" {
    pub fn udsPullPacket(bindcontext: *const udsBindContext,
                         buf: *mut libc::c_void, size: usize,
                         actual_size: *mut usize, src_NetworkNodeID: *mut u16)
     -> Result;
}
extern "C" {
    pub fn udsSendTo(dst_NetworkNodeID: u16, data_channel: u8, flags: u8,
                     buf: *const libc::c_void, size: usize) -> Result;
}
extern "C" {
    pub fn udsGetChannel(channel: *mut u8) -> Result;
}
extern "C" {
    pub fn udsCreateNetwork(network: *const udsNetworkStruct,
                            passphrase: *const libc::c_void,
                            passphrase_size: usize,
                            context: *mut udsBindContext, data_channel: u8,
                            recv_buffer_size: u32) -> Result;
}
extern "C" {
    pub fn udsConnectNetwork(network: *const udsNetworkStruct,
                             passphrase: *const libc::c_void,
                             passphrase_size: usize,
                             context: *mut udsBindContext,
                             recv_NetworkNodeID: u16,
                             connection_type: udsConnectionType,
                             data_channel: u8, recv_buffer_size: u32)
     -> Result;
}
extern "C" {
    pub fn udsDestroyNetwork() -> Result;
}
extern "C" {
    pub fn udsDisconnectNetwork() -> Result;
}
extern "C" {
    pub fn udsEjectClient(NetworkNodeID: u16) -> Result;
}
extern "C" {
    pub fn udsEjectSpectator() -> Result;
}
extern "C" {
    pub fn udsUpdateNetworkAttribute(bitmask: u16, flag: bool) -> Result;
}
extern "C" {
    pub fn udsSetNewConnectionsBlocked(block: bool, clients: bool, flag: bool)
     -> Result;
}
extern "C" {
    pub fn udsAllowSpectators() -> Result;
}
extern "C" {
    pub fn udsGetConnectionStatus(output: *mut udsConnectionStatus) -> Result;
}
extern "C" {
    pub fn udsWaitConnectionStatusEvent(nextEvent: bool, wait: bool) -> bool;
}
extern "C" {
    pub fn udsGetNodeInformation(NetworkNodeID: u16, output: *mut udsNodeInfo)
     -> Result;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum NDM_ExclusiveState {
    EXCLUSIVE_STATE_NONE = 0,
    EXCLUSIVE_STATE_INFRASTRUCTURE = 1,
    EXCLUSIVE_STATE_LOCAL_COMMUNICATIONS = 2,
    EXCLUSIVE_STATE_STREETPASS = 3,
    EXCLUSIVE_STATE_STREETPASS_DATA = 4,
}
extern "C" {
    pub fn ndmuInit() -> Result;
}
extern "C" {
    pub fn ndmuExit();
}
extern "C" {
    pub fn ndmuEnterExclusiveState(state: NDM_ExclusiveState) -> Result;
}
extern "C" {
    pub fn ndmuLeaveExclusiveState() -> Result;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum NIM_InstallationMode {
    IM_DEFAULT = 0,
    IM_UNKNOWN1 = 1,
    IM_UNKNOWN2 = 2,
    IM_REINSTALL = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum NIM_DownloadState {
    DS_NOT_INITIALIZED = 0,
    DS_INITIALIZED = 1,
    DS_DOWNLOAD_TMD = 2,
    DS_PREPARE_SAVE_DATA = 3,
    DS_DOWNLOAD_CONTENTS = 4,
    DS_WAIT_COMMIT = 5,
    DS_COMMITTING = 6,
    DS_FINISHED = 7,
    DS_VERSION_ERROR = 8,
    DS_CREATE_CONTEXT = 9,
    DS_CANNOT_RECOVER = 10,
    DS_INVALID = 11,
}
#[repr(C)]
#[derive(Copy)]
pub struct NIM_TitleConfig {
    pub titleId: u64,
    pub version: u32,
    pub unknown_0: u32,
    pub ratingAge: u8,
    pub mediaType: u8,
    pub padding: [u8; 2usize],
    pub unknown_1: u32,
}
impl Clone for NIM_TitleConfig {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct NIM_TitleProgress {
    pub state: u32,
    pub lastResult: Result,
    pub downloadedSize: u64,
    pub totalSize: u64,
}
impl Clone for NIM_TitleProgress {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn nimsInit(buffer: *mut libc::c_void, buffer_len: usize) -> Result;
}
extern "C" {
    pub fn nimsInitWithTIN(buffer: *mut libc::c_void, buffer_len: usize,
                           TIN: *const libc::c_char) -> Result;
}
extern "C" {
    pub fn nimsExit();
}
extern "C" {
    pub fn nimsGetSessionHandle() -> *mut Handle;
}
extern "C" {
    pub fn NIMS_SetAttribute(attr: *const libc::c_char,
                             val: *const libc::c_char) -> Result;
}
extern "C" {
    pub fn NIMS_WantUpdate(want_update: *mut bool) -> Result;
}
extern "C" {
    pub fn NIMS_MakeTitleConfig(cfg: *mut NIM_TitleConfig, titleId: u64,
                                version: u32, ratingAge: u8,
                                mediaType: FS_MediaType);
}
extern "C" {
    pub fn NIMS_RegisterTask(cfg: *const NIM_TitleConfig,
                             name: *const libc::c_char,
                             maker: *const libc::c_char) -> Result;
}
extern "C" {
    pub fn NIMS_IsTaskRegistered(titleId: u64, registered: *mut bool)
     -> Result;
}
extern "C" {
    pub fn NIMS_UnregisterTask(titleId: u64) -> Result;
}
extern "C" {
    pub fn NIMS_StartDownload(cfg: *const NIM_TitleConfig,
                              mode: NIM_InstallationMode) -> Result;
}
extern "C" {
    pub fn NIMS_StartDownloadSimple(cfg: *const NIM_TitleConfig) -> Result;
}
extern "C" {
    pub fn NIMS_GetProgress(tp: *mut NIM_TitleProgress) -> Result;
}
extern "C" {
    pub fn NIMS_CancelDownload() -> Result;
}
extern "C" {
    pub fn nwmExtInit() -> Result;
}
extern "C" {
    pub fn nwmExtExit();
}
extern "C" {
    pub fn NWMEXT_ControlWirelessEnabled(enableWifi: bool) -> Result;
}
extern "C" {
    pub fn iruInit(sharedmem_addr: *mut u32, sharedmem_size: u32) -> Result;
}
extern "C" {
    pub fn iruExit();
}
extern "C" {
    pub fn iruGetServHandle() -> Handle;
}
extern "C" {
    pub fn iruSendData(buf: *mut u8, size: u32, wait: bool) -> Result;
}
extern "C" {
    pub fn iruRecvData(buf: *mut u8, size: u32, flag: u8,
                       transfercount: *mut u32, wait: bool) -> Result;
}
extern "C" {
    pub fn IRU_Initialize() -> Result;
}
extern "C" {
    pub fn IRU_Shutdown() -> Result;
}
extern "C" {
    pub fn IRU_StartSendTransfer(buf: *mut u8, size: u32) -> Result;
}
extern "C" {
    pub fn IRU_WaitSendTransfer() -> Result;
}
extern "C" {
    pub fn IRU_StartRecvTransfer(size: u32, flag: u8) -> Result;
}
extern "C" {
    pub fn IRU_WaitRecvTransfer(transfercount: *mut u32) -> Result;
}
extern "C" {
    pub fn IRU_SetBitRate(value: u8) -> Result;
}
extern "C" {
    pub fn IRU_GetBitRate(out: *mut u8) -> Result;
}
extern "C" {
    pub fn IRU_SetIRLEDState(value: u32) -> Result;
}
extern "C" {
    pub fn IRU_GetIRLEDRecvState(out: *mut u32) -> Result;
}
extern "C" {
    pub fn nsInit() -> Result;
}
extern "C" {
    pub fn nsExit();
}
extern "C" {
    pub fn NS_LaunchFIRM(titleid: u64) -> Result;
}
extern "C" {
    pub fn NS_LaunchTitle(titleid: u64, launch_flags: u32, procid: *mut u32)
     -> Result;
}
extern "C" {
    pub fn NS_LaunchApplicationFIRM(titleid: u64, flags: u32) -> Result;
}
extern "C" {
    pub fn NS_RebootToTitle(mediatype: u8, titleid: u64) -> Result;
}
extern "C" {
    pub fn NS_TerminateProcessTID(titleid: u64) -> Result;
}
extern "C" {
    pub fn pmInit() -> Result;
}
extern "C" {
    pub fn pmExit();
}
extern "C" {
    pub fn PM_LaunchTitle(mediatype: u8, titleid: u64, launch_flags: u32)
     -> Result;
}
extern "C" {
    pub fn PM_GetTitleExheaderFlags(mediatype: u8, titleid: u64, out: *mut u8)
     -> Result;
}
extern "C" {
    pub fn PM_SetFIRMLaunchParams(size: u32, in_: *mut u8) -> Result;
}
extern "C" {
    pub fn PM_GetFIRMLaunchParams(size: u32, out: *mut u8) -> Result;
}
extern "C" {
    pub fn PM_LaunchFIRMSetParams(firm_titleid_low: u32, size: u32,
                                  in_: *mut u8) -> Result;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum PS_AESAlgorithm {
    PS_ALGORITHM_CBC_ENC = 0,
    PS_ALGORITHM_CBC_DEC = 1,
    PS_ALGORITHM_CTR_ENC = 2,
    PS_ALGORITHM_CTR_DEC = 3,
    PS_ALGORITHM_CCM_ENC = 4,
    PS_ALGORITHM_CCM_DEC = 5,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum PS_AESKeyType {
    PS_KEYSLOT_0D = 0,
    PS_KEYSLOT_2D = 1,
    PS_KEYSLOT_31 = 2,
    PS_KEYSLOT_38 = 3,
    PS_KEYSLOT_32 = 4,
    PS_KEYSLOT_39_DLP = 5,
    PS_KEYSLOT_2E = 6,
    PS_KEYSLOT_INVALID = 7,
    PS_KEYSLOT_36 = 8,
    PS_KEYSLOT_39_NFC = 9,
}
#[repr(C)]
pub struct psRSAContext {
    pub modulo: [u8; 256usize],
    pub exponent: [u8; 256usize],
    pub rsa_bitsize: u32,
    pub unk: u32,
}
extern "C" {
    pub fn psInit() -> Result;
}
extern "C" {
    pub fn psInitHandle(handle: Handle) -> Result;
}
extern "C" {
    pub fn psExit();
}
extern "C" {
    pub fn psGetSessionHandle() -> Handle;
}
extern "C" {
    pub fn PS_SignRsaSha256(hash: *mut u8, ctx: *mut psRSAContext,
                            signature: *mut u8) -> Result;
}
extern "C" {
    pub fn PS_VerifyRsaSha256(hash: *mut u8, ctx: *mut psRSAContext,
                              signature: *mut u8) -> Result;
}
extern "C" {
    pub fn PS_EncryptDecryptAes(size: u32, in_: *mut u8, out: *mut u8,
                                aes_algo: PS_AESAlgorithm,
                                key_type: PS_AESKeyType, iv: *mut u8)
     -> Result;
}
extern "C" {
    pub fn PS_EncryptSignDecryptVerifyAesCcm(in_: *mut u8, in_size: u32,
                                             out: *mut u8, out_size: u32,
                                             data_len: u32, mac_data_len: u32,
                                             mac_len: u32,
                                             aes_algo: PS_AESAlgorithm,
                                             key_type: PS_AESKeyType,
                                             nonce: *mut u8) -> Result;
}
extern "C" {
    pub fn PS_GetLocalFriendCodeSeed(seed: *mut u64) -> Result;
}
extern "C" {
    pub fn PS_GetDeviceId(device_id: *mut u32) -> Result;
}
extern "C" {
    pub fn PS_GenerateRandomBytes(out: *mut libc::c_void, len: usize)
     -> Result;
}
extern "C" {
    pub fn ptmuInit() -> Result;
}
extern "C" {
    pub fn ptmuExit();
}
extern "C" {
    pub fn PTMU_GetShellState(out: *mut u8) -> Result;
}
extern "C" {
    pub fn PTMU_GetBatteryLevel(out: *mut u8) -> Result;
}
extern "C" {
    pub fn PTMU_GetBatteryChargeState(out: *mut u8) -> Result;
}
extern "C" {
    pub fn PTMU_GetPedometerState(out: *mut u8) -> Result;
}
extern "C" {
    pub fn PTMU_GetTotalStepCount(steps: *mut u32) -> Result;
}
extern "C" {
    pub fn PTMU_GetAdapterState(out: *mut bool) -> Result;
}
extern "C" {
    pub fn ptmSysmInit() -> Result;
}
extern "C" {
    pub fn ptmSysmExit();
}
extern "C" {
    pub fn PTMSYSM_CheckNew3DS() -> Result;
}
extern "C" {
    pub fn PTMSYSM_ConfigureNew3DSCPU(value: u8) -> Result;
}
extern "C" {
    pub fn PTMSYSM_ShutdownAsync(timeout: u64) -> Result;
}
extern "C" {
    pub fn PTMSYSM_RebootAsync(timeout: u64) -> Result;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum PXIDEV_WaitType {
    WAIT_NONE = 0,
    WAIT_SLEEP = 1,
    WAIT_IREQ_RETURN = 2,
    WAIT_IREQ_CONTINUE = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum PXIDEV_DeassertType {
    DEASSERT_NONE = 0,
    DEASSERT_BEFORE_WAIT = 1,
    DEASSERT_AFTER_WAIT = 2,
}
#[repr(C)]
#[derive(Copy)]
pub struct PXIDEV_SPIBuffer {
    pub ptr: *mut libc::c_void,
    pub size: u32,
    pub transferOption: u8,
    pub waitOperation: u64,
}
impl Clone for PXIDEV_SPIBuffer {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn pxiDevInit() -> Result;
}
extern "C" {
    pub fn pxiDevExit();
}
extern "C" {
    pub fn PXIDEV_SPIMultiWriteRead(header: *mut PXIDEV_SPIBuffer,
                                    writeBuffer1: *mut PXIDEV_SPIBuffer,
                                    readBuffer1: *mut PXIDEV_SPIBuffer,
                                    writeBuffer2: *mut PXIDEV_SPIBuffer,
                                    readBuffer2: *mut PXIDEV_SPIBuffer,
                                    footer: *mut PXIDEV_SPIBuffer) -> Result;
}
extern "C" {
    pub fn PXIDEV_SPIWriteRead(bytesRead: *mut u32, initialWaitOperation: u64,
                               writeBuffer: *mut PXIDEV_SPIBuffer,
                               readBuffer: *mut PXIDEV_SPIBuffer) -> Result;
}
#[repr(C)]
#[derive(Copy)]
pub struct timezone {
    pub tz_minuteswest: libc::c_int,
    pub tz_dsttime: libc::c_int,
}
impl Clone for timezone {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct bintime {
    pub sec: time_t,
    pub frac: u64,
}
impl Clone for bintime {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
impl Clone for itimerval {
    fn clone(&self) -> Self { *self }
}
pub type __ULong = libc::c_ulong;
#[repr(C)]
#[derive(Copy)]
pub struct _reent {
    pub _errno: libc::c_int,
    pub _stdin: *mut __FILE,
    pub _stdout: *mut __FILE,
    pub _stderr: *mut __FILE,
    pub _inc: libc::c_int,
    pub _emergency: [libc::c_char; 25usize],
    pub _unspecified_locale_info: libc::c_int,
    pub _locale: *mut __locale_t,
    pub __sdidinit: libc::c_int,
    pub __cleanup: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                   *mut _reent)>,
    pub _result: *mut _Bigint,
    pub _result_k: libc::c_int,
    pub _p5s: *mut _Bigint,
    pub _freelist: *mut *mut _Bigint,
    pub _cvtlen: libc::c_int,
    pub _cvtbuf: *mut libc::c_char,
    pub _new: _reent__bindgen_ty_1,
    pub _atexit: *mut _atexit,
    pub _atexit0: _atexit,
    pub _sig_func: *mut ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                        libc::c_int)>,
    pub __sglue: _glue,
    pub __sf: [__FILE; 3usize],
    pub deviceData: *mut libc::c_void,
}
#[repr(C)]
#[derive(Copy)]
pub union _reent__bindgen_ty_1 {
    pub _reent: _reent__bindgen_ty_1__bindgen_ty_1,
    pub _unused: _reent__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy)]
pub struct _reent__bindgen_ty_1__bindgen_ty_1 {
    pub _unused_rand: libc::c_uint,
    pub _strtok_last: *mut libc::c_char,
    pub _asctime_buf: [libc::c_char; 26usize],
    pub _localtime_buf: __tm,
    pub _gamma_signgam: libc::c_int,
    pub _rand_next: libc::c_ulonglong,
    pub _r48: _rand48,
    pub _mblen_state: _mbstate_t,
    pub _mbtowc_state: _mbstate_t,
    pub _wctomb_state: _mbstate_t,
    pub _l64a_buf: [libc::c_char; 8usize],
    pub _signal_buf: [libc::c_char; 24usize],
    pub _getdate_err: libc::c_int,
    pub _mbrlen_state: _mbstate_t,
    pub _mbrtowc_state: _mbstate_t,
    pub _mbsrtowcs_state: _mbstate_t,
    pub _wcrtomb_state: _mbstate_t,
    pub _wcsrtombs_state: _mbstate_t,
    pub _h_errno: libc::c_int,
}
impl Clone for _reent__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _reent__bindgen_ty_1__bindgen_ty_2 {
    pub _nextf: [*mut libc::c_uchar; 30usize],
    pub _nmalloc: [libc::c_uint; 30usize],
}
impl Clone for _reent__bindgen_ty_1__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Clone for _reent__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Clone for _reent {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy)]
pub struct _Bigint {
    pub _next: *mut _Bigint,
    pub _k: libc::c_int,
    pub _maxwds: libc::c_int,
    pub _sign: libc::c_int,
    pub _wds: libc::c_int,
    pub _x: [__ULong; 1usize],
}
impl Clone for _Bigint {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct __tm {
    pub __tm_sec: libc::c_int,
    pub __tm_min: libc::c_int,
    pub __tm_hour: libc::c_int,
    pub __tm_mday: libc::c_int,
    pub __tm_mon: libc::c_int,
    pub __tm_year: libc::c_int,
    pub __tm_wday: libc::c_int,
    pub __tm_yday: libc::c_int,
    pub __tm_isdst: libc::c_int,
}
impl Clone for __tm {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _on_exit_args {
    pub _fnargs: [*mut libc::c_void; 32usize],
    pub _dso_handle: [*mut libc::c_void; 32usize],
    pub _fntypes: __ULong,
    pub _is_cxa: __ULong,
}
impl Clone for _on_exit_args {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _atexit {
    pub _next: *mut _atexit,
    pub _ind: libc::c_int,
    pub _fns: [::core::option::Option<unsafe extern "C" fn()>; 32usize],
    pub _on_exit_args: _on_exit_args,
}
impl Clone for _atexit {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct __sbuf {
    pub _base: *mut libc::c_uchar,
    pub _size: libc::c_int,
}
impl Clone for __sbuf {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct __sFILE {
    pub _p: *mut libc::c_uchar,
    pub _r: libc::c_int,
    pub _w: libc::c_int,
    pub _flags: libc::c_short,
    pub _file: libc::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: libc::c_int,
    pub _cookie: *mut libc::c_void,
    pub _read: ::core::option::Option<unsafe extern "C" fn(arg1: *mut _reent,
                                                           arg2:
                                                               *mut libc::c_void,
                                                           arg3:
                                                               *mut libc::c_char,
                                                           arg4: libc::c_int)
                                          -> libc::c_int>,
    pub _write: ::core::option::Option<unsafe extern "C" fn(arg1: *mut _reent,
                                                            arg2:
                                                                *mut libc::c_void,
                                                            arg3:
                                                                *const libc::c_char,
                                                            arg4: libc::c_int)
                                           -> libc::c_int>,
    pub _seek: ::core::option::Option<unsafe extern "C" fn(arg1: *mut _reent,
                                                           arg2:
                                                               *mut libc::c_void,
                                                           arg3: _fpos_t,
                                                           arg4: libc::c_int)
                                          -> _fpos_t>,
    pub _close: ::core::option::Option<unsafe extern "C" fn(arg1: *mut _reent,
                                                            arg2:
                                                                *mut libc::c_void)
                                           -> libc::c_int>,
    pub _ub: __sbuf,
    pub _up: *mut libc::c_uchar,
    pub _ur: libc::c_int,
    pub _ubuf: [libc::c_uchar; 3usize],
    pub _nbuf: [libc::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: libc::c_int,
    pub _offset: _off_t,
    pub _data: *mut _reent,
    pub _lock: _flock_t,
    pub _mbstate: _mbstate_t,
    pub _flags2: libc::c_int,
}
impl Clone for __sFILE {
    fn clone(&self) -> Self { *self }
}
pub type __FILE = __sFILE;
#[repr(C)]
#[derive(Copy)]
pub struct _glue {
    pub _next: *mut _glue,
    pub _niobs: libc::c_int,
    pub _iobs: *mut __FILE,
}
impl Clone for _glue {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _rand48 {
    pub _seed: [libc::c_ushort; 3usize],
    pub _mult: [libc::c_ushort; 3usize],
    pub _add: libc::c_ushort,
}
impl Clone for _rand48 {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub static mut _impure_ptr: *mut _reent;
}
extern "C" {
    pub static _global_impure_ptr: *const _reent;
}
extern "C" {
    pub fn _reclaim_reent(arg1: *mut _reent);
}
extern "C" {
    pub fn __getreent() -> *mut _reent;
}
pub type locale_t = *mut __locale_t;
#[repr(C)]
#[derive(Copy)]
pub struct tm {
    pub tm_sec: libc::c_int,
    pub tm_min: libc::c_int,
    pub tm_hour: libc::c_int,
    pub tm_mday: libc::c_int,
    pub tm_mon: libc::c_int,
    pub tm_year: libc::c_int,
    pub tm_wday: libc::c_int,
    pub tm_yday: libc::c_int,
    pub tm_isdst: libc::c_int,
}
impl Clone for tm {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn difftime(_time2: time_t, _time1: time_t) -> f64;
}
extern "C" {
    pub fn mktime(_timeptr: *mut tm) -> time_t;
}
extern "C" {
    pub fn time(_timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn asctime(_tblock: *const tm) -> *mut libc::c_char;
}
extern "C" {
    pub fn ctime(_time: *const time_t) -> *mut libc::c_char;
}
extern "C" {
    pub fn gmtime(_timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(_timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn strftime(_s: *mut libc::c_char, _maxsize: usize,
                    _fmt: *const libc::c_char, _t: *const tm) -> usize;
}
extern "C" {
    pub fn strftime_l(_s: *mut libc::c_char, _maxsize: usize,
                      _fmt: *const libc::c_char, _t: *const tm, _l: locale_t)
     -> usize;
}
extern "C" {
    pub fn asctime_r(arg1: *const tm, arg2: *mut libc::c_char)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn ctime_r(arg1: *const time_t, arg2: *mut libc::c_char)
     -> *mut libc::c_char;
}
extern "C" {
    pub fn gmtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub fn _tzset_r(arg1: *mut _reent);
}
#[repr(C)]
#[derive(Copy)]
pub struct __tzrule_struct {
    pub ch: libc::c_char,
    pub m: libc::c_int,
    pub n: libc::c_int,
    pub d: libc::c_int,
    pub s: libc::c_int,
    pub change: time_t,
    pub offset: libc::c_long,
}
impl Clone for __tzrule_struct {
    fn clone(&self) -> Self { *self }
}
pub type __tzrule_type = __tzrule_struct;
#[repr(C)]
#[derive(Copy)]
pub struct __tzinfo_struct {
    pub __tznorth: libc::c_int,
    pub __tzyear: libc::c_int,
    pub __tzrule: [__tzrule_type; 2usize],
}
impl Clone for __tzinfo_struct {
    fn clone(&self) -> Self { *self }
}
pub type __tzinfo_type = __tzinfo_struct;
extern "C" {
    pub fn __gettzinfo() -> *mut __tzinfo_type;
}
extern "C" {
    pub static mut _timezone: libc::c_long;
}
extern "C" {
    pub static mut _daylight: libc::c_int;
}
extern "C" {
    pub static mut _tzname: [*mut libc::c_char; 2usize];
}
extern "C" {
    pub fn utimes(__path: *const libc::c_char, __tvp: *const timeval)
     -> libc::c_int;
}
extern "C" {
    pub fn adjtime(arg1: *const timeval, arg2: *mut timeval) -> libc::c_int;
}
extern "C" {
    pub fn futimes(arg1: libc::c_int, arg2: *const timeval) -> libc::c_int;
}
extern "C" {
    pub fn lutimes(arg1: *const libc::c_char, arg2: *const timeval)
     -> libc::c_int;
}
extern "C" {
    pub fn settimeofday(arg1: *const timeval, arg2: *const timezone)
     -> libc::c_int;
}
extern "C" {
    pub fn getitimer(__which: libc::c_int, __value: *mut itimerval)
     -> libc::c_int;
}
extern "C" {
    pub fn setitimer(__which: libc::c_int, __value: *const itimerval,
                     __ovalue: *mut itimerval) -> libc::c_int;
}
extern "C" {
    pub fn gettimeofday(__p: *mut timeval, __tz: *mut libc::c_void)
     -> libc::c_int;
}
pub type socklen_t = u32;
pub type sa_family_t = u16;
#[repr(C)]
#[derive(Copy)]
pub struct sockaddr {
    pub sa_family: sa_family_t,
    pub sa_data: __IncompleteArrayField<libc::c_char>,
}
impl Clone for sockaddr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct sockaddr_storage {
    pub ss_family: sa_family_t,
    pub __ss_padding: [libc::c_char; 26usize],
}
impl Clone for sockaddr_storage {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct linger {
    pub l_onoff: libc::c_int,
    pub l_linger: libc::c_int,
}
impl Clone for linger {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn accept(sockfd: libc::c_int, addr: *mut sockaddr,
                  addrlen: *mut socklen_t) -> libc::c_int;
}
extern "C" {
    pub fn bind(sockfd: libc::c_int, addr: *const sockaddr,
                addrlen: socklen_t) -> libc::c_int;
}
extern "C" {
    pub fn closesocket(sockfd: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn connect(sockfd: libc::c_int, addr: *const sockaddr,
                   addrlen: socklen_t) -> libc::c_int;
}
extern "C" {
    pub fn getpeername(sockfd: libc::c_int, addr: *mut sockaddr,
                       addrlen: *mut socklen_t) -> libc::c_int;
}
extern "C" {
    pub fn getsockname(sockfd: libc::c_int, addr: *mut sockaddr,
                       addrlen: *mut socklen_t) -> libc::c_int;
}
extern "C" {
    pub fn getsockopt(sockfd: libc::c_int, level: libc::c_int,
                      optname: libc::c_int, optval: *mut libc::c_void,
                      optlen: *mut socklen_t) -> libc::c_int;
}
extern "C" {
    pub fn listen(sockfd: libc::c_int, backlog: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn recv(sockfd: libc::c_int, buf: *mut libc::c_void, len: usize,
                flags: libc::c_int) -> isize;
}
extern "C" {
    pub fn recvfrom(sockfd: libc::c_int, buf: *mut libc::c_void, len: usize,
                    flags: libc::c_int, src_addr: *mut sockaddr,
                    addrlen: *mut socklen_t) -> isize;
}
extern "C" {
    pub fn send(sockfd: libc::c_int, buf: *const libc::c_void, len: usize,
                flags: libc::c_int) -> isize;
}
extern "C" {
    pub fn sendto(sockfd: libc::c_int, buf: *const libc::c_void, len: usize,
                  flags: libc::c_int, dest_addr: *const sockaddr,
                  addrlen: socklen_t) -> isize;
}
extern "C" {
    pub fn setsockopt(sockfd: libc::c_int, level: libc::c_int,
                      optname: libc::c_int, optval: *const libc::c_void,
                      optlen: socklen_t) -> libc::c_int;
}
extern "C" {
    pub fn shutdown(sockfd: libc::c_int, how: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn socket(domain: libc::c_int, type_: libc::c_int,
                  protocol: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn sockatmark(sockfd: libc::c_int) -> libc::c_int;
}
#[repr(C)]
#[derive(Copy)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
impl Clone for in_addr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct sockaddr_in {
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: in_addr,
    pub sin_zero: [libc::c_uchar; 8usize],
}
impl Clone for sockaddr_in {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ip_mreq {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
}
impl Clone for ip_mreq {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum NetworkOpt {
    NETOPT_MAC_ADDRESS = 4100,
    NETOPT_ARP_TABLE = 12290,
    NETOPT_IP_INFO = 16387,
    NETOPT_IP_MTU = 16388,
    NETOPT_ROUTING_TABLE = 16390,
    NETOPT_UDP_NUMBER = 32770,
    NETOPT_UDP_TABLE = 32771,
    NETOPT_TCP_NUMBER = 36866,
    NETOPT_TCP_TABLE = 36867,
    NETOPT_DNS_TABLE = 45059,
    NETOPT_DHCP_LEASE_TIME = 49153,
}
#[repr(C)]
#[derive(Copy)]
pub struct SOCU_ARPTableEntry {
    pub unk0: u32,
    pub ip: in_addr,
    pub mac: [u8; 6usize],
    pub padding: [u8; 2usize],
}
impl Clone for SOCU_ARPTableEntry {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct SOCU_IPInfo {
    pub ip: in_addr,
    pub netmask: in_addr,
    pub broadcast: in_addr,
}
impl Clone for SOCU_IPInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct SOCU_RoutingTableEntry {
    pub dest_ip: in_addr,
    pub netmask: in_addr,
    pub gateway: in_addr,
    pub flags: u32,
    pub time: u64,
}
impl Clone for SOCU_RoutingTableEntry {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct SOCU_UDPTableEntry {
    pub local: sockaddr_storage,
    pub remote: sockaddr_storage,
}
impl Clone for SOCU_UDPTableEntry {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct SOCU_TCPTableEntry {
    pub state: u32,
    pub local: sockaddr_storage,
    pub remote: sockaddr_storage,
}
impl Clone for SOCU_TCPTableEntry {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct SOCU_DNSTableEntry {
    pub family: u32,
    pub ip: in_addr,
    pub padding: [u8; 12usize],
}
impl Clone for SOCU_DNSTableEntry {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn socInit(context_addr: *mut u32, context_size: u32) -> Result;
}
extern "C" {
    pub fn socExit() -> Result;
}
extern "C" {
    pub fn gethostid() -> libc::c_long;
}
extern "C" {
    pub fn gethostname(name: *mut libc::c_char, namelen: usize)
     -> libc::c_int;
}
extern "C" {
    pub fn SOCU_ShutdownSockets() -> libc::c_int;
}
extern "C" {
    pub fn SOCU_CloseSockets() -> libc::c_int;
}
extern "C" {
    pub fn SOCU_GetNetworkOpt(level: libc::c_int, optname: NetworkOpt,
                              optval: *mut libc::c_void,
                              optlen: *mut socklen_t) -> libc::c_int;
}
extern "C" {
    pub fn SOCU_GetIPInfo(ip: *mut in_addr, netmask: *mut in_addr,
                          broadcast: *mut in_addr) -> libc::c_int;
}
extern "C" {
    pub fn SOCU_AddGlobalSocket(sockfd: libc::c_int) -> libc::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum MICU_Encoding {
    MICU_ENCODING_PCM8 = 0,
    MICU_ENCODING_PCM16 = 1,
    MICU_ENCODING_PCM8_SIGNED = 2,
    MICU_ENCODING_PCM16_SIGNED = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum MICU_SampleRate {
    MICU_SAMPLE_RATE_32730 = 0,
    MICU_SAMPLE_RATE_16360 = 1,
    MICU_SAMPLE_RATE_10910 = 2,
    MICU_SAMPLE_RATE_8180 = 3,
}
extern "C" {
    pub fn micInit(buffer: *mut u8, bufferSize: u32) -> Result;
}
extern "C" {
    pub fn micExit();
}
extern "C" {
    pub fn micGetSampleDataSize() -> u32;
}
extern "C" {
    pub fn micGetLastSampleOffset() -> u32;
}
extern "C" {
    pub fn MICU_MapSharedMem(size: u32, handle: Handle) -> Result;
}
extern "C" {
    pub fn MICU_UnmapSharedMem() -> Result;
}
extern "C" {
    pub fn MICU_StartSampling(encoding: MICU_Encoding,
                              sampleRate: MICU_SampleRate, offset: u32,
                              size: u32, loop_: bool) -> Result;
}
extern "C" {
    pub fn MICU_AdjustSampling(sampleRate: MICU_SampleRate) -> Result;
}
extern "C" {
    pub fn MICU_StopSampling() -> Result;
}
extern "C" {
    pub fn MICU_IsSampling(sampling: *mut bool) -> Result;
}
extern "C" {
    pub fn MICU_GetEventHandle(handle: *mut Handle) -> Result;
}
extern "C" {
    pub fn MICU_SetGain(gain: u8) -> Result;
}
extern "C" {
    pub fn MICU_GetGain(gain: *mut u8) -> Result;
}
extern "C" {
    pub fn MICU_SetPower(power: bool) -> Result;
}
extern "C" {
    pub fn MICU_GetPower(power: *mut bool) -> Result;
}
extern "C" {
    pub fn MICU_SetClamp(clamp: bool) -> Result;
}
extern "C" {
    pub fn MICU_GetClamp(clamp: *mut bool) -> Result;
}
extern "C" {
    pub fn MICU_SetAllowShellClosed(allowShellClosed: bool) -> Result;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum MVDSTD_Mode {
    MVDMODE_COLORFORMATCONV = 0,
    MVDMODE_VIDEOPROCESSING = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum MVDSTD_InputFormat {
    MVD_INPUT_YUYV422 = 65537,
    MVD_INPUT_H264 = 131073,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum MVDSTD_OutputFormat {
    MVD_OUTPUT_YUYV422 = 65537,
    MVD_OUTPUT_BGR565 = 262146,
    MVD_OUTPUT_RGB565 = 262148,
}
#[repr(C)]
pub struct MVDSTD_Config {
    pub input_type: MVDSTD_InputFormat,
    pub unk_x04: u32,
    pub unk_x08: u32,
    pub inwidth: u32,
    pub inheight: u32,
    pub physaddr_colorconv_indata: u32,
    pub physaddr_colorconv_unk0: u32,
    pub physaddr_colorconv_unk1: u32,
    pub physaddr_colorconv_unk2: u32,
    pub physaddr_colorconv_unk3: u32,
    pub unk_x28: [u32; 6usize],
    pub enable_cropping: u32,
    pub input_crop_x_pos: u32,
    pub input_crop_y_pos: u32,
    pub input_crop_height: u32,
    pub input_crop_width: u32,
    pub unk_x54: u32,
    pub output_type: MVDSTD_OutputFormat,
    pub outwidth: u32,
    pub outheight: u32,
    pub physaddr_outdata0: u32,
    pub physaddr_outdata1: u32,
    pub unk_x6c: [u32; 38usize],
    pub flag_x104: u32,
    pub output_x_pos: u32,
    pub output_y_pos: u32,
    pub output_width_override: u32,
    pub output_height_override: u32,
    pub unk_x118: u32,
}
#[repr(C)]
#[derive(Copy)]
pub struct MVDSTD_ProcessNALUnitOut {
    pub end_vaddr: u32,
    pub end_physaddr: u32,
    pub remaining_size: u32,
}
impl Clone for MVDSTD_ProcessNALUnitOut {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct MVDSTD_OutputBuffersEntry {
    pub outdata0: *mut libc::c_void,
    pub outdata1: *mut libc::c_void,
}
impl Clone for MVDSTD_OutputBuffersEntry {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct MVDSTD_OutputBuffersEntryList {
    pub total_entries: u32,
    pub entries: [MVDSTD_OutputBuffersEntry; 17usize],
}
impl Clone for MVDSTD_OutputBuffersEntryList {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct MVDSTD_InitStruct {
    pub cmd5_inval0: s8,
    pub cmd5_inval1: s8,
    pub cmd5_inval2: s8,
    pub cmd5_inval3: u32,
    pub cmd1b_inval: u8,
}
impl Clone for MVDSTD_InitStruct {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn mvdstdInit(mode: MVDSTD_Mode, input_type: MVDSTD_InputFormat,
                      output_type: MVDSTD_OutputFormat, size: u32,
                      initstruct: *mut MVDSTD_InitStruct) -> Result;
}
extern "C" {
    pub fn mvdstdExit();
}
extern "C" {
    pub fn mvdstdGenerateDefaultConfig(config: *mut MVDSTD_Config,
                                       input_width: u32, input_height: u32,
                                       output_width: u32, output_height: u32,
                                       vaddr_colorconv_indata: *mut u32,
                                       vaddr_outdata0: *mut u32,
                                       vaddr_outdata1: *mut u32);
}
extern "C" {
    pub fn mvdstdConvertImage(config: *mut MVDSTD_Config) -> Result;
}
extern "C" {
    pub fn mvdstdProcessVideoFrame(inbuf_vaddr: *mut libc::c_void,
                                   size: usize, flag: u32,
                                   out: *mut MVDSTD_ProcessNALUnitOut)
     -> Result;
}
extern "C" {
    pub fn mvdstdRenderVideoFrame(config: *mut MVDSTD_Config, wait: bool)
     -> Result;
}
extern "C" {
    pub fn MVDSTD_SetConfig(config: *mut MVDSTD_Config) -> Result;
}
extern "C" {
    pub fn mvdstdSetupOutputBuffers(entrylist:
                                        *mut MVDSTD_OutputBuffersEntryList,
                                    bufsize: u32) -> Result;
}
extern "C" {
    pub fn mvdstdOverrideOutputBuffers(cur_outdata0: *mut libc::c_void,
                                       cur_outdata1: *mut libc::c_void,
                                       new_outdata0: *mut libc::c_void,
                                       new_outdata1: *mut libc::c_void)
     -> Result;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum NFC_OpType {
    NFC_OpType_1 = 1,
    NFC_OpType_NFCTag = 2,
    NFC_OpType_RawNFC = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum NFC_TagState {
    NFC_TagState_Uninitialized = 0,
    NFC_TagState_ScanningStopped = 1,
    NFC_TagState_Scanning = 2,
    NFC_TagState_InRange = 3,
    NFC_TagState_OutOfRange = 4,
    NFC_TagState_DataReady = 5,
}
pub const NFC_amiiboFlag_Setup: _bindgen_ty_22 =
    _bindgen_ty_22::NFC_amiiboFlag_Setup;
pub const NFC_amiiboFlag_AppDataSetup: _bindgen_ty_22 =
    _bindgen_ty_22::NFC_amiiboFlag_AppDataSetup;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_22 {
    NFC_amiiboFlag_Setup = 16,
    NFC_amiiboFlag_AppDataSetup = 32,
}
#[repr(C)]
pub struct NFC_TagInfo {
    pub id_offset_size: u16,
    pub unk_x2: u8,
    pub unk_x3: u8,
    pub id: [u8; 40usize],
}
#[repr(C)]
pub struct NFC_AmiiboSettings {
    pub mii: [u8; 96usize],
    pub nickname: [u16; 11usize],
    pub flags: u8,
    pub countrycodeid: u8,
    pub setupdate_year: u16,
    pub setupdate_month: u8,
    pub setupdate_day: u8,
    pub unk_x7c: [u8; 44usize],
}
#[repr(C)]
pub struct NFC_AmiiboConfig {
    pub lastwritedate_year: u16,
    pub lastwritedate_month: u8,
    pub lastwritedate_day: u8,
    pub write_counter: u16,
    pub characterID: [u8; 3usize],
    pub series: u8,
    pub amiiboID: u16,
    pub type_: u8,
    pub pagex4_byte3: u8,
    pub appdata_size: u16,
    pub zeros: [u8; 48usize],
}
#[repr(C)]
pub struct NFC_AppDataInitStruct {
    pub data_x0: [u8; 12usize],
    pub data_xc: [u8; 48usize],
}
#[repr(C)]
#[derive(Copy)]
pub struct NFC_AppDataWriteStruct {
    pub id: [u8; 10usize],
    pub id_size: u8,
    pub unused_xb: [u8; 21usize],
}
impl Clone for NFC_AppDataWriteStruct {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn nfcInit(type_: NFC_OpType) -> Result;
}
extern "C" {
    pub fn nfcExit();
}
extern "C" {
    pub fn nfcGetSessionHandle() -> Handle;
}
extern "C" {
    pub fn nfcStartScanning(inval: u16) -> Result;
}
extern "C" {
    pub fn nfcStopScanning();
}
extern "C" {
    pub fn nfcLoadAmiiboData() -> Result;
}
extern "C" {
    pub fn nfcResetTagScanState() -> Result;
}
extern "C" {
    pub fn nfcUpdateStoredAmiiboData() -> Result;
}
extern "C" {
    pub fn nfcGetTagState(state: *mut NFC_TagState) -> Result;
}
extern "C" {
    pub fn nfcGetTagInfo(out: *mut NFC_TagInfo) -> Result;
}
extern "C" {
    pub fn nfcOpenAppData(amiibo_appid: u32) -> Result;
}
extern "C" {
    pub fn nfcInitializeWriteAppData(amiibo_appid: u32,
                                     buf: *const libc::c_void, size: usize)
     -> Result;
}
extern "C" {
    pub fn nfcReadAppData(buf: *mut libc::c_void, size: usize) -> Result;
}
extern "C" {
    pub fn nfcWriteAppData(buf: *const libc::c_void, size: usize,
                           taginfo: *mut NFC_TagInfo) -> Result;
}
extern "C" {
    pub fn nfcGetAmiiboSettings(out: *mut NFC_AmiiboSettings) -> Result;
}
extern "C" {
    pub fn nfcGetAmiiboConfig(out: *mut NFC_AmiiboConfig) -> Result;
}
extern "C" {
    pub fn nfcStartOtherTagScanning(unk0: u16, unk1: u32) -> Result;
}
extern "C" {
    pub fn nfcSendTagCommand(inbuf: *const libc::c_void, insize: usize,
                             outbuf: *mut libc::c_void, outsize: usize,
                             actual_transfer_size: *mut usize,
                             microseconds: u64) -> Result;
}
extern "C" {
    pub fn nfcCmd21() -> Result;
}
extern "C" {
    pub fn nfcCmd22() -> Result;
}
#[repr(C)]
#[derive(Copy)]
pub struct NotificationHeader {
    pub dataSet: bool,
    pub unread: bool,
    pub enableJPEG: bool,
    pub isSpotPass: bool,
    pub isOptedOut: bool,
    pub unkData: [u8; 3usize],
    pub processID: u64,
    pub unkData2: [u8; 8usize],
    pub jumpParam: u64,
    pub unkData3: [u8; 8usize],
    pub time: u64,
    pub title: [u16; 32usize],
}
impl Clone for NotificationHeader {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn newsInit() -> Result;
}
extern "C" {
    pub fn newsExit();
}
extern "C" {
    pub fn NEWS_AddNotification(title: *const u16, titleLength: u32,
                                message: *const u16, messageLength: u32,
                                imageData: *const libc::c_void,
                                imageSize: u32, jpeg: bool) -> Result;
}
extern "C" {
    pub fn NEWS_GetTotalNotifications(num: *mut u32) -> Result;
}
extern "C" {
    pub fn NEWS_SetNotificationHeader(news_id: u32,
                                      header: *const NotificationHeader)
     -> Result;
}
extern "C" {
    pub fn NEWS_GetNotificationHeader(news_id: u32,
                                      header: *mut NotificationHeader)
     -> Result;
}
extern "C" {
    pub fn NEWS_SetNotificationMessage(news_id: u32, message: *const u16,
                                       size: u32) -> Result;
}
extern "C" {
    pub fn NEWS_GetNotificationMessage(news_id: u32, message: *mut u16,
                                       size: *mut u32) -> Result;
}
extern "C" {
    pub fn NEWS_SetNotificationImage(news_id: u32,
                                     buffer: *const libc::c_void, size: u32)
     -> Result;
}
extern "C" {
    pub fn NEWS_GetNotificationImage(news_id: u32, buffer: *mut libc::c_void,
                                     size: *mut u32) -> Result;
}
#[repr(C)]
#[derive(Copy)]
pub struct QTM_HeadTrackingInfoCoord {
    pub x: f32,
    pub y: f32,
}
impl Clone for QTM_HeadTrackingInfoCoord {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct QTM_HeadTrackingInfo {
    pub flags: [u8; 5usize],
    pub padding: [u8; 3usize],
    pub floatdata_x08: f32,
    pub coords0: [QTM_HeadTrackingInfoCoord; 4usize],
    pub unk_x2c: [u32; 5usize],
}
impl Clone for QTM_HeadTrackingInfo {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn qtmInit() -> Result;
}
extern "C" {
    pub fn qtmExit();
}
extern "C" {
    pub fn qtmCheckInitialized() -> bool;
}
extern "C" {
    pub fn qtmCheckHeadFullyDetected(info: *mut QTM_HeadTrackingInfo) -> bool;
}
extern "C" {
    pub fn qtmConvertCoordToScreen(coord: *mut QTM_HeadTrackingInfoCoord,
                                   screen_width: *mut f32,
                                   screen_height: *mut f32, x: *mut u32,
                                   y: *mut u32) -> Result;
}
extern "C" {
    pub fn QTM_GetHeadTrackingInfo(val: u64, out: *mut QTM_HeadTrackingInfo)
     -> Result;
}
extern "C" {
    pub fn srvPmInit() -> Result;
}
extern "C" {
    pub fn srvPmExit();
}
extern "C" {
    pub fn SRVPM_PublishToProcess(notificationId: u32, process: Handle)
     -> Result;
}
extern "C" {
    pub fn SRVPM_PublishToAll(notificationId: u32) -> Result;
}
extern "C" {
    pub fn SRVPM_RegisterProcess(procid: u32, count: u32,
                                 serviceaccesscontrol: *mut libc::c_void)
     -> Result;
}
extern "C" {
    pub fn SRVPM_UnregisterProcess(procid: u32) -> Result;
}
extern "C" {
    pub fn hbInit() -> Result;
}
extern "C" {
    pub fn hbExit();
}
extern "C" {
    pub fn HB_FlushInvalidateCache() -> Result;
}
extern "C" {
    pub fn HB_GetBootloaderAddresses(load3dsx: *mut *mut libc::c_void,
                                     setArgv: *mut *mut libc::c_void)
     -> Result;
}
extern "C" {
    pub fn HB_ReprotectMemory(addr: *mut u32, pages: u32, mode: u32,
                              reprotectedPages: *mut u32) -> Result;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GX_TRANSFER_FORMAT {
    GX_TRANSFER_FMT_RGBA8 = 0,
    GX_TRANSFER_FMT_RGB8 = 1,
    GX_TRANSFER_FMT_RGB565 = 2,
    GX_TRANSFER_FMT_RGB5A1 = 3,
    GX_TRANSFER_FMT_RGBA4 = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GX_TRANSFER_SCALE {
    GX_TRANSFER_SCALE_NO = 0,
    GX_TRANSFER_SCALE_X = 1,
    GX_TRANSFER_SCALE_XY = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GX_FILL_CONTROL {
    GX_FILL_TRIGGER = 1,
    GX_FILL_FINISHED = 2,
    GX_FILL_16BIT_DEPTH = 0,
    GX_FILL_24BIT_DEPTH = 256,
    GX_FILL_32BIT_DEPTH = 512,
}
extern "C" {
    pub static mut gxCmdBuf: *mut u32;
}
#[repr(C)]
#[derive(Copy)]
pub union gxCmdEntry_s {
    pub data: [u32; 8usize],
    pub __bindgen_anon_1: gxCmdEntry_s__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub struct gxCmdEntry_s__bindgen_ty_1 {
    pub type_: u8,
    pub unk1: u8,
    pub unk2: u8,
    pub unk3: u8,
    pub args: [u32; 7usize],
}
impl Clone for gxCmdEntry_s__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Clone for gxCmdEntry_s {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct tag_gxCmdQueue_s {
    pub entries: *mut gxCmdEntry_s,
    pub maxEntries: u16,
    pub numEntries: u16,
    pub curEntry: u16,
    pub lastEntry: u16,
    pub callback: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                  *mut tag_gxCmdQueue_s)>,
    pub user: *mut libc::c_void,
}
impl Clone for tag_gxCmdQueue_s {
    fn clone(&self) -> Self { *self }
}
pub type gxCmdQueue_s = tag_gxCmdQueue_s;
extern "C" {
    pub fn gxCmdQueueClear(queue: *mut gxCmdQueue_s);
}
extern "C" {
    pub fn gxCmdQueueAdd(queue: *mut gxCmdQueue_s,
                         entry: *const gxCmdEntry_s);
}
extern "C" {
    pub fn gxCmdQueueRun(queue: *mut gxCmdQueue_s);
}
extern "C" {
    pub fn gxCmdQueueStop(queue: *mut gxCmdQueue_s);
}
extern "C" {
    pub fn gxCmdQueueWait(queue: *mut gxCmdQueue_s, timeout: s64) -> bool;
}
extern "C" {
    pub fn GX_BindQueue(queue: *mut gxCmdQueue_s);
}
extern "C" {
    pub fn GX_RequestDma(src: *mut u32, dst: *mut u32, length: u32) -> Result;
}
extern "C" {
    pub fn GX_ProcessCommandList(buf0a: *mut u32, buf0s: u32, flags: u8)
     -> Result;
}
extern "C" {
    pub fn GX_MemoryFill(buf0a: *mut u32, buf0v: u32, buf0e: *mut u32,
                         control0: u16, buf1a: *mut u32, buf1v: u32,
                         buf1e: *mut u32, control1: u16) -> Result;
}
extern "C" {
    pub fn GX_DisplayTransfer(inadr: *mut u32, indim: u32, outadr: *mut u32,
                              outdim: u32, flags: u32) -> Result;
}
extern "C" {
    pub fn GX_TextureCopy(inadr: *mut u32, indim: u32, outadr: *mut u32,
                          outdim: u32, size: u32, flags: u32) -> Result;
}
extern "C" {
    pub fn GX_FlushCacheRegions(buf0a: *mut u32, buf0s: u32, buf1a: *mut u32,
                                buf1s: u32, buf2a: *mut u32, buf2s: u32)
     -> Result;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GPU_TEXTURE_FILTER_PARAM { GPU_NEAREST = 0, GPU_LINEAR = 1, }
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GPU_TEXTURE_WRAP_PARAM {
    GPU_CLAMP_TO_EDGE = 0,
    GPU_CLAMP_TO_BORDER = 1,
    GPU_REPEAT = 2,
    GPU_MIRRORED_REPEAT = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GPU_TEXTURE_MODE_PARAM {
    GPU_TEX_2D = 0,
    GPU_TEX_CUBE_MAP = 1,
    GPU_TEX_SHADOW_2D = 2,
    GPU_TEX_PROJECTION = 3,
    GPU_TEX_SHADOW_CUBE = 4,
    GPU_TEX_DISABLED = 5,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GPU_TEXUNIT { GPU_TEXUNIT0 = 1, GPU_TEXUNIT1 = 2, GPU_TEXUNIT2 = 4, }
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GPU_TEXCOLOR {
    GPU_RGBA8 = 0,
    GPU_RGB8 = 1,
    GPU_RGBA5551 = 2,
    GPU_RGB565 = 3,
    GPU_RGBA4 = 4,
    GPU_LA8 = 5,
    GPU_HILO8 = 6,
    GPU_L8 = 7,
    GPU_A8 = 8,
    GPU_LA4 = 9,
    GPU_L4 = 10,
    GPU_A4 = 11,
    GPU_ETC1 = 12,
    GPU_ETC1A4 = 13,
}
pub const GPU_POSITIVE_X: GPU_TEXFACE = GPU_TEXFACE::GPU_TEXFACE_2D;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GPU_TEXFACE {
    GPU_TEXFACE_2D = 0,
    GPU_NEGATIVE_X = 1,
    GPU_POSITIVE_Y = 2,
    GPU_NEGATIVE_Y = 3,
    GPU_POSITIVE_Z = 4,
    GPU_NEGATIVE_Z = 5,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GPU_PROCTEX_CLAMP {
    GPU_PT_CLAMP_TO_ZERO = 0,
    GPU_PT_CLAMP_TO_EDGE = 1,
    GPU_PT_REPEAT = 2,
    GPU_PT_MIRRORED_REPEAT = 3,
    GPU_PT_PULSE = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GPU_PROCTEX_MAPFUNC {
    GPU_PT_U = 0,
    GPU_PT_U2 = 1,
    GPU_PT_V = 2,
    GPU_PT_V2 = 3,
    GPU_PT_ADD = 4,
    GPU_PT_ADD2 = 5,
    GPU_PT_SQRT2 = 6,
    GPU_PT_MIN = 7,
    GPU_PT_MAX = 8,
    GPU_PT_RMAX = 9,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GPU_PROCTEX_SHIFT {
    GPU_PT_NONE = 0,
    GPU_PT_ODD = 1,
    GPU_PT_EVEN = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GPU_PROCTEX_FILTER {
    GPU_PT_NEAREST = 0,
    GPU_PT_LINEAR = 1,
    GPU_PT_NEAREST_MIP_NEAREST = 2,
    GPU_PT_LINEAR_MIP_NEAREST = 3,
    GPU_PT_NEAREST_MIP_LINEAR = 4,
    GPU_PT_LINEAR_MIP_LINEAR = 5,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GPU_PROCTEX_LUTID {
    GPU_LUT_NOISE = 0,
    GPU_LUT_RGBMAP = 2,
    GPU_LUT_ALPHAMAP = 3,
    GPU_LUT_COLOR = 4,
    GPU_LUT_COLORDIF = 5,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GPU_COLORBUF {
    GPU_RB_RGBA8 = 0,
    GPU_RB_RGB8 = 1,
    GPU_RB_RGBA5551 = 2,
    GPU_RB_RGB565 = 3,
    GPU_RB_RGBA4 = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GPU_DEPTHBUF {
    GPU_RB_DEPTH16 = 0,
    GPU_RB_DEPTH24 = 2,
    GPU_RB_DEPTH24_STENCIL8 = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GPU_TESTFUNC {
    GPU_NEVER = 0,
    GPU_ALWAYS = 1,
    GPU_EQUAL = 2,
    GPU_NOTEQUAL = 3,
    GPU_LESS = 4,
    GPU_LEQUAL = 5,
    GPU_GREATER = 6,
    GPU_GEQUAL = 7,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GPU_EARLYDEPTHFUNC {
    GPU_EARLYDEPTH_GEQUAL = 0,
    GPU_EARLYDEPTH_GREATER = 1,
    GPU_EARLYDEPTH_LEQUAL = 2,
    GPU_EARLYDEPTH_LESS = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GPU_SCISSORMODE {
    GPU_SCISSOR_DISABLE = 0,
    GPU_SCISSOR_INVERT = 1,
    GPU_SCISSOR_NORMAL = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GPU_STENCILOP {
    GPU_STENCIL_KEEP = 0,
    GPU_STENCIL_ZERO = 1,
    GPU_STENCIL_REPLACE = 2,
    GPU_STENCIL_INCR = 3,
    GPU_STENCIL_DECR = 4,
    GPU_STENCIL_INVERT = 5,
    GPU_STENCIL_INCR_WRAP = 6,
    GPU_STENCIL_DECR_WRAP = 7,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GPU_WRITEMASK {
    GPU_WRITE_RED = 1,
    GPU_WRITE_GREEN = 2,
    GPU_WRITE_BLUE = 4,
    GPU_WRITE_ALPHA = 8,
    GPU_WRITE_DEPTH = 16,
    GPU_WRITE_COLOR = 15,
    GPU_WRITE_ALL = 31,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GPU_BLENDEQUATION {
    GPU_BLEND_ADD = 0,
    GPU_BLEND_SUBTRACT = 1,
    GPU_BLEND_REVERSE_SUBTRACT = 2,
    GPU_BLEND_MIN = 3,
    GPU_BLEND_MAX = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GPU_BLENDFACTOR {
    GPU_ZERO = 0,
    GPU_ONE = 1,
    GPU_SRC_COLOR = 2,
    GPU_ONE_MINUS_SRC_COLOR = 3,
    GPU_DST_COLOR = 4,
    GPU_ONE_MINUS_DST_COLOR = 5,
    GPU_SRC_ALPHA = 6,
    GPU_ONE_MINUS_SRC_ALPHA = 7,
    GPU_DST_ALPHA = 8,
    GPU_ONE_MINUS_DST_ALPHA = 9,
    GPU_CONSTANT_COLOR = 10,
    GPU_ONE_MINUS_CONSTANT_COLOR = 11,
    GPU_CONSTANT_ALPHA = 12,
    GPU_ONE_MINUS_CONSTANT_ALPHA = 13,
    GPU_SRC_ALPHA_SATURATE = 14,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GPU_LOGICOP {
    GPU_LOGICOP_CLEAR = 0,
    GPU_LOGICOP_AND = 1,
    GPU_LOGICOP_AND_REVERSE = 2,
    GPU_LOGICOP_COPY = 3,
    GPU_LOGICOP_SET = 4,
    GPU_LOGICOP_COPY_INVERTED = 5,
    GPU_LOGICOP_NOOP = 6,
    GPU_LOGICOP_INVERT = 7,
    GPU_LOGICOP_NAND = 8,
    GPU_LOGICOP_OR = 9,
    GPU_LOGICOP_NOR = 10,
    GPU_LOGICOP_XOR = 11,
    GPU_LOGICOP_EQUIV = 12,
    GPU_LOGICOP_AND_INVERTED = 13,
    GPU_LOGICOP_OR_REVERSE = 14,
    GPU_LOGICOP_OR_INVERTED = 15,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GPU_FRAGOPMODE {
    GPU_FRAGOPMODE_GL = 0,
    GPU_FRAGOPMODE_GAS_ACC = 1,
    GPU_FRAGOPMODE_SHADOW = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GPU_FORMATS {
    GPU_BYTE = 0,
    GPU_UNSIGNED_BYTE = 1,
    GPU_SHORT = 2,
    GPU_FLOAT = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GPU_CULLMODE {
    GPU_CULL_NONE = 0,
    GPU_CULL_FRONT_CCW = 1,
    GPU_CULL_BACK_CCW = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GPU_TEVSRC {
    GPU_PRIMARY_COLOR = 0,
    GPU_FRAGMENT_PRIMARY_COLOR = 1,
    GPU_FRAGMENT_SECONDARY_COLOR = 2,
    GPU_TEXTURE0 = 3,
    GPU_TEXTURE1 = 4,
    GPU_TEXTURE2 = 5,
    GPU_TEXTURE3 = 6,
    GPU_PREVIOUS_BUFFER = 13,
    GPU_CONSTANT = 14,
    GPU_PREVIOUS = 15,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GPU_TEVOP_RGB {
    GPU_TEVOP_RGB_SRC_COLOR = 0,
    GPU_TEVOP_RGB_ONE_MINUS_SRC_COLOR = 1,
    GPU_TEVOP_RGB_SRC_ALPHA = 2,
    GPU_TEVOP_RGB_ONE_MINUS_SRC_ALPHA = 3,
    GPU_TEVOP_RGB_SRC_R = 4,
    GPU_TEVOP_RGB_ONE_MINUS_SRC_R = 5,
    GPU_TEVOP_RGB_0x06 = 6,
    GPU_TEVOP_RGB_0x07 = 7,
    GPU_TEVOP_RGB_SRC_G = 8,
    GPU_TEVOP_RGB_ONE_MINUS_SRC_G = 9,
    GPU_TEVOP_RGB_0x0A = 10,
    GPU_TEVOP_RGB_0x0B = 11,
    GPU_TEVOP_RGB_SRC_B = 12,
    GPU_TEVOP_RGB_ONE_MINUS_SRC_B = 13,
    GPU_TEVOP_RGB_0x0E = 14,
    GPU_TEVOP_RGB_0x0F = 15,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GPU_TEVOP_A {
    GPU_TEVOP_A_SRC_ALPHA = 0,
    GPU_TEVOP_A_ONE_MINUS_SRC_ALPHA = 1,
    GPU_TEVOP_A_SRC_R = 2,
    GPU_TEVOP_A_ONE_MINUS_SRC_R = 3,
    GPU_TEVOP_A_SRC_G = 4,
    GPU_TEVOP_A_ONE_MINUS_SRC_G = 5,
    GPU_TEVOP_A_SRC_B = 6,
    GPU_TEVOP_A_ONE_MINUS_SRC_B = 7,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GPU_COMBINEFUNC {
    GPU_REPLACE = 0,
    GPU_MODULATE = 1,
    GPU_ADD = 2,
    GPU_ADD_SIGNED = 3,
    GPU_INTERPOLATE = 4,
    GPU_SUBTRACT = 5,
    GPU_DOT3_RGB = 6,
    GPU_MULTIPLY_ADD = 8,
    GPU_ADD_MULTIPLY = 9,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GPU_TEVSCALE {
    GPU_TEVSCALE_1 = 0,
    GPU_TEVSCALE_2 = 1,
    GPU_TEVSCALE_4 = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GPU_FRESNELSEL {
    GPU_NO_FRESNEL = 0,
    GPU_PRI_ALPHA_FRESNEL = 1,
    GPU_SEC_ALPHA_FRESNEL = 2,
    GPU_PRI_SEC_ALPHA_FRESNEL = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GPU_BUMPMODE {
    GPU_BUMP_NOT_USED = 0,
    GPU_BUMP_AS_BUMP = 1,
    GPU_BUMP_AS_TANG = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GPU_LIGHTLUTID {
    GPU_LUT_D0 = 0,
    GPU_LUT_D1 = 1,
    GPU_LUT_SP = 2,
    GPU_LUT_FR = 3,
    GPU_LUT_RB = 4,
    GPU_LUT_RG = 5,
    GPU_LUT_RR = 6,
    GPU_LUT_DA = 7,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GPU_LIGHTLUTINPUT {
    GPU_LUTINPUT_NH = 0,
    GPU_LUTINPUT_VH = 1,
    GPU_LUTINPUT_NV = 2,
    GPU_LUTINPUT_LN = 3,
    GPU_LUTINPUT_SP = 4,
    GPU_LUTINPUT_CP = 5,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GPU_LIGHTLUTSCALER {
    GPU_LUTSCALER_1x = 0,
    GPU_LUTSCALER_2x = 1,
    GPU_LUTSCALER_4x = 2,
    GPU_LUTSCALER_8x = 3,
    GPU_LUTSCALER_0_25x = 6,
    GPU_LUTSCALER_0_5x = 7,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GPU_LIGHTLUTSELECT {
    GPU_LUTSELECT_COMMON = 0,
    GPU_LUTSELECT_SP = 1,
    GPU_LUTSELECT_DA = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GPU_FOGMODE { GPU_NO_FOG = 0, GPU_FOG = 5, GPU_GAS = 7, }
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GPU_GASMODE { GPU_PLAIN_DENSITY = 0, GPU_DEPTH_DENSITY = 1, }
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GPU_GASLUTINPUT { GPU_GAS_DENSITY = 0, GPU_GAS_LIGHT_FACTOR = 1, }
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GPU_Primitive_t {
    GPU_TRIANGLES = 0,
    GPU_TRIANGLE_STRIP = 256,
    GPU_TRIANGLE_FAN = 512,
    GPU_GEOMETRY_PRIM = 768,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GPU_SHADER_TYPE { GPU_VERTEX_SHADER = 0, GPU_GEOMETRY_SHADER = 1, }
extern "C" {
    pub static mut gpuCmdBuf: *mut u32;
}
extern "C" {
    pub static mut gpuCmdBufSize: u32;
}
extern "C" {
    pub static mut gpuCmdBufOffset: u32;
}
extern "C" {
    pub fn GPUCMD_AddRawCommands(cmd: *const u32, size: u32);
}
extern "C" {
    pub fn GPUCMD_Run();
}
extern "C" {
    pub fn GPUCMD_FlushAndRun();
}
extern "C" {
    pub fn GPUCMD_Add(header: u32, param: *const u32, paramlength: u32);
}
extern "C" {
    pub fn GPUCMD_Split(addr: *mut *mut u32, size: *mut u32);
}
extern "C" {
    pub fn GPUCMD_Finalize();
}
extern "C" {
    pub fn f32tof16(f: f32) -> u32;
}
extern "C" {
    pub fn f32tof20(f: f32) -> u32;
}
extern "C" {
    pub fn f32tof24(f: f32) -> u32;
}
extern "C" {
    pub fn f32tof31(f: f32) -> u32;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum DVLE_type { VERTEX_SHDR = 0, GEOMETRY_SHDR = 1, }
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum DVLE_constantType {
    DVLE_CONST_BOOL = 0,
    DVLE_CONST_u8 = 1,
    DVLE_CONST_FLOAT24 = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum DVLE_outputAttribute_t {
    RESULT_POSITION = 0,
    RESULT_NORMALQUAT = 1,
    RESULT_COLOR = 2,
    RESULT_TEXCOORD0 = 3,
    RESULT_TEXCOORD0W = 4,
    RESULT_TEXCOORD1 = 5,
    RESULT_TEXCOORD2 = 6,
    RESULT_VIEW = 8,
    RESULT_DUMMY = 9,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum DVLE_geoShaderMode {
    GSH_POINT = 0,
    GSH_VARIABLE_PRIM = 1,
    GSH_FIXED_PRIM = 2,
}
#[repr(C)]
#[derive(Copy)]
pub struct DVLP_s {
    pub codeSize: u32,
    pub codeData: *mut u32,
    pub opdescSize: u32,
    pub opcdescData: *mut u32,
}
impl Clone for DVLP_s {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct DVLE_constEntry_s {
    pub type_: u16,
    pub id: u16,
    pub data: [u32; 4usize],
}
impl Clone for DVLE_constEntry_s {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct DVLE_outEntry_s {
    pub type_: u16,
    pub regID: u16,
    pub mask: u8,
    pub unk: [u8; 3usize],
}
impl Clone for DVLE_outEntry_s {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct DVLE_uniformEntry_s {
    pub symbolOffset: u32,
    pub startReg: u16,
    pub endReg: u16,
}
impl Clone for DVLE_uniformEntry_s {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct DVLE_s {
    pub type_: DVLE_type,
    pub mergeOutmaps: bool,
    pub gshMode: DVLE_geoShaderMode,
    pub gshFixedVtxStart: u8,
    pub gshVariableVtxNum: u8,
    pub gshFixedVtxNum: u8,
    pub dvlp: *mut DVLP_s,
    pub mainOffset: u32,
    pub endmainOffset: u32,
    pub constTableSize: u32,
    pub constTableData: *mut DVLE_constEntry_s,
    pub outTableSize: u32,
    pub outTableData: *mut DVLE_outEntry_s,
    pub uniformTableSize: u32,
    pub uniformTableData: *mut DVLE_uniformEntry_s,
    pub symbolTableData: *mut libc::c_char,
    pub outmapMask: u8,
    pub outmapData: [u32; 8usize],
    pub outmapMode: u32,
    pub outmapClock: u32,
}
impl Clone for DVLE_s {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct DVLB_s {
    pub numDVLE: u32,
    pub DVLP: DVLP_s,
    pub DVLE: *mut DVLE_s,
}
impl Clone for DVLB_s {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn DVLB_ParseFile(shbinData: *mut u32, shbinSize: u32) -> *mut DVLB_s;
}
extern "C" {
    pub fn DVLB_Free(dvlb: *mut DVLB_s);
}
extern "C" {
    pub fn DVLE_GetUniformRegister(dvle: *mut DVLE_s,
                                   name: *const libc::c_char) -> s8;
}
extern "C" {
    pub fn DVLE_GenerateOutmap(dvle: *mut DVLE_s);
}
#[repr(C)]
#[derive(Copy)]
pub struct float24Uniform_s {
    pub id: u32,
    pub data: [u32; 3usize],
}
impl Clone for float24Uniform_s {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct shaderInstance_s {
    pub dvle: *mut DVLE_s,
    pub boolUniforms: u16,
    pub boolUniformMask: u16,
    pub intUniforms: [u32; 4usize],
    pub float24Uniforms: *mut float24Uniform_s,
    pub intUniformMask: u8,
    pub numFloat24Uniforms: u8,
}
impl Clone for shaderInstance_s {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct shaderProgram_s {
    pub vertexShader: *mut shaderInstance_s,
    pub geometryShader: *mut shaderInstance_s,
    pub geoShaderInputPermutation: [u32; 2usize],
    pub geoShaderInputStride: u8,
}
impl Clone for shaderProgram_s {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn shaderInstanceInit(si: *mut shaderInstance_s, dvle: *mut DVLE_s)
     -> Result;
}
extern "C" {
    pub fn shaderInstanceFree(si: *mut shaderInstance_s) -> Result;
}
extern "C" {
    pub fn shaderInstanceSetBool(si: *mut shaderInstance_s, id: libc::c_int,
                                 value: bool) -> Result;
}
extern "C" {
    pub fn shaderInstanceGetBool(si: *mut shaderInstance_s, id: libc::c_int,
                                 value: *mut bool) -> Result;
}
extern "C" {
    pub fn shaderInstanceGetUniformLocation(si: *mut shaderInstance_s,
                                            name: *const libc::c_char) -> s8;
}
extern "C" {
    pub fn shaderProgramInit(sp: *mut shaderProgram_s) -> Result;
}
extern "C" {
    pub fn shaderProgramFree(sp: *mut shaderProgram_s) -> Result;
}
extern "C" {
    pub fn shaderProgramSetVsh(sp: *mut shaderProgram_s, dvle: *mut DVLE_s)
     -> Result;
}
extern "C" {
    pub fn shaderProgramSetGsh(sp: *mut shaderProgram_s, dvle: *mut DVLE_s,
                               stride: u8) -> Result;
}
extern "C" {
    pub fn shaderProgramSetGshInputPermutation(sp: *mut shaderProgram_s,
                                               permutation: u64) -> Result;
}
extern "C" {
    pub fn shaderProgramConfigure(sp: *mut shaderProgram_s, sendVshCode: bool,
                                  sendGshCode: bool) -> Result;
}
extern "C" {
    pub fn shaderProgramUse(sp: *mut shaderProgram_s) -> Result;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ndspOutputMode {
    NDSP_OUTPUT_MONO = 0,
    NDSP_OUTPUT_STEREO = 1,
    NDSP_OUTPUT_SURROUND = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ndspClippingMode { NDSP_CLIP_NORMAL = 0, NDSP_CLIP_SOFT = 1, }
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ndspSpeakerPos {
    NDSP_SPKPOS_SQUARE = 0,
    NDSP_SPKPOS_WIDE = 1,
    NDSP_SPKPOS_NUM = 2,
}
#[repr(C)]
#[derive(Copy)]
pub struct ndspAdpcmData {
    pub index: u16,
    pub history0: s16,
    pub history1: s16,
}
impl Clone for ndspAdpcmData {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct tag_ndspWaveBuf {
    pub __bindgen_anon_1: tag_ndspWaveBuf__bindgen_ty_1,
    pub nsamples: u32,
    pub adpcm_data: *mut ndspAdpcmData,
    pub offset: u32,
    pub looping: bool,
    pub status: u8,
    pub sequence_id: u16,
    pub next: *mut ndspWaveBuf,
}
#[repr(C)]
#[derive(Copy)]
pub union tag_ndspWaveBuf__bindgen_ty_1 {
    pub data_pcm8: *mut s8,
    pub data_pcm16: *mut s16,
    pub data_adpcm: *mut u8,
    pub data_vaddr: *const libc::c_void,
}
impl Clone for tag_ndspWaveBuf__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Clone for tag_ndspWaveBuf {
    fn clone(&self) -> Self { *self }
}
pub type ndspWaveBuf = tag_ndspWaveBuf;
pub const NDSP_WBUF_FREE: _bindgen_ty_23 = _bindgen_ty_23::NDSP_WBUF_FREE;
pub const NDSP_WBUF_QUEUED: _bindgen_ty_23 = _bindgen_ty_23::NDSP_WBUF_QUEUED;
pub const NDSP_WBUF_PLAYING: _bindgen_ty_23 =
    _bindgen_ty_23::NDSP_WBUF_PLAYING;
pub const NDSP_WBUF_DONE: _bindgen_ty_23 = _bindgen_ty_23::NDSP_WBUF_DONE;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_23 {
    NDSP_WBUF_FREE = 0,
    NDSP_WBUF_QUEUED = 1,
    NDSP_WBUF_PLAYING = 2,
    NDSP_WBUF_DONE = 3,
}
pub type ndspCallback =
    ::core::option::Option<unsafe extern "C" fn(data: *mut libc::c_void)>;
pub type ndspAuxCallback =
    ::core::option::Option<unsafe extern "C" fn(data: *mut libc::c_void,
                                                nsamples: libc::c_int,
                                                samples:
                                                    *mut *mut libc::c_void)>;
extern "C" {
    pub fn ndspUseComponent(binary: *const libc::c_void, size: u32,
                            progMask: u16, dataMask: u16);
}
extern "C" {
    pub fn ndspInit() -> Result;
}
extern "C" {
    pub fn ndspExit();
}
extern "C" {
    pub fn ndspGetDroppedFrames() -> u32;
}
extern "C" {
    pub fn ndspGetFrameCount() -> u32;
}
extern "C" {
    pub fn ndspSetMasterVol(volume: f32);
}
extern "C" {
    pub fn ndspSetOutputMode(mode: ndspOutputMode);
}
extern "C" {
    pub fn ndspSetClippingMode(mode: ndspClippingMode);
}
extern "C" {
    pub fn ndspSetOutputCount(count: libc::c_int);
}
extern "C" {
    pub fn ndspSetCapture(capture: *mut ndspWaveBuf);
}
extern "C" {
    pub fn ndspSetCallback(callback: ndspCallback, data: *mut libc::c_void);
}
extern "C" {
    pub fn ndspSurroundSetDepth(depth: u16);
}
extern "C" {
    pub fn ndspSurroundSetPos(pos: ndspSpeakerPos);
}
extern "C" {
    pub fn ndspSurroundSetRearRatio(ratio: u16);
}
extern "C" {
    pub fn ndspAuxSetEnable(id: libc::c_int, enable: bool);
}
extern "C" {
    pub fn ndspAuxSetFrontBypass(id: libc::c_int, bypass: bool);
}
extern "C" {
    pub fn ndspAuxSetVolume(id: libc::c_int, volume: f32);
}
extern "C" {
    pub fn ndspAuxSetCallback(id: libc::c_int, callback: ndspAuxCallback,
                              data: *mut libc::c_void);
}
pub const NDSP_ENCODING_PCM8: _bindgen_ty_24 =
    _bindgen_ty_24::NDSP_ENCODING_PCM8;
pub const NDSP_ENCODING_PCM16: _bindgen_ty_24 =
    _bindgen_ty_24::NDSP_ENCODING_PCM16;
pub const NDSP_ENCODING_ADPCM: _bindgen_ty_24 =
    _bindgen_ty_24::NDSP_ENCODING_ADPCM;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_24 {
    NDSP_ENCODING_PCM8 = 0,
    NDSP_ENCODING_PCM16 = 1,
    NDSP_ENCODING_ADPCM = 2,
}
pub const NDSP_FORMAT_MONO_PCM8: _bindgen_ty_25 =
    _bindgen_ty_25::NDSP_FORMAT_MONO_PCM8;
pub const NDSP_FORMAT_MONO_PCM16: _bindgen_ty_25 =
    _bindgen_ty_25::NDSP_FORMAT_MONO_PCM16;
pub const NDSP_FORMAT_MONO_ADPCM: _bindgen_ty_25 =
    _bindgen_ty_25::NDSP_FORMAT_MONO_ADPCM;
pub const NDSP_FORMAT_STEREO_PCM8: _bindgen_ty_25 =
    _bindgen_ty_25::NDSP_FORMAT_STEREO_PCM8;
pub const NDSP_FORMAT_STEREO_PCM16: _bindgen_ty_25 =
    _bindgen_ty_25::NDSP_FORMAT_STEREO_PCM16;
pub const NDSP_FORMAT_PCM8: _bindgen_ty_25 =
    _bindgen_ty_25::NDSP_FORMAT_MONO_PCM8;
pub const NDSP_FORMAT_PCM16: _bindgen_ty_25 =
    _bindgen_ty_25::NDSP_FORMAT_MONO_PCM16;
pub const NDSP_FORMAT_ADPCM: _bindgen_ty_25 =
    _bindgen_ty_25::NDSP_FORMAT_MONO_ADPCM;
pub const NDSP_FRONT_BYPASS: _bindgen_ty_25 =
    _bindgen_ty_25::NDSP_FRONT_BYPASS;
pub const NDSP_3D_SURROUND_PREPROCESSED: _bindgen_ty_25 =
    _bindgen_ty_25::NDSP_3D_SURROUND_PREPROCESSED;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_25 {
    NDSP_FORMAT_MONO_PCM8 = 1,
    NDSP_FORMAT_MONO_PCM16 = 5,
    NDSP_FORMAT_MONO_ADPCM = 9,
    NDSP_FORMAT_STEREO_PCM8 = 2,
    NDSP_FORMAT_STEREO_PCM16 = 6,
    NDSP_FRONT_BYPASS = 16,
    NDSP_3D_SURROUND_PREPROCESSED = 64,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ndspInterpType {
    NDSP_INTERP_POLYPHASE = 0,
    NDSP_INTERP_LINEAR = 1,
    NDSP_INTERP_NONE = 2,
}
extern "C" {
    pub fn ndspChnReset(id: libc::c_int);
}
extern "C" {
    pub fn ndspChnInitParams(id: libc::c_int);
}
extern "C" {
    pub fn ndspChnIsPlaying(id: libc::c_int) -> bool;
}
extern "C" {
    pub fn ndspChnGetSamplePos(id: libc::c_int) -> u32;
}
extern "C" {
    pub fn ndspChnGetWaveBufSeq(id: libc::c_int) -> u16;
}
extern "C" {
    pub fn ndspChnIsPaused(id: libc::c_int) -> bool;
}
extern "C" {
    pub fn ndspChnSetPaused(id: libc::c_int, paused: bool);
}
extern "C" {
    pub fn ndspChnSetFormat(id: libc::c_int, format: u16);
}
extern "C" {
    pub fn ndspChnSetInterp(id: libc::c_int, type_: ndspInterpType);
}
extern "C" {
    pub fn ndspChnSetRate(id: libc::c_int, rate: f32);
}
extern "C" {
    pub fn ndspChnSetMix(id: libc::c_int, mix: *mut f32);
}
extern "C" {
    pub fn ndspChnSetAdpcmCoefs(id: libc::c_int, coefs: *mut u16);
}
extern "C" {
    pub fn ndspChnWaveBufClear(id: libc::c_int);
}
extern "C" {
    pub fn ndspChnWaveBufAdd(id: libc::c_int, buf: *mut ndspWaveBuf);
}
extern "C" {
    pub fn ndspChnIirMonoSetEnable(id: libc::c_int, enable: bool);
}
extern "C" {
    pub fn ndspChnIirMonoSetParamsCustomFilter(id: libc::c_int, a0: f32,
                                               a1: f32, b0: f32) -> bool;
}
extern "C" {
    pub fn ndspChnIirMonoSetParamsLowPassFilter(id: libc::c_int, f0: f32)
     -> bool;
}
extern "C" {
    pub fn ndspChnIirMonoSetParamsHighPassFilter(id: libc::c_int, f0: f32)
     -> bool;
}
extern "C" {
    pub fn ndspChnIirBiquadSetEnable(id: libc::c_int, enable: bool);
}
extern "C" {
    pub fn ndspChnIirBiquadSetParamsCustomFilter(id: libc::c_int, a0: f32,
                                                 a1: f32, a2: f32, b0: f32,
                                                 b1: f32, b2: f32) -> bool;
}
extern "C" {
    pub fn ndspChnIirBiquadSetParamsLowPassFilter(id: libc::c_int, f0: f32,
                                                  Q: f32) -> bool;
}
extern "C" {
    pub fn ndspChnIirBiquadSetParamsHighPassFilter(id: libc::c_int, f0: f32,
                                                   Q: f32) -> bool;
}
extern "C" {
    pub fn ndspChnIirBiquadSetParamsBandPassFilter(id: libc::c_int, f0: f32,
                                                   Q: f32) -> bool;
}
extern "C" {
    pub fn ndspChnIirBiquadSetParamsNotchFilter(id: libc::c_int, f0: f32,
                                                Q: f32) -> bool;
}
extern "C" {
    pub fn ndspChnIirBiquadSetParamsPeakingEqualizer(id: libc::c_int, f0: f32,
                                                     Q: f32, gain: f32)
     -> bool;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SwkbdType {
    SWKBD_TYPE_NORMAL = 0,
    SWKBD_TYPE_QWERTY = 1,
    SWKBD_TYPE_NUMPAD = 2,
    SWKBD_TYPE_WESTERN = 3,
}
pub const SWKBD_NOTBLANK_NOTEMPTY: SwkbdValidInput =
    SwkbdValidInput::SWKBD_NOTEMPTY_NOTBLANK;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SwkbdValidInput {
    SWKBD_ANYTHING = 0,
    SWKBD_NOTEMPTY = 1,
    SWKBD_NOTEMPTY_NOTBLANK = 2,
    SWKBD_NOTBLANK = 3,
    SWKBD_FIXEDLEN = 4,
}
pub const SWKBD_BUTTON_CONFIRM: SwkbdButton = SwkbdButton::SWKBD_BUTTON_RIGHT;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SwkbdButton {
    SWKBD_BUTTON_LEFT = 0,
    SWKBD_BUTTON_MIDDLE = 1,
    SWKBD_BUTTON_RIGHT = 2,
    SWKBD_BUTTON_NONE = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SwkbdPasswordMode {
    SWKBD_PASSWORD_NONE = 0,
    SWKBD_PASSWORD_HIDE = 1,
    SWKBD_PASSWORD_HIDE_DELAY = 2,
}
pub const SWKBD_FILTER_DIGITS: _bindgen_ty_26 =
    _bindgen_ty_26::SWKBD_FILTER_DIGITS;
pub const SWKBD_FILTER_AT: _bindgen_ty_26 = _bindgen_ty_26::SWKBD_FILTER_AT;
pub const SWKBD_FILTER_PERCENT: _bindgen_ty_26 =
    _bindgen_ty_26::SWKBD_FILTER_PERCENT;
pub const SWKBD_FILTER_BACKSLASH: _bindgen_ty_26 =
    _bindgen_ty_26::SWKBD_FILTER_BACKSLASH;
pub const SWKBD_FILTER_PROFANITY: _bindgen_ty_26 =
    _bindgen_ty_26::SWKBD_FILTER_PROFANITY;
pub const SWKBD_FILTER_CALLBACK: _bindgen_ty_26 =
    _bindgen_ty_26::SWKBD_FILTER_CALLBACK;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_26 {
    SWKBD_FILTER_DIGITS = 1,
    SWKBD_FILTER_AT = 2,
    SWKBD_FILTER_PERCENT = 4,
    SWKBD_FILTER_BACKSLASH = 8,
    SWKBD_FILTER_PROFANITY = 16,
    SWKBD_FILTER_CALLBACK = 32,
}
pub const SWKBD_PARENTAL: _bindgen_ty_27 = _bindgen_ty_27::SWKBD_PARENTAL;
pub const SWKBD_DARKEN_TOP_SCREEN: _bindgen_ty_27 =
    _bindgen_ty_27::SWKBD_DARKEN_TOP_SCREEN;
pub const SWKBD_PREDICTIVE_INPUT: _bindgen_ty_27 =
    _bindgen_ty_27::SWKBD_PREDICTIVE_INPUT;
pub const SWKBD_MULTILINE: _bindgen_ty_27 = _bindgen_ty_27::SWKBD_MULTILINE;
pub const SWKBD_FIXED_WIDTH: _bindgen_ty_27 =
    _bindgen_ty_27::SWKBD_FIXED_WIDTH;
pub const SWKBD_ALLOW_HOME: _bindgen_ty_27 = _bindgen_ty_27::SWKBD_ALLOW_HOME;
pub const SWKBD_ALLOW_RESET: _bindgen_ty_27 =
    _bindgen_ty_27::SWKBD_ALLOW_RESET;
pub const SWKBD_ALLOW_POWER: _bindgen_ty_27 =
    _bindgen_ty_27::SWKBD_ALLOW_POWER;
pub const SWKBD_DEFAULT_QWERTY: _bindgen_ty_27 =
    _bindgen_ty_27::SWKBD_DEFAULT_QWERTY;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_27 {
    SWKBD_PARENTAL = 1,
    SWKBD_DARKEN_TOP_SCREEN = 2,
    SWKBD_PREDICTIVE_INPUT = 4,
    SWKBD_MULTILINE = 8,
    SWKBD_FIXED_WIDTH = 16,
    SWKBD_ALLOW_HOME = 32,
    SWKBD_ALLOW_RESET = 64,
    SWKBD_ALLOW_POWER = 128,
    SWKBD_DEFAULT_QWERTY = 512,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SwkbdCallbackResult {
    SWKBD_CALLBACK_OK = 0,
    SWKBD_CALLBACK_CLOSE = 1,
    SWKBD_CALLBACK_CONTINUE = 2,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SwkbdResult {
    SWKBD_NONE = -1,
    SWKBD_INVALID_INPUT = -2,
    SWKBD_OUTOFMEM = -3,
    SWKBD_D0_CLICK = 0,
    SWKBD_D1_CLICK0 = 1,
    SWKBD_D1_CLICK1 = 2,
    SWKBD_D2_CLICK0 = 3,
    SWKBD_D2_CLICK1 = 4,
    SWKBD_D2_CLICK2 = 5,
    SWKBD_HOMEPRESSED = 10,
    SWKBD_RESETPRESSED = 11,
    SWKBD_POWERPRESSED = 12,
    SWKBD_PARENTAL_OK = 20,
    SWKBD_PARENTAL_FAIL = 21,
    SWKBD_BANNED_INPUT = 30,
}
#[repr(C)]
pub struct SwkbdDictWord {
    pub reading: [u16; 41usize],
    pub word: [u16; 41usize],
    pub language: u8,
    pub all_languages: bool,
}
pub type SwkbdCallbackFn =
    ::core::option::Option<unsafe extern "C" fn(user: *mut libc::c_void,
                                                ppMessage:
                                                    *mut *const libc::c_char,
                                                text: *const libc::c_char,
                                                textlen: usize)
                               -> SwkbdCallbackResult>;
#[repr(C)]
#[derive(Copy)]
pub struct SwkbdStatusData {
    pub data: [u32; 17usize],
}
impl Clone for SwkbdStatusData {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct SwkbdLearningData {
    pub data: [u32; 10523usize],
}
#[repr(C)]
#[derive(Copy)]
pub struct SwkbdExtra {
    pub initial_text: *const libc::c_char,
    pub dict: *const SwkbdDictWord,
    pub status_data: *mut SwkbdStatusData,
    pub learning_data: *mut SwkbdLearningData,
    pub callback: SwkbdCallbackFn,
    pub callback_user: *mut libc::c_void,
}
impl Clone for SwkbdExtra {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct SwkbdState {
    pub type_: libc::c_int,
    pub num_buttons_m1: libc::c_int,
    pub valid_input: libc::c_int,
    pub password_mode: libc::c_int,
    pub is_parental_screen: libc::c_int,
    pub darken_top_screen: libc::c_int,
    pub filter_flags: u32,
    pub save_state_flags: u32,
    pub max_text_len: u16,
    pub dict_word_count: u16,
    pub max_digits: u16,
    pub button_text: [[u16; 17usize]; 3usize],
    pub numpad_keys: [u16; 2usize],
    pub hint_text: [u16; 65usize],
    pub predictive_input: bool,
    pub multiline: bool,
    pub fixed_width: bool,
    pub allow_home: bool,
    pub allow_reset: bool,
    pub allow_power: bool,
    pub unknown: bool,
    pub default_qwerty: bool,
    pub button_submits_text: [bool; 4usize],
    pub language: u16,
    pub initial_text_offset: libc::c_int,
    pub dict_offset: libc::c_int,
    pub initial_status_offset: libc::c_int,
    pub initial_learning_offset: libc::c_int,
    pub shared_memory_size: usize,
    pub version: u32,
    pub result: SwkbdResult,
    pub status_offset: libc::c_int,
    pub learning_offset: libc::c_int,
    pub text_offset: libc::c_int,
    pub text_length: u16,
    pub callback_result: libc::c_int,
    pub callback_msg: [u16; 257usize],
    pub skip_at_check: bool,
    pub __bindgen_anon_1: SwkbdState__bindgen_ty_1,
}
#[repr(C)]
pub union SwkbdState__bindgen_ty_1 {
    pub reserved: [u8; 171usize],
    pub extra: SwkbdExtra,
}
extern "C" {
    pub fn swkbdInit(swkbd: *mut SwkbdState, type_: SwkbdType,
                     numButtons: libc::c_int, maxTextLength: libc::c_int);
}
extern "C" {
    pub fn swkbdSetFeatures(swkbd: *mut SwkbdState, features: u32);
}
extern "C" {
    pub fn swkbdSetHintText(swkbd: *mut SwkbdState,
                            text: *const libc::c_char);
}
extern "C" {
    pub fn swkbdSetButton(swkbd: *mut SwkbdState, button: SwkbdButton,
                          text: *const libc::c_char, submit: bool);
}
extern "C" {
    pub fn swkbdSetInitialText(swkbd: *mut SwkbdState,
                               text: *const libc::c_char);
}
extern "C" {
    pub fn swkbdSetDictWord(word: *mut SwkbdDictWord,
                            reading: *const libc::c_char,
                            text: *const libc::c_char);
}
extern "C" {
    pub fn swkbdSetDictionary(swkbd: *mut SwkbdState,
                              dict: *const SwkbdDictWord,
                              wordCount: libc::c_int);
}
extern "C" {
    pub fn swkbdSetStatusData(swkbd: *mut SwkbdState,
                              data: *mut SwkbdStatusData, in_: bool,
                              out: bool);
}
extern "C" {
    pub fn swkbdSetLearningData(swkbd: *mut SwkbdState,
                                data: *mut SwkbdLearningData, in_: bool,
                                out: bool);
}
extern "C" {
    pub fn swkbdSetFilterCallback(swkbd: *mut SwkbdState,
                                  callback: SwkbdCallbackFn,
                                  user: *mut libc::c_void);
}
extern "C" {
    pub fn swkbdInputText(swkbd: *mut SwkbdState, buf: *mut libc::c_char,
                          bufsize: usize) -> SwkbdButton;
}
pub const ERROR_LANGUAGE_FLAG: _bindgen_ty_28 =
    _bindgen_ty_28::ERROR_LANGUAGE_FLAG;
pub const ERROR_WORD_WRAP_FLAG: _bindgen_ty_28 =
    _bindgen_ty_28::ERROR_WORD_WRAP_FLAG;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_28 {
    ERROR_LANGUAGE_FLAG = 256,
    ERROR_WORD_WRAP_FLAG = 512,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum errorType {
    ERROR_CODE = 0,
    ERROR_TEXT = 1,
    ERROR_EULA = 2,
    ERROR_TYPE_EULA_FIRST_BOOT = 3,
    ERROR_TYPE_EULA_DRAW_ONLY = 4,
    ERROR_TYPE_AGREE = 5,
    ERROR_CODE_LANGUAGE = 256,
    ERROR_TEXT_LANGUAGE = 257,
    ERROR_EULA_LANGUAGE = 258,
    ERROR_TEXT_WORD_WRAP = 513,
    ERROR_TEXT_LANGUAGE_WORD_WRAP = 769,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum errorScreenFlag { ERROR_NORMAL = 0, ERROR_STEREO = 1, }
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum errorReturnCode {
    ERROR_UNKNOWN = -1,
    ERROR_NONE = 0,
    ERROR_SUCCESS = 1,
    ERROR_NOT_SUPPORTED = 2,
    ERROR_HOME_BUTTON = 10,
    ERROR_SOFTWARE_RESET = 11,
    ERROR_POWER_BUTTON = 12,
}
#[repr(C)]
pub struct errorConf {
    pub type_: errorType,
    pub errorCode: libc::c_int,
    pub upperScreenFlag: errorScreenFlag,
    pub useLanguage: u16,
    pub Text: [u16; 1900usize],
    pub homeButton: bool,
    pub softwareReset: bool,
    pub appJump: bool,
    pub returnCode: errorReturnCode,
    pub eulaVersion: u16,
}
extern "C" {
    pub fn errorInit(err: *mut errorConf, type_: errorType,
                     lang: CFG_Language);
}
extern "C" {
    pub fn errorCode(err: *mut errorConf, error: libc::c_int);
}
extern "C" {
    pub fn errorText(err: *mut errorConf, text: *const libc::c_char);
}
extern "C" {
    pub fn errorDisp(err: *mut errorConf);
}
#[repr(C)]
pub struct sdmc_dir_t {
    pub magic: u32,
    pub fd: Handle,
    pub index: isize,
    pub size: usize,
    pub entry_data: [FS_DirectoryEntry; 32usize],
}
extern "C" {
    pub fn sdmcInit() -> Result;
}
extern "C" {
    pub fn sdmcWriteSafe(enable: bool);
}
extern "C" {
    pub fn sdmcExit() -> Result;
}
extern "C" {
    pub fn sdmc_getmtime(name: *const libc::c_char, mtime: *mut u64)
     -> Result;
}
#[repr(C)]
#[derive(Copy)]
pub struct romfs_header {
    pub headerSize: u32,
    pub dirHashTableOff: u32,
    pub dirHashTableSize: u32,
    pub dirTableOff: u32,
    pub dirTableSize: u32,
    pub fileHashTableOff: u32,
    pub fileHashTableSize: u32,
    pub fileTableOff: u32,
    pub fileTableSize: u32,
    pub fileDataOff: u32,
}
impl Clone for romfs_header {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct romfs_dir {
    pub parent: u32,
    pub sibling: u32,
    pub childDir: u32,
    pub childFile: u32,
    pub nextHash: u32,
    pub nameLen: u32,
    pub name: __IncompleteArrayField<u16>,
}
impl Clone for romfs_dir {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct romfs_file {
    pub parent: u32,
    pub sibling: u32,
    pub dataOff: u64,
    pub dataSize: u64,
    pub nextHash: u32,
    pub nameLen: u32,
    pub name: __IncompleteArrayField<u16>,
}
impl Clone for romfs_file {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct romfs_mount {
    _unused: [u8; 0],
}
extern "C" {
    pub fn romfsMount(mount: *mut *mut romfs_mount) -> Result;
}
extern "C" {
    pub fn romfsMountFromFile(file: Handle, offset: u32,
                              mount: *mut *mut romfs_mount) -> Result;
}
extern "C" {
    pub fn romfsBind(mount: *mut romfs_mount) -> Result;
}
extern "C" {
    pub fn romfsUnmount(mount: *mut romfs_mount) -> Result;
}
#[repr(C)]
#[derive(Copy)]
pub struct charWidthInfo_s {
    pub left: s8,
    pub glyphWidth: u8,
    pub charWidth: u8,
}
impl Clone for charWidthInfo_s {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct TGLP_s {
    pub cellWidth: u8,
    pub cellHeight: u8,
    pub baselinePos: u8,
    pub maxCharWidth: u8,
    pub sheetSize: u32,
    pub nSheets: u16,
    pub sheetFmt: u16,
    pub nRows: u16,
    pub nLines: u16,
    pub sheetWidth: u16,
    pub sheetHeight: u16,
    pub sheetData: *mut u8,
}
impl Clone for TGLP_s {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct tag_CWDH_s {
    pub startIndex: u16,
    pub endIndex: u16,
    pub next: *mut CWDH_s,
    pub widths: __IncompleteArrayField<charWidthInfo_s>,
}
impl Clone for tag_CWDH_s {
    fn clone(&self) -> Self { *self }
}
pub type CWDH_s = tag_CWDH_s;
pub const CMAP_TYPE_DIRECT: _bindgen_ty_29 = _bindgen_ty_29::CMAP_TYPE_DIRECT;
pub const CMAP_TYPE_TABLE: _bindgen_ty_29 = _bindgen_ty_29::CMAP_TYPE_TABLE;
pub const CMAP_TYPE_SCAN: _bindgen_ty_29 = _bindgen_ty_29::CMAP_TYPE_SCAN;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_29 {
    CMAP_TYPE_DIRECT = 0,
    CMAP_TYPE_TABLE = 1,
    CMAP_TYPE_SCAN = 2,
}
#[repr(C)]
#[derive(Copy)]
pub struct tag_CMAP_s {
    pub codeBegin: u16,
    pub codeEnd: u16,
    pub mappingMethod: u16,
    pub reserved: u16,
    pub next: *mut CMAP_s,
    pub __bindgen_anon_1: tag_CMAP_s__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub union tag_CMAP_s__bindgen_ty_1 {
    pub indexOffset: u16,
    pub indexTable: __IncompleteArrayField<u16>,
    pub __bindgen_anon_1: tag_CMAP_s__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub struct tag_CMAP_s__bindgen_ty_1__bindgen_ty_1 {
    pub nScanEntries: u16,
    pub scanEntries: __IncompleteArrayField<tag_CMAP_s__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>,
}
#[repr(C)]
#[derive(Copy)]
pub struct tag_CMAP_s__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub code: u16,
    pub glyphIndex: u16,
}
impl Clone for tag_CMAP_s__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Clone for tag_CMAP_s__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Clone for tag_CMAP_s__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Clone for tag_CMAP_s {
    fn clone(&self) -> Self { *self }
}
pub type CMAP_s = tag_CMAP_s;
#[repr(C)]
#[derive(Copy)]
pub struct FINF_s {
    pub signature: u32,
    pub sectionSize: u32,
    pub fontType: u8,
    pub lineFeed: u8,
    pub alterCharIndex: u16,
    pub defaultWidth: charWidthInfo_s,
    pub encoding: u8,
    pub tglp: *mut TGLP_s,
    pub cwdh: *mut CWDH_s,
    pub cmap: *mut CMAP_s,
    pub height: u8,
    pub width: u8,
    pub ascent: u8,
    pub padding: u8,
}
impl Clone for FINF_s {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct CFNT_s {
    pub signature: u32,
    pub endianness: u16,
    pub headerSize: u16,
    pub version: u32,
    pub fileSize: u32,
    pub nBlocks: u32,
    pub finf: FINF_s,
}
impl Clone for CFNT_s {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct fontGlyphPos_s {
    pub sheetIndex: libc::c_int,
    pub xOffset: f32,
    pub xAdvance: f32,
    pub width: f32,
    pub texcoord: fontGlyphPos_s__bindgen_ty_1,
    pub vtxcoord: fontGlyphPos_s__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy)]
pub struct fontGlyphPos_s__bindgen_ty_1 {
    pub left: f32,
    pub top: f32,
    pub right: f32,
    pub bottom: f32,
}
impl Clone for fontGlyphPos_s__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct fontGlyphPos_s__bindgen_ty_2 {
    pub left: f32,
    pub top: f32,
    pub right: f32,
    pub bottom: f32,
}
impl Clone for fontGlyphPos_s__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Clone for fontGlyphPos_s {
    fn clone(&self) -> Self { *self }
}
pub const GLYPH_POS_CALC_VTXCOORD: _bindgen_ty_30 =
    _bindgen_ty_30::GLYPH_POS_CALC_VTXCOORD;
pub const GLYPH_POS_AT_BASELINE: _bindgen_ty_30 =
    _bindgen_ty_30::GLYPH_POS_AT_BASELINE;
pub const GLYPH_POS_Y_POINTS_UP: _bindgen_ty_30 =
    _bindgen_ty_30::GLYPH_POS_Y_POINTS_UP;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_30 {
    GLYPH_POS_CALC_VTXCOORD = 1,
    GLYPH_POS_AT_BASELINE = 2,
    GLYPH_POS_Y_POINTS_UP = 4,
}
extern "C" {
    pub fn fontEnsureMapped() -> Result;
}
extern "C" {
    pub fn fontGlyphIndexFromCodePoint(codePoint: u32) -> libc::c_int;
}
extern "C" {
    pub fn fontGetCharWidthInfo(glyphIndex: libc::c_int)
     -> *mut charWidthInfo_s;
}
extern "C" {
    pub fn fontCalcGlyphPos(out: *mut fontGlyphPos_s, glyphIndex: libc::c_int,
                            flags: u32, scaleX: f32, scaleY: f32);
}
