/* automatically generated by rust-bindgen 0.64.0 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::core::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::core::mem::transmute(self)
    }
}
impl<T> ::core::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::core::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::core::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::core::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::core::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::core::cmp::Eq for __BindgenUnionField<T> {}
pub const _NEWLIB_VERSION_H__: u32 = 1;
pub const _NEWLIB_VERSION: &[u8; 6usize] = b"4.2.0\0";
pub const __NEWLIB__: u32 = 4;
pub const __NEWLIB_MINOR__: u32 = 2;
pub const __NEWLIB_PATCHLEVEL__: u32 = 0;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __ATFILE_VISIBLE: u32 = 1;
pub const __BSD_VISIBLE: u32 = 1;
pub const __GNU_VISIBLE: u32 = 0;
pub const __ISO_C_VISIBLE: u32 = 2011;
pub const __LARGEFILE_VISIBLE: u32 = 0;
pub const __MISC_VISIBLE: u32 = 1;
pub const __POSIX_VISIBLE: u32 = 200809;
pub const __SVID_VISIBLE: u32 = 1;
pub const __XSI_VISIBLE: u32 = 0;
pub const __SSP_FORTIFY_LEVEL: u32 = 0;
pub const _POSIX_MONOTONIC_CLOCK: u32 = 200112;
pub const _POSIX_TIMERS: u32 = 1;
pub const __have_longlong64: u32 = 1;
pub const __have_long32: u32 = 1;
pub const ___int8_t_defined: u32 = 1;
pub const ___int16_t_defined: u32 = 1;
pub const ___int32_t_defined: u32 = 1;
pub const ___int64_t_defined: u32 = 1;
pub const ___int_least8_t_defined: u32 = 1;
pub const ___int_least16_t_defined: u32 = 1;
pub const ___int_least32_t_defined: u32 = 1;
pub const ___int_least64_t_defined: u32 = 1;
pub const __int20: u32 = 2;
pub const __int20__: u32 = 2;
pub const __INT8: &[u8; 3usize] = b"hh\0";
pub const __INT16: &[u8; 2usize] = b"h\0";
pub const __INT64: &[u8; 3usize] = b"ll\0";
pub const __FAST8: &[u8; 3usize] = b"hh\0";
pub const __FAST16: &[u8; 2usize] = b"h\0";
pub const __FAST64: &[u8; 3usize] = b"ll\0";
pub const __LEAST8: &[u8; 3usize] = b"hh\0";
pub const __LEAST16: &[u8; 2usize] = b"h\0";
pub const __LEAST64: &[u8; 3usize] = b"ll\0";
pub const __int8_t_defined: u32 = 1;
pub const __int16_t_defined: u32 = 1;
pub const __int32_t_defined: u32 = 1;
pub const __int64_t_defined: u32 = 1;
pub const __int_least8_t_defined: u32 = 1;
pub const __int_least16_t_defined: u32 = 1;
pub const __int_least32_t_defined: u32 = 1;
pub const __int_least64_t_defined: u32 = 1;
pub const __int_fast8_t_defined: u32 = 1;
pub const __int_fast16_t_defined: u32 = 1;
pub const __int_fast32_t_defined: u32 = 1;
pub const __int_fast64_t_defined: u32 = 1;
pub const WINT_MIN: u32 = 0;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const CUR_PROCESS_HANDLE: u32 = 4294934529;
pub const ARBITRATION_SIGNAL_ALL: i32 = -1;
pub const CUR_THREAD_HANDLE: u32 = 4294934528;
pub const SYSCLOCK_SOC: u32 = 16756991;
pub const SYSCLOCK_SYS: u32 = 33513982;
pub const SYSCLOCK_SDMMC: u32 = 67027964;
pub const SYSCLOCK_ARM9: u32 = 134055928;
pub const SYSCLOCK_ARM11: u32 = 268111856;
pub const SYSCLOCK_ARM11_LGR1: u32 = 536223712;
pub const SYSCLOCK_ARM11_LGR2: u32 = 804335568;
pub const SYSCLOCK_ARM11_NEW: u32 = 804335568;
pub const CPU_TICKS_PER_MSEC: f64 = 268111.856;
pub const CPU_TICKS_PER_USEC: f64 = 268.111856;
pub const OS_HEAP_AREA_BEGIN: u32 = 134217728;
pub const OS_HEAP_AREA_END: u32 = 234881024;
pub const OS_MAP_AREA_BEGIN: u32 = 268435456;
pub const OS_MAP_AREA_END: u32 = 335544320;
pub const OS_OLD_FCRAM_VADDR: u32 = 335544320;
pub const OS_OLD_FCRAM_PADDR: u32 = 536870912;
pub const OS_OLD_FCRAM_SIZE: u32 = 134217728;
pub const OS_QTMRAM_VADDR: u32 = 511705088;
pub const OS_QTMRAM_PADDR: u32 = 520093696;
pub const OS_QTMRAM_SIZE: u32 = 4194304;
pub const OS_MMIO_VADDR: u32 = 515899392;
pub const OS_MMIO_PADDR: u32 = 269484032;
pub const OS_MMIO_SIZE: u32 = 4194304;
pub const OS_VRAM_VADDR: u32 = 520093696;
pub const OS_VRAM_PADDR: u32 = 402653184;
pub const OS_VRAM_SIZE: u32 = 6291456;
pub const OS_DSPRAM_VADDR: u32 = 535822336;
pub const OS_DSPRAM_PADDR: u32 = 535822336;
pub const OS_DSPRAM_SIZE: u32 = 524288;
pub const OS_KERNELCFG_VADDR: u32 = 536346624;
pub const OS_SHAREDCFG_VADDR: u32 = 536350720;
pub const OS_FCRAM_VADDR: u32 = 805306368;
pub const OS_FCRAM_PADDR: u32 = 536870912;
pub const OS_FCRAM_SIZE: u32 = 268435456;
pub const __NEWLIB_H__: u32 = 1;
pub const _WANT_IO_C99_FORMATS: u32 = 1;
pub const _WANT_IO_LONG_LONG: u32 = 1;
pub const _WANT_IO_POS_ARGS: u32 = 1;
pub const _REENT_CHECK_VERIFY: u32 = 1;
pub const _MB_CAPABLE: u32 = 1;
pub const _MB_LEN_MAX: u32 = 8;
pub const HAVE_INITFINI_ARRAY: u32 = 1;
pub const _ATEXIT_DYNAMIC_ALLOC: u32 = 1;
pub const _HAVE_LONG_DOUBLE: u32 = 1;
pub const _HAVE_CC_INHIBIT_LOOP_TO_LIBCALL: u32 = 1;
pub const _LDBL_EQ_DBL: u32 = 1;
pub const _FVWRITE_IN_STREAMIO: u32 = 1;
pub const _FSEEK_OPTIMIZATION: u32 = 1;
pub const _UNBUF_STREAM_OPT: u32 = 1;
pub const _WANT_USE_GDTOA: u32 = 1;
pub const __OBSOLETE_MATH_DEFAULT: u32 = 0;
pub const __OBSOLETE_MATH: u32 = 0;
pub const __RAND_MAX: u32 = 2147483647;
pub const GSP_SCREEN_TOP: u32 = 0;
pub const GSP_SCREEN_BOTTOM: u32 = 1;
pub const GSP_SCREEN_WIDTH: u32 = 240;
pub const GSP_SCREEN_HEIGHT_TOP: u32 = 400;
pub const GSP_SCREEN_HEIGHT_TOP_2X: u32 = 800;
pub const GSP_SCREEN_HEIGHT_BOTTOM: u32 = 320;
pub const CONSOLE_COLOR_BOLD: u32 = 1;
pub const CONSOLE_COLOR_FAINT: u32 = 2;
pub const CONSOLE_ITALIC: u32 = 4;
pub const CONSOLE_UNDERLINE: u32 = 8;
pub const CONSOLE_BLINK_SLOW: u32 = 16;
pub const CONSOLE_BLINK_FAST: u32 = 32;
pub const CONSOLE_COLOR_REVERSE: u32 = 64;
pub const CONSOLE_CONCEAL: u32 = 128;
pub const CONSOLE_CROSSED_OUT: u32 = 256;
pub const CONSOLE_FG_CUSTOM: u32 = 512;
pub const CONSOLE_BG_CUSTOM: u32 = 1024;
pub const __GNUCLIKE_ASM: u32 = 3;
pub const __GNUCLIKE___TYPEOF: u32 = 1;
pub const __GNUCLIKE___OFFSETOF: u32 = 1;
pub const __GNUCLIKE___SECTION: u32 = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: u32 = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: u32 = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: u32 = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: u32 = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: u32 = 1;
pub const __CC_SUPPORTS_INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE__: u32 = 1;
pub const __CC_SUPPORTS___FUNC__: u32 = 1;
pub const __CC_SUPPORTS_WARNING: u32 = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: u32 = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _LITTLE_ENDIAN: u32 = 1234;
pub const _BIG_ENDIAN: u32 = 4321;
pub const _PDP_ENDIAN: u32 = 3412;
pub const _BYTE_ORDER: u32 = 1234;
pub const _QUAD_HIGHWORD: u32 = 1;
pub const _QUAD_LOWWORD: u32 = 0;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const FD_SETSIZE: u32 = 64;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const PTHREAD_SCOPE_PROCESS: u32 = 0;
pub const PTHREAD_SCOPE_SYSTEM: u32 = 1;
pub const PTHREAD_INHERIT_SCHED: u32 = 1;
pub const PTHREAD_EXPLICIT_SCHED: u32 = 2;
pub const PTHREAD_CREATE_DETACHED: u32 = 0;
pub const PTHREAD_CREATE_JOINABLE: u32 = 1;
pub const CSND_NUM_CHANNELS: u32 = 32;
pub const FRIEND_SCREEN_NAME_SIZE: u32 = 11;
pub const FRIEND_COMMENT_SIZE: u32 = 33;
pub const FRIEND_LIST_SIZE: u32 = 100;
pub const HTTPC_RESULTCODE_DOWNLOADPENDING: u32 = 3628113963;
pub const HTTPC_RESULTCODE_NOTFOUND: u32 = 3628113960;
pub const HTTPC_RESULTCODE_TIMEDOUT: u32 = 3626016873;
pub const UDS_MAXNODES: u32 = 16;
pub const UDS_BROADCAST_NETWORKNODEID: u32 = 65535;
pub const UDS_HOST_NETWORKNODEID: u32 = 1;
pub const UDS_DEFAULT_RECVBUFSIZE: u32 = 11824;
pub const UDS_DATAFRAME_MAXSIZE: u32 = 1478;
pub const DST_NONE: u32 = 0;
pub const DST_USA: u32 = 1;
pub const DST_AUST: u32 = 2;
pub const DST_WET: u32 = 3;
pub const DST_MET: u32 = 4;
pub const DST_EET: u32 = 5;
pub const DST_CAN: u32 = 6;
pub const SBT_MAX: u64 = 9223372036854775807;
pub const ITIMER_REAL: u32 = 0;
pub const ITIMER_VIRTUAL: u32 = 1;
pub const ITIMER_PROF: u32 = 2;
pub const _NULL: u32 = 0;
pub const _ATEXIT_SIZE: u32 = 32;
pub const _RAND48_SEED_0: u32 = 13070;
pub const _RAND48_SEED_1: u32 = 43981;
pub const _RAND48_SEED_2: u32 = 4660;
pub const _RAND48_MULT_0: u32 = 58989;
pub const _RAND48_MULT_1: u32 = 57068;
pub const _RAND48_MULT_2: u32 = 5;
pub const _RAND48_ADD: u32 = 11;
pub const _REENT_EMERGENCY_SIZE: u32 = 25;
pub const _REENT_ASCTIME_SIZE: u32 = 26;
pub const _REENT_SIGNAL_SIZE: u32 = 24;
pub const _N_LISTS: u32 = 30;
pub const _CLOCKS_PER_SEC_: u32 = 100;
pub const CLOCKS_PER_SEC: u32 = 100;
pub const CLK_TCK: u32 = 100;
pub const SIGEV_NONE: u32 = 1;
pub const SIGEV_SIGNAL: u32 = 2;
pub const SIGEV_THREAD: u32 = 3;
pub const SI_USER: u32 = 1;
pub const SI_QUEUE: u32 = 2;
pub const SI_TIMER: u32 = 3;
pub const SI_ASYNCIO: u32 = 4;
pub const SI_MESGQ: u32 = 5;
pub const SA_NOCLDSTOP: u32 = 1;
pub const MINSIGSTKSZ: u32 = 2048;
pub const SIGSTKSZ: u32 = 8192;
pub const SS_ONSTACK: u32 = 1;
pub const SS_DISABLE: u32 = 2;
pub const SIG_SETMASK: u32 = 0;
pub const SIG_BLOCK: u32 = 1;
pub const SIG_UNBLOCK: u32 = 2;
pub const SIGHUP: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGQUIT: u32 = 3;
pub const SIGILL: u32 = 4;
pub const SIGTRAP: u32 = 5;
pub const SIGIOT: u32 = 6;
pub const SIGABRT: u32 = 6;
pub const SIGEMT: u32 = 7;
pub const SIGFPE: u32 = 8;
pub const SIGKILL: u32 = 9;
pub const SIGBUS: u32 = 10;
pub const SIGSEGV: u32 = 11;
pub const SIGSYS: u32 = 12;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGTERM: u32 = 15;
pub const SIGURG: u32 = 16;
pub const SIGSTOP: u32 = 17;
pub const SIGTSTP: u32 = 18;
pub const SIGCONT: u32 = 19;
pub const SIGCHLD: u32 = 20;
pub const SIGCLD: u32 = 20;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGIO: u32 = 23;
pub const SIGPOLL: u32 = 23;
pub const SIGXCPU: u32 = 24;
pub const SIGXFSZ: u32 = 25;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGWINCH: u32 = 28;
pub const SIGLOST: u32 = 29;
pub const SIGUSR1: u32 = 30;
pub const SIGUSR2: u32 = 31;
pub const NSIG: u32 = 32;
pub const CLOCK_ENABLED: u32 = 1;
pub const CLOCK_DISABLED: u32 = 0;
pub const CLOCK_ALLOWED: u32 = 1;
pub const CLOCK_DISALLOWED: u32 = 0;
pub const TIMER_ABSTIME: u32 = 4;
pub const SOL_SOCKET: u32 = 65535;
pub const PF_UNSPEC: u32 = 0;
pub const PF_INET: u32 = 2;
pub const PF_INET6: u32 = 23;
pub const AF_UNSPEC: u32 = 0;
pub const AF_INET: u32 = 2;
pub const AF_INET6: u32 = 23;
pub const SOCK_STREAM: u32 = 1;
pub const SOCK_DGRAM: u32 = 2;
pub const MSG_OOB: u32 = 1;
pub const MSG_PEEK: u32 = 2;
pub const MSG_DONTWAIT: u32 = 4;
pub const MSG_DONTROUTE: u32 = 0;
pub const MSG_WAITALL: u32 = 0;
pub const MSG_MORE: u32 = 0;
pub const MSG_NOSIGNAL: u32 = 0;
pub const SHUT_RD: u32 = 0;
pub const SHUT_WR: u32 = 1;
pub const SHUT_RDWR: u32 = 2;
pub const SO_REUSEADDR: u32 = 4;
pub const SO_LINGER: u32 = 128;
pub const SO_OOBINLINE: u32 = 256;
pub const SO_SNDBUF: u32 = 4097;
pub const SO_RCVBUF: u32 = 4098;
pub const SO_SNDLOWAT: u32 = 4099;
pub const SO_RCVLOWAT: u32 = 4100;
pub const SO_TYPE: u32 = 4104;
pub const SO_ERROR: u32 = 4105;
pub const SO_BROADCAST: u32 = 0;
pub const INADDR_LOOPBACK: u32 = 2130706433;
pub const INADDR_ANY: u32 = 0;
pub const INADDR_BROADCAST: u32 = 4294967295;
pub const INADDR_NONE: u32 = 4294967295;
pub const INET_ADDRSTRLEN: u32 = 16;
pub const IPPROTO_IP: u32 = 0;
pub const IPPROTO_UDP: u32 = 17;
pub const IPPROTO_TCP: u32 = 6;
pub const IP_TOS: u32 = 7;
pub const IP_TTL: u32 = 8;
pub const IP_MULTICAST_LOOP: u32 = 9;
pub const IP_MULTICAST_TTL: u32 = 10;
pub const IP_ADD_MEMBERSHIP: u32 = 11;
pub const IP_DROP_MEMBERSHIP: u32 = 12;
pub const SOL_CONFIG: u32 = 65534;
pub const ROUTING_FLAG_G: u32 = 1;
pub const TCP_STATE_CLOSED: u32 = 1;
pub const TCP_STATE_LISTEN: u32 = 2;
pub const TCP_STATE_ESTABLISHED: u32 = 5;
pub const TCP_STATE_FINWAIT1: u32 = 6;
pub const TCP_STATE_FINWAIT2: u32 = 7;
pub const TCP_STATE_CLOSE_WAIT: u32 = 8;
pub const TCP_STATE_LAST_ACK: u32 = 9;
pub const TCP_STATE_TIME_WAIT: u32 = 11;
pub const MVD_STATUS_OK: u32 = 94208;
pub const MVD_STATUS_PARAMSET: u32 = 94209;
pub const MVD_STATUS_BUSY: u32 = 94210;
pub const MVD_STATUS_FRAMEREADY: u32 = 94211;
pub const MVD_STATUS_INCOMPLETEPROCESSING: u32 = 94212;
pub const MVD_STATUS_NALUPROCFLAG: u32 = 94215;
pub const MVD_DEFAULT_WORKBUF_SIZE: u32 = 9438920;
pub const NFC_ERR_INVALID_STATE: u32 = 3366024704;
pub const NFC_ERR_APPDATA_UNINITIALIZED: u32 = 3366024736;
pub const NFC_ERR_AMIIBO_NOTSETUP: u32 = 3366024744;
pub const NFC_ERR_APPID_MISMATCH: u32 = 3366024760;
pub const NFC_ERR_DATACORRUPTION0: u32 = 3368121868;
pub const NFC_ERR_DATACORRUPTION1: u32 = 3366024728;
pub const NFC_STARTSCAN_DEFAULTINPUT: u32 = 0;
pub const GPUREG_0000: u32 = 0;
pub const GPUREG_0001: u32 = 1;
pub const GPUREG_0002: u32 = 2;
pub const GPUREG_0003: u32 = 3;
pub const GPUREG_0004: u32 = 4;
pub const GPUREG_0005: u32 = 5;
pub const GPUREG_0006: u32 = 6;
pub const GPUREG_0007: u32 = 7;
pub const GPUREG_0008: u32 = 8;
pub const GPUREG_0009: u32 = 9;
pub const GPUREG_000A: u32 = 10;
pub const GPUREG_000B: u32 = 11;
pub const GPUREG_000C: u32 = 12;
pub const GPUREG_000D: u32 = 13;
pub const GPUREG_000E: u32 = 14;
pub const GPUREG_000F: u32 = 15;
pub const GPUREG_FINALIZE: u32 = 16;
pub const GPUREG_0011: u32 = 17;
pub const GPUREG_0012: u32 = 18;
pub const GPUREG_0013: u32 = 19;
pub const GPUREG_0014: u32 = 20;
pub const GPUREG_0015: u32 = 21;
pub const GPUREG_0016: u32 = 22;
pub const GPUREG_0017: u32 = 23;
pub const GPUREG_0018: u32 = 24;
pub const GPUREG_0019: u32 = 25;
pub const GPUREG_001A: u32 = 26;
pub const GPUREG_001B: u32 = 27;
pub const GPUREG_001C: u32 = 28;
pub const GPUREG_001D: u32 = 29;
pub const GPUREG_001E: u32 = 30;
pub const GPUREG_001F: u32 = 31;
pub const GPUREG_0020: u32 = 32;
pub const GPUREG_0021: u32 = 33;
pub const GPUREG_0022: u32 = 34;
pub const GPUREG_0023: u32 = 35;
pub const GPUREG_0024: u32 = 36;
pub const GPUREG_0025: u32 = 37;
pub const GPUREG_0026: u32 = 38;
pub const GPUREG_0027: u32 = 39;
pub const GPUREG_0028: u32 = 40;
pub const GPUREG_0029: u32 = 41;
pub const GPUREG_002A: u32 = 42;
pub const GPUREG_002B: u32 = 43;
pub const GPUREG_002C: u32 = 44;
pub const GPUREG_002D: u32 = 45;
pub const GPUREG_002E: u32 = 46;
pub const GPUREG_002F: u32 = 47;
pub const GPUREG_0030: u32 = 48;
pub const GPUREG_0031: u32 = 49;
pub const GPUREG_0032: u32 = 50;
pub const GPUREG_0033: u32 = 51;
pub const GPUREG_0034: u32 = 52;
pub const GPUREG_0035: u32 = 53;
pub const GPUREG_0036: u32 = 54;
pub const GPUREG_0037: u32 = 55;
pub const GPUREG_0038: u32 = 56;
pub const GPUREG_0039: u32 = 57;
pub const GPUREG_003A: u32 = 58;
pub const GPUREG_003B: u32 = 59;
pub const GPUREG_003C: u32 = 60;
pub const GPUREG_003D: u32 = 61;
pub const GPUREG_003E: u32 = 62;
pub const GPUREG_003F: u32 = 63;
pub const GPUREG_FACECULLING_CONFIG: u32 = 64;
pub const GPUREG_VIEWPORT_WIDTH: u32 = 65;
pub const GPUREG_VIEWPORT_INVW: u32 = 66;
pub const GPUREG_VIEWPORT_HEIGHT: u32 = 67;
pub const GPUREG_VIEWPORT_INVH: u32 = 68;
pub const GPUREG_0045: u32 = 69;
pub const GPUREG_0046: u32 = 70;
pub const GPUREG_FRAGOP_CLIP: u32 = 71;
pub const GPUREG_FRAGOP_CLIP_DATA0: u32 = 72;
pub const GPUREG_FRAGOP_CLIP_DATA1: u32 = 73;
pub const GPUREG_FRAGOP_CLIP_DATA2: u32 = 74;
pub const GPUREG_FRAGOP_CLIP_DATA3: u32 = 75;
pub const GPUREG_004C: u32 = 76;
pub const GPUREG_DEPTHMAP_SCALE: u32 = 77;
pub const GPUREG_DEPTHMAP_OFFSET: u32 = 78;
pub const GPUREG_SH_OUTMAP_TOTAL: u32 = 79;
pub const GPUREG_SH_OUTMAP_O0: u32 = 80;
pub const GPUREG_SH_OUTMAP_O1: u32 = 81;
pub const GPUREG_SH_OUTMAP_O2: u32 = 82;
pub const GPUREG_SH_OUTMAP_O3: u32 = 83;
pub const GPUREG_SH_OUTMAP_O4: u32 = 84;
pub const GPUREG_SH_OUTMAP_O5: u32 = 85;
pub const GPUREG_SH_OUTMAP_O6: u32 = 86;
pub const GPUREG_0057: u32 = 87;
pub const GPUREG_0058: u32 = 88;
pub const GPUREG_0059: u32 = 89;
pub const GPUREG_005A: u32 = 90;
pub const GPUREG_005B: u32 = 91;
pub const GPUREG_005C: u32 = 92;
pub const GPUREG_005D: u32 = 93;
pub const GPUREG_005E: u32 = 94;
pub const GPUREG_005F: u32 = 95;
pub const GPUREG_0060: u32 = 96;
pub const GPUREG_EARLYDEPTH_FUNC: u32 = 97;
pub const GPUREG_EARLYDEPTH_TEST1: u32 = 98;
pub const GPUREG_EARLYDEPTH_CLEAR: u32 = 99;
pub const GPUREG_SH_OUTATTR_MODE: u32 = 100;
pub const GPUREG_SCISSORTEST_MODE: u32 = 101;
pub const GPUREG_SCISSORTEST_POS: u32 = 102;
pub const GPUREG_SCISSORTEST_DIM: u32 = 103;
pub const GPUREG_VIEWPORT_XY: u32 = 104;
pub const GPUREG_0069: u32 = 105;
pub const GPUREG_EARLYDEPTH_DATA: u32 = 106;
pub const GPUREG_006B: u32 = 107;
pub const GPUREG_006C: u32 = 108;
pub const GPUREG_DEPTHMAP_ENABLE: u32 = 109;
pub const GPUREG_RENDERBUF_DIM: u32 = 110;
pub const GPUREG_SH_OUTATTR_CLOCK: u32 = 111;
pub const GPUREG_0070: u32 = 112;
pub const GPUREG_0071: u32 = 113;
pub const GPUREG_0072: u32 = 114;
pub const GPUREG_0073: u32 = 115;
pub const GPUREG_0074: u32 = 116;
pub const GPUREG_0075: u32 = 117;
pub const GPUREG_0076: u32 = 118;
pub const GPUREG_0077: u32 = 119;
pub const GPUREG_0078: u32 = 120;
pub const GPUREG_0079: u32 = 121;
pub const GPUREG_007A: u32 = 122;
pub const GPUREG_007B: u32 = 123;
pub const GPUREG_007C: u32 = 124;
pub const GPUREG_007D: u32 = 125;
pub const GPUREG_007E: u32 = 126;
pub const GPUREG_007F: u32 = 127;
pub const GPUREG_TEXUNIT_CONFIG: u32 = 128;
pub const GPUREG_TEXUNIT0_BORDER_COLOR: u32 = 129;
pub const GPUREG_TEXUNIT0_DIM: u32 = 130;
pub const GPUREG_TEXUNIT0_PARAM: u32 = 131;
pub const GPUREG_TEXUNIT0_LOD: u32 = 132;
pub const GPUREG_TEXUNIT0_ADDR1: u32 = 133;
pub const GPUREG_TEXUNIT0_ADDR2: u32 = 134;
pub const GPUREG_TEXUNIT0_ADDR3: u32 = 135;
pub const GPUREG_TEXUNIT0_ADDR4: u32 = 136;
pub const GPUREG_TEXUNIT0_ADDR5: u32 = 137;
pub const GPUREG_TEXUNIT0_ADDR6: u32 = 138;
pub const GPUREG_TEXUNIT0_SHADOW: u32 = 139;
pub const GPUREG_008C: u32 = 140;
pub const GPUREG_008D: u32 = 141;
pub const GPUREG_TEXUNIT0_TYPE: u32 = 142;
pub const GPUREG_LIGHTING_ENABLE0: u32 = 143;
pub const GPUREG_0090: u32 = 144;
pub const GPUREG_TEXUNIT1_BORDER_COLOR: u32 = 145;
pub const GPUREG_TEXUNIT1_DIM: u32 = 146;
pub const GPUREG_TEXUNIT1_PARAM: u32 = 147;
pub const GPUREG_TEXUNIT1_LOD: u32 = 148;
pub const GPUREG_TEXUNIT1_ADDR: u32 = 149;
pub const GPUREG_TEXUNIT1_TYPE: u32 = 150;
pub const GPUREG_0097: u32 = 151;
pub const GPUREG_0098: u32 = 152;
pub const GPUREG_TEXUNIT2_BORDER_COLOR: u32 = 153;
pub const GPUREG_TEXUNIT2_DIM: u32 = 154;
pub const GPUREG_TEXUNIT2_PARAM: u32 = 155;
pub const GPUREG_TEXUNIT2_LOD: u32 = 156;
pub const GPUREG_TEXUNIT2_ADDR: u32 = 157;
pub const GPUREG_TEXUNIT2_TYPE: u32 = 158;
pub const GPUREG_009F: u32 = 159;
pub const GPUREG_00A0: u32 = 160;
pub const GPUREG_00A1: u32 = 161;
pub const GPUREG_00A2: u32 = 162;
pub const GPUREG_00A3: u32 = 163;
pub const GPUREG_00A4: u32 = 164;
pub const GPUREG_00A5: u32 = 165;
pub const GPUREG_00A6: u32 = 166;
pub const GPUREG_00A7: u32 = 167;
pub const GPUREG_TEXUNIT3_PROCTEX0: u32 = 168;
pub const GPUREG_TEXUNIT3_PROCTEX1: u32 = 169;
pub const GPUREG_TEXUNIT3_PROCTEX2: u32 = 170;
pub const GPUREG_TEXUNIT3_PROCTEX3: u32 = 171;
pub const GPUREG_TEXUNIT3_PROCTEX4: u32 = 10;
pub const GPUREG_TEXUNIT3_PROCTEX5: u32 = 13;
pub const GPUREG_00AE: u32 = 174;
pub const GPUREG_PROCTEX_LUT: u32 = 175;
pub const GPUREG_PROCTEX_LUT_DATA0: u32 = 176;
pub const GPUREG_PROCTEX_LUT_DATA1: u32 = 177;
pub const GPUREG_PROCTEX_LUT_DATA2: u32 = 178;
pub const GPUREG_PROCTEX_LUT_DATA3: u32 = 179;
pub const GPUREG_PROCTEX_LUT_DATA4: u32 = 180;
pub const GPUREG_PROCTEX_LUT_DATA5: u32 = 181;
pub const GPUREG_PROCTEX_LUT_DATA6: u32 = 182;
pub const GPUREG_PROCTEX_LUT_DATA7: u32 = 183;
pub const GPUREG_00B8: u32 = 184;
pub const GPUREG_00B9: u32 = 185;
pub const GPUREG_00BA: u32 = 186;
pub const GPUREG_00BB: u32 = 187;
pub const GPUREG_00BC: u32 = 188;
pub const GPUREG_00BD: u32 = 189;
pub const GPUREG_00BE: u32 = 190;
pub const GPUREG_00BF: u32 = 191;
pub const GPUREG_TEXENV0_SOURCE: u32 = 192;
pub const GPUREG_TEXENV0_OPERAND: u32 = 193;
pub const GPUREG_TEXENV0_COMBINER: u32 = 194;
pub const GPUREG_TEXENV0_COLOR: u32 = 195;
pub const GPUREG_TEXENV0_SCALE: u32 = 196;
pub const GPUREG_00C5: u32 = 197;
pub const GPUREG_00C6: u32 = 198;
pub const GPUREG_00C7: u32 = 199;
pub const GPUREG_TEXENV1_SOURCE: u32 = 200;
pub const GPUREG_TEXENV1_OPERAND: u32 = 201;
pub const GPUREG_TEXENV1_COMBINER: u32 = 202;
pub const GPUREG_TEXENV1_COLOR: u32 = 203;
pub const GPUREG_TEXENV1_SCALE: u32 = 204;
pub const GPUREG_00CD: u32 = 205;
pub const GPUREG_00CE: u32 = 206;
pub const GPUREG_00CF: u32 = 207;
pub const GPUREG_TEXENV2_SOURCE: u32 = 208;
pub const GPUREG_TEXENV2_OPERAND: u32 = 209;
pub const GPUREG_TEXENV2_COMBINER: u32 = 210;
pub const GPUREG_TEXENV2_COLOR: u32 = 211;
pub const GPUREG_TEXENV2_SCALE: u32 = 212;
pub const GPUREG_00D5: u32 = 213;
pub const GPUREG_00D6: u32 = 214;
pub const GPUREG_00D7: u32 = 215;
pub const GPUREG_TEXENV3_SOURCE: u32 = 216;
pub const GPUREG_TEXENV3_OPERAND: u32 = 217;
pub const GPUREG_TEXENV3_COMBINER: u32 = 218;
pub const GPUREG_TEXENV3_COLOR: u32 = 219;
pub const GPUREG_TEXENV3_SCALE: u32 = 220;
pub const GPUREG_00DD: u32 = 221;
pub const GPUREG_00DE: u32 = 222;
pub const GPUREG_00DF: u32 = 223;
pub const GPUREG_TEXENV_UPDATE_BUFFER: u32 = 224;
pub const GPUREG_FOG_COLOR: u32 = 225;
pub const GPUREG_00E2: u32 = 226;
pub const GPUREG_00E3: u32 = 227;
pub const GPUREG_GAS_ATTENUATION: u32 = 228;
pub const GPUREG_GAS_ACCMAX: u32 = 229;
pub const GPUREG_FOG_LUT_INDEX: u32 = 230;
pub const GPUREG_00E7: u32 = 231;
pub const GPUREG_FOG_LUT_DATA0: u32 = 232;
pub const GPUREG_FOG_LUT_DATA1: u32 = 233;
pub const GPUREG_FOG_LUT_DATA2: u32 = 234;
pub const GPUREG_FOG_LUT_DATA3: u32 = 235;
pub const GPUREG_FOG_LUT_DATA4: u32 = 236;
pub const GPUREG_FOG_LUT_DATA5: u32 = 237;
pub const GPUREG_FOG_LUT_DATA6: u32 = 238;
pub const GPUREG_FOG_LUT_DATA7: u32 = 239;
pub const GPUREG_TEXENV4_SOURCE: u32 = 240;
pub const GPUREG_TEXENV4_OPERAND: u32 = 241;
pub const GPUREG_TEXENV4_COMBINER: u32 = 242;
pub const GPUREG_TEXENV4_COLOR: u32 = 243;
pub const GPUREG_TEXENV4_SCALE: u32 = 244;
pub const GPUREG_00F5: u32 = 245;
pub const GPUREG_00F6: u32 = 246;
pub const GPUREG_00F7: u32 = 247;
pub const GPUREG_TEXENV5_SOURCE: u32 = 248;
pub const GPUREG_TEXENV5_OPERAND: u32 = 249;
pub const GPUREG_TEXENV5_COMBINER: u32 = 250;
pub const GPUREG_TEXENV5_COLOR: u32 = 251;
pub const GPUREG_TEXENV5_SCALE: u32 = 252;
pub const GPUREG_TEXENV_BUFFER_COLOR: u32 = 253;
pub const GPUREG_00FE: u32 = 254;
pub const GPUREG_00FF: u32 = 255;
pub const GPUREG_COLOR_OPERATION: u32 = 256;
pub const GPUREG_BLEND_FUNC: u32 = 257;
pub const GPUREG_LOGIC_OP: u32 = 258;
pub const GPUREG_BLEND_COLOR: u32 = 259;
pub const GPUREG_FRAGOP_ALPHA_TEST: u32 = 260;
pub const GPUREG_STENCIL_TEST: u32 = 261;
pub const GPUREG_STENCIL_OP: u32 = 262;
pub const GPUREG_DEPTH_COLOR_MASK: u32 = 263;
pub const GPUREG_0108: u32 = 264;
pub const GPUREG_0109: u32 = 265;
pub const GPUREG_010A: u32 = 266;
pub const GPUREG_010B: u32 = 267;
pub const GPUREG_010C: u32 = 268;
pub const GPUREG_010D: u32 = 269;
pub const GPUREG_010E: u32 = 270;
pub const GPUREG_010F: u32 = 271;
pub const GPUREG_FRAMEBUFFER_INVALIDATE: u32 = 272;
pub const GPUREG_FRAMEBUFFER_FLUSH: u32 = 273;
pub const GPUREG_COLORBUFFER_READ: u32 = 274;
pub const GPUREG_COLORBUFFER_WRITE: u32 = 275;
pub const GPUREG_DEPTHBUFFER_READ: u32 = 276;
pub const GPUREG_DEPTHBUFFER_WRITE: u32 = 277;
pub const GPUREG_DEPTHBUFFER_FORMAT: u32 = 278;
pub const GPUREG_COLORBUFFER_FORMAT: u32 = 279;
pub const GPUREG_EARLYDEPTH_TEST2: u32 = 280;
pub const GPUREG_0119: u32 = 281;
pub const GPUREG_011A: u32 = 282;
pub const GPUREG_FRAMEBUFFER_BLOCK32: u32 = 283;
pub const GPUREG_DEPTHBUFFER_LOC: u32 = 284;
pub const GPUREG_COLORBUFFER_LOC: u32 = 285;
pub const GPUREG_FRAMEBUFFER_DIM: u32 = 286;
pub const GPUREG_011F: u32 = 287;
pub const GPUREG_GAS_LIGHT_XY: u32 = 288;
pub const GPUREG_GAS_LIGHT_Z: u32 = 289;
pub const GPUREG_GAS_LIGHT_Z_COLOR: u32 = 290;
pub const GPUREG_GAS_LUT_INDEX: u32 = 291;
pub const GPUREG_GAS_LUT_DATA: u32 = 292;
pub const GPUREG_GAS_ACCMAX_FEEDBACK: u32 = 293;
pub const GPUREG_GAS_DELTAZ_DEPTH: u32 = 294;
pub const GPUREG_0127: u32 = 295;
pub const GPUREG_0128: u32 = 296;
pub const GPUREG_0129: u32 = 297;
pub const GPUREG_012A: u32 = 298;
pub const GPUREG_012B: u32 = 299;
pub const GPUREG_012C: u32 = 300;
pub const GPUREG_012D: u32 = 301;
pub const GPUREG_012E: u32 = 302;
pub const GPUREG_012F: u32 = 303;
pub const GPUREG_FRAGOP_SHADOW: u32 = 304;
pub const GPUREG_0131: u32 = 305;
pub const GPUREG_0132: u32 = 306;
pub const GPUREG_0133: u32 = 307;
pub const GPUREG_0134: u32 = 308;
pub const GPUREG_0135: u32 = 309;
pub const GPUREG_0136: u32 = 310;
pub const GPUREG_0137: u32 = 311;
pub const GPUREG_0138: u32 = 312;
pub const GPUREG_0139: u32 = 313;
pub const GPUREG_013A: u32 = 314;
pub const GPUREG_013B: u32 = 315;
pub const GPUREG_013C: u32 = 316;
pub const GPUREG_013D: u32 = 317;
pub const GPUREG_013E: u32 = 318;
pub const GPUREG_013F: u32 = 319;
pub const GPUREG_LIGHT0_SPECULAR0: u32 = 320;
pub const GPUREG_LIGHT0_SPECULAR1: u32 = 321;
pub const GPUREG_LIGHT0_DIFFUSE: u32 = 322;
pub const GPUREG_LIGHT0_AMBIENT: u32 = 323;
pub const GPUREG_LIGHT0_XY: u32 = 324;
pub const GPUREG_LIGHT0_Z: u32 = 325;
pub const GPUREG_LIGHT0_SPOTDIR_XY: u32 = 326;
pub const GPUREG_LIGHT0_SPOTDIR_Z: u32 = 327;
pub const GPUREG_0148: u32 = 328;
pub const GPUREG_LIGHT0_CONFIG: u32 = 329;
pub const GPUREG_LIGHT0_ATTENUATION_BIAS: u32 = 330;
pub const GPUREG_LIGHT0_ATTENUATION_SCALE: u32 = 331;
pub const GPUREG_014C: u32 = 332;
pub const GPUREG_014D: u32 = 333;
pub const GPUREG_014E: u32 = 334;
pub const GPUREG_014F: u32 = 335;
pub const GPUREG_LIGHT1_SPECULAR0: u32 = 336;
pub const GPUREG_LIGHT1_SPECULAR1: u32 = 337;
pub const GPUREG_LIGHT1_DIFFUSE: u32 = 338;
pub const GPUREG_LIGHT1_AMBIENT: u32 = 339;
pub const GPUREG_LIGHT1_XY: u32 = 340;
pub const GPUREG_LIGHT1_Z: u32 = 341;
pub const GPUREG_LIGHT1_SPOTDIR_XY: u32 = 342;
pub const GPUREG_LIGHT1_SPOTDIR_Z: u32 = 343;
pub const GPUREG_0158: u32 = 344;
pub const GPUREG_LIGHT1_CONFIG: u32 = 345;
pub const GPUREG_LIGHT1_ATTENUATION_BIAS: u32 = 346;
pub const GPUREG_LIGHT1_ATTENUATION_SCALE: u32 = 347;
pub const GPUREG_015C: u32 = 348;
pub const GPUREG_015D: u32 = 349;
pub const GPUREG_015E: u32 = 350;
pub const GPUREG_015F: u32 = 351;
pub const GPUREG_LIGHT2_SPECULAR0: u32 = 352;
pub const GPUREG_LIGHT2_SPECULAR1: u32 = 353;
pub const GPUREG_LIGHT2_DIFFUSE: u32 = 354;
pub const GPUREG_LIGHT2_AMBIENT: u32 = 355;
pub const GPUREG_LIGHT2_XY: u32 = 356;
pub const GPUREG_LIGHT2_Z: u32 = 357;
pub const GPUREG_LIGHT2_SPOTDIR_XY: u32 = 358;
pub const GPUREG_LIGHT2_SPOTDIR_Z: u32 = 359;
pub const GPUREG_0168: u32 = 360;
pub const GPUREG_LIGHT2_CONFIG: u32 = 361;
pub const GPUREG_LIGHT2_ATTENUATION_BIAS: u32 = 362;
pub const GPUREG_LIGHT2_ATTENUATION_SCALE: u32 = 363;
pub const GPUREG_016C: u32 = 364;
pub const GPUREG_016D: u32 = 365;
pub const GPUREG_016E: u32 = 366;
pub const GPUREG_016F: u32 = 367;
pub const GPUREG_LIGHT3_SPECULAR0: u32 = 368;
pub const GPUREG_LIGHT3_SPECULAR1: u32 = 369;
pub const GPUREG_LIGHT3_DIFFUSE: u32 = 370;
pub const GPUREG_LIGHT3_AMBIENT: u32 = 371;
pub const GPUREG_LIGHT3_XY: u32 = 372;
pub const GPUREG_LIGHT3_Z: u32 = 373;
pub const GPUREG_LIGHT3_SPOTDIR_XY: u32 = 374;
pub const GPUREG_LIGHT3_SPOTDIR_Z: u32 = 375;
pub const GPUREG_0178: u32 = 376;
pub const GPUREG_LIGHT3_CONFIG: u32 = 377;
pub const GPUREG_LIGHT3_ATTENUATION_BIAS: u32 = 378;
pub const GPUREG_LIGHT3_ATTENUATION_SCALE: u32 = 379;
pub const GPUREG_017C: u32 = 380;
pub const GPUREG_017D: u32 = 381;
pub const GPUREG_017E: u32 = 382;
pub const GPUREG_017F: u32 = 383;
pub const GPUREG_LIGHT4_SPECULAR0: u32 = 384;
pub const GPUREG_LIGHT4_SPECULAR1: u32 = 385;
pub const GPUREG_LIGHT4_DIFFUSE: u32 = 386;
pub const GPUREG_LIGHT4_AMBIENT: u32 = 387;
pub const GPUREG_LIGHT4_XY: u32 = 388;
pub const GPUREG_LIGHT4_Z: u32 = 389;
pub const GPUREG_LIGHT4_SPOTDIR_XY: u32 = 390;
pub const GPUREG_LIGHT4_SPOTDIR_Z: u32 = 391;
pub const GPUREG_0188: u32 = 392;
pub const GPUREG_LIGHT4_CONFIG: u32 = 393;
pub const GPUREG_LIGHT4_ATTENUATION_BIAS: u32 = 394;
pub const GPUREG_LIGHT4_ATTENUATION_SCALE: u32 = 395;
pub const GPUREG_018C: u32 = 396;
pub const GPUREG_018D: u32 = 397;
pub const GPUREG_018E: u32 = 398;
pub const GPUREG_018F: u32 = 399;
pub const GPUREG_LIGHT5_SPECULAR0: u32 = 400;
pub const GPUREG_LIGHT5_SPECULAR1: u32 = 401;
pub const GPUREG_LIGHT5_DIFFUSE: u32 = 402;
pub const GPUREG_LIGHT5_AMBIENT: u32 = 403;
pub const GPUREG_LIGHT5_XY: u32 = 404;
pub const GPUREG_LIGHT5_Z: u32 = 405;
pub const GPUREG_LIGHT5_SPOTDIR_XY: u32 = 406;
pub const GPUREG_LIGHT5_SPOTDIR_Z: u32 = 407;
pub const GPUREG_0198: u32 = 408;
pub const GPUREG_LIGHT5_CONFIG: u32 = 409;
pub const GPUREG_LIGHT5_ATTENUATION_BIAS: u32 = 410;
pub const GPUREG_LIGHT5_ATTENUATION_SCALE: u32 = 411;
pub const GPUREG_019C: u32 = 412;
pub const GPUREG_019D: u32 = 413;
pub const GPUREG_019E: u32 = 414;
pub const GPUREG_019F: u32 = 415;
pub const GPUREG_LIGHT6_SPECULAR0: u32 = 416;
pub const GPUREG_LIGHT6_SPECULAR1: u32 = 417;
pub const GPUREG_LIGHT6_DIFFUSE: u32 = 418;
pub const GPUREG_LIGHT6_AMBIENT: u32 = 419;
pub const GPUREG_LIGHT6_XY: u32 = 420;
pub const GPUREG_LIGHT6_Z: u32 = 421;
pub const GPUREG_LIGHT6_SPOTDIR_XY: u32 = 422;
pub const GPUREG_LIGHT6_SPOTDIR_Z: u32 = 423;
pub const GPUREG_01A8: u32 = 424;
pub const GPUREG_LIGHT6_CONFIG: u32 = 425;
pub const GPUREG_LIGHT6_ATTENUATION_BIAS: u32 = 426;
pub const GPUREG_LIGHT6_ATTENUATION_SCALE: u32 = 427;
pub const GPUREG_01AC: u32 = 428;
pub const GPUREG_01AD: u32 = 429;
pub const GPUREG_01AE: u32 = 430;
pub const GPUREG_01AF: u32 = 431;
pub const GPUREG_LIGHT7_SPECULAR0: u32 = 432;
pub const GPUREG_LIGHT7_SPECULAR1: u32 = 433;
pub const GPUREG_LIGHT7_DIFFUSE: u32 = 434;
pub const GPUREG_LIGHT7_AMBIENT: u32 = 435;
pub const GPUREG_LIGHT7_XY: u32 = 436;
pub const GPUREG_LIGHT7_Z: u32 = 437;
pub const GPUREG_LIGHT7_SPOTDIR_XY: u32 = 438;
pub const GPUREG_LIGHT7_SPOTDIR_Z: u32 = 439;
pub const GPUREG_01B8: u32 = 440;
pub const GPUREG_LIGHT7_CONFIG: u32 = 441;
pub const GPUREG_LIGHT7_ATTENUATION_BIAS: u32 = 442;
pub const GPUREG_LIGHT7_ATTENUATION_SCALE: u32 = 443;
pub const GPUREG_01BC: u32 = 444;
pub const GPUREG_01BD: u32 = 445;
pub const GPUREG_01BE: u32 = 446;
pub const GPUREG_01BF: u32 = 447;
pub const GPUREG_LIGHTING_AMBIENT: u32 = 448;
pub const GPUREG_01C1: u32 = 449;
pub const GPUREG_LIGHTING_NUM_LIGHTS: u32 = 450;
pub const GPUREG_LIGHTING_CONFIG0: u32 = 451;
pub const GPUREG_LIGHTING_CONFIG1: u32 = 452;
pub const GPUREG_LIGHTING_LUT_INDEX: u32 = 453;
pub const GPUREG_LIGHTING_ENABLE1: u32 = 454;
pub const GPUREG_01C7: u32 = 455;
pub const GPUREG_LIGHTING_LUT_DATA0: u32 = 456;
pub const GPUREG_LIGHTING_LUT_DATA1: u32 = 457;
pub const GPUREG_LIGHTING_LUT_DATA2: u32 = 458;
pub const GPUREG_LIGHTING_LUT_DATA3: u32 = 459;
pub const GPUREG_LIGHTING_LUT_DATA4: u32 = 460;
pub const GPUREG_LIGHTING_LUT_DATA5: u32 = 461;
pub const GPUREG_LIGHTING_LUT_DATA6: u32 = 462;
pub const GPUREG_LIGHTING_LUT_DATA7: u32 = 463;
pub const GPUREG_LIGHTING_LUTINPUT_ABS: u32 = 464;
pub const GPUREG_LIGHTING_LUTINPUT_SELECT: u32 = 465;
pub const GPUREG_LIGHTING_LUTINPUT_SCALE: u32 = 466;
pub const GPUREG_01D3: u32 = 467;
pub const GPUREG_01D4: u32 = 468;
pub const GPUREG_01D5: u32 = 469;
pub const GPUREG_01D6: u32 = 470;
pub const GPUREG_01D7: u32 = 471;
pub const GPUREG_01D8: u32 = 472;
pub const GPUREG_LIGHTING_LIGHT_PERMUTATION: u32 = 473;
pub const GPUREG_01DA: u32 = 474;
pub const GPUREG_01DB: u32 = 475;
pub const GPUREG_01DC: u32 = 476;
pub const GPUREG_01DD: u32 = 477;
pub const GPUREG_01DE: u32 = 478;
pub const GPUREG_01DF: u32 = 479;
pub const GPUREG_01E0: u32 = 480;
pub const GPUREG_01E1: u32 = 481;
pub const GPUREG_01E2: u32 = 482;
pub const GPUREG_01E3: u32 = 483;
pub const GPUREG_01E4: u32 = 484;
pub const GPUREG_01E5: u32 = 485;
pub const GPUREG_01E6: u32 = 486;
pub const GPUREG_01E7: u32 = 487;
pub const GPUREG_01E8: u32 = 488;
pub const GPUREG_01E9: u32 = 489;
pub const GPUREG_01EA: u32 = 490;
pub const GPUREG_01EB: u32 = 491;
pub const GPUREG_01EC: u32 = 492;
pub const GPUREG_01ED: u32 = 493;
pub const GPUREG_01EE: u32 = 494;
pub const GPUREG_01EF: u32 = 495;
pub const GPUREG_01F0: u32 = 496;
pub const GPUREG_01F1: u32 = 497;
pub const GPUREG_01F2: u32 = 498;
pub const GPUREG_01F3: u32 = 499;
pub const GPUREG_01F4: u32 = 500;
pub const GPUREG_01F5: u32 = 501;
pub const GPUREG_01F6: u32 = 502;
pub const GPUREG_01F7: u32 = 503;
pub const GPUREG_01F8: u32 = 504;
pub const GPUREG_01F9: u32 = 505;
pub const GPUREG_01FA: u32 = 506;
pub const GPUREG_01FB: u32 = 507;
pub const GPUREG_01FC: u32 = 508;
pub const GPUREG_01FD: u32 = 509;
pub const GPUREG_01FE: u32 = 510;
pub const GPUREG_01FF: u32 = 511;
pub const GPUREG_ATTRIBBUFFERS_LOC: u32 = 512;
pub const GPUREG_ATTRIBBUFFERS_FORMAT_LOW: u32 = 513;
pub const GPUREG_ATTRIBBUFFERS_FORMAT_HIGH: u32 = 514;
pub const GPUREG_ATTRIBBUFFER0_OFFSET: u32 = 515;
pub const GPUREG_ATTRIBBUFFER0_CONFIG1: u32 = 516;
pub const GPUREG_ATTRIBBUFFER0_CONFIG2: u32 = 517;
pub const GPUREG_ATTRIBBUFFER1_OFFSET: u32 = 518;
pub const GPUREG_ATTRIBBUFFER1_CONFIG1: u32 = 519;
pub const GPUREG_ATTRIBBUFFER1_CONFIG2: u32 = 520;
pub const GPUREG_ATTRIBBUFFER2_OFFSET: u32 = 521;
pub const GPUREG_ATTRIBBUFFER2_CONFIG1: u32 = 522;
pub const GPUREG_ATTRIBBUFFER2_CONFIG2: u32 = 523;
pub const GPUREG_ATTRIBBUFFER3_OFFSET: u32 = 524;
pub const GPUREG_ATTRIBBUFFER3_CONFIG1: u32 = 525;
pub const GPUREG_ATTRIBBUFFER3_CONFIG2: u32 = 526;
pub const GPUREG_ATTRIBBUFFER4_OFFSET: u32 = 527;
pub const GPUREG_ATTRIBBUFFER4_CONFIG1: u32 = 528;
pub const GPUREG_ATTRIBBUFFER4_CONFIG2: u32 = 529;
pub const GPUREG_ATTRIBBUFFER5_OFFSET: u32 = 530;
pub const GPUREG_ATTRIBBUFFER5_CONFIG1: u32 = 531;
pub const GPUREG_ATTRIBBUFFER5_CONFIG2: u32 = 532;
pub const GPUREG_ATTRIBBUFFER6_OFFSET: u32 = 533;
pub const GPUREG_ATTRIBBUFFER6_CONFIG1: u32 = 534;
pub const GPUREG_ATTRIBBUFFER6_CONFIG2: u32 = 535;
pub const GPUREG_ATTRIBBUFFER7_OFFSET: u32 = 536;
pub const GPUREG_ATTRIBBUFFER7_CONFIG1: u32 = 537;
pub const GPUREG_ATTRIBBUFFER7_CONFIG2: u32 = 538;
pub const GPUREG_ATTRIBBUFFER8_OFFSET: u32 = 539;
pub const GPUREG_ATTRIBBUFFER8_CONFIG1: u32 = 540;
pub const GPUREG_ATTRIBBUFFER8_CONFIG2: u32 = 541;
pub const GPUREG_ATTRIBBUFFER9_OFFSET: u32 = 542;
pub const GPUREG_ATTRIBBUFFER9_CONFIG1: u32 = 543;
pub const GPUREG_ATTRIBBUFFER9_CONFIG2: u32 = 544;
pub const GPUREG_ATTRIBBUFFERA_OFFSET: u32 = 545;
pub const GPUREG_ATTRIBBUFFERA_CONFIG1: u32 = 546;
pub const GPUREG_ATTRIBBUFFERA_CONFIG2: u32 = 547;
pub const GPUREG_ATTRIBBUFFERB_OFFSET: u32 = 548;
pub const GPUREG_ATTRIBBUFFERB_CONFIG1: u32 = 549;
pub const GPUREG_ATTRIBBUFFERB_CONFIG2: u32 = 550;
pub const GPUREG_INDEXBUFFER_CONFIG: u32 = 551;
pub const GPUREG_NUMVERTICES: u32 = 552;
pub const GPUREG_GEOSTAGE_CONFIG: u32 = 553;
pub const GPUREG_VERTEX_OFFSET: u32 = 554;
pub const GPUREG_022B: u32 = 555;
pub const GPUREG_022C: u32 = 556;
pub const GPUREG_POST_VERTEX_CACHE_NUM: u32 = 557;
pub const GPUREG_DRAWARRAYS: u32 = 558;
pub const GPUREG_DRAWELEMENTS: u32 = 559;
pub const GPUREG_0230: u32 = 560;
pub const GPUREG_VTX_FUNC: u32 = 561;
pub const GPUREG_FIXEDATTRIB_INDEX: u32 = 562;
pub const GPUREG_FIXEDATTRIB_DATA0: u32 = 563;
pub const GPUREG_FIXEDATTRIB_DATA1: u32 = 564;
pub const GPUREG_FIXEDATTRIB_DATA2: u32 = 565;
pub const GPUREG_0236: u32 = 566;
pub const GPUREG_0237: u32 = 567;
pub const GPUREG_CMDBUF_SIZE0: u32 = 568;
pub const GPUREG_CMDBUF_SIZE1: u32 = 569;
pub const GPUREG_CMDBUF_ADDR0: u32 = 570;
pub const GPUREG_CMDBUF_ADDR1: u32 = 571;
pub const GPUREG_CMDBUF_JUMP0: u32 = 572;
pub const GPUREG_CMDBUF_JUMP1: u32 = 573;
pub const GPUREG_023E: u32 = 574;
pub const GPUREG_023F: u32 = 575;
pub const GPUREG_0240: u32 = 576;
pub const GPUREG_0241: u32 = 577;
pub const GPUREG_VSH_NUM_ATTR: u32 = 578;
pub const GPUREG_0243: u32 = 579;
pub const GPUREG_VSH_COM_MODE: u32 = 580;
pub const GPUREG_START_DRAW_FUNC0: u32 = 581;
pub const GPUREG_0246: u32 = 582;
pub const GPUREG_0247: u32 = 583;
pub const GPUREG_0248: u32 = 584;
pub const GPUREG_0249: u32 = 585;
pub const GPUREG_VSH_OUTMAP_TOTAL1: u32 = 586;
pub const GPUREG_024B: u32 = 587;
pub const GPUREG_024C: u32 = 588;
pub const GPUREG_024D: u32 = 589;
pub const GPUREG_024E: u32 = 590;
pub const GPUREG_024F: u32 = 591;
pub const GPUREG_0250: u32 = 592;
pub const GPUREG_VSH_OUTMAP_TOTAL2: u32 = 593;
pub const GPUREG_GSH_MISC0: u32 = 594;
pub const GPUREG_GEOSTAGE_CONFIG2: u32 = 595;
pub const GPUREG_GSH_MISC1: u32 = 596;
pub const GPUREG_0255: u32 = 597;
pub const GPUREG_0256: u32 = 598;
pub const GPUREG_0257: u32 = 599;
pub const GPUREG_0258: u32 = 600;
pub const GPUREG_0259: u32 = 601;
pub const GPUREG_025A: u32 = 602;
pub const GPUREG_025B: u32 = 603;
pub const GPUREG_025C: u32 = 604;
pub const GPUREG_025D: u32 = 605;
pub const GPUREG_PRIMITIVE_CONFIG: u32 = 606;
pub const GPUREG_RESTART_PRIMITIVE: u32 = 607;
pub const GPUREG_0260: u32 = 608;
pub const GPUREG_0261: u32 = 609;
pub const GPUREG_0262: u32 = 610;
pub const GPUREG_0263: u32 = 611;
pub const GPUREG_0264: u32 = 612;
pub const GPUREG_0265: u32 = 613;
pub const GPUREG_0266: u32 = 614;
pub const GPUREG_0267: u32 = 615;
pub const GPUREG_0268: u32 = 616;
pub const GPUREG_0269: u32 = 617;
pub const GPUREG_026A: u32 = 618;
pub const GPUREG_026B: u32 = 619;
pub const GPUREG_026C: u32 = 620;
pub const GPUREG_026D: u32 = 621;
pub const GPUREG_026E: u32 = 622;
pub const GPUREG_026F: u32 = 623;
pub const GPUREG_0270: u32 = 624;
pub const GPUREG_0271: u32 = 625;
pub const GPUREG_0272: u32 = 626;
pub const GPUREG_0273: u32 = 627;
pub const GPUREG_0274: u32 = 628;
pub const GPUREG_0275: u32 = 629;
pub const GPUREG_0276: u32 = 630;
pub const GPUREG_0277: u32 = 631;
pub const GPUREG_0278: u32 = 632;
pub const GPUREG_0279: u32 = 633;
pub const GPUREG_027A: u32 = 634;
pub const GPUREG_027B: u32 = 635;
pub const GPUREG_027C: u32 = 636;
pub const GPUREG_027D: u32 = 637;
pub const GPUREG_027E: u32 = 638;
pub const GPUREG_027F: u32 = 639;
pub const GPUREG_GSH_BOOLUNIFORM: u32 = 640;
pub const GPUREG_GSH_INTUNIFORM_I0: u32 = 641;
pub const GPUREG_GSH_INTUNIFORM_I1: u32 = 642;
pub const GPUREG_GSH_INTUNIFORM_I2: u32 = 643;
pub const GPUREG_GSH_INTUNIFORM_I3: u32 = 644;
pub const GPUREG_0285: u32 = 645;
pub const GPUREG_0286: u32 = 646;
pub const GPUREG_0287: u32 = 647;
pub const GPUREG_0288: u32 = 648;
pub const GPUREG_GSH_INPUTBUFFER_CONFIG: u32 = 649;
pub const GPUREG_GSH_ENTRYPOINT: u32 = 650;
pub const GPUREG_GSH_ATTRIBUTES_PERMUTATION_LOW: u32 = 651;
pub const GPUREG_GSH_ATTRIBUTES_PERMUTATION_HIGH: u32 = 652;
pub const GPUREG_GSH_OUTMAP_MASK: u32 = 653;
pub const GPUREG_028E: u32 = 654;
pub const GPUREG_GSH_CODETRANSFER_END: u32 = 655;
pub const GPUREG_GSH_FLOATUNIFORM_CONFIG: u32 = 656;
pub const GPUREG_GSH_FLOATUNIFORM_DATA: u32 = 657;
pub const GPUREG_0299: u32 = 665;
pub const GPUREG_029A: u32 = 666;
pub const GPUREG_GSH_CODETRANSFER_CONFIG: u32 = 667;
pub const GPUREG_GSH_CODETRANSFER_DATA: u32 = 668;
pub const GPUREG_02A4: u32 = 676;
pub const GPUREG_GSH_OPDESCS_CONFIG: u32 = 677;
pub const GPUREG_GSH_OPDESCS_DATA: u32 = 678;
pub const GPUREG_02AE: u32 = 686;
pub const GPUREG_02AF: u32 = 687;
pub const GPUREG_VSH_BOOLUNIFORM: u32 = 688;
pub const GPUREG_VSH_INTUNIFORM_I0: u32 = 689;
pub const GPUREG_VSH_INTUNIFORM_I1: u32 = 690;
pub const GPUREG_VSH_INTUNIFORM_I2: u32 = 691;
pub const GPUREG_VSH_INTUNIFORM_I3: u32 = 692;
pub const GPUREG_02B5: u32 = 693;
pub const GPUREG_02B6: u32 = 694;
pub const GPUREG_02B7: u32 = 695;
pub const GPUREG_02B8: u32 = 696;
pub const GPUREG_VSH_INPUTBUFFER_CONFIG: u32 = 697;
pub const GPUREG_VSH_ENTRYPOINT: u32 = 698;
pub const GPUREG_VSH_ATTRIBUTES_PERMUTATION_LOW: u32 = 699;
pub const GPUREG_VSH_ATTRIBUTES_PERMUTATION_HIGH: u32 = 700;
pub const GPUREG_VSH_OUTMAP_MASK: u32 = 701;
pub const GPUREG_02BE: u32 = 702;
pub const GPUREG_VSH_CODETRANSFER_END: u32 = 703;
pub const GPUREG_VSH_FLOATUNIFORM_CONFIG: u32 = 704;
pub const GPUREG_VSH_FLOATUNIFORM_DATA: u32 = 705;
pub const GPUREG_02C9: u32 = 713;
pub const GPUREG_02CA: u32 = 714;
pub const GPUREG_VSH_CODETRANSFER_CONFIG: u32 = 715;
pub const GPUREG_VSH_CODETRANSFER_DATA: u32 = 716;
pub const GPUREG_02D4: u32 = 724;
pub const GPUREG_VSH_OPDESCS_CONFIG: u32 = 725;
pub const GPUREG_VSH_OPDESCS_DATA: u32 = 726;
pub const GPUREG_02DE: u32 = 734;
pub const GPUREG_02DF: u32 = 735;
pub const GPUREG_02E0: u32 = 736;
pub const GPUREG_02E1: u32 = 737;
pub const GPUREG_02E2: u32 = 738;
pub const GPUREG_02E3: u32 = 739;
pub const GPUREG_02E4: u32 = 740;
pub const GPUREG_02E5: u32 = 741;
pub const GPUREG_02E6: u32 = 742;
pub const GPUREG_02E7: u32 = 743;
pub const GPUREG_02E8: u32 = 744;
pub const GPUREG_02E9: u32 = 745;
pub const GPUREG_02EA: u32 = 746;
pub const GPUREG_02EB: u32 = 747;
pub const GPUREG_02EC: u32 = 748;
pub const GPUREG_02ED: u32 = 749;
pub const GPUREG_02EE: u32 = 750;
pub const GPUREG_02EF: u32 = 751;
pub const GPUREG_02F0: u32 = 752;
pub const GPUREG_02F1: u32 = 753;
pub const GPUREG_02F2: u32 = 754;
pub const GPUREG_02F3: u32 = 755;
pub const GPUREG_02F4: u32 = 756;
pub const GPUREG_02F5: u32 = 757;
pub const GPUREG_02F6: u32 = 758;
pub const GPUREG_02F7: u32 = 759;
pub const GPUREG_02F8: u32 = 760;
pub const GPUREG_02F9: u32 = 761;
pub const GPUREG_02FA: u32 = 762;
pub const GPUREG_02FB: u32 = 763;
pub const GPUREG_02FC: u32 = 764;
pub const GPUREG_02FD: u32 = 765;
pub const GPUREG_02FE: u32 = 766;
pub const GPUREG_02FF: u32 = 767;
pub const NDSP_SAMPLE_RATE: f64 = 32728.498046875;
pub const SWKBD_MAX_WORD_LEN: u32 = 40;
pub const SWKBD_MAX_BUTTON_TEXT_LEN: u32 = 16;
pub const SWKBD_MAX_HINT_TEXT_LEN: u32 = 64;
pub const SWKBD_MAX_CALLBACK_MSG_LEN: u32 = 256;
pub const MIISELECTOR_MAGIC: u32 = 333326543;
pub const MIISELECTOR_TITLE_LEN: u32 = 64;
pub const MIISELECTOR_GUESTMII_SLOTS: u32 = 6;
pub const MIISELECTOR_USERMII_SLOTS: u32 = 100;
pub const MIISELECTOR_GUESTMII_NAME_LEN: u32 = 12;
pub const ARCHIVE_DIRITER_MAGIC: u32 = 1751347809;
pub const LINK3DS_COMM_PORT: u32 = 17491;
pub type __int8_t = ::libc::c_schar;
pub type __uint8_t = ::libc::c_uchar;
pub type __int16_t = ::libc::c_short;
pub type __uint16_t = ::libc::c_ushort;
pub type __int32_t = ::libc::c_int;
pub type __uint32_t = ::libc::c_uint;
pub type __int64_t = ::libc::c_longlong;
pub type __uint64_t = ::libc::c_ulonglong;
pub type __int_least8_t = ::libc::c_schar;
pub type __uint_least8_t = ::libc::c_uchar;
pub type __int_least16_t = ::libc::c_short;
pub type __uint_least16_t = ::libc::c_ushort;
pub type __int_least32_t = ::libc::c_int;
pub type __uint_least32_t = ::libc::c_uint;
pub type __int_least64_t = ::libc::c_longlong;
pub type __uint_least64_t = ::libc::c_ulonglong;
pub type __intmax_t = ::libc::c_longlong;
pub type __uintmax_t = ::libc::c_ulonglong;
pub type __intptr_t = ::libc::c_int;
pub type __uintptr_t = ::libc::c_uint;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type int_least8_t = __int_least8_t;
pub type uint_least8_t = __uint_least8_t;
pub type int_least16_t = __int_least16_t;
pub type uint_least16_t = __uint_least16_t;
pub type int_least32_t = __int_least32_t;
pub type uint_least32_t = __uint_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::libc::c_schar;
pub type uint_fast8_t = ::libc::c_uchar;
pub type int_fast16_t = ::libc::c_short;
pub type uint_fast16_t = ::libc::c_ushort;
pub type int_fast32_t = ::libc::c_int;
pub type uint_fast32_t = ::libc::c_uint;
pub type int_fast64_t = ::libc::c_longlong;
pub type uint_fast64_t = ::libc::c_ulonglong;
pub type wchar_t = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::libc::c_longlong,
    pub __clang_max_align_nonce2: f64,
}
pub type u8_ = u8;
pub type u16_ = u16;
pub type u32_ = u32;
pub type u64_ = u64;
pub type s8 = i8;
pub type s16 = i16;
pub type s32 = i32;
pub type s64 = i64;
pub type vu8 = u8_;
pub type vu16 = u16_;
pub type vu32 = u32_;
pub type vu64 = u64_;
pub type vs8 = s8;
pub type vs16 = s16;
pub type vs32 = s32;
pub type vs64 = s64;
pub type Handle = u32_;
pub type Result = s32;
pub type ThreadFunc = ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::libc::c_void)>;
pub type voidfn = ::core::option::Option<unsafe extern "C" fn()>;
#[doc = "Structure representing CPU registers"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CpuRegisters {
    #[doc = "r0-r12."]
    #[doc = ""]
    pub r: [u32_; 13usize],
    #[doc = "sp."]
    #[doc = ""]
    pub sp: u32_,
    #[doc = "lr."]
    #[doc = ""]
    pub lr: u32_,
    #[doc = "pc. May need to be adjusted."]
    #[doc = ""]
    pub pc: u32_,
    #[doc = "cpsr."]
    #[doc = ""]
    pub cpsr: u32_,
}
#[doc = "Structure representing FPU registers"]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FpuRegisters {
    pub __bindgen_anon_1: FpuRegisters__bindgen_ty_1,
    #[doc = "fpscr."]
    #[doc = ""]
    pub fpscr: u32_,
    #[doc = "fpexc."]
    #[doc = ""]
    pub fpexc: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union FpuRegisters__bindgen_ty_1 {
    pub __bindgen_anon_1: FpuRegisters__bindgen_ty_1__bindgen_ty_1,
    #[doc = "s0-s31."]
    #[doc = ""]
    pub s: [f32; 32usize],
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FpuRegisters__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "d0-d15."]
    #[doc = ""]
    pub d: [f64; 16usize],
}
impl Default for FpuRegisters__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for FpuRegisters {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const RL_SUCCESS: _bindgen_ty_1 = 0;
pub const RL_INFO: _bindgen_ty_1 = 1;
pub const RL_FATAL: _bindgen_ty_1 = 31;
pub const RL_RESET: _bindgen_ty_1 = 30;
pub const RL_REINITIALIZE: _bindgen_ty_1 = 29;
pub const RL_USAGE: _bindgen_ty_1 = 28;
pub const RL_PERMANENT: _bindgen_ty_1 = 27;
pub const RL_TEMPORARY: _bindgen_ty_1 = 26;
pub const RL_STATUS: _bindgen_ty_1 = 25;
#[doc = "Result code level values."]
#[doc = ""]

pub type _bindgen_ty_1 = ::libc::c_uint;
pub const RS_SUCCESS: _bindgen_ty_2 = 0;
pub const RS_NOP: _bindgen_ty_2 = 1;
pub const RS_WOULDBLOCK: _bindgen_ty_2 = 2;
pub const RS_OUTOFRESOURCE: _bindgen_ty_2 = 3;
pub const RS_NOTFOUND: _bindgen_ty_2 = 4;
pub const RS_INVALIDSTATE: _bindgen_ty_2 = 5;
pub const RS_NOTSUPPORTED: _bindgen_ty_2 = 6;
pub const RS_INVALIDARG: _bindgen_ty_2 = 7;
pub const RS_WRONGARG: _bindgen_ty_2 = 8;
pub const RS_CANCELED: _bindgen_ty_2 = 9;
pub const RS_STATUSCHANGED: _bindgen_ty_2 = 10;
pub const RS_INTERNAL: _bindgen_ty_2 = 11;
pub const RS_INVALIDRESVAL: _bindgen_ty_2 = 63;
#[doc = "Result code summary values."]
#[doc = ""]

pub type _bindgen_ty_2 = ::libc::c_uint;
pub const RM_COMMON: _bindgen_ty_3 = 0;
pub const RM_KERNEL: _bindgen_ty_3 = 1;
pub const RM_UTIL: _bindgen_ty_3 = 2;
pub const RM_FILE_SERVER: _bindgen_ty_3 = 3;
pub const RM_LOADER_SERVER: _bindgen_ty_3 = 4;
pub const RM_TCB: _bindgen_ty_3 = 5;
pub const RM_OS: _bindgen_ty_3 = 6;
pub const RM_DBG: _bindgen_ty_3 = 7;
pub const RM_DMNT: _bindgen_ty_3 = 8;
pub const RM_PDN: _bindgen_ty_3 = 9;
pub const RM_GSP: _bindgen_ty_3 = 10;
pub const RM_I2C: _bindgen_ty_3 = 11;
pub const RM_GPIO: _bindgen_ty_3 = 12;
pub const RM_DD: _bindgen_ty_3 = 13;
pub const RM_CODEC: _bindgen_ty_3 = 14;
pub const RM_SPI: _bindgen_ty_3 = 15;
pub const RM_PXI: _bindgen_ty_3 = 16;
pub const RM_FS: _bindgen_ty_3 = 17;
pub const RM_DI: _bindgen_ty_3 = 18;
pub const RM_HID: _bindgen_ty_3 = 19;
pub const RM_CAM: _bindgen_ty_3 = 20;
pub const RM_PI: _bindgen_ty_3 = 21;
pub const RM_PM: _bindgen_ty_3 = 22;
pub const RM_PM_LOW: _bindgen_ty_3 = 23;
pub const RM_FSI: _bindgen_ty_3 = 24;
pub const RM_SRV: _bindgen_ty_3 = 25;
pub const RM_NDM: _bindgen_ty_3 = 26;
pub const RM_NWM: _bindgen_ty_3 = 27;
pub const RM_SOC: _bindgen_ty_3 = 28;
pub const RM_LDR: _bindgen_ty_3 = 29;
pub const RM_ACC: _bindgen_ty_3 = 30;
pub const RM_ROMFS: _bindgen_ty_3 = 31;
pub const RM_AM: _bindgen_ty_3 = 32;
pub const RM_HIO: _bindgen_ty_3 = 33;
pub const RM_UPDATER: _bindgen_ty_3 = 34;
pub const RM_MIC: _bindgen_ty_3 = 35;
pub const RM_FND: _bindgen_ty_3 = 36;
pub const RM_MP: _bindgen_ty_3 = 37;
pub const RM_MPWL: _bindgen_ty_3 = 38;
pub const RM_AC: _bindgen_ty_3 = 39;
pub const RM_HTTP: _bindgen_ty_3 = 40;
pub const RM_DSP: _bindgen_ty_3 = 41;
pub const RM_SND: _bindgen_ty_3 = 42;
pub const RM_DLP: _bindgen_ty_3 = 43;
pub const RM_HIO_LOW: _bindgen_ty_3 = 44;
pub const RM_CSND: _bindgen_ty_3 = 45;
pub const RM_SSL: _bindgen_ty_3 = 46;
pub const RM_AM_LOW: _bindgen_ty_3 = 47;
pub const RM_NEX: _bindgen_ty_3 = 48;
pub const RM_FRIENDS: _bindgen_ty_3 = 49;
pub const RM_RDT: _bindgen_ty_3 = 50;
pub const RM_APPLET: _bindgen_ty_3 = 51;
pub const RM_NIM: _bindgen_ty_3 = 52;
pub const RM_PTM: _bindgen_ty_3 = 53;
pub const RM_MIDI: _bindgen_ty_3 = 54;
pub const RM_MC: _bindgen_ty_3 = 55;
pub const RM_SWC: _bindgen_ty_3 = 56;
pub const RM_FATFS: _bindgen_ty_3 = 57;
pub const RM_NGC: _bindgen_ty_3 = 58;
pub const RM_CARD: _bindgen_ty_3 = 59;
pub const RM_CARDNOR: _bindgen_ty_3 = 60;
pub const RM_SDMC: _bindgen_ty_3 = 61;
pub const RM_BOSS: _bindgen_ty_3 = 62;
pub const RM_DBM: _bindgen_ty_3 = 63;
pub const RM_CONFIG: _bindgen_ty_3 = 64;
pub const RM_PS: _bindgen_ty_3 = 65;
pub const RM_CEC: _bindgen_ty_3 = 66;
pub const RM_IR: _bindgen_ty_3 = 67;
pub const RM_UDS: _bindgen_ty_3 = 68;
pub const RM_PL: _bindgen_ty_3 = 69;
pub const RM_CUP: _bindgen_ty_3 = 70;
pub const RM_GYROSCOPE: _bindgen_ty_3 = 71;
pub const RM_MCU: _bindgen_ty_3 = 72;
pub const RM_NS: _bindgen_ty_3 = 73;
pub const RM_NEWS: _bindgen_ty_3 = 74;
pub const RM_RO: _bindgen_ty_3 = 75;
pub const RM_GD: _bindgen_ty_3 = 76;
pub const RM_CARD_SPI: _bindgen_ty_3 = 77;
pub const RM_EC: _bindgen_ty_3 = 78;
pub const RM_WEB_BROWSER: _bindgen_ty_3 = 79;
pub const RM_TEST: _bindgen_ty_3 = 80;
pub const RM_ENC: _bindgen_ty_3 = 81;
pub const RM_PIA: _bindgen_ty_3 = 82;
pub const RM_ACT: _bindgen_ty_3 = 83;
pub const RM_VCTL: _bindgen_ty_3 = 84;
pub const RM_OLV: _bindgen_ty_3 = 85;
pub const RM_NEIA: _bindgen_ty_3 = 86;
pub const RM_NPNS: _bindgen_ty_3 = 87;
pub const RM_AVD: _bindgen_ty_3 = 90;
pub const RM_L2B: _bindgen_ty_3 = 91;
pub const RM_MVD: _bindgen_ty_3 = 92;
pub const RM_NFC: _bindgen_ty_3 = 93;
pub const RM_UART: _bindgen_ty_3 = 94;
pub const RM_SPM: _bindgen_ty_3 = 95;
pub const RM_QTM: _bindgen_ty_3 = 96;
pub const RM_NFP: _bindgen_ty_3 = 97;
pub const RM_APPLICATION: _bindgen_ty_3 = 254;
pub const RM_INVALIDRESVAL: _bindgen_ty_3 = 255;
#[doc = "Result code module values."]
#[doc = ""]

pub type _bindgen_ty_3 = ::libc::c_uint;
pub const RD_SUCCESS: _bindgen_ty_4 = 0;
pub const RD_INVALID_RESULT_VALUE: _bindgen_ty_4 = 1023;
pub const RD_TIMEOUT: _bindgen_ty_4 = 1022;
pub const RD_OUT_OF_RANGE: _bindgen_ty_4 = 1021;
pub const RD_ALREADY_EXISTS: _bindgen_ty_4 = 1020;
pub const RD_CANCEL_REQUESTED: _bindgen_ty_4 = 1019;
pub const RD_NOT_FOUND: _bindgen_ty_4 = 1018;
pub const RD_ALREADY_INITIALIZED: _bindgen_ty_4 = 1017;
pub const RD_NOT_INITIALIZED: _bindgen_ty_4 = 1016;
pub const RD_INVALID_HANDLE: _bindgen_ty_4 = 1015;
pub const RD_INVALID_POINTER: _bindgen_ty_4 = 1014;
pub const RD_INVALID_ADDRESS: _bindgen_ty_4 = 1013;
pub const RD_NOT_IMPLEMENTED: _bindgen_ty_4 = 1012;
pub const RD_OUT_OF_MEMORY: _bindgen_ty_4 = 1011;
pub const RD_MISALIGNED_SIZE: _bindgen_ty_4 = 1010;
pub const RD_MISALIGNED_ADDRESS: _bindgen_ty_4 = 1009;
pub const RD_BUSY: _bindgen_ty_4 = 1008;
pub const RD_NO_DATA: _bindgen_ty_4 = 1007;
pub const RD_INVALID_COMBINATION: _bindgen_ty_4 = 1006;
pub const RD_INVALID_ENUM_VALUE: _bindgen_ty_4 = 1005;
pub const RD_INVALID_SIZE: _bindgen_ty_4 = 1004;
pub const RD_ALREADY_DONE: _bindgen_ty_4 = 1003;
pub const RD_NOT_AUTHORIZED: _bindgen_ty_4 = 1002;
pub const RD_TOO_LARGE: _bindgen_ty_4 = 1001;
pub const RD_INVALID_SELECTION: _bindgen_ty_4 = 1000;
#[doc = "Result code generic description values."]
#[doc = ""]

pub type _bindgen_ty_4 = ::libc::c_uint;
#[doc = "Readable"]
#[doc = ""]

pub const IPC_BUFFER_R: IPC_BufferRights = 2;
#[doc = "Writable"]
#[doc = ""]

pub const IPC_BUFFER_W: IPC_BufferRights = 4;
#[doc = "Readable and Writable"]
#[doc = ""]

pub const IPC_BUFFER_RW: IPC_BufferRights = 6;
#[doc = "IPC buffer access rights."]
#[doc = ""]

pub type IPC_BufferRights = ::libc::c_uint;
#[doc = "Memory un-mapping"]
#[doc = ""]

pub const MEMOP_FREE: MemOp = 1;
#[doc = "Reserve memory"]
#[doc = ""]

pub const MEMOP_RESERVE: MemOp = 2;
#[doc = "Memory mapping"]
#[doc = ""]

pub const MEMOP_ALLOC: MemOp = 3;
#[doc = "Mirror mapping"]
#[doc = ""]

pub const MEMOP_MAP: MemOp = 4;
#[doc = "Mirror unmapping"]
#[doc = ""]

pub const MEMOP_UNMAP: MemOp = 5;
#[doc = "Change protection"]
#[doc = ""]

pub const MEMOP_PROT: MemOp = 6;
#[doc = "APPLICATION memory region."]
#[doc = ""]

pub const MEMOP_REGION_APP: MemOp = 256;
#[doc = "SYSTEM memory region."]
#[doc = ""]

pub const MEMOP_REGION_SYSTEM: MemOp = 512;
#[doc = "BASE memory region."]
#[doc = ""]

pub const MEMOP_REGION_BASE: MemOp = 768;
#[doc = "Operation bitmask."]
#[doc = ""]

pub const MEMOP_OP_MASK: MemOp = 255;
#[doc = "Region bitmask."]
#[doc = ""]

pub const MEMOP_REGION_MASK: MemOp = 3840;
#[doc = "Flag for linear memory operations"]
#[doc = ""]

pub const MEMOP_LINEAR_FLAG: MemOp = 65536;
#[doc = "Allocates linear memory."]
#[doc = ""]

pub const MEMOP_ALLOC_LINEAR: MemOp = 65539;
#[doc = "[`svcControlMemory`] operation flags\n\n The lowest 8 bits are the operation"]
#[doc = ""]

pub type MemOp = ::libc::c_uint;
#[doc = "Free memory"]
#[doc = ""]

pub const MEMSTATE_FREE: MemState = 0;
#[doc = "Reserved memory"]
#[doc = ""]

pub const MEMSTATE_RESERVED: MemState = 1;
#[doc = "I/O memory"]
#[doc = ""]

pub const MEMSTATE_IO: MemState = 2;
#[doc = "Static memory"]
#[doc = ""]

pub const MEMSTATE_STATIC: MemState = 3;
#[doc = "Code memory"]
#[doc = ""]

pub const MEMSTATE_CODE: MemState = 4;
#[doc = "Private memory"]
#[doc = ""]

pub const MEMSTATE_PRIVATE: MemState = 5;
#[doc = "Shared memory"]
#[doc = ""]

pub const MEMSTATE_SHARED: MemState = 6;
#[doc = "Continuous memory"]
#[doc = ""]

pub const MEMSTATE_CONTINUOUS: MemState = 7;
#[doc = "Aliased memory"]
#[doc = ""]

pub const MEMSTATE_ALIASED: MemState = 8;
#[doc = "Alias memory"]
#[doc = ""]

pub const MEMSTATE_ALIAS: MemState = 9;
#[doc = "Aliased code memory"]
#[doc = ""]

pub const MEMSTATE_ALIASCODE: MemState = 10;
#[doc = "Locked memory"]
#[doc = ""]

pub const MEMSTATE_LOCKED: MemState = 11;
#[doc = "The state of a memory block."]
#[doc = ""]

pub type MemState = ::libc::c_uint;
#[doc = "Readable"]
#[doc = ""]

pub const MEMPERM_READ: MemPerm = 1;
#[doc = "Writable"]
#[doc = ""]

pub const MEMPERM_WRITE: MemPerm = 2;
#[doc = "Executable"]
#[doc = ""]

pub const MEMPERM_EXECUTE: MemPerm = 4;
#[doc = "Readable and writable"]
#[doc = ""]

pub const MEMPERM_READWRITE: MemPerm = 3;
#[doc = "Readable and executable"]
#[doc = ""]

pub const MEMPERM_READEXECUTE: MemPerm = 5;
#[doc = "Don't care"]
#[doc = ""]

pub const MEMPERM_DONTCARE: MemPerm = 268435456;
#[doc = "Memory permission flags"]
#[doc = ""]

pub type MemPerm = ::libc::c_uint;
#[doc = "All regions."]
#[doc = ""]

pub const MEMREGION_ALL: MemRegion = 0;
#[doc = "APPLICATION memory."]
#[doc = ""]

pub const MEMREGION_APPLICATION: MemRegion = 1;
#[doc = "SYSTEM memory."]
#[doc = ""]

pub const MEMREGION_SYSTEM: MemRegion = 2;
#[doc = "BASE memory."]
#[doc = ""]

pub const MEMREGION_BASE: MemRegion = 3;
#[doc = "Memory regions."]
#[doc = ""]

pub type MemRegion = ::libc::c_uint;
#[doc = "Memory information."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MemInfo {
    #[doc = "Base address."]
    #[doc = ""]
    pub base_addr: u32_,
    #[doc = "Size."]
    #[doc = ""]
    pub size: u32_,
    #[doc = "Memory permissions. See [`MemPerm`]"]
    #[doc = ""]
    pub perm: u32_,
    #[doc = "Memory state. See [`MemState`]"]
    #[doc = ""]
    pub state: u32_,
}
#[doc = "Memory page information."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PageInfo {
    #[doc = "Page flags."]
    #[doc = ""]
    pub flags: u32_,
}
#[doc = "Signal #value threads for wake-up."]
#[doc = ""]

pub const ARBITRATION_SIGNAL: ArbitrationType = 0;
#[doc = "If the memory at the address is strictly lower than #value, then wait for signal."]
#[doc = ""]

pub const ARBITRATION_WAIT_IF_LESS_THAN: ArbitrationType = 1;
#[doc = "If the memory at the address is strictly lower than #value, then decrement it and wait for signal."]
#[doc = ""]

pub const ARBITRATION_DECREMENT_AND_WAIT_IF_LESS_THAN: ArbitrationType = 2;
#[doc = "If the memory at the address is strictly lower than #value, then wait for signal or timeout."]
#[doc = ""]

pub const ARBITRATION_WAIT_IF_LESS_THAN_TIMEOUT: ArbitrationType = 3;
#[doc = "If the memory at the address is strictly lower than #value, then decrement it and wait for signal or timeout."]
#[doc = ""]

pub const ARBITRATION_DECREMENT_AND_WAIT_IF_LESS_THAN_TIMEOUT: ArbitrationType = 4;
#[doc = "Arbitration modes."]
#[doc = ""]

pub type ArbitrationType = ::libc::c_uint;
#[doc = "When the primitive is signaled, it will wake up exactly one thread and will clear itself automatically."]
#[doc = ""]

pub const RESET_ONESHOT: ResetType = 0;
#[doc = "When the primitive is signaled, it will wake up all threads and it won't clear itself automatically."]
#[doc = ""]

pub const RESET_STICKY: ResetType = 1;
#[doc = "Only meaningful for timers: same as ONESHOT but it will periodically signal the timer instead of just once."]
#[doc = ""]

pub const RESET_PULSE: ResetType = 2;
#[doc = "Reset types (for use with events and timers)"]
#[doc = ""]

pub type ResetType = ::libc::c_uint;
#[doc = "Unknown."]
#[doc = ""]

pub const THREADINFO_TYPE_UNKNOWN: ThreadInfoType = 0;
#[doc = "Types of thread info."]
#[doc = ""]

pub type ThreadInfoType = ::libc::c_uint;
#[doc = "Thread priority"]
#[doc = ""]

pub const RESLIMIT_PRIORITY: ResourceLimitType = 0;
#[doc = "Quantity of allocatable memory"]
#[doc = ""]

pub const RESLIMIT_COMMIT: ResourceLimitType = 1;
#[doc = "Number of threads"]
#[doc = ""]

pub const RESLIMIT_THREAD: ResourceLimitType = 2;
#[doc = "Number of events"]
#[doc = ""]

pub const RESLIMIT_EVENT: ResourceLimitType = 3;
#[doc = "Number of mutexes"]
#[doc = ""]

pub const RESLIMIT_MUTEX: ResourceLimitType = 4;
#[doc = "Number of semaphores"]
#[doc = ""]

pub const RESLIMIT_SEMAPHORE: ResourceLimitType = 5;
#[doc = "Number of timers"]
#[doc = ""]

pub const RESLIMIT_TIMER: ResourceLimitType = 6;
#[doc = "Number of shared memory objects, see [`svcCreateMemoryBlock`]"]
#[doc = ""]

pub const RESLIMIT_SHAREDMEMORY: ResourceLimitType = 7;
#[doc = "Number of address arbiters"]
#[doc = ""]

pub const RESLIMIT_ADDRESSARBITER: ResourceLimitType = 8;
#[doc = "CPU time. Value expressed in percentage regular until it reaches 90."]
#[doc = ""]

pub const RESLIMIT_CPUTIME: ResourceLimitType = 9;
#[doc = "Forces enum size to be 32 bits"]
#[doc = ""]

pub const RESLIMIT_BIT: ResourceLimitType = 2147483648;
#[doc = "Types of resource limit"]
#[doc = ""]

pub type ResourceLimitType = ::libc::c_uint;
#[doc = "DMA transfer involving at least one device is starting and has not reached DMAWFP yet."]
#[doc = ""]

pub const DMASTATE_STARTING: DmaState = 0;
#[doc = "DMA channel is in WFP state for the destination device (2nd loop iteration onwards)."]
#[doc = ""]

pub const DMASTATE_WFP_DST: DmaState = 1;
#[doc = "DMA channel is in WFP state for the source device (2nd loop iteration onwards)."]
#[doc = ""]

pub const DMASTATE_WFP_SRC: DmaState = 2;
#[doc = "DMA transfer is running."]
#[doc = ""]

pub const DMASTATE_RUNNING: DmaState = 3;
#[doc = "DMA transfer is done."]
#[doc = ""]

pub const DMASTATE_DONE: DmaState = 4;
#[doc = "DMA transfer state."]
#[doc = ""]

pub type DmaState = ::libc::c_uint;
#[doc = "DMA source is a device/peripheral. Address will not auto-increment."]
#[doc = ""]

pub const DMACFG_SRC_IS_DEVICE: _bindgen_ty_5 = 1;
#[doc = "DMA destination is a device/peripheral. Address will not auto-increment."]
#[doc = ""]

pub const DMACFG_DST_IS_DEVICE: _bindgen_ty_5 = 2;
#[doc = "Make [`svcStartInterProcessDma`] wait for the channel to be unlocked."]
#[doc = ""]

pub const DMACFG_WAIT_AVAILABLE: _bindgen_ty_5 = 4;
#[doc = "Keep the channel locked after the transfer. Required for [`svcRestartDma`]"]
#[doc = ""]

pub const DMACFG_KEEP_LOCKED: _bindgen_ty_5 = 8;
#[doc = "Use the provided source device configuration even if the DMA source is not a device."]
#[doc = ""]

pub const DMACFG_USE_SRC_CONFIG: _bindgen_ty_5 = 64;
#[doc = "Use the provided destination device configuration even if the DMA destination is not a device."]
#[doc = ""]

pub const DMACFG_USE_DST_CONFIG: _bindgen_ty_5 = 128;
#[doc = "Configuration flags for [`DmaConfig`]"]
#[doc = ""]

pub type _bindgen_ty_5 = ::libc::c_uint;
#[doc = "Unlock the channel after transfer."]
#[doc = ""]

pub const DMARST_UNLOCK: _bindgen_ty_6 = 1;
#[doc = "Replace DMAFLUSHP instructions by NOP (they may not be regenerated even if this flag is not set)."]
#[doc = ""]

pub const DMARST_RESUME_DEVICE: _bindgen_ty_6 = 2;
#[doc = "Configuration flags for [`svcRestartDma`]"]
#[doc = ""]

pub type _bindgen_ty_6 = ::libc::c_uint;
#[doc = "Device configuration structure, part of [`DmaConfig.\n`] @note\n - if (and only if) src/dst is a device, then src/dst won't be auto-incremented.\n - the kernel uses DMAMOV instead of DMAADNH, when having to decrement (possibly working around an erratum);\n this forces all loops to be unrolled -- you need to keep that in mind when using negative increments, as the kernel\n uses a limit of 100 DMA instruction bytes per channel."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct DmaDeviceConfig {
    #[doc = "DMA device ID."]
    #[doc = ""]
    pub deviceId: s8,
    #[doc = "Mask of allowed access alignments (8, 4, 2, 1)."]
    #[doc = ""]
    pub allowedAlignments: s8,
    #[doc = "Number of bytes transferred in a burst loop. Can be 0 (in which case the max allowed alignment is used as unit)."]
    #[doc = ""]
    pub burstSize: s16,
    #[doc = "Number of bytes transferred in a \"transfer\" loop (made of burst loops)."]
    #[doc = ""]
    pub transferSize: s16,
    #[doc = "Burst loop stride, can be <= 0."]
    #[doc = ""]
    pub burstStride: s16,
    #[doc = "\"Transfer\" loop stride, can be <= 0."]
    #[doc = ""]
    pub transferStride: s16,
}
#[doc = "Configuration stucture for [`svcStartInterProcessDma`]"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct DmaConfig {
    #[doc = "Channel ID (Arm11: 0-7, Arm9: 0-1). Use -1 to auto-assign to a free channel (Arm11: 3-7, Arm9: 0-1)."]
    #[doc = ""]
    pub channelId: s8,
    #[doc = "Endian swap size (can be 0)."]
    #[doc = ""]
    pub endianSwapSize: s8,
    #[doc = "DMACFG_* flags."]
    #[doc = ""]
    pub flags: u8_,
    pub _padding: u8_,
    #[doc = "Source device configuration, read if [`DMACFG_SRC_IS_DEVICE`] and/or [`DMACFG_USE_SRC_CONFIG`] are set."]
    #[doc = ""]
    pub srcCfg: DmaDeviceConfig,
    #[doc = "Destination device configuration, read if [`DMACFG_SRC_IS_DEVICE`] and/or [`DMACFG_USE_SRC_CONFIG`] are set."]
    #[doc = ""]
    pub dstCfg: DmaDeviceConfig,
}
#[doc = "Enable and lock perfmon. functionality."]
#[doc = ""]

pub const PERFCOUNTEROP_ENABLE: PerfCounterOperation = 0;
#[doc = "Disable and forcibly unlock perfmon. functionality."]
#[doc = ""]

pub const PERFCOUNTEROP_DISABLE: PerfCounterOperation = 1;
#[doc = "Get the value of a counter register."]
#[doc = ""]

pub const PERFCOUNTEROP_GET_VALUE: PerfCounterOperation = 2;
#[doc = "Set the value of a counter register."]
#[doc = ""]

pub const PERFCOUNTEROP_SET_VALUE: PerfCounterOperation = 3;
#[doc = "Get the overflow flags for all CP15 and SCU counters."]
#[doc = ""]

pub const PERFCOUNTEROP_GET_OVERFLOW_FLAGS: PerfCounterOperation = 4;
#[doc = "Reset the value and/or overflow flags of selected counters."]
#[doc = ""]

pub const PERFCOUNTEROP_RESET: PerfCounterOperation = 5;
#[doc = "Get the event ID associated to a particular counter."]
#[doc = ""]

pub const PERFCOUNTEROP_GET_EVENT: PerfCounterOperation = 6;
#[doc = "Set the event ID associated to a paritcular counter."]
#[doc = ""]

pub const PERFCOUNTEROP_SET_EVENT: PerfCounterOperation = 7;
#[doc = "(Dis)allow the kernel to track counter overflows and to use 64-bit counter values."]
#[doc = ""]

pub const PERFCOUNTEROP_SET_VIRTUAL_COUNTER_ENABLED: PerfCounterOperation = 8;
#[doc = "Operations for [`svcControlPerformanceCounter`]"]
#[doc = ""]

pub type PerfCounterOperation = ::libc::c_uint;
pub const PERFCOUNTERREG_CORE_BASE: PerfCounterRegister = 0;
#[doc = "CP15 PMN0."]
#[doc = ""]

pub const PERFCOUNTERREG_CORE_COUNT_REG_0: PerfCounterRegister = 0;
#[doc = "CP15 PMN1."]
#[doc = ""]

pub const PERFCOUNTERREG_CORE_COUNT_REG_1: PerfCounterRegister = 1;
#[doc = "CP15 CCNT."]
#[doc = ""]

pub const PERFCOUNTERREG_CORE_CYCLE_COUNTER: PerfCounterRegister = 2;
pub const PERFCOUNTERREG_SCU_BASE: PerfCounterRegister = 16;
#[doc = "SCU MN0."]
#[doc = ""]

pub const PERFCOUNTERREG_SCU_0: PerfCounterRegister = 16;
#[doc = "SCU MN1."]
#[doc = ""]

pub const PERFCOUNTERREG_SCU_1: PerfCounterRegister = 17;
#[doc = "SCU MN2."]
#[doc = ""]

pub const PERFCOUNTERREG_SCU_2: PerfCounterRegister = 18;
#[doc = "SCU MN3."]
#[doc = ""]

pub const PERFCOUNTERREG_SCU_3: PerfCounterRegister = 19;
#[doc = "SCU MN4. Prod-N3DS only. IRQ line missing."]
#[doc = ""]

pub const PERFCOUNTERREG_SCU_4: PerfCounterRegister = 20;
#[doc = "SCU MN5. Prod-N3DS only. IRQ line missing."]
#[doc = ""]

pub const PERFCOUNTERREG_SCU_5: PerfCounterRegister = 21;
#[doc = "SCU MN6. Prod-N3DS only. IRQ line missing."]
#[doc = ""]

pub const PERFCOUNTERREG_SCU_6: PerfCounterRegister = 22;
#[doc = "SCU MN7. Prod-N3DS only. IRQ line missing."]
#[doc = ""]

pub const PERFCOUNTERREG_SCU_7: PerfCounterRegister = 23;
#[doc = "Performance counter register IDs (CP15 and SCU)."]
#[doc = ""]

pub type PerfCounterRegister = ::libc::c_uint;
pub const PERFCOUNTEREVT_CORE_BASE: PerfCounterEvent = 0;
pub const PERFCOUNTEREVT_CORE_INST_CACHE_MISS: PerfCounterEvent = 0;
pub const PERFCOUNTEREVT_CORE_STALL_BY_LACK_OF_INST: PerfCounterEvent = 1;
pub const PERFCOUNTEREVT_CORE_STALL_BY_DATA_HAZARD: PerfCounterEvent = 2;
pub const PERFCOUNTEREVT_CORE_INST_MICRO_TLB_MISS: PerfCounterEvent = 3;
pub const PERFCOUNTEREVT_CORE_DATA_MICRO_TLB_MISS: PerfCounterEvent = 4;
pub const PERFCOUNTEREVT_CORE_BRANCH_INST: PerfCounterEvent = 5;
pub const PERFCOUNTEREVT_CORE_BRANCH_NOT_PREDICTED: PerfCounterEvent = 6;
pub const PERFCOUNTEREVT_CORE_BRANCH_MISS_PREDICTED: PerfCounterEvent = 7;
pub const PERFCOUNTEREVT_CORE_INST_EXECUTED: PerfCounterEvent = 8;
pub const PERFCOUNTEREVT_CORE_FOLDED_INST_EXECUTED: PerfCounterEvent = 9;
pub const PERFCOUNTEREVT_CORE_DATA_CACHE_READ: PerfCounterEvent = 10;
pub const PERFCOUNTEREVT_CORE_DATA_CACHE_READ_MISS: PerfCounterEvent = 11;
pub const PERFCOUNTEREVT_CORE_DATA_CACHE_WRITE: PerfCounterEvent = 12;
pub const PERFCOUNTEREVT_CORE_DATA_CACHE_WRITE_MISS: PerfCounterEvent = 13;
pub const PERFCOUNTEREVT_CORE_DATA_CACHE_LINE_EVICTION: PerfCounterEvent = 14;
pub const PERFCOUNTEREVT_CORE_PC_CHANGED: PerfCounterEvent = 15;
pub const PERFCOUNTEREVT_CORE_MAIN_TLB_MISS: PerfCounterEvent = 16;
pub const PERFCOUNTEREVT_CORE_EXTERNAL_REQUEST: PerfCounterEvent = 17;
pub const PERFCOUNTEREVT_CORE_STALL_BY_LSU_FULL: PerfCounterEvent = 18;
pub const PERFCOUNTEREVT_CORE_STORE_BUFFER_DRAIN: PerfCounterEvent = 19;
pub const PERFCOUNTEREVT_CORE_MERGE_IN_STORE_BUFFER: PerfCounterEvent = 20;
#[doc = "One cycle elapsed."]
#[doc = ""]

pub const PERFCOUNTEREVT_CORE_CYCLE_COUNT: PerfCounterEvent = 255;
#[doc = "64 cycles elapsed."]
#[doc = ""]

pub const PERFCOUNTEREVT_CORE_CYCLE_COUNT_64: PerfCounterEvent = 4095;
pub const PERFCOUNTEREVT_SCU_BASE: PerfCounterEvent = 4096;
pub const PERFCOUNTEREVT_SCU_DISABLED: PerfCounterEvent = 4096;
pub const PERFCOUNTEREVT_SCU_LINEFILL_MISS_FROM_CORE0: PerfCounterEvent = 4097;
pub const PERFCOUNTEREVT_SCU_LINEFILL_MISS_FROM_CORE1: PerfCounterEvent = 4098;
pub const PERFCOUNTEREVT_SCU_LINEFILL_MISS_FROM_CORE2: PerfCounterEvent = 4099;
pub const PERFCOUNTEREVT_SCU_LINEFILL_MISS_FROM_CORE3: PerfCounterEvent = 4100;
pub const PERFCOUNTEREVT_SCU_LINEFILL_HIT_FROM_CORE0: PerfCounterEvent = 4101;
pub const PERFCOUNTEREVT_SCU_LINEFILL_HIT_FROM_CORE1: PerfCounterEvent = 4102;
pub const PERFCOUNTEREVT_SCU_LINEFILL_HIT_FROM_CORE2: PerfCounterEvent = 4103;
pub const PERFCOUNTEREVT_SCU_LINEFILL_HIT_FROM_CORE3: PerfCounterEvent = 4104;
pub const PERFCOUNTEREVT_SCU_LINE_MISSING_FROM_CORE0: PerfCounterEvent = 4105;
pub const PERFCOUNTEREVT_SCU_LINE_MISSING_FROM_CORE1: PerfCounterEvent = 4106;
pub const PERFCOUNTEREVT_SCU_LINE_MISSING_FROM_CORE2: PerfCounterEvent = 4107;
pub const PERFCOUNTEREVT_SCU_LINE_MISSING_FROM_CORE3: PerfCounterEvent = 4108;
pub const PERFCOUNTEREVT_SCU_LINE_MIGRATION: PerfCounterEvent = 4109;
pub const PERFCOUNTEREVT_SCU_READ_BUSY_PORT0: PerfCounterEvent = 4110;
pub const PERFCOUNTEREVT_SCU_READ_BUSY_PORT1: PerfCounterEvent = 4111;
pub const PERFCOUNTEREVT_SCU_WRITE_BUSY_PORT0: PerfCounterEvent = 4112;
pub const PERFCOUNTEREVT_SCU_WRITE_BUSY_PORT1: PerfCounterEvent = 4113;
pub const PERFCOUNTEREVT_SCU_EXTERNAL_READ: PerfCounterEvent = 4114;
pub const PERFCOUNTEREVT_SCU_EXTERNAL_WRITE: PerfCounterEvent = 4115;
pub const PERFCOUNTEREVT_SCU_CYCLE_COUNT: PerfCounterEvent = 4127;
#[doc = "Performance counter event IDs (CP15 or SCU).\n\n @note Refer to:\n - CP15: <https://developer.arm.com/documentation/ddi0360/e/control-coprocessor-cp15/register-descriptions/c15--performance-monitor-control-register--pmnc-\n> - SCU: <https://developer.arm.com/documentation/ddi0360/e/mpcore-private-memory-region/about-the-mpcore-private-memory-region/performance-monitor-event-registers>"]
#[doc = ""]

pub type PerfCounterEvent = ::libc::c_uint;
#[doc = "Event relating to the attachment of a process."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AttachProcessEvent {
    #[doc = "ID of the program."]
    #[doc = ""]
    pub program_id: u64_,
    #[doc = "Name of the process."]
    #[doc = ""]
    pub process_name: [::libc::c_char; 8usize],
    #[doc = "ID of the process."]
    #[doc = ""]
    pub process_id: u32_,
    #[doc = "Always 0"]
    #[doc = ""]
    pub other_flags: u32_,
}
#[doc = "Process exited either normally or due to an uncaught exception."]
#[doc = ""]

pub const EXITPROCESS_EVENT_EXIT: ExitProcessEventReason = 0;
#[doc = "Process has been terminated by [`svcTerminateProcess`]"]
#[doc = ""]

pub const EXITPROCESS_EVENT_TERMINATE: ExitProcessEventReason = 1;
#[doc = "Process has been terminated by [`svcTerminateDebugProcess`]"]
#[doc = ""]

pub const EXITPROCESS_EVENT_DEBUG_TERMINATE: ExitProcessEventReason = 2;
#[doc = "Reasons for an exit process event."]
#[doc = ""]

pub type ExitProcessEventReason = ::libc::c_uint;
#[doc = "Event relating to the exiting of a process."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExitProcessEvent {
    #[doc = "Reason for exiting. See [`ExitProcessEventReason`]"]
    #[doc = ""]
    pub reason: ExitProcessEventReason,
}
impl Default for ExitProcessEvent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Event relating to the attachment of a thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AttachThreadEvent {
    #[doc = "ID of the creating thread."]
    #[doc = ""]
    pub creator_thread_id: u32_,
    #[doc = "Thread local storage."]
    #[doc = ""]
    pub thread_local_storage: u32_,
    #[doc = "Entry point of the thread."]
    #[doc = ""]
    pub entry_point: u32_,
}
#[doc = "Thread exited."]
#[doc = ""]

pub const EXITTHREAD_EVENT_EXIT: ExitThreadEventReason = 0;
#[doc = "Thread terminated."]
#[doc = ""]

pub const EXITTHREAD_EVENT_TERMINATE: ExitThreadEventReason = 1;
#[doc = "Process exited either normally or due to an uncaught exception."]
#[doc = ""]

pub const EXITTHREAD_EVENT_EXIT_PROCESS: ExitThreadEventReason = 2;
#[doc = "Process has been terminated by [`svcTerminateProcess`]"]
#[doc = ""]

pub const EXITTHREAD_EVENT_TERMINATE_PROCESS: ExitThreadEventReason = 3;
#[doc = "Reasons for an exit thread event."]
#[doc = ""]

pub type ExitThreadEventReason = ::libc::c_uint;
#[doc = "Event relating to the exiting of a thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExitThreadEvent {
    #[doc = "Reason for exiting. See [`ExitThreadEventReason`]"]
    #[doc = ""]
    pub reason: ExitThreadEventReason,
}
impl Default for ExitThreadEvent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Panic."]
#[doc = ""]

pub const USERBREAK_PANIC: UserBreakType = 0;
#[doc = "Assertion failed."]
#[doc = ""]

pub const USERBREAK_ASSERT: UserBreakType = 1;
#[doc = "User related."]
#[doc = ""]

pub const USERBREAK_USER: UserBreakType = 2;
#[doc = "Load RO."]
#[doc = ""]

pub const USERBREAK_LOAD_RO: UserBreakType = 3;
#[doc = "Unload RO."]
#[doc = ""]

pub const USERBREAK_UNLOAD_RO: UserBreakType = 4;
#[doc = "Reasons for a user break."]
#[doc = ""]

pub type UserBreakType = ::libc::c_uint;
#[doc = "Undefined instruction."]
#[doc = ""]

pub const EXCEVENT_UNDEFINED_INSTRUCTION: ExceptionEventType = 0;
#[doc = "Prefetch abort."]
#[doc = ""]

pub const EXCEVENT_PREFETCH_ABORT: ExceptionEventType = 1;
#[doc = "Data abort (other than the below kind)."]
#[doc = ""]

pub const EXCEVENT_DATA_ABORT: ExceptionEventType = 2;
#[doc = "Unaligned data access."]
#[doc = ""]

pub const EXCEVENT_UNALIGNED_DATA_ACCESS: ExceptionEventType = 3;
#[doc = "Attached break."]
#[doc = ""]

pub const EXCEVENT_ATTACH_BREAK: ExceptionEventType = 4;
#[doc = "Stop point reached."]
#[doc = ""]

pub const EXCEVENT_STOP_POINT: ExceptionEventType = 5;
#[doc = "User break occurred."]
#[doc = ""]

pub const EXCEVENT_USER_BREAK: ExceptionEventType = 6;
#[doc = "Debugger break occurred."]
#[doc = ""]

pub const EXCEVENT_DEBUGGER_BREAK: ExceptionEventType = 7;
#[doc = "Undefined syscall."]
#[doc = ""]

pub const EXCEVENT_UNDEFINED_SYSCALL: ExceptionEventType = 8;
#[doc = "Reasons for an exception event."]
#[doc = ""]

pub type ExceptionEventType = ::libc::c_uint;
#[doc = "Event relating to fault exceptions (CPU exceptions other than stop points and undefined syscalls)."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FaultExceptionEvent {
    #[doc = "FAR (for DATA ABORT / UNALIGNED DATA ACCESS), attempted syscall or 0"]
    #[doc = ""]
    pub fault_information: u32_,
}
#[doc = "See [`SVC_STOP_POINT`]"]
#[doc = ""]

pub const STOPPOINT_SVC_FF: StopPointType = 0;
#[doc = "Breakpoint."]
#[doc = ""]

pub const STOPPOINT_BREAKPOINT: StopPointType = 1;
#[doc = "Watchpoint."]
#[doc = ""]

pub const STOPPOINT_WATCHPOINT: StopPointType = 2;
#[doc = "Stop point types"]
#[doc = ""]

pub type StopPointType = ::libc::c_uint;
#[doc = "Event relating to stop points"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct StopPointExceptionEvent {
    #[doc = "Stop point type, see [`StopPointType`]"]
    #[doc = ""]
    pub type_: StopPointType,
    #[doc = "FAR for Watchpoints, otherwise 0."]
    #[doc = ""]
    pub fault_information: u32_,
}
impl Default for StopPointExceptionEvent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Event relating to [`svcBreak`]"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UserBreakExceptionEvent {
    #[doc = "User break type, see [`UserBreakType`]"]
    #[doc = ""]
    pub type_: UserBreakType,
    #[doc = "For LOAD_RO and UNLOAD_RO."]
    #[doc = ""]
    pub croInfo: u32_,
    #[doc = "For LOAD_RO and UNLOAD_RO."]
    #[doc = ""]
    pub croInfoSize: u32_,
}
impl Default for UserBreakExceptionEvent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Event relating to [`svcBreakDebugProcess`]"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct DebuggerBreakExceptionEvent {
    #[doc = "IDs of the attached process's threads that were running on each core at the time of the [`svcBreakDebugProcess`] call, or -1 (only the first 2 values are meaningful on O3DS)."]
    #[doc = ""]
    pub thread_ids: [s32; 4usize],
}
#[doc = "Event relating to exceptions."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ExceptionEvent {
    #[doc = "Type of event. See [`ExceptionEventType`]"]
    #[doc = ""]
    pub type_: ExceptionEventType,
    #[doc = "Address of the exception."]
    #[doc = ""]
    pub address: u32_,
    pub __bindgen_anon_1: ExceptionEvent__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ExceptionEvent__bindgen_ty_1 {
    #[doc = "Fault exception event data."]
    #[doc = ""]
    pub fault: FaultExceptionEvent,
    #[doc = "Stop point exception event data."]
    #[doc = ""]
    pub stop_point: StopPointExceptionEvent,
    #[doc = "User break exception event data."]
    #[doc = ""]
    pub user_break: UserBreakExceptionEvent,
    #[doc = "Debugger break exception event data"]
    #[doc = ""]
    pub debugger_break: DebuggerBreakExceptionEvent,
}
impl Default for ExceptionEvent__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ExceptionEvent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Event relating to the scheduler."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ScheduleInOutEvent {
    #[doc = "Clock tick that the event occurred."]
    #[doc = ""]
    pub clock_tick: u64_,
}
#[doc = "Event relating to syscalls."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SyscallInOutEvent {
    #[doc = "Clock tick that the event occurred."]
    #[doc = ""]
    pub clock_tick: u64_,
    #[doc = "Syscall sent/received."]
    #[doc = ""]
    pub syscall: u32_,
}
#[doc = "Event relating to debug output."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct OutputStringEvent {
    #[doc = "Address of the outputted string."]
    #[doc = ""]
    pub string_addr: u32_,
    #[doc = "Size of the outputted string."]
    #[doc = ""]
    pub string_size: u32_,
}
#[doc = "Event relating to the mapping of memory."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MapEvent {
    #[doc = "Mapped address."]
    #[doc = ""]
    pub mapped_addr: u32_,
    #[doc = "Mapped size."]
    #[doc = ""]
    pub mapped_size: u32_,
    #[doc = "Memory permissions. See [`MemPerm`]"]
    #[doc = ""]
    pub memperm: MemPerm,
    #[doc = "Memory state. See [`MemState`]"]
    #[doc = ""]
    pub memstate: MemState,
}
impl Default for MapEvent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Process attached event."]
#[doc = ""]

pub const DBGEVENT_ATTACH_PROCESS: DebugEventType = 0;
#[doc = "Thread attached event."]
#[doc = ""]

pub const DBGEVENT_ATTACH_THREAD: DebugEventType = 1;
#[doc = "Thread exit event."]
#[doc = ""]

pub const DBGEVENT_EXIT_THREAD: DebugEventType = 2;
#[doc = "Process exit event."]
#[doc = ""]

pub const DBGEVENT_EXIT_PROCESS: DebugEventType = 3;
#[doc = "Exception event."]
#[doc = ""]

pub const DBGEVENT_EXCEPTION: DebugEventType = 4;
#[doc = "DLL load event."]
#[doc = ""]

pub const DBGEVENT_DLL_LOAD: DebugEventType = 5;
#[doc = "DLL unload event."]
#[doc = ""]

pub const DBGEVENT_DLL_UNLOAD: DebugEventType = 6;
#[doc = "Schedule in event."]
#[doc = ""]

pub const DBGEVENT_SCHEDULE_IN: DebugEventType = 7;
#[doc = "Schedule out event."]
#[doc = ""]

pub const DBGEVENT_SCHEDULE_OUT: DebugEventType = 8;
#[doc = "Syscall in event."]
#[doc = ""]

pub const DBGEVENT_SYSCALL_IN: DebugEventType = 9;
#[doc = "Syscall out event."]
#[doc = ""]

pub const DBGEVENT_SYSCALL_OUT: DebugEventType = 10;
#[doc = "Output string event."]
#[doc = ""]

pub const DBGEVENT_OUTPUT_STRING: DebugEventType = 11;
#[doc = "Map event."]
#[doc = ""]

pub const DBGEVENT_MAP: DebugEventType = 12;
#[doc = "Debug event type."]
#[doc = ""]

pub type DebugEventType = ::libc::c_uint;
#[doc = "Information about a debug event."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DebugEventInfo {
    #[doc = "Type of event. See [`DebugEventType`]"]
    #[doc = ""]
    pub type_: DebugEventType,
    #[doc = "ID of the thread."]
    #[doc = ""]
    pub thread_id: u32_,
    #[doc = "Flags. Bit0 means that [`svcContinueDebugEvent`] needs to be called for this event (except for EXIT PROCESS events, where this flag is disregarded)."]
    #[doc = ""]
    pub flags: u32_,
    #[doc = "Always 0."]
    #[doc = ""]
    pub remnants: [u8_; 4usize],
    pub __bindgen_anon_1: DebugEventInfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DebugEventInfo__bindgen_ty_1 {
    #[doc = "Process attachment event data."]
    #[doc = ""]
    pub attach_process: AttachProcessEvent,
    #[doc = "Thread attachment event data."]
    #[doc = ""]
    pub attach_thread: AttachThreadEvent,
    #[doc = "Thread exit event data."]
    #[doc = ""]
    pub exit_thread: ExitThreadEvent,
    #[doc = "Process exit event data."]
    #[doc = ""]
    pub exit_process: ExitProcessEvent,
    #[doc = "Exception event data."]
    #[doc = ""]
    pub exception: ExceptionEvent,
    #[doc = "Schedule in/out event data."]
    #[doc = ""]
    pub scheduler: ScheduleInOutEvent,
    #[doc = "Syscall in/out event data."]
    #[doc = ""]
    pub syscall: SyscallInOutEvent,
    #[doc = "Output string event data."]
    #[doc = ""]
    pub output_string: OutputStringEvent,
    #[doc = "Map event data."]
    #[doc = ""]
    pub map: MapEvent,
}
impl Default for DebugEventInfo__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for DebugEventInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Inhibit user-defined CPU exception handlers (including watchpoints and breakpoints, regardless of any [`svcKernelSetState`] call)."]
#[doc = ""]

pub const DBG_INHIBIT_USER_CPU_EXCEPTION_HANDLERS: DebugFlags = 1;
#[doc = "Signal fault exception events. See [`FaultExceptionEvent`]"]
#[doc = ""]

pub const DBG_SIGNAL_FAULT_EXCEPTION_EVENTS: DebugFlags = 2;
#[doc = "Signal schedule in/out events. See [`ScheduleInOutEvent`]"]
#[doc = ""]

pub const DBG_SIGNAL_SCHEDULE_EVENTS: DebugFlags = 4;
#[doc = "Signal syscall in/out events. See [`SyscallInOutEvent`]"]
#[doc = ""]

pub const DBG_SIGNAL_SYSCALL_EVENTS: DebugFlags = 8;
#[doc = "Signal map events. See [`MapEvent`]"]
#[doc = ""]

pub const DBG_SIGNAL_MAP_EVENTS: DebugFlags = 16;
#[doc = "Debug flags for an attached process, set by [`svcContinueDebugEvent`]"]
#[doc = ""]

pub type DebugFlags = ::libc::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ThreadContext {
    #[doc = "CPU registers."]
    #[doc = ""]
    pub cpu_registers: CpuRegisters,
    #[doc = "FPU registers."]
    #[doc = ""]
    pub fpu_registers: FpuRegisters,
}
impl Default for ThreadContext {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Control r0-r12."]
#[doc = ""]

pub const THREADCONTEXT_CONTROL_CPU_GPRS: ThreadContextControlFlags = 1;
#[doc = "Control sp, lr, pc, cpsr."]
#[doc = ""]

pub const THREADCONTEXT_CONTROL_CPU_SPRS: ThreadContextControlFlags = 2;
#[doc = "Control d0-d15 (or s0-s31)."]
#[doc = ""]

pub const THREADCONTEXT_CONTROL_FPU_GPRS: ThreadContextControlFlags = 4;
#[doc = "Control fpscr, fpexc."]
#[doc = ""]

pub const THREADCONTEXT_CONTROL_FPU_SPRS: ThreadContextControlFlags = 8;
#[doc = "Control r0-r12, sp, lr, pc, cpsr."]
#[doc = ""]

pub const THREADCONTEXT_CONTROL_CPU_REGS: ThreadContextControlFlags = 3;
#[doc = "Control d0-d15, fpscr, fpexc."]
#[doc = ""]

pub const THREADCONTEXT_CONTROL_FPU_REGS: ThreadContextControlFlags = 12;
#[doc = "Control all of the above."]
#[doc = ""]

pub const THREADCONTEXT_CONTROL_ALL: ThreadContextControlFlags = 15;
#[doc = "Control flags for [`svcGetDebugThreadContext`] and [`svcSetDebugThreadContext`]"]
#[doc = ""]

pub type ThreadContextControlFlags = ::libc::c_uint;
#[doc = "Thread priority."]
#[doc = ""]

pub const DBGTHREAD_PARAMETER_PRIORITY: DebugThreadParameter = 0;
#[doc = "Low scheduling mask."]
#[doc = ""]

pub const DBGTHREAD_PARAMETER_SCHEDULING_MASK_LOW: DebugThreadParameter = 1;
#[doc = "Ideal processor."]
#[doc = ""]

pub const DBGTHREAD_PARAMETER_CPU_IDEAL: DebugThreadParameter = 2;
#[doc = "Processor that created the threod."]
#[doc = ""]

pub const DBGTHREAD_PARAMETER_CPU_CREATOR: DebugThreadParameter = 3;
#[doc = "Thread parameter field for [`svcGetDebugThreadParameter`]"]
#[doc = ""]

pub type DebugThreadParameter = ::libc::c_uint;
#[doc = "Information on address space for process. All sizes are in pages (0x1000 bytes)"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CodeSetHeader {
    #[doc = "ASCII name of codeset"]
    #[doc = ""]
    pub name: [u8_; 8usize],
    #[doc = "Version field of codeset (unused)"]
    #[doc = ""]
    pub version: u16_,
    #[doc = "Padding"]
    #[doc = ""]
    pub padding: [u16_; 3usize],
    #[doc = ".text start address"]
    #[doc = ""]
    pub text_addr: u32_,
    #[doc = ".text number of pages"]
    #[doc = ""]
    pub text_size: u32_,
    #[doc = ".rodata start address"]
    #[doc = ""]
    pub ro_addr: u32_,
    #[doc = ".rodata number of pages"]
    #[doc = ""]
    pub ro_size: u32_,
    #[doc = ".data, .bss start address"]
    #[doc = ""]
    pub rw_addr: u32_,
    #[doc = ".data number of pages"]
    #[doc = ""]
    pub rw_size: u32_,
    #[doc = "total pages for .text (aligned)"]
    #[doc = ""]
    pub text_size_total: u32_,
    #[doc = "total pages for .rodata (aligned)"]
    #[doc = ""]
    pub ro_size_total: u32_,
    #[doc = "total pages for .data, .bss (aligned)"]
    #[doc = ""]
    pub rw_size_total: u32_,
    #[doc = "Padding"]
    #[doc = ""]
    pub padding2: u32_,
    #[doc = "Program ID"]
    #[doc = ""]
    pub program_id: u64_,
}
#[doc = "Information for the main thread of a process."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct StartupInfo {
    #[doc = "Priority of the main thread."]
    #[doc = ""]
    pub priority: ::libc::c_int,
    #[doc = "Size of the stack of the main thread."]
    #[doc = ""]
    pub stack_size: u32_,
    #[doc = "Unused on retail kernel."]
    #[doc = ""]
    pub argc: ::libc::c_int,
    #[doc = "Unused on retail kernel."]
    #[doc = ""]
    pub argv: *mut u16_,
    #[doc = "Unused on retail kernel."]
    #[doc = ""]
    pub envp: *mut u16_,
}
impl Default for StartupInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[must_use]
    #[doc = "# Memory management\n@{\n**\n* @brief Controls memory mapping\n* @param[out] addr_out The virtual address resulting from the operation. Usually the same as addr0.\n* @param addr0 The virtual address to be used for the operation.\n* @param addr1 The virtual address to be (un)mirrored by @p addr0 when using [`MEMOP_MAP`] or [`MEMOP_UNMAP.\n*`] It has to be pointing to a RW memory.\n* Use NULL if the operation is [`MEMOP_FREE`] or [`MEMOP_ALLOC.\n*`] @param size The requested size for [`MEMOP_ALLOC`] and [`MEMOP_ALLOC_LINEAR.\n*`] @param op Operation flags. See [`MemOp.\n*`] @param perm A combination of [`MEMPERM_READ`] and [`MEMPERM_WRITE`] Using MEMPERM_EXECUTE will return an error.\n* Value 0 is used when unmapping memory.\n*\n* If a memory is mapped for two or more addresses, you have to use MEMOP_UNMAP before being able to MEMOP_FREE it.\n* MEMOP_MAP will fail if @p addr1 was already mapped to another address.\n*\n* More information is available at <http://3dbrew.org/wiki/SVC#Memory_Mapping.\n*\n*> [`svcControlProcessMemory\n*/`]"]
    #[doc = ""]
    pub fn svcControlMemory(
        addr_out: *mut u32_,
        addr0: u32_,
        addr1: u32_,
        size: u32_,
        op: MemOp,
        perm: MemPerm,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Controls the memory mapping of a process\n @param addr0 The virtual address to map\n @param addr1 The virtual address to be mapped by @p addr0\n @param type Only operations [`MEMOP_MAP`] [`MEMOP_UNMAP`] and [`MEMOP_PROT`] are allowed.\n\n This is the only SVC which allows mapping executable memory.\n Using [`MEMOP_PROT`] will change the memory permissions of an already mapped memory.\n\n @note The pseudo handle for the current process is not supported by this service call.\n [`svcControlProcess`]"]
    #[doc = ""]
    pub fn svcControlProcessMemory(
        process: Handle,
        addr0: u32_,
        addr1: u32_,
        size: u32_,
        type_: u32_,
        perm: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Creates a block of shared memory\n @param[out] memblock Pointer to store the handle of the block\n @param addr Address of the memory to map, page-aligned. So its alignment must be 0x1000.\n @param size Size of the memory to map, a multiple of 0x1000.\n @param my_perm Memory permissions for the current process\n @param other_perm Memory permissions for the other processes\n\n @note The shared memory block, and its rights, are destroyed when the handle is closed."]
    #[doc = ""]
    pub fn svcCreateMemoryBlock(
        memblock: *mut Handle,
        addr: u32_,
        size: u32_,
        my_perm: MemPerm,
        other_perm: MemPerm,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Maps a block of shared memory\n @param memblock Handle of the block\n @param addr Address of the memory to map, page-aligned. So its alignment must be 0x1000.\n @param my_perm Memory permissions for the current process\n @param other_perm Memory permissions for the other processes\n\n @note The shared memory block, and its rights, are destroyed when the handle is closed."]
    #[doc = ""]
    pub fn svcMapMemoryBlock(
        memblock: Handle,
        addr: u32_,
        my_perm: MemPerm,
        other_perm: MemPerm,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Maps a block of process memory, starting from address 0x00100000.\n @param process Handle of the process.\n @param destAddress Address of the block of memory to map, in the current (destination) process.\n @param size Size of the block of memory to map (truncated to a multiple of 0x1000 bytes)."]
    #[doc = ""]
    pub fn svcMapProcessMemory(process: Handle, destAddress: u32_, size: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Unmaps a block of process memory, starting from address 0x00100000.\n @param process Handle of the process.\n @param destAddress Address of the block of memory to unmap, in the current (destination) process.\n @param size Size of the block of memory to unmap (truncated to a multiple of 0x1000 bytes)."]
    #[doc = ""]
    pub fn svcUnmapProcessMemory(process: Handle, destAddress: u32_, size: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Unmaps a block of shared memory\n @param memblock Handle of the block\n @param addr Address of the memory to unmap, page-aligned. So its alignment must be 0x1000."]
    #[doc = ""]
    pub fn svcUnmapMemoryBlock(memblock: Handle, addr: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Queries memory information.\n @param[out] info Pointer to output memory info to.\n @param out Pointer to output page info to.\n @param addr Virtual memory address to query."]
    #[doc = ""]
    pub fn svcQueryMemory(info: *mut MemInfo, out: *mut PageInfo, addr: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Queries process memory information.\n @param[out] info Pointer to output memory info to.\n @param[out] out Pointer to output page info to.\n @param process Process to query memory from.\n @param addr Virtual memory address to query."]
    #[doc = ""]
    pub fn svcQueryProcessMemory(
        info: *mut MemInfo,
        out: *mut PageInfo,
        process: Handle,
        addr: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "# Process management\n@{\n**\n* @brief Gets the handle of a process.\n* @param[out] process The handle of the process\n* @param processId The ID of the process to open\n*/"]
    #[doc = ""]
    pub fn svcOpenProcess(process: *mut Handle, processId: u32_) -> Result;
}
extern "C" {
    #[doc = "Exits the current process."]
    #[doc = ""]
    pub fn svcExitProcess() -> !;
}
extern "C" {
    #[must_use]
    #[doc = "Terminates a process.\n @param process Handle of the process to terminate."]
    #[doc = ""]
    pub fn svcTerminateProcess(process: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets information about a process.\n @param[out] out Pointer to output process info to.\n @param process Handle of the process to get information about.\n @param type Type of information to retreieve."]
    #[doc = ""]
    pub fn svcGetProcessInfo(out: *mut s64, process: Handle, type_: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the ID of a process.\n @param[out] out Pointer to output the process ID to.\n @param handle Handle of the process to get the ID of."]
    #[doc = ""]
    pub fn svcGetProcessId(out: *mut u32_, handle: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets a list of running processes.\n @param[out] processCount Pointer to output the process count to.\n @param[out] processIds Pointer to output the process IDs to.\n @param processIdMaxCount Maximum number of process IDs."]
    #[doc = ""]
    pub fn svcGetProcessList(
        processCount: *mut s32,
        processIds: *mut u32_,
        processIdMaxCount: s32,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets a list of the threads of a process.\n @param[out] threadCount Pointer to output the thread count to.\n @param[out] threadIds Pointer to output the thread IDs to.\n @param threadIdMaxCount Maximum number of thread IDs.\n @param process Process handle to list the threads of."]
    #[doc = ""]
    pub fn svcGetThreadList(
        threadCount: *mut s32,
        threadIds: *mut u32_,
        threadIdMaxCount: s32,
        process: Handle,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Creates a port.\n @param[out] portServer Pointer to output the port server handle to.\n @param[out] portClient Pointer to output the port client handle to.\n @param name Name of the port.\n @param maxSessions Maximum number of sessions that can connect to the port."]
    #[doc = ""]
    pub fn svcCreatePort(
        portServer: *mut Handle,
        portClient: *mut Handle,
        name: *const ::libc::c_char,
        maxSessions: s32,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Connects to a port.\n @param[out] out Pointer to output the port handle to.\n @param portName Name of the port."]
    #[doc = ""]
    pub fn svcConnectToPort(out: *mut Handle, portName: *const ::libc::c_char) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets up virtual address space for a new process.\n @param[out] out Pointer to output the codeset handle to.\n @param info Codeset header, contains process name, titleId and segment info.\n @param textSegmentLma Address of executable segment in caller's address space.\n @param roSegmentLma Address of read-only segment in caller's address space.\n @param dataSegmentLma Address of read-write segment in caller's address space.\n @note On success, the provided segments are unmapped from the caller's address space."]
    #[doc = ""]
    pub fn svcCreateCodeSet(
        out: *mut Handle,
        info: *const CodeSetHeader,
        textSegmentLma: u32_,
        roSegmentLma: u32_,
        dataSegmentLma: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Create a new process.\n @param[out] out Pointer to output the process handle to.\n @param codeset Codeset created for this process.\n @param arm11KernelCaps Arm11 Kernel Capabilities from exheader.\n @param numArm11KernelCaps Number of kernel capabilities."]
    #[doc = ""]
    pub fn svcCreateProcess(
        out: *mut Handle,
        codeset: Handle,
        arm11KernelCaps: *const u32_,
        numArm11KernelCaps: s32,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets a process's affinity mask.\n @param[out] affinitymask Pointer to store the affinity masks.\n @param process Handle of the process.\n @param processorcount Number of processors."]
    #[doc = ""]
    pub fn svcGetProcessAffinityMask(
        affinitymask: *mut u8_,
        process: Handle,
        processorcount: s32,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets a process's affinity mask.\n @param process Handle of the process.\n @param affinitymask Pointer to retrieve the affinity masks from.\n @param processorcount Number of processors."]
    #[doc = ""]
    pub fn svcSetProcessAffinityMask(
        process: Handle,
        affinitymask: *const u8_,
        processorcount: s32,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets a process's ideal processor.\n @param[out] processorid Pointer to store the ID of the process's ideal processor.\n @param process Handle of the process."]
    #[doc = ""]
    pub fn svcGetProcessIdealProcessor(processorid: *mut s32, process: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets a process's ideal processor.\n @param process Handle of the process.\n @param processorid ID of the process's ideal processor."]
    #[doc = ""]
    pub fn svcSetProcessIdealProcessor(process: Handle, processorid: s32) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Launches the main thread of the process.\n @param process Handle of the process.\n @param info Pointer to a StartupInfo structure describing information for the main thread."]
    #[doc = ""]
    pub fn svcRun(process: Handle, info: *const StartupInfo) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "# Multithreading\n@{\n**\n* @brief Creates a new thread.\n* @param[out] thread The thread handle\n* @param entrypoint The function that will be called first upon thread creation\n* @param arg The argument passed to @p entrypoint\n* @param stack_top The top of the thread's stack. Must be 0x8 bytes mem-aligned.\n* @param thread_priority Low values gives the thread higher priority.\n* For userland apps, this has to be within the range [0x18;0x3F]\n* @param processor_id The id of the processor the thread should be ran on. Those are labelled starting from 0.\n* For old 3ds it has to be <2, and for new 3DS <4.\n* Value -1 means all CPUs and -2 read from the Exheader.\n*\n* The processor with ID 1 is the system processor.\n* To enable multi-threading on this core you need to call APT_SetAppCpuTimeLimit at least once with a non-zero value.\n*\n* Since a thread is considered as a waitable object, you can use [`svcWaitSynchronization\n*`] and [`svcWaitSynchronizationN`] to join with it.\n*\n* @note The kernel will clear the @p stack_top's address low 3 bits to make sure it is 0x8-bytes aligned.\n*/"]
    #[doc = ""]
    pub fn svcCreateThread(
        thread: *mut Handle,
        entrypoint: ThreadFunc,
        arg: u32_,
        stack_top: *mut u32_,
        thread_priority: s32,
        processor_id: s32,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the handle of a thread.\n @param[out] thread The handle of the thread\n @param process The ID of the process linked to the thread"]
    #[doc = ""]
    pub fn svcOpenThread(thread: *mut Handle, process: Handle, threadId: u32_) -> Result;
}
extern "C" {
    #[doc = "Exits the current thread.\n\n This will trigger a state change and hence release all [`svcWaitSynchronization`] operations.\n It means that you can join a thread by calling ``` svcWaitSynchronization(threadHandle,yourtimeout); ```"]
    #[doc = ""]
    pub fn svcExitThread() -> !;
}
extern "C" {
    #[doc = "Puts the current thread to sleep.\n @param ns The minimum number of nanoseconds to sleep for."]
    #[doc = ""]
    pub fn svcSleepThread(ns: s64);
}
extern "C" {
    #[must_use]
    #[doc = "Retrieves the priority of a thread."]
    #[doc = ""]
    pub fn svcGetThreadPriority(out: *mut s32, handle: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Changes the priority of a thread\n @param prio For userland apps, this has to be within the range [0x18;0x3F]\n\n Low values gives the thread higher priority."]
    #[doc = ""]
    pub fn svcSetThreadPriority(thread: Handle, prio: s32) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets a thread's affinity mask.\n @param[out] affinitymask Pointer to output the affinity masks to.\n @param thread Handle of the thread.\n @param processorcount Number of processors."]
    #[doc = ""]
    pub fn svcGetThreadAffinityMask(
        affinitymask: *mut u8_,
        thread: Handle,
        processorcount: s32,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets a thread's affinity mask.\n @param thread Handle of the thread.\n @param affinitymask Pointer to retrieve the affinity masks from.\n @param processorcount Number of processors."]
    #[doc = ""]
    pub fn svcSetThreadAffinityMask(
        thread: Handle,
        affinitymask: *const u8_,
        processorcount: s32,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets a thread's ideal processor.\n @param[out] processorid Pointer to output the ID of the thread's ideal processor to.\n @param thread Handle of the thread."]
    #[doc = ""]
    pub fn svcGetThreadIdealProcessor(processorid: *mut s32, thread: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets a thread's ideal processor.\n @param thread Handle of the thread.\n @param processorid ID of the thread's ideal processor."]
    #[doc = ""]
    pub fn svcSetThreadIdealProcessor(thread: Handle, processorid: s32) -> Result;
}
extern "C" {
    #[doc = "Returns the ID of the processor the current thread is running on.\n [`svcCreateThread`]"]
    #[doc = ""]
    pub fn svcGetProcessorID() -> s32;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the ID of a thread.\n @param[out] out Pointer to output the thread ID of the thread @p handle to.\n @param handle Handle of the thread."]
    #[doc = ""]
    pub fn svcGetThreadId(out: *mut u32_, handle: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the resource limit set of a process.\n @param[out] resourceLimit Pointer to output the resource limit set handle to.\n @param process Process to get the resource limits of."]
    #[doc = ""]
    pub fn svcGetResourceLimit(resourceLimit: *mut Handle, process: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the value limits of a resource limit set.\n @param[out] values Pointer to output the value limits to.\n @param resourceLimit Resource limit set to use.\n @param names Resource limit names to get the limits of.\n @param nameCount Number of resource limit names."]
    #[doc = ""]
    pub fn svcGetResourceLimitLimitValues(
        values: *mut s64,
        resourceLimit: Handle,
        names: *mut ResourceLimitType,
        nameCount: s32,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the values of a resource limit set.\n @param[out] values Pointer to output the values to.\n @param resourceLimit Resource limit set to use.\n @param names Resource limit names to get the values of.\n @param nameCount Number of resource limit names."]
    #[doc = ""]
    pub fn svcGetResourceLimitCurrentValues(
        values: *mut s64,
        resourceLimit: Handle,
        names: *mut ResourceLimitType,
        nameCount: s32,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the resource limit set of a process.\n @param process Process to set the resource limit set to.\n @param resourceLimit Resource limit set handle."]
    #[doc = ""]
    pub fn svcSetProcessResourceLimits(process: Handle, resourceLimit: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Creates a resource limit set.\n @param[out] resourceLimit Pointer to output the resource limit set handle to."]
    #[doc = ""]
    pub fn svcCreateResourceLimit(resourceLimit: *mut Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the value limits of a resource limit set.\n @param resourceLimit Resource limit set to use.\n @param names Resource limit names to set the limits of.\n @param values Value limits to set. The high 32 bits of RESLIMIT_COMMIT are used to\nset APPMEMALLOC in configuration memory, otherwise those bits are unused.\n @param nameCount Number of resource limit names."]
    #[doc = ""]
    pub fn svcSetResourceLimitValues(
        resourceLimit: Handle,
        names: *const ResourceLimitType,
        values: *const s64,
        nameCount: s32,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the process ID of a thread.\n @param[out] out Pointer to output the process ID of the thread @p handle to.\n @param handle Handle of the thread.\n [`svcOpenProcess`]"]
    #[doc = ""]
    pub fn svcGetProcessIdOfThread(out: *mut u32_, handle: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Checks if a thread handle is valid.\n This requests always return an error when called, it only checks if the handle is a thread or not.\n @return 0xD8E007ED (BAD_ENUM) if the Handle is a Thread Handle\n @return 0xD8E007F7 (BAD_HANDLE) if it isn't."]
    #[doc = ""]
    pub fn svcGetThreadInfo(out: *mut s64, thread: Handle, type_: ThreadInfoType) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "# Synchronization\n@{\n**\n* @brief Creates a mutex.\n* @param[out] mutex Pointer to output the handle of the created mutex to.\n* @param initially_locked Whether the mutex should be initially locked.\n*/"]
    #[doc = ""]
    pub fn svcCreateMutex(mutex: *mut Handle, initially_locked: bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Releases a mutex.\n @param handle Handle of the mutex."]
    #[doc = ""]
    pub fn svcReleaseMutex(handle: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Creates a semaphore.\n @param[out] semaphore Pointer to output the handle of the created semaphore to.\n @param initial_count Initial count of the semaphore.\n @param max_count Maximum count of the semaphore."]
    #[doc = ""]
    pub fn svcCreateSemaphore(semaphore: *mut Handle, initial_count: s32, max_count: s32)
        -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Releases a semaphore.\n @param[out] count Pointer to output the current count of the semaphore to.\n @param semaphore Handle of the semaphore.\n @param release_count Number to increase the semaphore count by."]
    #[doc = ""]
    pub fn svcReleaseSemaphore(count: *mut s32, semaphore: Handle, release_count: s32) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Creates an event handle.\n @param[out] event Pointer to output the created event handle to.\n @param reset_type Type of reset the event uses (RESET_ONESHOT/RESET_STICKY)."]
    #[doc = ""]
    pub fn svcCreateEvent(event: *mut Handle, reset_type: ResetType) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Signals an event.\n @param handle Handle of the event to signal."]
    #[doc = ""]
    pub fn svcSignalEvent(handle: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Clears an event.\n @param handle Handle of the event to clear."]
    #[doc = ""]
    pub fn svcClearEvent(handle: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Waits for synchronization on a handle.\n @param handle Handle to wait on.\n @param nanoseconds Maximum nanoseconds to wait for."]
    #[doc = ""]
    pub fn svcWaitSynchronization(handle: Handle, nanoseconds: s64) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Waits for synchronization on multiple handles.\n @param[out] out Pointer to output the index of the synchronized handle to.\n @param handles Handles to wait on.\n @param handles_num Number of handles.\n @param wait_all Whether to wait for synchronization on all handles.\n @param nanoseconds Maximum nanoseconds to wait for."]
    #[doc = ""]
    pub fn svcWaitSynchronizationN(
        out: *mut s32,
        handles: *const Handle,
        handles_num: s32,
        wait_all: bool,
        nanoseconds: s64,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Creates an address arbiter\n @param[out] mutex Pointer to output the handle of the created address arbiter to.\n [`svcArbitrateAddress`]"]
    #[doc = ""]
    pub fn svcCreateAddressArbiter(arbiter: *mut Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Arbitrate an address, can be used for synchronization\n @param arbiter Handle of the arbiter\n @param addr A pointer to a s32 value.\n @param type Type of action to be performed by the arbiter\n @param value Number of threads to signal if using [`ARBITRATION_SIGNAL`] or the value used for comparison.\n @param timeout_ns Optional timeout in nanoseconds when using TIMEOUT actions, ignored otherwise. If not needed, use [`svcArbitrateAddressNoTimeout`] instead.\n @note Usage of this syscall entails an implicit Data Memory Barrier (dmb).\n @warning Please use [`syncArbitrateAddressWithTimeout`] instead."]
    #[doc = ""]
    pub fn svcArbitrateAddress(
        arbiter: Handle,
        addr: u32_,
        type_: ArbitrationType,
        value: s32,
        timeout_ns: s64,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Same as [`svcArbitrateAddress`] but with the timeout_ns parameter undefined.\n @param arbiter Handle of the arbiter\n @param addr A pointer to a s32 value.\n @param type Type of action to be performed by the arbiter\n @param value Number of threads to signal if using [`ARBITRATION_SIGNAL`] or the value used for comparison.\n @note Usage of this syscall entails an implicit Data Memory Barrier (dmb).\n @warning Please use [`syncArbitrateAddress`] instead."]
    #[doc = ""]
    pub fn svcArbitrateAddressNoTimeout(
        arbiter: Handle,
        addr: u32_,
        type_: ArbitrationType,
        value: s32,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sends a synchronized request to a session handle.\n @param session Handle of the session."]
    #[doc = ""]
    pub fn svcSendSyncRequest(session: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Connects to a port via a handle.\n @param[out] clientSession Pointer to output the client session handle to.\n @param clientPort Port client endpoint to connect to."]
    #[doc = ""]
    pub fn svcCreateSessionToPort(clientSession: *mut Handle, clientPort: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Creates a linked pair of session endpoints.\n @param[out] serverSession Pointer to output the created server endpoint handle to.\n @param[out] clientSession Pointer to output the created client endpoint handle to."]
    #[doc = ""]
    pub fn svcCreateSession(serverSession: *mut Handle, clientSession: *mut Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Accepts a session.\n @param[out] session Pointer to output the created session handle to.\n @param port Handle of the port to accept a session from."]
    #[doc = ""]
    pub fn svcAcceptSession(session: *mut Handle, port: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Replies to and receives a new request.\n @param index Pointer to the index of the request.\n @param handles Session handles to receive requests from.\n @param handleCount Number of handles.\n @param replyTarget Handle of the session to reply to."]
    #[doc = ""]
    pub fn svcReplyAndReceive(
        index: *mut s32,
        handles: *const Handle,
        handleCount: s32,
        replyTarget: Handle,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "# Time\n@{\n**\n* @brief Creates a timer.\n* @param[out] timer Pointer to output the handle of the created timer to.\n* @param reset_type Type of reset to perform on the timer.\n*/"]
    #[doc = ""]
    pub fn svcCreateTimer(timer: *mut Handle, reset_type: ResetType) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets a timer.\n @param timer Handle of the timer to set.\n @param initial Initial value of the timer.\n @param interval Interval of the timer."]
    #[doc = ""]
    pub fn svcSetTimer(timer: Handle, initial: s64, interval: s64) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Cancels a timer.\n @param timer Handle of the timer to cancel."]
    #[doc = ""]
    pub fn svcCancelTimer(timer: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Clears a timer.\n @param timer Handle of the timer to clear."]
    #[doc = ""]
    pub fn svcClearTimer(timer: Handle) -> Result;
}
extern "C" {
    #[doc = "Gets the current system tick.\n @return The current system tick."]
    #[doc = ""]
    pub fn svcGetSystemTick() -> u64_;
}
extern "C" {
    #[must_use]
    #[doc = "# System\n@{\n**\n* @brief Closes a handle.\n* @param handle Handle to close.\n*/"]
    #[doc = ""]
    pub fn svcCloseHandle(handle: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Duplicates a handle.\n @param[out] out Pointer to output the duplicated handle to.\n @param original Handle to duplicate."]
    #[doc = ""]
    pub fn svcDuplicateHandle(out: *mut Handle, original: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets a handle info.\n @param[out] out Pointer to output the handle info to.\n @param handle Handle to get the info for.\n @param param Parameter clarifying the handle info type."]
    #[doc = ""]
    pub fn svcGetHandleInfo(out: *mut s64, handle: Handle, param: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the system info.\n @param[out] out Pointer to output the system info to.\n @param type Type of system info to retrieve.\n @param param Parameter clarifying the system info type."]
    #[doc = ""]
    pub fn svcGetSystemInfo(out: *mut s64, type_: u32_, param: s32) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the current kernel state.\n @param type Type of state to set (the other parameters depend on it)."]
    #[doc = ""]
    pub fn svcKernelSetState(type_: u32_, ...) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Binds an event or semaphore handle to an ARM11 interrupt.\n @param interruptId Interrupt identfier (see <https://www.3dbrew.org/wiki/ARM11_Interrupts).\n> @param eventOrSemaphore Event or semaphore handle to bind to the given interrupt.\n @param priority Priority of the interrupt for the current process.\n @param isManualClear Indicates whether the interrupt has to be manually cleared or not (= level-high active)."]
    #[doc = ""]
    pub fn svcBindInterrupt(
        interruptId: u32_,
        eventOrSemaphore: Handle,
        priority: s32,
        isManualClear: bool,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Unbinds an event or semaphore handle from an ARM11 interrupt.\n @param interruptId Interrupt identfier, see (see <https://www.3dbrew.org/wiki/ARM11_Interrupts).\n> @param eventOrSemaphore Event or semaphore handle to unbind from the given interrupt."]
    #[doc = ""]
    pub fn svcUnbindInterrupt(interruptId: u32_, eventOrSemaphore: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Invalidates a process's data cache.\n @param process Handle of the process.\n @param addr Address to invalidate.\n @param size Size of the memory to invalidate."]
    #[doc = ""]
    pub fn svcInvalidateProcessDataCache(process: Handle, addr: u32_, size: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Cleans a process's data cache.\n @param process Handle of the process.\n @param addr Address to clean.\n @param size Size of the memory to clean."]
    #[doc = ""]
    pub fn svcStoreProcessDataCache(process: Handle, addr: u32_, size: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Flushes (cleans and invalidates) a process's data cache.\n @param process Handle of the process.\n @param addr Address to flush.\n @param size Size of the memory to flush."]
    #[doc = ""]
    pub fn svcFlushProcessDataCache(process: Handle, addr: u32_, size: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Begins an inter-process DMA transfer.\n @param[out] dma Pointer to output the handle of the DMA channel object to.\n @param dstProcess Destination process handle.\n @param dstAddr Address in the destination process to write data to.\n @param srcProcess Source process handle.\n @param srcAddr Address in the source to read data from.\n @param size Size of the data to transfer.\n @param cfg Configuration structure.\n @note The handle is signaled when the transfer finishes."]
    #[doc = ""]
    pub fn svcStartInterProcessDma(
        dma: *mut Handle,
        dstProcess: Handle,
        dstAddr: u32_,
        srcProcess: Handle,
        srcAddr: u32_,
        size: u32_,
        cfg: *const DmaConfig,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Stops an inter-process DMA transfer.\n @param dma Handle of the DMA channel object."]
    #[doc = ""]
    pub fn svcStopDma(dma: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the state of an inter-process DMA transfer.\n @param[out] state Pointer to output the state of the DMA transfer to.\n @param dma Handle of the DMA channel object."]
    #[doc = ""]
    pub fn svcGetDmaState(state: *mut DmaState, dma: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Restarts a DMA transfer, using the same configuration as before.\n @param[out] state Pointer to output the state of the DMA transfer to.\n @param dma Handle of the DMA channel object.\n @param dstAddr Address in the destination process to write data to.\n @param srcAddr Address in the source to read data from.\n @param size Size of the data to transfer.\n @param flags Restart flags, [`DMARST_UNLOCK`] and/or [`DMARST_RESUME_DEVICE.\n`] @note The first transfer has to be configured with [`DMACFG_KEEP_LOCKED`]"]
    #[doc = ""]
    pub fn svcRestartDma(
        dma: Handle,
        dstAddr: u32_,
        srcAddr: u32_,
        size: u32_,
        flags: s8,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the GPU protection register to restrict the range of the GPU DMA. 11.3+ only.\n @param useApplicationRestriction Whether to use the register value used for APPLICATION titles."]
    #[doc = ""]
    pub fn svcSetGpuProt(useApplicationRestriction: bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Enables or disables Wi-Fi. 11.4+ only.\n @param enabled Whether to enable or disable Wi-Fi."]
    #[doc = ""]
    pub fn svcSetWifiEnabled(enabled: bool) -> Result;
}
extern "C" {
    #[doc = "# Debugging\n@{\n**\n* @brief Breaks execution.\n* @param breakReason Reason for breaking.\n*/"]
    #[doc = ""]
    pub fn svcBreak(breakReason: UserBreakType);
}
extern "C" {
    #[doc = "Breaks execution (LOAD_RO and UNLOAD_RO).\n @param breakReason Debug reason for breaking.\n @param croInfo Library information.\n @param croInfoSize Size of the above structure."]
    #[doc = ""]
    pub fn svcBreakRO(
        breakReason: UserBreakType,
        croInfo: *const ::libc::c_void,
        croInfoSize: u32_,
    );
}
extern "C" {
    #[must_use]
    #[doc = "Outputs a debug string.\n @param str String to output.\n @param length Length of the string to output, needs to be positive."]
    #[doc = ""]
    pub fn svcOutputDebugString(str_: *const ::libc::c_char, length: s32) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Controls performance monitoring on the CP15 interface and the SCU.\n The meaning of the parameters depend on the operation.\n @param[out] out Output.\n @param op Operation, see details.\n @param param1 First parameter.\n @param param2 Second parameter.\n @details The operations are the following:\n - [`PERFCOUNTEROP_ENABLE`] (void) -> void, tries to enable and lock perfmon. functionality.\n - [`PERFCOUNTEROP_DISABLE`] (void) -> void, disable and forcibly unlocks perfmon. functionality.\n - [`PERFCOUNTEROP_GET_VALUE`] [`PerfCounterRegister`] reg) -> u64, gets the value of a particular counter register.\n - [`PERFCOUNTEROP_SET_VALUE`] [`PerfCounterRegister`] reg, u64 value) -> void, sets the value of a particular counter register.\n - [`PERFCOUNTEROP_GET_OVERFLOW_FLAGS`] (void) -> u32, gets the overflow flags of all CP15 and SCU registers.\n - Format is a bitfield of [`PerfCounterRegister.\n`] - [`PERFCOUNTEROP_RESET`] (u32 valueResetMask, u32 overflowFlagResetMask) -> void, resets the value and/or\n overflow flags of selected registers.\n - Format is two bitfields of [`PerfCounterRegister.\n`] - [`PERFCOUNTEROP_GET_EVENT`] [`PerfCounterRegister`] reg) -> [`PerfCounterEvent`] gets the event associated\n to a particular counter register.\n - [`PERFCOUNTEROP_SET_EVENT`] [`PerfCounterRegister`] reg, [`PerfCounterEvent)`] -> void, sets the event associated\n to a particular counter register.\n - [`PERFCOUNTEROP_SET_VIRTUAL_COUNTER_ENABLED`] (bool enabled) -> void, (dis)allows the kernel to track counter overflows\n and to use 64-bit counter values."]
    #[doc = ""]
    pub fn svcControlPerformanceCounter(
        out: *mut u64_,
        op: PerfCounterOperation,
        param1: u32_,
        param2: u64_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Creates a debug handle for an active process.\n @param[out] debug Pointer to output the created debug handle to.\n @param processId ID of the process to debug."]
    #[doc = ""]
    pub fn svcDebugActiveProcess(debug: *mut Handle, processId: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Breaks a debugged process.\n @param debug Debug handle of the process."]
    #[doc = ""]
    pub fn svcBreakDebugProcess(debug: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Terminates a debugged process.\n @param debug Debug handle of the process."]
    #[doc = ""]
    pub fn svcTerminateDebugProcess(debug: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the current debug event of a debugged process.\n @param[out] info Pointer to output the debug event information to.\n @param debug Debug handle of the process."]
    #[doc = ""]
    pub fn svcGetProcessDebugEvent(info: *mut DebugEventInfo, debug: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Continues the current debug event of a debugged process (not necessarily the same as [`svcGetProcessDebugEvent).\n`] @param debug Debug handle of the process.\n @param flags Flags to continue with, see [`DebugFlags`]"]
    #[doc = ""]
    pub fn svcContinueDebugEvent(debug: Handle, flags: DebugFlags) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Fetches the saved registers of a thread, either inactive or awaiting [`svcContinueDebugEvent`] belonging to a debugged process.\n @param[out] context Values of the registers to fetch, see [`ThreadContext.\n`] @param debug Debug handle of the parent process.\n @param threadId ID of the thread to fetch the saved registers of.\n @param controlFlags Which registers to fetch, see [`ThreadContextControlFlags`]"]
    #[doc = ""]
    pub fn svcGetDebugThreadContext(
        context: *mut ThreadContext,
        debug: Handle,
        threadId: u32_,
        controlFlags: ThreadContextControlFlags,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Updates the saved registers of a thread, either inactive or awaiting [`svcContinueDebugEvent`] belonging to a debugged process.\n @param debug Debug handle of the parent process.\n @param threadId ID of the thread to update the saved registers of.\n @param context Values of the registers to update, see [`ThreadContext.\n`] @param controlFlags Which registers to update, see [`ThreadContextControlFlags`]"]
    #[doc = ""]
    pub fn svcSetDebugThreadContext(
        debug: Handle,
        threadId: u32_,
        context: *mut ThreadContext,
        controlFlags: ThreadContextControlFlags,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Queries memory information of a debugged process.\n @param[out] info Pointer to output memory info to.\n @param[out] out Pointer to output page info to.\n @param debug Debug handle of the process to query memory from.\n @param addr Virtual memory address to query."]
    #[doc = ""]
    pub fn svcQueryDebugProcessMemory(
        info: *mut MemInfo,
        out: *mut PageInfo,
        debug: Handle,
        addr: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Reads from a debugged process's memory.\n @param buffer Buffer to read data to.\n @param debug Debug handle of the process.\n @param addr Address to read from.\n @param size Size of the memory to read."]
    #[doc = ""]
    pub fn svcReadProcessMemory(
        buffer: *mut ::libc::c_void,
        debug: Handle,
        addr: u32_,
        size: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Writes to a debugged process's memory.\n @param debug Debug handle of the process.\n @param buffer Buffer to write data from.\n @param addr Address to write to.\n @param size Size of the memory to write."]
    #[doc = ""]
    pub fn svcWriteProcessMemory(
        debug: Handle,
        buffer: *const ::libc::c_void,
        addr: u32_,
        size: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets an hardware breakpoint or watchpoint. This is an interface to the BRP/WRP registers, see <http://infocenter.arm.com/help/topic/com.arm.doc.ddi0360f/CEGEBGFC.html> .\n @param registerId range 0..5 = breakpoints (BRP0-5), 0x100..0x101 = watchpoints (WRP0-1). The previous stop point for the register is disabled.\n @param control Value of the control regiser.\n @param value Value of the value register: either and address (if bit21 of control is clear) or the debug handle of a process to fetch the context ID of."]
    #[doc = ""]
    pub fn svcSetHardwareBreakPoint(registerId: s32, control: u32_, value: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets a debugged thread's parameter.\n @param[out] unused Unused.\n @param[out] out Output value.\n @param debug Debug handle of the process.\n @param threadId ID of the thread\n @param parameter Parameter to fetch, see [`DebugThreadParameter`]"]
    #[doc = ""]
    pub fn svcGetDebugThreadParam(
        unused: *mut s64,
        out: *mut u32_,
        debug: Handle,
        threadId: u32_,
        parameter: DebugThreadParameter,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Executes a function in supervisor mode.\n @param callback Function to execute."]
    #[doc = ""]
    pub fn svcBackdoor(callback: ::core::option::Option<unsafe extern "C" fn() -> s32>) -> Result;
}
#[doc = "Mount \"nand:/\""]
#[doc = ""]

pub const ARM9DESC_MOUNT_NAND: _bindgen_ty_7 = 1;
#[doc = "Mount nand:/ro/ as read-write"]
#[doc = ""]

pub const ARM9DESC_MOUNT_NANDRO_RW: _bindgen_ty_7 = 2;
#[doc = "Mount \"twln:/\""]
#[doc = ""]

pub const ARM9DESC_MOUNT_TWLN: _bindgen_ty_7 = 4;
#[doc = "Mount \"wnand:/\""]
#[doc = ""]

pub const ARM9DESC_MOUNT_WNAND: _bindgen_ty_7 = 8;
#[doc = "Mount \"cardspi:/\""]
#[doc = ""]

pub const ARM9DESC_MOUNT_CARDSPI: _bindgen_ty_7 = 16;
#[doc = "Use SDIF3"]
#[doc = ""]

pub const ARM9DESC_USE_SDIF3: _bindgen_ty_7 = 32;
#[doc = "Create seed (movable.sed)"]
#[doc = ""]

pub const ARM9DESC_CREATE_SEED: _bindgen_ty_7 = 64;
#[doc = "Use card SPI, required by multiple pxi:dev commands"]
#[doc = ""]

pub const ARM9DESC_USE_CARD_SPI: _bindgen_ty_7 = 128;
#[doc = "SD application (not checked)"]
#[doc = ""]

pub const ARM9DESC_SD_APPLICATION: _bindgen_ty_7 = 256;
#[doc = "Mount \"sdmc:/\" as read-write"]
#[doc = ""]

pub const ARM9DESC_MOUNT_SDMC_RW: _bindgen_ty_7 = 512;
#[doc = "ARM9 descriptor flags"]
#[doc = ""]

pub type _bindgen_ty_7 = ::libc::c_uint;
#[doc = "Category \"system application\""]
#[doc = ""]

pub const FSACCESS_CATEGORY_SYSTEM_APPLICATION: _bindgen_ty_8 = 1;
#[doc = "Category \"hardware check\""]
#[doc = ""]

pub const FSACCESS_CATEGORY_HARDWARE_CHECK: _bindgen_ty_8 = 2;
#[doc = "Category \"filesystem tool\""]
#[doc = ""]

pub const FSACCESS_CATEGORY_FILESYSTEM_TOOL: _bindgen_ty_8 = 4;
#[doc = "Debug"]
#[doc = ""]

pub const FSACCESS_DEBUG: _bindgen_ty_8 = 8;
#[doc = "TWLCARD backup"]
#[doc = ""]

pub const FSACCESS_TWLCARD_BACKUP: _bindgen_ty_8 = 16;
#[doc = "TWLNAND data"]
#[doc = ""]

pub const FSACCESS_TWLNAND_DATA: _bindgen_ty_8 = 32;
#[doc = "BOSS (SpotPass)"]
#[doc = ""]

pub const FSACCESS_BOSS: _bindgen_ty_8 = 64;
#[doc = "SDMC (read-write)"]
#[doc = ""]

pub const FSACCESS_SDMC_RW: _bindgen_ty_8 = 128;
#[doc = "Core"]
#[doc = ""]

pub const FSACCESS_CORE: _bindgen_ty_8 = 256;
#[doc = "nand:/ro/ (read-only)"]
#[doc = ""]

pub const FSACCESS_NANDRO_RO: _bindgen_ty_8 = 512;
#[doc = "nand:/rw/"]
#[doc = ""]

pub const FSACCESS_NANDRW: _bindgen_ty_8 = 1024;
#[doc = "nand:/ro/ (read-write)"]
#[doc = ""]

pub const FSACCESS_NANDRO_RW: _bindgen_ty_8 = 2048;
#[doc = "Category \"System Settings\""]
#[doc = ""]

pub const FSACCESS_CATEGORY_SYSTEM_SETTINGS: _bindgen_ty_8 = 4096;
#[doc = "Cardboard (System Transfer)"]
#[doc = ""]

pub const FSACCESS_CARDBOARD: _bindgen_ty_8 = 8192;
#[doc = "Export/Import IVs (movable.sed)"]
#[doc = ""]

pub const FSACCESS_EXPORT_IMPORT_IVS: _bindgen_ty_8 = 16384;
#[doc = "SDMC (write-only)"]
#[doc = ""]

pub const FSACCESS_SDMC_WO: _bindgen_ty_8 = 32768;
#[doc = "\"Switch cleanup\" (3.0+)"]
#[doc = ""]

pub const FSACCESS_SWITCH_CLEANUP: _bindgen_ty_8 = 65536;
#[doc = "Savedata move (5.0+)"]
#[doc = ""]

pub const FSACCESS_SAVEDATA_MOVE: _bindgen_ty_8 = 131072;
#[doc = "Shop (5.0+)"]
#[doc = ""]

pub const FSACCESS_SHOP: _bindgen_ty_8 = 262144;
#[doc = "Shop (5.0+)"]
#[doc = ""]

pub const FSACCESS_SHELL: _bindgen_ty_8 = 524288;
#[doc = "Category \"Home Menu\" (6.0+)"]
#[doc = ""]

pub const FSACCESS_CATEGORY_HOME_MENU: _bindgen_ty_8 = 1048576;
#[doc = "Seed DB (9.6+)"]
#[doc = ""]

pub const FSACCESS_SEEDDB: _bindgen_ty_8 = 2097152;
#[doc = "Filesystem access flags"]
#[doc = ""]

pub type _bindgen_ty_8 = ::libc::c_uint;
#[doc = "Regular application"]
#[doc = ""]

pub const RESLIMIT_CATEGORY_APPLICATION: ResourceLimitCategory = 0;
#[doc = "System applet"]
#[doc = ""]

pub const RESLIMIT_CATEGORY_SYS_APPLET: ResourceLimitCategory = 1;
#[doc = "Library applet"]
#[doc = ""]

pub const RESLIMIT_CATEGORY_LIB_APPLET: ResourceLimitCategory = 2;
#[doc = "System modules running inside the BASE memregion"]
#[doc = ""]

pub const RESLIMIT_CATEGORY_OTHER: ResourceLimitCategory = 3;
#[doc = "The resource limit category of a title"]
#[doc = ""]

pub type ResourceLimitCategory = ::libc::c_uint;
#[doc = "64MB of usable application memory"]
#[doc = ""]

pub const SYSMODE_O3DS_PROD: SystemMode = 0;
#[doc = "124MB of usable application memory. Unusable on O3DS"]
#[doc = ""]

pub const SYSMODE_N3DS_PROD: SystemMode = 1;
#[doc = "97MB/178MB of usable application memory"]
#[doc = ""]

pub const SYSMODE_DEV1: SystemMode = 2;
#[doc = "80MB/124MB of usable application memory"]
#[doc = ""]

pub const SYSMODE_DEV2: SystemMode = 3;
#[doc = "72MB of usable application memory. Same as \"Prod\" on N3DS"]
#[doc = ""]

pub const SYSMODE_DEV3: SystemMode = 4;
#[doc = "32MB of usable application memory. Same as \"Prod\" on N3DS"]
#[doc = ""]

pub const SYSMODE_DEV4: SystemMode = 5;
#[doc = "The system mode a title should be launched under"]
#[doc = ""]

pub type SystemMode = ::libc::c_uint;
#[doc = "The system info flags and remaster version of a title"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ExHeader_SystemInfoFlags {
    #[doc = "Reserved"]
    #[doc = ""]
    pub reserved: [u8_; 5usize],
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "Remaster version"]
    #[doc = ""]
    pub remaster_version: u16_,
}
impl ExHeader_SystemInfoFlags {
    #[inline]
    pub fn compress_exefs_code(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_compress_exefs_code(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_sd_application(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_sd_application(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        compress_exefs_code: bool,
        is_sd_application: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let compress_exefs_code: u8 = unsafe { ::core::mem::transmute(compress_exefs_code) };
            compress_exefs_code as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let is_sd_application: u8 = unsafe { ::core::mem::transmute(is_sd_application) };
            is_sd_application as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "Information about a title's section"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ExHeader_CodeSectionInfo {
    #[doc = "The address of the section"]
    #[doc = ""]
    pub address: u32_,
    #[doc = "The number of pages the section occupies"]
    #[doc = ""]
    pub num_pages: u32_,
    #[doc = "The size of the section"]
    #[doc = ""]
    pub size: u32_,
}
#[doc = "The name of a title and infomation about its section"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ExHeader_CodeSetInfo {
    #[doc = "Title name"]
    #[doc = ""]
    pub name: [::libc::c_char; 8usize],
    #[doc = "System info flags, see [`ExHeader_SystemInfoFlags`]"]
    #[doc = ""]
    pub flags: ExHeader_SystemInfoFlags,
    #[doc = ".text section info, see [`ExHeader_CodeSectionInfo`]"]
    #[doc = ""]
    pub text: ExHeader_CodeSectionInfo,
    #[doc = "Stack size"]
    #[doc = ""]
    pub stack_size: u32_,
    #[doc = ".rodata section info, see [`ExHeader_CodeSectionInfo`]"]
    #[doc = ""]
    pub rodata: ExHeader_CodeSectionInfo,
    #[doc = "Reserved"]
    #[doc = ""]
    pub reserved: u32_,
    #[doc = ".data section info, see [`ExHeader_CodeSectionInfo`]"]
    #[doc = ""]
    pub data: ExHeader_CodeSectionInfo,
    #[doc = ".bss section size"]
    #[doc = ""]
    pub bss_size: u32_,
}
#[doc = "The savedata size and jump ID of a title"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExHeader_SystemInfo {
    #[doc = "Savedata size"]
    #[doc = ""]
    pub savedata_size: u64_,
    #[doc = "Jump ID"]
    #[doc = ""]
    pub jump_id: u64_,
    #[doc = "Reserved"]
    #[doc = ""]
    pub reserved: [u8_; 48usize],
}
impl Default for ExHeader_SystemInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "The code set info, dependencies and system info of a title (SCI)"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExHeader_SystemControlInfo {
    #[doc = "Code set info, see [`ExHeader_CodeSetInfo`]"]
    #[doc = ""]
    pub codeset_info: ExHeader_CodeSetInfo,
    #[doc = "Title IDs of the titles that this program depends on"]
    #[doc = ""]
    pub dependencies: [u64_; 48usize],
    #[doc = "System info, see [`ExHeader_SystemInfo`]"]
    #[doc = ""]
    pub system_info: ExHeader_SystemInfo,
}
impl Default for ExHeader_SystemControlInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "The ARM11 filesystem info of a title"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ExHeader_Arm11StorageInfo {
    #[doc = "Extdata ID"]
    #[doc = ""]
    pub extdata_id: u64_,
    #[doc = "IDs of the system savedata accessible by the title"]
    #[doc = ""]
    pub system_savedata_ids: [u32_; 2usize],
    #[doc = "IDs of the savedata accessible by the title, 20 bits each, followed by \"Use other variation savedata\""]
    #[doc = ""]
    pub accessible_savedata_ids: u64_,
    #[doc = "FS access flags"]
    #[doc = ""]
    pub fs_access_info: u32_,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl ExHeader_Arm11StorageInfo {
    #[inline]
    pub fn reserved(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn no_romfs(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_no_romfs(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn use_extended_savedata_access(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_use_extended_savedata_access(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved: u32_,
        no_romfs: bool,
        use_extended_savedata_access: bool,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let no_romfs: u8 = unsafe { ::core::mem::transmute(no_romfs) };
            no_romfs as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let use_extended_savedata_access: u8 =
                unsafe { ::core::mem::transmute(use_extended_savedata_access) };
            use_extended_savedata_access as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "The CPU-related and memory-layout-related info of a title"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExHeader_Arm11CoreInfo {
    #[doc = "The low title ID of the target firmware"]
    #[doc = ""]
    pub core_version: u32_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    #[doc = "The priority of the title's main thread"]
    #[doc = ""]
    pub priority: u8_,
}
impl Default for ExHeader_Arm11CoreInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ExHeader_Arm11CoreInfo {
    #[inline]
    pub fn use_cpu_clockrate_804MHz(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_use_cpu_clockrate_804MHz(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_l2c(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_enable_l2c(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flag1_unused(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_flag1_unused(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn n3ds_system_mode(&self) -> SystemMode {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_n3ds_system_mode(&mut self, val: SystemMode) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn flag2_unused(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_flag2_unused(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn ideal_processor(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_ideal_processor(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn affinity_mask(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_affinity_mask(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn o3ds_system_mode(&self) -> SystemMode {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_o3ds_system_mode(&mut self, val: SystemMode) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        use_cpu_clockrate_804MHz: bool,
        enable_l2c: bool,
        flag1_unused: u8_,
        n3ds_system_mode: SystemMode,
        flag2_unused: u8_,
        ideal_processor: u8_,
        affinity_mask: u8_,
        o3ds_system_mode: SystemMode,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let use_cpu_clockrate_804MHz: u8 =
                unsafe { ::core::mem::transmute(use_cpu_clockrate_804MHz) };
            use_cpu_clockrate_804MHz as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let enable_l2c: u8 = unsafe { ::core::mem::transmute(enable_l2c) };
            enable_l2c as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let flag1_unused: u8 = unsafe { ::core::mem::transmute(flag1_unused) };
            flag1_unused as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let n3ds_system_mode: u32 = unsafe { ::core::mem::transmute(n3ds_system_mode) };
            n3ds_system_mode as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let flag2_unused: u8 = unsafe { ::core::mem::transmute(flag2_unused) };
            flag2_unused as u64
        });
        __bindgen_bitfield_unit.set(16usize, 2u8, {
            let ideal_processor: u8 = unsafe { ::core::mem::transmute(ideal_processor) };
            ideal_processor as u64
        });
        __bindgen_bitfield_unit.set(18usize, 2u8, {
            let affinity_mask: u8 = unsafe { ::core::mem::transmute(affinity_mask) };
            affinity_mask as u64
        });
        __bindgen_bitfield_unit.set(20usize, 4u8, {
            let o3ds_system_mode: u32 = unsafe { ::core::mem::transmute(o3ds_system_mode) };
            o3ds_system_mode as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "The ARM11 system-local capabilities of a title"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExHeader_Arm11SystemLocalCapabilities {
    #[doc = "Title ID"]
    #[doc = ""]
    pub title_id: u64_,
    #[doc = "Core info, see [`ExHeader_Arm11CoreInfo`]"]
    #[doc = ""]
    pub core_info: ExHeader_Arm11CoreInfo,
    #[doc = "Resource limit descriptors, only \"CpuTime\" (first byte) sems to be used"]
    #[doc = ""]
    pub reslimits: [u16_; 16usize],
    #[doc = "Storage info, see [`ExHeader_Arm11StorageInfo`]"]
    #[doc = ""]
    pub storage_info: ExHeader_Arm11StorageInfo,
    #[doc = "List of the services the title has access to. Limited to 32 prior to system version 9.3"]
    #[doc = ""]
    pub service_access: [[::libc::c_char; 8usize]; 34usize],
    #[doc = "Reserved"]
    #[doc = ""]
    pub reserved: [u8_; 15usize],
    #[doc = "Resource limit category, see [`ExHeader_Arm11SystemLocalCapabilities`]"]
    #[doc = ""]
    pub reslimit_category: ResourceLimitCategory,
}
impl Default for ExHeader_Arm11SystemLocalCapabilities {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "The ARM11 kernel capabilities of a title"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ExHeader_Arm11KernelCapabilities {
    #[doc = "ARM11 kernel descriptors, see 3dbrew"]
    #[doc = ""]
    pub descriptors: [u32_; 28usize],
    #[doc = "Reserved"]
    #[doc = ""]
    pub reserved: [u8_; 16usize],
}
#[doc = "The ARM9 access control of a title"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ExHeader_Arm9AccessControl {
    #[doc = "Process9 FS descriptors, see 3dbrew"]
    #[doc = ""]
    pub descriptors: [u8_; 15usize],
    #[doc = "Descriptor version"]
    #[doc = ""]
    pub descriptor_version: u8_,
}
#[doc = "The access control information of a title"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExHeader_AccessControlInfo {
    #[doc = "ARM11 system-local capabilities, see [`ExHeader_Arm11SystemLocalCapabilities`]"]
    #[doc = ""]
    pub local_caps: ExHeader_Arm11SystemLocalCapabilities,
    #[doc = "ARM11 kernel capabilities, see [`ExHeader_Arm11SystemLocalCapabilities`]"]
    #[doc = ""]
    pub kernel_caps: ExHeader_Arm11KernelCapabilities,
    #[doc = "ARM9 access control, see [`ExHeader_Arm9AccessControl`]"]
    #[doc = ""]
    pub access_control: ExHeader_Arm9AccessControl,
}
impl Default for ExHeader_AccessControlInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Main extended header data, as returned by PXIPM, Loader and FSREG service commands"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExHeader_Info {
    #[doc = "System control info, see [`ExHeader_SystemControlInfo`]"]
    #[doc = ""]
    pub sci: ExHeader_SystemControlInfo,
    #[doc = "Access control info, see [`ExHeader_AccessControlInfo`]"]
    #[doc = ""]
    pub aci: ExHeader_AccessControlInfo,
}
impl Default for ExHeader_Info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Extended header access descriptor"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExHeader_AccessDescriptor {
    #[doc = "The signature of the access descriptor (RSA-2048-SHA256)"]
    #[doc = ""]
    pub signature: [u8_; 256usize],
    #[doc = "The modulus used for the above signature, with 65537 as public exponent"]
    #[doc = ""]
    pub ncchModulus: [u8_; 256usize],
    #[doc = "This is compared for equality with the first ACI by Process9, see [`ExHeader_AccessControlInfo`]"]
    #[doc = ""]
    pub acli: ExHeader_AccessControlInfo,
}
impl Default for ExHeader_AccessDescriptor {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "The NCCH Extended Header of a title"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExHeader {
    #[doc = "Main extended header data, see [`ExHeader_Info`]"]
    #[doc = ""]
    pub info: ExHeader_Info,
    #[doc = "Access descriptor, see [`ExHeader_AccessDescriptor`]"]
    #[doc = ""]
    pub access_descriptor: ExHeader_AccessDescriptor,
}
impl Default for ExHeader {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[must_use]
    #[doc = "Initializes the service API."]
    #[doc = ""]
    pub fn srvInit() -> Result;
}
extern "C" {
    #[doc = "Exits the service API."]
    #[doc = ""]
    pub fn srvExit();
}
extern "C" {
    #[doc = "Makes srvGetServiceHandle non-blocking for the current thread (or blocking, the default), in case of unavailable (full) requested services.\n @param blocking Whether srvGetServiceHandle should be non-blocking.\n srvGetServiceHandle will always block if the service hasn't been registered yet,\n use srvIsServiceRegistered to check whether that is the case or not."]
    #[doc = ""]
    pub fn srvSetBlockingPolicy(nonBlocking: bool);
}
extern "C" {
    #[doc = "Gets the current service API session handle.\n @return The current service API session handle."]
    #[doc = ""]
    pub fn srvGetSessionHandle() -> *mut Handle;
}
extern "C" {
    #[must_use]
    #[doc = "Retrieves a service handle, retrieving from the environment handle list if possible.\n @param out Pointer to write the handle to.\n @param name Name of the service.\n @return 0 if no error occured,\n 0xD8E06406 if the caller has no right to access the service,\n 0xD0401834 if the requested service port is full and srvGetServiceHandle is non-blocking (see [`srvSetBlockingPolicy)`]"]
    #[doc = ""]
    pub fn srvGetServiceHandle(out: *mut Handle, name: *const ::libc::c_char) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Registers the current process as a client to the service API."]
    #[doc = ""]
    pub fn srvRegisterClient() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Enables service notificatios, returning a notification semaphore.\n @param semaphoreOut Pointer to output the notification semaphore to."]
    #[doc = ""]
    pub fn srvEnableNotification(semaphoreOut: *mut Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Registers the current process as a service.\n @param out Pointer to write the service handle to.\n @param name Name of the service.\n @param maxSessions Maximum number of sessions the service can handle."]
    #[doc = ""]
    pub fn srvRegisterService(
        out: *mut Handle,
        name: *const ::libc::c_char,
        maxSessions: ::libc::c_int,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Unregisters the current process as a service.\n @param name Name of the service."]
    #[doc = ""]
    pub fn srvUnregisterService(name: *const ::libc::c_char) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Retrieves a service handle.\n @param out Pointer to output the handle to.\n @param name Name of the service.\n * @return 0 if no error occured,\n 0xD8E06406 if the caller has no right to access the service,\n 0xD0401834 if the requested service port is full and srvGetServiceHandle is non-blocking (see [`srvSetBlockingPolicy)`]"]
    #[doc = ""]
    pub fn srvGetServiceHandleDirect(out: *mut Handle, name: *const ::libc::c_char) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Registers a port.\n @param name Name of the port.\n @param clientHandle Client handle of the port."]
    #[doc = ""]
    pub fn srvRegisterPort(name: *const ::libc::c_char, clientHandle: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Unregisters a port.\n @param name Name of the port."]
    #[doc = ""]
    pub fn srvUnregisterPort(name: *const ::libc::c_char) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Retrieves a port handle.\n @param out Pointer to output the handle to.\n @param name Name of the port."]
    #[doc = ""]
    pub fn srvGetPort(out: *mut Handle, name: *const ::libc::c_char) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Waits for a port to be registered.\n @param name Name of the port to wait for registration."]
    #[doc = ""]
    pub fn srvWaitForPortRegistered(name: *const ::libc::c_char) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Subscribes to a notification.\n @param notificationId ID of the notification."]
    #[doc = ""]
    pub fn srvSubscribe(notificationId: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Unsubscribes from a notification.\n @param notificationId ID of the notification."]
    #[doc = ""]
    pub fn srvUnsubscribe(notificationId: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Receives a notification.\n @param notificationIdOut Pointer to output the ID of the received notification to."]
    #[doc = ""]
    pub fn srvReceiveNotification(notificationIdOut: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Publishes a notification to subscribers.\n @param notificationId ID of the notification.\n @param flags Flags to publish with. (bit 0 = only fire if not fired, bit 1 = do not report an error if there are more than 16 pending notifications)"]
    #[doc = ""]
    pub fn srvPublishToSubscriber(notificationId: u32_, flags: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Publishes a notification to subscribers and retrieves a list of all processes that were notified.\n @param processIdCountOut Pointer to output the number of process IDs to.\n @param processIdsOut Pointer to output the process IDs to. Should have size \"60 * sizeof(u32)\".\n @param notificationId ID of the notification."]
    #[doc = ""]
    pub fn srvPublishAndGetSubscriber(
        processIdCountOut: *mut u32_,
        processIdsOut: *mut u32_,
        notificationId: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Checks whether a service is registered.\n @param registeredOut Pointer to output the registration status to.\n @param name Name of the service to check."]
    #[doc = ""]
    pub fn srvIsServiceRegistered(registeredOut: *mut bool, name: *const ::libc::c_char) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Checks whether a port is registered.\n @param registeredOut Pointer to output the registration status to.\n @param name Name of the port to check."]
    #[doc = ""]
    pub fn srvIsPortRegistered(registeredOut: *mut bool, name: *const ::libc::c_char) -> Result;
}
#[doc = "Generic fatal error. Shows miscellaneous info, including the address of the caller"]
#[doc = ""]

pub const ERRF_ERRTYPE_GENERIC: ERRF_ErrType = 0;
#[doc = "Damaged NAND (CC_ERROR after reading CSR)"]
#[doc = ""]

pub const ERRF_ERRTYPE_NAND_DAMAGED: ERRF_ErrType = 1;
#[doc = "Game content storage medium (cartridge and/or SD card) ejected. Not logged"]
#[doc = ""]

pub const ERRF_ERRTYPE_CARD_REMOVED: ERRF_ErrType = 2;
#[doc = "CPU or VFP exception"]
#[doc = ""]

pub const ERRF_ERRTYPE_EXCEPTION: ERRF_ErrType = 3;
#[doc = "Fatal error with a message instead of the caller's address"]
#[doc = ""]

pub const ERRF_ERRTYPE_FAILURE: ERRF_ErrType = 4;
#[doc = "Log-level failure. Does not display the exception and does not force the system to reboot"]
#[doc = ""]

pub const ERRF_ERRTYPE_LOG_ONLY: ERRF_ErrType = 5;
#[doc = "Types of errors that can be thrown by err:f."]
#[doc = ""]

pub type ERRF_ErrType = ::libc::c_uint;
#[doc = "Prefetch Abort"]
#[doc = ""]

pub const ERRF_EXCEPTION_PREFETCH_ABORT: ERRF_ExceptionType = 0;
#[doc = "Data abort"]
#[doc = ""]

pub const ERRF_EXCEPTION_DATA_ABORT: ERRF_ExceptionType = 1;
#[doc = "Undefined instruction"]
#[doc = ""]

pub const ERRF_EXCEPTION_UNDEFINED: ERRF_ExceptionType = 2;
#[doc = "VFP (floating point) exception."]
#[doc = ""]

pub const ERRF_EXCEPTION_VFP: ERRF_ExceptionType = 3;
#[doc = "Types of 'Exceptions' thrown for ERRF_ERRTYPE_EXCEPTION"]
#[doc = ""]

pub type ERRF_ExceptionType = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ERRF_ExceptionInfo {
    #[doc = "Type of the exception. One of the ERRF_EXCEPTION_* values."]
    #[doc = ""]
    pub type_: ERRF_ExceptionType,
    pub reserved: [u8_; 3usize],
    #[doc = "ifsr (prefetch abort) / dfsr (data abort)"]
    #[doc = ""]
    pub fsr: u32_,
    #[doc = "pc = ifar (prefetch abort) / dfar (data abort)"]
    #[doc = ""]
    pub far: u32_,
    pub fpexc: u32_,
    pub fpinst: u32_,
    pub fpinst2: u32_,
}
impl Default for ERRF_ExceptionInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ERRF_ExceptionData {
    #[doc = "Exception info struct"]
    #[doc = ""]
    pub excep: ERRF_ExceptionInfo,
    #[doc = "CPU register dump."]
    #[doc = ""]
    pub regs: CpuRegisters,
}
impl Default for ERRF_ExceptionData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ERRF_FatalErrInfo {
    #[doc = "Type, one of the ERRF_ERRTYPE_* enum"]
    #[doc = ""]
    pub type_: ERRF_ErrType,
    #[doc = "High revison ID"]
    #[doc = ""]
    pub revHigh: u8_,
    #[doc = "Low revision ID"]
    #[doc = ""]
    pub revLow: u16_,
    #[doc = "Result code"]
    #[doc = ""]
    pub resCode: u32_,
    #[doc = "PC address at exception"]
    #[doc = ""]
    pub pcAddr: u32_,
    #[doc = "Process ID of the caller"]
    #[doc = ""]
    pub procId: u32_,
    #[doc = "Title ID of the caller"]
    #[doc = ""]
    pub titleId: u64_,
    #[doc = "Title ID of the running application"]
    #[doc = ""]
    pub appTitleId: u64_,
    #[doc = "The different types of data for errors."]
    #[doc = ""]
    pub data: ERRF_FatalErrInfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ERRF_FatalErrInfo__bindgen_ty_1 {
    #[doc = "Data for when type is ERRF_ERRTYPE_EXCEPTION"]
    #[doc = ""]
    pub exception_data: ERRF_ExceptionData,
    #[doc = "String for when type is ERRF_ERRTYPE_FAILURE"]
    #[doc = ""]
    pub failure_mesg: [::libc::c_char; 96usize],
}
impl Default for ERRF_FatalErrInfo__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ERRF_FatalErrInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[must_use]
    #[doc = "Initializes ERR:f. Unless you plan to call ERRF_Throw yourself, do not use this."]
    #[doc = ""]
    pub fn errfInit() -> Result;
}
extern "C" {
    #[doc = "Exits ERR:f. Unless you plan to call ERRF_Throw yourself, do not use this."]
    #[doc = ""]
    pub fn errfExit();
}
extern "C" {
    #[doc = "Gets the current err:f API session handle.\n @return The current err:f API session handle."]
    #[doc = ""]
    pub fn errfGetSessionHandle() -> *mut Handle;
}
extern "C" {
    #[must_use]
    #[doc = "Throws a system error and possibly logs it.\n @param[in] error Error to throw.\n\n ErrDisp may convert the error info to [`ERRF_ERRTYPE_NAND_DAMAGED`] or [`ERRF_ERRTYPE_CARD_REMOVED\n`] depending on the error code.\n\n Except with [`ERRF_ERRTYPE_LOG_ONLY`] the system will panic and will need to be rebooted.\n Fatal error information will also be logged into a file, unless the type either [`ERRF_ERRTYPE_NAND_DAMAGED\n`] or [`ERRF_ERRTYPE_CARD_REMOVED.\n\n`] No error will be shown if the system is asleep.\n\n On retail units with vanilla firmware, no detailed information will be displayed on screen.\n\n You may wish to use ERRF_ThrowResult() or ERRF_ThrowResultWithMessage() instead of\n constructing the ERRF_FatalErrInfo struct yourself."]
    #[doc = ""]
    pub fn ERRF_Throw(error: *const ERRF_FatalErrInfo) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Throws (and logs) a system error with the given Result code.\n @param[in] failure Result code to throw.\n\n This calls [`ERRF_Throw`] with error type [`ERRF_ERRTYPE_GENERIC`] and fills in the required data.\n\n This function \\em does fill in the address where this function was called from."]
    #[doc = ""]
    pub fn ERRF_ThrowResult(failure: Result) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Logs a system error with the given Result code.\n @param[in] failure Result code to log.\n\n Similar to [`ERRF_Throw`] except that it does not display anything on the screen,\n nor does it force the system to reboot.\n\n This function \\em does fill in the address where this function was called from."]
    #[doc = ""]
    pub fn ERRF_LogResult(failure: Result) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Throws a system error with the given Result code and message.\n @param[in] failure Result code to throw.\n @param[in] message The message to display.\n\n This calls [`ERRF_Throw`] with error type [`ERRF_ERRTYPE_FAILURE`] and fills in the required data.\n\n This function does \\em not fill in the address where this function was called from because it\n would not be displayed."]
    #[doc = ""]
    pub fn ERRF_ThrowResultWithMessage(failure: Result, message: *const ::libc::c_char) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Specify an additional user string to use for error reporting.\n @param[in] user_string User string (up to 256 bytes, not including NUL byte)"]
    #[doc = ""]
    pub fn ERRF_SetUserString(user_string: *const ::libc::c_char) -> Result;
}
extern "C" {
    #[doc = "Handles an exception using ErrDisp.\n @param excep Exception information\n @param regs CPU registers\n\n You might want to clear ENVINFO's bit0 to be able to see any debugging information.\n [`threadOnException`]"]
    #[doc = ""]
    pub fn ERRF_ExceptionHandler(excep: *mut ERRF_ExceptionInfo, regs: *mut CpuRegisters) -> !;
}
#[doc = "Kernel configuration page (read-only)."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct osKernelConfig_s {
    pub kernel_ver: u32_,
    pub update_flag: u32_,
    pub ns_tid: u64_,
    pub kernel_syscore_ver: u32_,
    pub env_info: u8_,
    pub unit_info: u8_,
    pub boot_env: u8_,
    pub unk_0x17: u8_,
    pub kernel_ctrsdk_ver: u32_,
    pub unk_0x1c: u32_,
    pub firmlaunch_flags: u32_,
    pub unk_0x24: [u8_; 12usize],
    pub app_memtype: u32_,
    pub unk_0x34: [u8_; 12usize],
    pub memregion_sz: [u32_; 3usize],
    pub unk_0x4c: [u8_; 20usize],
    pub firm_ver: u32_,
    pub firm_syscore_ver: u32_,
    pub firm_ctrsdk_ver: u32_,
}
#[doc = "Time reference information struct (filled in by PTM)."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct osTimeRef_s {
    #[doc = "Milliseconds elapsed since January 1900 when this structure was last updated"]
    #[doc = ""]
    pub value_ms: u64_,
    #[doc = "System ticks elapsed since boot when this structure was last updated"]
    #[doc = ""]
    pub value_tick: u64_,
    #[doc = "System clock frequency in Hz adjusted using RTC measurements (usually around [`SYSCLOCK_ARM11)`]"]
    #[doc = ""]
    pub sysclock_hz: s64,
    #[doc = "Measured time drift of the system clock (according to the RTC) in milliseconds since the last update"]
    #[doc = ""]
    pub drift_ms: s64,
}
#[doc = "Shared system configuration page structure (read-only or read-write depending on exheader)."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct osSharedConfig_s {
    pub timeref_cnt: vu32,
    pub running_hw: u8_,
    pub mcu_hwinfo: u8_,
    pub unk_0x06: [u8_; 26usize],
    pub timeref: [osTimeRef_s; 2usize],
    pub wifi_macaddr: [u8_; 6usize],
    pub wifi_strength: vu8,
    pub network_state: vu8,
    pub unk_0x68: [u8_; 24usize],
    pub slider_3d: f32,
    pub led_3d: vu8,
    pub led_battery: vu8,
    pub unk_flag: vu8,
    pub unk_0x87: u8_,
    pub unk_0x88: [u8_; 24usize],
    pub menu_tid: vu64,
    pub cur_menu_tid: vu64,
    pub unk_0xB0: [u8_; 16usize],
    pub headset_connected: vu8,
}
#[doc = "Tick counter."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TickCounter {
    #[doc = "Elapsed CPU ticks between measurements."]
    #[doc = ""]
    pub elapsed: u64_,
    #[doc = "Point in time used as reference."]
    #[doc = ""]
    pub reference: u64_,
}
#[doc = "OS_VersionBin. Format of the system version: \"<major>.<minor>.<build>-<nupver><region>\""]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct OS_VersionBin {
    pub build: u8_,
    pub minor: u8_,
    pub mainver: u8_,
    pub reserved_x3: u8_,
    pub region: ::libc::c_char,
    pub reserved_x5: [u8_; 3usize],
}
extern "C" {
    #[doc = "Converts an address from virtual (process) memory to physical memory.\n @param vaddr Input virtual address.\n @return The corresponding physical address.\n It is sometimes required by services or when using the GPU command buffer."]
    #[doc = ""]
    pub fn osConvertVirtToPhys(vaddr: *const ::libc::c_void) -> u32_;
}
extern "C" {
    #[doc = "Converts 0x14* vmem to 0x30*.\n @param vaddr Input virtual address.\n @return The corresponding address in the 0x30* range, the input address if it's already within the new vmem, or 0 if it's outside of both ranges."]
    #[doc = ""]
    pub fn osConvertOldLINEARMemToNew(vaddr: *const ::libc::c_void) -> *mut ::libc::c_void;
}
extern "C" {
    #[doc = "Retrieves basic information about a service error.\n @param error Error to retrieve information about.\n @return A string containing a summary of an error.\n\n This can be used to get some details about an error returned by a service call."]
    #[doc = ""]
    pub fn osStrError(error: Result) -> *const ::libc::c_char;
}
extern "C" {
    #[doc = "Reads the latest reference timepoint published by PTM.\n @return Structure (see [`osTimeRef_s)`]"]
    #[doc = ""]
    pub fn osGetTimeRef() -> osTimeRef_s;
}
extern "C" {
    #[doc = "Gets the current time.\n @return The number of milliseconds since 1st Jan 1900 00:00."]
    #[doc = ""]
    pub fn osGetTime() -> u64_;
}
extern "C" {
    #[doc = "Reads the elapsed time in a tick counter.\n @param cnt The tick counter.\n @return The number of milliseconds elapsed."]
    #[doc = ""]
    pub fn osTickCounterRead(cnt: *const TickCounter) -> f64;
}
extern "C" {
    #[doc = "Configures the New 3DS speedup.\n @param enable Specifies whether to enable or disable the speedup."]
    #[doc = ""]
    pub fn osSetSpeedupEnable(enable: bool);
}
extern "C" {
    #[must_use]
    #[doc = "Gets the NAND system-version stored in NVer/CVer.\n @param nver_versionbin Output OS_VersionBin structure for the data read from NVer.\n @param cver_versionbin Output OS_VersionBin structure for the data read from CVer.\n @return The result-code. This value can be positive if opening \"romfs:/version.bin\" fails with stdio, since errno would be returned in that case. In some cases the error can be special negative values as well."]
    #[doc = ""]
    pub fn osGetSystemVersionData(
        nver_versionbin: *mut OS_VersionBin,
        cver_versionbin: *mut OS_VersionBin,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "This is a wrapper for osGetSystemVersionData.\n @param nver_versionbin Optional output OS_VersionBin structure for the data read from NVer, can be NULL.\n @param cver_versionbin Optional output OS_VersionBin structure for the data read from CVer, can be NULL.\n @param sysverstr Output string where the printed system-version will be written, in the same format displayed by the System Settings title.\n @param sysverstr_maxsize Max size of the above string buffer, *including* NULL-terminator.\n @return See osGetSystemVersionData."]
    #[doc = ""]
    pub fn osGetSystemVersionDataString(
        nver_versionbin: *mut OS_VersionBin,
        cver_versionbin: *mut OS_VersionBin,
        sysverstr: *mut ::libc::c_char,
        sysverstr_maxsize: u32_,
    ) -> Result;
}
pub type _LOCK_T = i32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __lock_t {
    pub lock: _LOCK_T,
    pub thread_tag: u32,
    pub counter: u32,
}
pub type _LOCK_RECURSIVE_T = __lock_t;
extern "C" {
    pub fn __libc_lock_init(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __libc_lock_init_recursive(lock: *mut _LOCK_RECURSIVE_T);
}
extern "C" {
    pub fn __libc_lock_close(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __libc_lock_close_recursive(lock: *mut _LOCK_RECURSIVE_T);
}
extern "C" {
    pub fn __libc_lock_acquire(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __libc_lock_acquire_recursive(lock: *mut _LOCK_RECURSIVE_T);
}
extern "C" {
    pub fn __libc_lock_release(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __libc_lock_release_recursive(lock: *mut _LOCK_RECURSIVE_T);
}
extern "C" {
    pub fn __libc_lock_try_acquire(lock: *mut _LOCK_T) -> ::libc::c_int;
}
extern "C" {
    pub fn __libc_lock_try_acquire_recursive(lock: *mut _LOCK_RECURSIVE_T) -> ::libc::c_int;
}
#[doc = "A light lock."]
#[doc = ""]

pub type LightLock = _LOCK_T;
#[doc = "A recursive lock."]
#[doc = ""]

pub type RecursiveLock = _LOCK_RECURSIVE_T;
#[doc = "A condition variable."]
#[doc = ""]

pub type CondVar = s32;
#[doc = "A light event."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct LightEvent {
    #[doc = "State of the event: -2=cleared sticky, -1=cleared oneshot, 0=signaled oneshot, 1=signaled sticky"]
    #[doc = ""]
    pub state: s32,
    #[doc = "Lock used for sticky timer operation"]
    #[doc = ""]
    pub lock: LightLock,
}
#[doc = "A light semaphore."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct LightSemaphore {
    #[doc = "The current release count of the semaphore"]
    #[doc = ""]
    pub current_count: s32,
    #[doc = "Number of threads concurrently acquiring the semaphore"]
    #[doc = ""]
    pub num_threads_acq: s16,
    #[doc = "The maximum release count of the semaphore"]
    #[doc = ""]
    pub max_count: s16,
}
extern "C" {
    #[must_use]
    #[doc = "Function used to implement user-mode synchronization primitives.\n @param addr Pointer to a signed 32-bit value whose address will be used to identify waiting threads.\n @param type Type of action to be performed by the arbiter\n @param value Number of threads to signal if using [`ARBITRATION_SIGNAL`] or the value used for comparison.\n\n This will perform an arbitration based on #type. The comparisons are done between #value and the value at the address #addr.\n\n ``` s32 val=0;\n // Does *nothing* since val >= 0\n syncArbitrateAddress(&val,ARBITRATION_WAIT_IF_LESS_THAN,0);\n ``` @note Usage of this function entails an implicit Data Memory Barrier (dmb)."]
    #[doc = ""]
    pub fn syncArbitrateAddress(addr: *mut s32, type_: ArbitrationType, value: s32) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Function used to implement user-mode synchronization primitives (with timeout).\n @param addr Pointer to a signed 32-bit value whose address will be used to identify waiting threads.\n @param type Type of action to be performed by the arbiter (must use [`ARBITRATION_WAIT_IF_LESS_THAN_TIMEOUT`] or [`ARBITRATION_DECREMENT_AND_WAIT_IF_LESS_THAN_TIMEOUT)\n`] @param value Number of threads to signal if using [`ARBITRATION_SIGNAL`] or the value used for comparison.\n\n This will perform an arbitration based on #type. The comparisons are done between #value and the value at the address #addr.\n\n ``` s32 val=0;\n // Thread will wait for a signal or wake up after 10000000 nanoseconds because val < 1.\n syncArbitrateAddressWithTimeout(&val,ARBITRATION_WAIT_IF_LESS_THAN_TIMEOUT,1,10000000LL);\n ``` @note Usage of this function entails an implicit Data Memory Barrier (dmb)."]
    #[doc = ""]
    pub fn syncArbitrateAddressWithTimeout(
        addr: *mut s32,
        type_: ArbitrationType,
        value: s32,
        timeout_ns: s64,
    ) -> Result;
}
extern "C" {
    #[doc = "Initializes a light lock.\n @param lock Pointer to the lock."]
    #[doc = ""]
    pub fn LightLock_Init(lock: *mut LightLock);
}
extern "C" {
    #[doc = "Locks a light lock.\n @param lock Pointer to the lock."]
    #[doc = ""]
    pub fn LightLock_Lock(lock: *mut LightLock);
}
extern "C" {
    #[doc = "Attempts to lock a light lock.\n @param lock Pointer to the lock.\n @return Zero on success, non-zero on failure."]
    #[doc = ""]
    pub fn LightLock_TryLock(lock: *mut LightLock) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Unlocks a light lock.\n @param lock Pointer to the lock."]
    #[doc = ""]
    pub fn LightLock_Unlock(lock: *mut LightLock);
}
extern "C" {
    #[doc = "Initializes a recursive lock.\n @param lock Pointer to the lock."]
    #[doc = ""]
    pub fn RecursiveLock_Init(lock: *mut RecursiveLock);
}
extern "C" {
    #[doc = "Locks a recursive lock.\n @param lock Pointer to the lock."]
    #[doc = ""]
    pub fn RecursiveLock_Lock(lock: *mut RecursiveLock);
}
extern "C" {
    #[doc = "Attempts to lock a recursive lock.\n @param lock Pointer to the lock.\n @return Zero on success, non-zero on failure."]
    #[doc = ""]
    pub fn RecursiveLock_TryLock(lock: *mut RecursiveLock) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Unlocks a recursive lock.\n @param lock Pointer to the lock."]
    #[doc = ""]
    pub fn RecursiveLock_Unlock(lock: *mut RecursiveLock);
}
extern "C" {
    #[doc = "Initializes a condition variable.\n @param cv Pointer to the condition variable."]
    #[doc = ""]
    pub fn CondVar_Init(cv: *mut CondVar);
}
extern "C" {
    #[doc = "Waits on a condition variable.\n @param cv Pointer to the condition variable.\n @param lock Pointer to the lock to atomically unlock/relock during the wait."]
    #[doc = ""]
    pub fn CondVar_Wait(cv: *mut CondVar, lock: *mut LightLock);
}
extern "C" {
    #[doc = "Waits on a condition variable with a timeout.\n @param cv Pointer to the condition variable.\n @param lock Pointer to the lock to atomically unlock/relock during the wait.\n @param timeout_ns Timeout in nanoseconds.\n @return Zero on success, non-zero on failure."]
    #[doc = ""]
    pub fn CondVar_WaitTimeout(
        cv: *mut CondVar,
        lock: *mut LightLock,
        timeout_ns: s64,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Wakes up threads waiting on a condition variable.\n @param cv Pointer to the condition variable.\n @param num_threads Maximum number of threads to wake up (or [`ARBITRATION_SIGNAL_ALL`] to wake them all)."]
    #[doc = ""]
    pub fn CondVar_WakeUp(cv: *mut CondVar, num_threads: s32);
}
extern "C" {
    #[doc = "Initializes a light event.\n @param event Pointer to the event.\n @param reset_type Type of reset the event uses (RESET_ONESHOT/RESET_STICKY)."]
    #[doc = ""]
    pub fn LightEvent_Init(event: *mut LightEvent, reset_type: ResetType);
}
extern "C" {
    #[doc = "Clears a light event.\n @param event Pointer to the event."]
    #[doc = ""]
    pub fn LightEvent_Clear(event: *mut LightEvent);
}
extern "C" {
    #[doc = "Wakes up threads waiting on a sticky light event without signaling it. If the event had been signaled before, it is cleared instead.\n @param event Pointer to the event."]
    #[doc = ""]
    pub fn LightEvent_Pulse(event: *mut LightEvent);
}
extern "C" {
    #[doc = "Signals a light event, waking up threads waiting on it.\n @param event Pointer to the event."]
    #[doc = ""]
    pub fn LightEvent_Signal(event: *mut LightEvent);
}
extern "C" {
    #[doc = "Attempts to wait on a light event.\n @param event Pointer to the event.\n @return Non-zero if the event was signaled, zero otherwise."]
    #[doc = ""]
    pub fn LightEvent_TryWait(event: *mut LightEvent) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Waits on a light event.\n @param event Pointer to the event."]
    #[doc = ""]
    pub fn LightEvent_Wait(event: *mut LightEvent);
}
extern "C" {
    #[doc = "Waits on a light event until either the event is signaled or the timeout is reached.\n @param event Pointer to the event.\n @param timeout_ns Timeout in nanoseconds.\n @return Non-zero on timeout, zero otherwise."]
    #[doc = ""]
    pub fn LightEvent_WaitTimeout(event: *mut LightEvent, timeout_ns: s64) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Initializes a light semaphore.\n @param event Pointer to the semaphore.\n @param max_count Initial count of the semaphore.\n @param max_count Maximum count of the semaphore."]
    #[doc = ""]
    pub fn LightSemaphore_Init(semaphore: *mut LightSemaphore, initial_count: s16, max_count: s16);
}
extern "C" {
    #[doc = "Acquires a light semaphore.\n @param semaphore Pointer to the semaphore.\n @param count Acquire count"]
    #[doc = ""]
    pub fn LightSemaphore_Acquire(semaphore: *mut LightSemaphore, count: s32);
}
extern "C" {
    #[doc = "Attempts to acquire a light semaphore.\n @param semaphore Pointer to the semaphore.\n @param count Acquire count\n @return Zero on success, non-zero on failure"]
    #[doc = ""]
    pub fn LightSemaphore_TryAcquire(semaphore: *mut LightSemaphore, count: s32) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Releases a light semaphore.\n @param semaphore Pointer to the semaphore.\n @param count Release count"]
    #[doc = ""]
    pub fn LightSemaphore_Release(semaphore: *mut LightSemaphore, count: s32);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Thread_tag {
    _unused: [u8; 0],
}
#[doc = "libctru thread handle type"]
#[doc = ""]

pub type Thread = *mut Thread_tag;
#[doc = "Exception handler type, necessarily an ARM function that does not return."]
#[doc = ""]

pub type ExceptionHandler = ::core::option::Option<
    unsafe extern "C" fn(excep: *mut ERRF_ExceptionInfo, regs: *mut CpuRegisters),
>;
extern "C" {
    #[doc = "Creates a new libctru thread.\n @param entrypoint The function that will be called first upon thread creation\n @param arg The argument passed to @p entrypoint\n @param stack_size The size of the stack that will be allocated for the thread (will be rounded to a multiple of 8 bytes)\n @param prio Low values gives the thread higher priority.\n For userland apps, this has to be within the range [0x18;0x3F].\n The main thread usually has a priority of 0x30, but not always. Use svcGetThreadPriority() if you need\n to create a thread with a priority that is explicitly greater or smaller than that of the main thread.\n @param core_id The ID of the processor the thread should be ran on. Processor IDs are labeled starting from 0.\n On Old3DS it must be <2, and on New3DS it must be <4.\n Pass -1 to execute the thread on all CPUs and -2 to execute the thread on the default CPU (read from the Exheader).\n @param detached When set to true, the thread is automatically freed when it finishes.\n @return The libctru thread handle on success, NULL on failure.\n\n - Processor #0 is the application core. It is always possible to create a thread on this core.\n - Processor #1 is the system core. If APT_SetAppCpuTimeLimit is used, it is possible to create a single thread on this core.\n - Processor #2 is New3DS exclusive. Normal applications can create threads on this core if the exheader kernel flags bitmask has 0x2000 set.\n - Processor #3 is New3DS exclusive. Normal applications cannot create threads on this core.\n - Processes in the BASE memory region can always create threads on processors #2 and #3.\n\n @note Default exit code of a thread is 0.\n @warning [`svcExitThread`] should never be called from the thread, use [`threadExit`] instead."]
    #[doc = ""]
    pub fn threadCreate(
        entrypoint: ThreadFunc,
        arg: *mut ::libc::c_void,
        stack_size: usize,
        prio: ::libc::c_int,
        core_id: ::libc::c_int,
        detached: bool,
    ) -> Thread;
}
extern "C" {
    #[doc = "Retrieves the OS thread handle of a libctru thread.\n @param thread libctru thread handle\n @return OS thread handle"]
    #[doc = ""]
    pub fn threadGetHandle(thread: Thread) -> Handle;
}
extern "C" {
    #[doc = "Retrieves the exit code of a finished libctru thread.\n @param thread libctru thread handle\n @return Exit code"]
    #[doc = ""]
    pub fn threadGetExitCode(thread: Thread) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Frees a finished libctru thread.\n @param thread libctru thread handle\n @remarks This function should not be called if the thread is detached, as it is freed automatically when it finishes."]
    #[doc = ""]
    pub fn threadFree(thread: Thread);
}
extern "C" {
    #[must_use]
    #[doc = "Waits for a libctru thread to finish (or returns immediately if it is already finished).\n @param thread libctru thread handle\n @param timeout_ns Timeout in nanoseconds. Pass U64_MAX if a timeout isn't desired"]
    #[doc = ""]
    pub fn threadJoin(thread: Thread, timeout_ns: u64_) -> Result;
}
extern "C" {
    #[doc = "Changes a thread's status from attached to detached.\n @param thread libctru thread handle"]
    #[doc = ""]
    pub fn threadDetach(thread: Thread);
}
extern "C" {
    #[doc = "Retrieves the libctru thread handle of the current thread.\n @return libctru thread handle of the current thread, or NULL for the main thread"]
    #[doc = ""]
    pub fn threadGetCurrent() -> Thread;
}
extern "C" {
    #[doc = "Exits the current libctru thread with an exit code (not usable from the main thread).\n @param rc Exit code"]
    #[doc = ""]
    pub fn threadExit(rc: ::libc::c_int) -> !;
}
#[doc = "Framebuffer information."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GSPGPU_FramebufferInfo {
    #[doc = "Active framebuffer. (0 = first, 1 = second)"]
    #[doc = ""]
    pub active_framebuf: u32_,
    #[doc = "Framebuffer virtual address, for the main screen this is the 3D left framebuffer."]
    #[doc = ""]
    pub framebuf0_vaddr: *mut u32_,
    #[doc = "For the main screen: 3D right framebuffer address."]
    #[doc = ""]
    pub framebuf1_vaddr: *mut u32_,
    #[doc = "Value for 0x1EF00X90, controls framebuffer width."]
    #[doc = ""]
    pub framebuf_widthbytesize: u32_,
    #[doc = "Framebuffer format, this u16 is written to the low u16 for LCD register 0x1EF00X70."]
    #[doc = ""]
    pub format: u32_,
    #[doc = "Value for 0x1EF00X78, controls which framebuffer is displayed."]
    #[doc = ""]
    pub framebuf_dispselect: u32_,
    #[doc = "Unknown."]
    #[doc = ""]
    pub unk: u32_,
}
impl Default for GSPGPU_FramebufferInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "RGBA8. (4 bytes)"]
#[doc = ""]

pub const GSP_RGBA8_OES: GSPGPU_FramebufferFormat = 0;
#[doc = "BGR8. (3 bytes)"]
#[doc = ""]

pub const GSP_BGR8_OES: GSPGPU_FramebufferFormat = 1;
#[doc = "RGB565. (2 bytes)"]
#[doc = ""]

pub const GSP_RGB565_OES: GSPGPU_FramebufferFormat = 2;
#[doc = "RGB5A1. (2 bytes)"]
#[doc = ""]

pub const GSP_RGB5_A1_OES: GSPGPU_FramebufferFormat = 3;
#[doc = "RGBA4. (2 bytes)"]
#[doc = ""]

pub const GSP_RGBA4_OES: GSPGPU_FramebufferFormat = 4;
#[doc = "Framebuffer format."]
#[doc = ""]

pub type GSPGPU_FramebufferFormat = ::libc::c_uint;
#[doc = "Capture info entry."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GSPGPU_CaptureInfoEntry {
    #[doc = "Left framebuffer."]
    #[doc = ""]
    pub framebuf0_vaddr: *mut u32_,
    #[doc = "Right framebuffer."]
    #[doc = ""]
    pub framebuf1_vaddr: *mut u32_,
    #[doc = "Framebuffer format."]
    #[doc = ""]
    pub format: u32_,
    #[doc = "Framebuffer pitch."]
    #[doc = ""]
    pub framebuf_widthbytesize: u32_,
}
impl Default for GSPGPU_CaptureInfoEntry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Capture info."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GSPGPU_CaptureInfo {
    #[doc = "Capture info entries, one for each screen."]
    #[doc = ""]
    pub screencapture: [GSPGPU_CaptureInfoEntry; 2usize],
}
impl Default for GSPGPU_CaptureInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Memory fill completed."]
#[doc = ""]

pub const GSPGPU_EVENT_PSC0: GSPGPU_Event = 0;
#[doc = "TODO"]
#[doc = ""]

pub const GSPGPU_EVENT_PSC1: GSPGPU_Event = 1;
#[doc = "TODO"]
#[doc = ""]

pub const GSPGPU_EVENT_VBlank0: GSPGPU_Event = 2;
#[doc = "TODO"]
#[doc = ""]

pub const GSPGPU_EVENT_VBlank1: GSPGPU_Event = 3;
#[doc = "Display transfer finished."]
#[doc = ""]

pub const GSPGPU_EVENT_PPF: GSPGPU_Event = 4;
#[doc = "Command list processing finished."]
#[doc = ""]

pub const GSPGPU_EVENT_P3D: GSPGPU_Event = 5;
#[doc = "TODO"]
#[doc = ""]

pub const GSPGPU_EVENT_DMA: GSPGPU_Event = 6;
#[doc = "Used to know how many events there are."]
#[doc = ""]

pub const GSPGPU_EVENT_MAX: GSPGPU_Event = 7;
#[doc = "GSPGPU events."]
#[doc = ""]

pub type GSPGPU_Event = ::libc::c_uint;
extern "C" {
    #[must_use]
    #[doc = "Initializes GSPGPU."]
    #[doc = ""]
    pub fn gspInit() -> Result;
}
extern "C" {
    #[doc = "Exits GSPGPU."]
    #[doc = ""]
    pub fn gspExit();
}
extern "C" {
    #[doc = "Gets a pointer to the current gsp::Gpu session handle.\n @return A pointer to the current gsp::Gpu session handle."]
    #[doc = ""]
    pub fn gspGetSessionHandle() -> *mut Handle;
}
extern "C" {
    #[doc = "Returns true if the application currently has GPU rights."]
    #[doc = ""]
    pub fn gspHasGpuRight() -> bool;
}
extern "C" {
    #[doc = "Presents a buffer to the specified screen.\n @param screen Screen ID (see [`GSP_SCREEN_TOP`] and [`GSP_SCREEN_BOTTOM)\n`] @param swap Specifies which set of framebuffer registers to configure and activate (0 or 1)\n @param fb_a Pointer to the framebuffer (in stereo mode: left eye)\n @param fb_b Pointer to the secondary framebuffer (only used in stereo mode for the right eye, otherwise pass the same as fb_a)\n @param stride Stride in bytes between scanlines\n @param mode Mode configuration to be written to LCD register\n @return true if a buffer had already been presented to the screen but not processed yet by GSP, false otherwise.\n @note The most recently presented buffer is processed and configured during the specified screen's next VBlank event."]
    #[doc = ""]
    pub fn gspPresentBuffer(
        screen: ::libc::c_uint,
        swap: ::libc::c_uint,
        fb_a: *const ::libc::c_void,
        fb_b: *const ::libc::c_void,
        stride: u32_,
        mode: u32_,
    ) -> bool;
}
extern "C" {
    #[doc = "Returns true if a prior [`gspPresentBuffer`] command is still pending to be processed by GSP.\n @param screen Screen ID (see [`GSP_SCREEN_TOP`] and [`GSP_SCREEN_BOTTOM)`]"]
    #[doc = ""]
    pub fn gspIsPresentPending(screen: ::libc::c_uint) -> bool;
}
extern "C" {
    #[doc = "Configures a callback to run when a GSPGPU event occurs.\n @param id ID of the event.\n @param cb Callback to run.\n @param data Data to be passed to the callback.\n @param oneShot When true, the callback is only executed once. When false, the callback is executed every time the event occurs."]
    #[doc = ""]
    pub fn gspSetEventCallback(
        id: GSPGPU_Event,
        cb: ThreadFunc,
        data: *mut ::libc::c_void,
        oneShot: bool,
    );
}
extern "C" {
    #[doc = "Waits for a GSPGPU event to occur.\n @param id ID of the event.\n @param nextEvent Whether to discard the current event and wait for the next event."]
    #[doc = ""]
    pub fn gspWaitForEvent(id: GSPGPU_Event, nextEvent: bool);
}
extern "C" {
    #[doc = "Waits for any GSPGPU event to occur.\n @return The ID of the event that occurred.\n\n The function returns immediately if there are unprocessed events at the time of call."]
    #[doc = ""]
    pub fn gspWaitForAnyEvent() -> GSPGPU_Event;
}
extern "C" {
    #[must_use]
    #[doc = "Submits a GX command.\n @param gxCommand GX command to execute."]
    #[doc = ""]
    pub fn gspSubmitGxCommand(gxCommand: *const u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Acquires GPU rights.\n @param flags Flags to acquire with."]
    #[doc = ""]
    pub fn GSPGPU_AcquireRight(flags: u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Releases GPU rights."]
    #[doc = ""]
    pub fn GSPGPU_ReleaseRight() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Retrieves display capture info.\n @param captureinfo Pointer to output capture info to."]
    #[doc = ""]
    pub fn GSPGPU_ImportDisplayCaptureInfo(captureinfo: *mut GSPGPU_CaptureInfo) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Saves the VRAM sys area."]
    #[doc = ""]
    pub fn GSPGPU_SaveVramSysArea() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Resets the GPU"]
    #[doc = ""]
    pub fn GSPGPU_ResetGpuCore() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Restores the VRAM sys area."]
    #[doc = ""]
    pub fn GSPGPU_RestoreVramSysArea() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets whether to force the LCD to black.\n @param flags Whether to force the LCD to black. (0 = no, non-zero = yes)"]
    #[doc = ""]
    pub fn GSPGPU_SetLcdForceBlack(flags: u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Updates a screen's framebuffer state.\n @param screenid ID of the screen to update.\n @param framebufinfo Framebuffer information to update with."]
    #[doc = ""]
    pub fn GSPGPU_SetBufferSwap(
        screenid: u32_,
        framebufinfo: *const GSPGPU_FramebufferInfo,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Flushes memory from the data cache.\n @param adr Address to flush.\n @param size Size of the memory to flush."]
    #[doc = ""]
    pub fn GSPGPU_FlushDataCache(adr: *const ::libc::c_void, size: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Invalidates memory in the data cache.\n @param adr Address to invalidate.\n @param size Size of the memory to invalidate."]
    #[doc = ""]
    pub fn GSPGPU_InvalidateDataCache(adr: *const ::libc::c_void, size: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Writes to GPU hardware registers.\n @param regAddr Register address to write to.\n @param data Data to write.\n @param size Size of the data to write."]
    #[doc = ""]
    pub fn GSPGPU_WriteHWRegs(regAddr: u32_, data: *const u32_, size: u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Writes to GPU hardware registers with a mask.\n @param regAddr Register address to write to.\n @param data Data to write.\n @param datasize Size of the data to write.\n @param maskdata Data of the mask.\n @param masksize Size of the mask."]
    #[doc = ""]
    pub fn GSPGPU_WriteHWRegsWithMask(
        regAddr: u32_,
        data: *const u32_,
        datasize: u8_,
        maskdata: *const u32_,
        masksize: u8_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Reads from GPU hardware registers.\n @param regAddr Register address to read from.\n @param data Buffer to read data to.\n @param size Size of the buffer."]
    #[doc = ""]
    pub fn GSPGPU_ReadHWRegs(regAddr: u32_, data: *mut u32_, size: u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Registers the interrupt relay queue.\n @param eventHandle Handle of the GX command event.\n @param flags Flags to register with.\n @param outMemHandle Pointer to output the shared memory handle to.\n @param threadID Pointer to output the GSP thread ID to."]
    #[doc = ""]
    pub fn GSPGPU_RegisterInterruptRelayQueue(
        eventHandle: Handle,
        flags: u32_,
        outMemHandle: *mut Handle,
        threadID: *mut u8_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Unregisters the interrupt relay queue."]
    #[doc = ""]
    pub fn GSPGPU_UnregisterInterruptRelayQueue() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Triggers a handling of commands written to shared memory."]
    #[doc = ""]
    pub fn GSPGPU_TriggerCmdReqQueue() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets 3D_LEDSTATE to the input state value.\n @param disable False = 3D LED enable, true = 3D LED disable."]
    #[doc = ""]
    pub fn GSPGPU_SetLedForceOff(disable: bool) -> Result;
}
#[doc = "Top screen"]
#[doc = ""]

pub const GFX_TOP: gfxScreen_t = 0;
#[doc = "Bottom screen"]
#[doc = ""]

pub const GFX_BOTTOM: gfxScreen_t = 1;
#[doc = "Screen IDs."]
#[doc = ""]

pub type gfxScreen_t = ::libc::c_uint;
#[doc = "Left eye framebuffer"]
#[doc = ""]

pub const GFX_LEFT: gfx3dSide_t = 0;
#[doc = "Right eye framebuffer"]
#[doc = ""]

pub const GFX_RIGHT: gfx3dSide_t = 1;
#[doc = "Top screen framebuffer side.\n\n This is only meaningful when stereoscopic 3D is enabled on the top screen.\n In any other case, use [`GFX_LEFT`]"]
#[doc = ""]

pub type gfx3dSide_t = ::libc::c_uint;
extern "C" {
    #[doc = "Initializes the LCD framebuffers with default parameters\n This is equivalent to calling: ``` gfxInit(GSP_BGR8_OES,GSP_BGR8_OES,false); ```"]
    #[doc = ""]
    pub fn gfxInitDefault();
}
extern "C" {
    #[doc = "Initializes the LCD framebuffers.\n @param topFormat The format of the top screen framebuffers.\n @param bottomFormat The format of the bottom screen framebuffers.\n @param vramBuffers Whether to allocate the framebuffers in VRAM.\n\n This function allocates memory for the framebuffers in the specified memory region.\n Initially, stereoscopic 3D is disabled and double buffering is enabled.\n\n @note This function internally calls [`gspInit`]"]
    #[doc = ""]
    pub fn gfxInit(
        topFormat: GSPGPU_FramebufferFormat,
        bottomFormat: GSPGPU_FramebufferFormat,
        vrambuffers: bool,
    );
}
extern "C" {
    #[doc = "Deinitializes and frees the LCD framebuffers.\n @note This function internally calls [`gspExit`]"]
    #[doc = ""]
    pub fn gfxExit();
}
extern "C" {
    #[doc = "Enables or disables the 3D stereoscopic effect on the top screen.\n @param enable Pass true to enable, false to disable.\n @note Stereoscopic 3D is disabled by default."]
    #[doc = ""]
    pub fn gfxSet3D(enable: bool);
}
extern "C" {
    #[doc = "Retrieves the status of the 3D stereoscopic effect on the top screen.\n @return true if 3D enabled, false otherwise."]
    #[doc = ""]
    pub fn gfxIs3D() -> bool;
}
extern "C" {
    #[doc = "Retrieves the status of the 800px (double-height) high resolution display mode of the top screen.\n @return true if wide mode enabled, false otherwise."]
    #[doc = ""]
    pub fn gfxIsWide() -> bool;
}
extern "C" {
    #[doc = "Enables or disables the 800px (double-height) high resolution display mode of the top screen.\n @param enable Pass true to enable, false to disable.\n @note Wide mode is disabled by default.\n @note Wide and stereoscopic 3D modes are mutually exclusive.\n @note In wide mode pixels are not square, since scanlines are half as tall as they normally are.\n @warning Wide mode does not work on Old 2DS consoles (however it does work on New 2DS XL consoles)."]
    #[doc = ""]
    pub fn gfxSetWide(enable: bool);
}
extern "C" {
    #[doc = "Changes the pixel format of a screen.\n @param screen Screen ID (see [`gfxScreen_t)\n`] @param format Pixel format (see [`GSPGPU_FramebufferFormat)\n`] @note If the currently allocated framebuffers are too small for the specified format,\n they are freed and new ones are reallocated."]
    #[doc = ""]
    pub fn gfxSetScreenFormat(screen: gfxScreen_t, format: GSPGPU_FramebufferFormat);
}
extern "C" {
    #[doc = "Retrieves the current pixel format of a screen.\n @param screen Screen ID (see [`gfxScreen_t)\n`] @return Pixel format (see [`GSPGPU_FramebufferFormat)`]"]
    #[doc = ""]
    pub fn gfxGetScreenFormat(screen: gfxScreen_t) -> GSPGPU_FramebufferFormat;
}
extern "C" {
    #[doc = "Enables or disables double buffering on a screen.\n @param screen Screen ID (see [`gfxScreen_t)\n`] @param enable Pass true to enable, false to disable.\n @note Double buffering is enabled by default."]
    #[doc = ""]
    pub fn gfxSetDoubleBuffering(screen: gfxScreen_t, enable: bool);
}
extern "C" {
    #[doc = "Retrieves the framebuffer of the specified screen to which graphics should be rendered.\n @param screen Screen ID (see [`gfxScreen_t)\n`] @param side Framebuffer side (see [`gfx3dSide_t)`] (pass [`GFX_LEFT`] if not using stereoscopic 3D)\n @param width Pointer that will hold the width of the framebuffer in pixels.\n @param height Pointer that will hold the height of the framebuffer in pixels.\n @return A pointer to the current framebuffer of the chosen screen.\n\n Please remember that the returned pointer will change every frame if double buffering is enabled."]
    #[doc = ""]
    pub fn gfxGetFramebuffer(
        screen: gfxScreen_t,
        side: gfx3dSide_t,
        width: *mut u16_,
        height: *mut u16_,
    ) -> *mut u8_;
}
extern "C" {
    #[doc = "Flushes the data cache for the current framebuffers.\n @warning This is **only used during software rendering**. Since this function has significant overhead,\n it is preferred to call this only once per frame, after all software rendering is completed."]
    #[doc = ""]
    pub fn gfxFlushBuffers();
}
extern "C" {
    #[doc = "Updates the configuration of the specified screen, swapping the buffers if double buffering is enabled.\n @param scr Screen ID (see [`gfxScreen_t)\n`] @param hasStereo For the top screen in 3D mode: true if the framebuffer contains individual images\n for both eyes, or false if the left image should be duplicated to the right eye.\n @note Previously rendered content will be displayed on the screen after the next VBlank.\n @note This function is still useful even if double buffering is disabled, as it must be used to commit configuration changes.\n @warning Only call this once per screen per frame, otherwise graphical glitches will occur\n since this API does not implement triple buffering."]
    #[doc = ""]
    pub fn gfxScreenSwapBuffers(scr: gfxScreen_t, hasStereo: bool);
}
extern "C" {
    #[doc = "Same as [`gfxScreenSwapBuffers`] but with hasStereo set to true.\n @param scr Screen ID (see [`gfxScreen_t)\n`] @param immediate This parameter no longer has any effect and is thus ignored.\n @deprecated This function has been superseded by [`gfxScreenSwapBuffers`] please use that instead."]
    #[doc = ""]
    pub fn gfxConfigScreen(scr: gfxScreen_t, immediate: bool);
}
extern "C" {
    #[doc = "Updates the configuration of both screens.\n @note This function is equivalent to: ``` gfxScreenSwapBuffers(GFX_TOP,true); gfxScreenSwapBuffers(GFX_BOTTOM,true); ```"]
    #[doc = ""]
    pub fn gfxSwapBuffers();
}
extern "C" {
    #[doc = "Same as [`gfxSwapBuffers`] (formerly different)."]
    #[doc = ""]
    pub fn gfxSwapBuffersGpu();
}
#[doc = "A callback for printing a character."]
#[doc = ""]

pub type ConsolePrint = ::core::option::Option<
    unsafe extern "C" fn(con: *mut ::libc::c_void, c: ::libc::c_int) -> bool,
>;
#[doc = "A font struct for the console."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ConsoleFont {
    #[doc = "A pointer to the font graphics"]
    #[doc = ""]
    pub gfx: *mut u8_,
    #[doc = "Offset to the first valid character in the font table"]
    #[doc = ""]
    pub asciiOffset: u16_,
    #[doc = "Number of characters in the font graphics"]
    #[doc = ""]
    pub numChars: u16_,
}
impl Default for ConsoleFont {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Console structure used to store the state of a console render context.\n\n Default values from consoleGetDefault();\n ``` PrintConsole defaultConsole =\n {\n \t//Font:\n \t{\n \t\t(u8*)default_font_bin, //font gfx\n \t\t0, //first ascii character in the set\n \t\t128, //number of characters in the font set\n\t},\n\t0,0, //cursorX cursorY\n\t0,0, //prevcursorX prevcursorY\n\t40, //console width\n\t30, //console height\n\t0, //window x\n\t0, //window y\n\t32, //window width\n\t24, //window height\n\t3, //tab size\n\t0, //font character offset\n\t0, //print callback\n\tfalse //console initialized\n };\n ```"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PrintConsole {
    #[doc = "Font of the console"]
    #[doc = ""]
    pub font: ConsoleFont,
    #[doc = "Framebuffer address"]
    #[doc = ""]
    pub frameBuffer: *mut u16_,
    #[doc = "Current X location of the cursor (as a tile offset by default)"]
    #[doc = ""]
    pub cursorX: ::libc::c_int,
    #[doc = "Current Y location of the cursor (as a tile offset by default)"]
    #[doc = ""]
    pub cursorY: ::libc::c_int,
    #[doc = "Internal state"]
    #[doc = ""]
    pub prevCursorX: ::libc::c_int,
    #[doc = "Internal state"]
    #[doc = ""]
    pub prevCursorY: ::libc::c_int,
    #[doc = "Width of the console hardware layer in characters"]
    #[doc = ""]
    pub consoleWidth: ::libc::c_int,
    #[doc = "Height of the console hardware layer in characters"]
    #[doc = ""]
    pub consoleHeight: ::libc::c_int,
    #[doc = "Window X location in characters (not implemented)"]
    #[doc = ""]
    pub windowX: ::libc::c_int,
    #[doc = "Window Y location in characters (not implemented)"]
    #[doc = ""]
    pub windowY: ::libc::c_int,
    #[doc = "Window width in characters (not implemented)"]
    #[doc = ""]
    pub windowWidth: ::libc::c_int,
    #[doc = "Window height in characters (not implemented)"]
    #[doc = ""]
    pub windowHeight: ::libc::c_int,
    #[doc = "Size of a tab"]
    #[doc = ""]
    pub tabSize: ::libc::c_int,
    #[doc = "Foreground color"]
    #[doc = ""]
    pub fg: u16_,
    #[doc = "Background color"]
    #[doc = ""]
    pub bg: u16_,
    #[doc = "Reverse/bright flags"]
    #[doc = ""]
    pub flags: ::libc::c_int,
    #[doc = "Callback for printing a character. Should return true if it has handled rendering the graphics (else the print engine will attempt to render via tiles)."]
    #[doc = ""]
    pub PrintChar: ConsolePrint,
    #[doc = "True if the console is initialized"]
    #[doc = ""]
    pub consoleInitialised: bool,
}
impl Default for PrintConsole {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Swallows prints to stderr"]
#[doc = ""]

pub const debugDevice_NULL: debugDevice = 0;
#[doc = "Outputs stderr debug statements using svcOutputDebugString, which can then be captured by interactive debuggers"]
#[doc = ""]

pub const debugDevice_SVC: debugDevice = 1;
#[doc = "Directs stderr debug statements to 3DS console window"]
#[doc = ""]

pub const debugDevice_CONSOLE: debugDevice = 2;
pub const debugDevice_3DMOO: debugDevice = 1;
#[doc = "Console debug devices supported by libnds."]
#[doc = ""]

pub type debugDevice = ::libc::c_uint;
extern "C" {
    #[doc = "Loads the font into the console.\n @param console Pointer to the console to update, if NULL it will update the current console.\n @param font The font to load."]
    #[doc = ""]
    pub fn consoleSetFont(console: *mut PrintConsole, font: *mut ConsoleFont);
}
extern "C" {
    #[doc = "Sets the print window.\n @param console Console to set, if NULL it will set the current console window.\n @param x X location of the window.\n @param y Y location of the window.\n @param width Width of the window.\n @param height Height of the window."]
    #[doc = ""]
    pub fn consoleSetWindow(
        console: *mut PrintConsole,
        x: ::libc::c_int,
        y: ::libc::c_int,
        width: ::libc::c_int,
        height: ::libc::c_int,
    );
}
extern "C" {
    #[doc = "Gets a pointer to the console with the default values.\n This should only be used when using a single console or without changing the console that is returned, otherwise use consoleInit().\n @return A pointer to the console with the default values."]
    #[doc = ""]
    pub fn consoleGetDefault() -> *mut PrintConsole;
}
extern "C" {
    #[doc = "Make the specified console the render target.\n @param console A pointer to the console struct (must have been initialized with consoleInit(PrintConsole* console)).\n @return A pointer to the previous console."]
    #[doc = ""]
    pub fn consoleSelect(console: *mut PrintConsole) -> *mut PrintConsole;
}
extern "C" {
    #[doc = "Initialise the console.\n @param screen The screen to use for the console.\n @param console A pointer to the console data to initialize (if it's NULL, the default console will be used).\n @return A pointer to the current console."]
    #[doc = ""]
    pub fn consoleInit(screen: gfxScreen_t, console: *mut PrintConsole) -> *mut PrintConsole;
}
extern "C" {
    #[doc = "Initializes debug console output on stderr to the specified device.\n @param device The debug device (or devices) to output debug print statements to."]
    #[doc = ""]
    pub fn consoleDebugInit(device: debugDevice);
}
extern "C" {
    #[doc = "Clears the screen by using iprintf(\"\\x1b[2J\");"]
    #[doc = ""]
    pub fn consoleClear();
}
#[doc = "Use APT workaround."]
#[doc = ""]

pub const RUNFLAG_APTWORKAROUND: _bindgen_ty_9 = 1;
#[doc = "Reinitialize APT."]
#[doc = ""]

pub const RUNFLAG_APTREINIT: _bindgen_ty_9 = 2;
#[doc = "Chainload APT on return."]
#[doc = ""]

pub const RUNFLAG_APTCHAINLOAD: _bindgen_ty_9 = 4;
#[doc = "System run-flags."]
#[doc = ""]

pub type _bindgen_ty_9 = ::libc::c_uint;
extern "C" {
    #[doc = "Retrieves a handle from the environment handle list.\n @param name Name of the handle.\n @return The retrieved handle."]
    #[doc = ""]
    pub fn envGetHandle(name: *const ::libc::c_char) -> Handle;
}
pub type _off_t = __int64_t;
pub type _fpos_t = __int64_t;
pub type __ino_t = __uint32_t;
pub type __dev_t = __uint32_t;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = __intptr_t;
pub type wint_t = ::libc::c_int;
pub type __blkcnt_t = ::libc::c_long;
pub type __blksize_t = ::libc::c_long;
pub type __fsblkcnt_t = __uint64_t;
pub type __fsfilcnt_t = __uint32_t;
pub type __pid_t = ::libc::c_int;
pub type __uid_t = ::libc::c_ushort;
pub type __gid_t = ::libc::c_ushort;
pub type __id_t = __uint32_t;
pub type __mode_t = __uint32_t;
pub type _off64_t = ::libc::c_longlong;
pub type __off_t = _off_t;
pub type __loff_t = _off64_t;
pub type __key_t = ::libc::c_long;
pub type __size_t = ::libc::c_uint;
pub type _ssize_t = ::libc::c_int;
pub type __ssize_t = _ssize_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _mbstate_t {
    pub __count: ::libc::c_int,
    pub __value: _mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _mbstate_t__bindgen_ty_1 {
    pub __wch: wint_t,
    pub __wchb: [::libc::c_uchar; 4usize],
}
impl Default for _mbstate_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _mbstate_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type _iconv_t = *mut ::libc::c_void;
pub type __clock_t = ::libc::c_ulong;
pub type __time_t = __int_least64_t;
pub type __clockid_t = ::libc::c_ulong;
pub type __timer_t = ::libc::c_ulong;
pub type __sa_family_t = __uint8_t;
pub type __socklen_t = __uint32_t;
pub type __nl_item = ::libc::c_int;
pub type __nlink_t = ::libc::c_ushort;
pub type __suseconds_t = ::libc::c_long;
pub type __useconds_t = ::libc::c_ulong;
pub type __sigset_t = ::libc::c_ulong;
pub type suseconds_t = __suseconds_t;
pub type time_t = __int_least64_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timeval {
    pub tv_sec: time_t,
    pub tv_usec: suseconds_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: ::libc::c_long,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
pub type sigset_t = __sigset_t;
pub type __fd_mask = ::libc::c_ulong;
pub type fd_mask = __fd_mask;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 2usize],
}
extern "C" {
    pub fn select(
        __n: ::libc::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pselect(
        __n: ::libc::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __set: *const sigset_t,
    ) -> ::libc::c_int;
}
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type u_register_t = __uintptr_t;
pub type u_char = ::libc::c_uchar;
pub type u_short = ::libc::c_ushort;
pub type u_int = ::libc::c_uint;
pub type u_long = ::libc::c_ulong;
pub type ushort = ::libc::c_ushort;
pub type uint = ::libc::c_uint;
pub type ulong = ::libc::c_ulong;
pub type blkcnt_t = __blkcnt_t;
pub type blksize_t = __blksize_t;
pub type clock_t = ::libc::c_ulong;
pub type daddr_t = ::libc::c_long;
pub type caddr_t = *mut ::libc::c_char;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type id_t = __id_t;
pub type ino_t = __ino_t;
pub type off_t = __off_t;
pub type dev_t = __dev_t;
pub type uid_t = __uid_t;
pub type gid_t = __gid_t;
pub type pid_t = __pid_t;
pub type key_t = __key_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub type useconds_t = __useconds_t;
pub type sbintime_t = __int64_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: ::libc::c_int,
}
pub type pthread_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_attr_t {
    pub is_initialized: ::libc::c_int,
    pub stackaddr: *mut ::libc::c_void,
    pub stacksize: ::libc::c_int,
    pub contentionscope: ::libc::c_int,
    pub inheritsched: ::libc::c_int,
    pub schedpolicy: ::libc::c_int,
    pub schedparam: sched_param,
    pub detachstate: ::libc::c_int,
}
impl Default for pthread_attr_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type pthread_mutex_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pthread_mutexattr_t {
    pub is_initialized: ::libc::c_int,
    pub recursive: ::libc::c_int,
}
pub type pthread_cond_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pthread_condattr_t {
    pub is_initialized: ::libc::c_int,
    pub clock: clock_t,
}
pub type pthread_key_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pthread_once_t {
    pub is_initialized: ::libc::c_int,
    pub init_executed: ::libc::c_int,
}
#[doc = "Dummy compression"]
#[doc = ""]

pub const DECOMPRESS_DUMMY: decompressType = 0;
#[doc = "LZSS/LZ10 compression"]
#[doc = ""]

pub const DECOMPRESS_LZSS: decompressType = 16;
#[doc = "LZSS/LZ10 compression"]
#[doc = ""]

pub const DECOMPRESS_LZ10: decompressType = 16;
#[doc = "LZ11 compression"]
#[doc = ""]

pub const DECOMPRESS_LZ11: decompressType = 17;
#[doc = "Huffman compression with 1-bit data"]
#[doc = ""]

pub const DECOMPRESS_HUFF1: decompressType = 33;
#[doc = "Huffman compression with 2-bit data"]
#[doc = ""]

pub const DECOMPRESS_HUFF2: decompressType = 34;
#[doc = "Huffman compression with 3-bit data"]
#[doc = ""]

pub const DECOMPRESS_HUFF3: decompressType = 35;
#[doc = "Huffman compression with 4-bit data"]
#[doc = ""]

pub const DECOMPRESS_HUFF4: decompressType = 36;
#[doc = "Huffman compression with 5-bit data"]
#[doc = ""]

pub const DECOMPRESS_HUFF5: decompressType = 37;
#[doc = "Huffman compression with 6-bit data"]
#[doc = ""]

pub const DECOMPRESS_HUFF6: decompressType = 38;
#[doc = "Huffman compression with 7-bit data"]
#[doc = ""]

pub const DECOMPRESS_HUFF7: decompressType = 39;
#[doc = "Huffman compression with 8-bit data"]
#[doc = ""]

pub const DECOMPRESS_HUFF8: decompressType = 40;
#[doc = "Huffman compression with 8-bit data"]
#[doc = ""]

pub const DECOMPRESS_HUFF: decompressType = 40;
#[doc = "Run-length encoding compression"]
#[doc = ""]

pub const DECOMPRESS_RLE: decompressType = 48;
#[doc = "Compression types"]
#[doc = ""]

pub type decompressType = ::libc::c_uint;
#[doc = "I/O vector"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct decompressIOVec {
    #[doc = "I/O buffer"]
    #[doc = ""]
    pub data: *mut ::libc::c_void,
    #[doc = "Buffer size"]
    #[doc = ""]
    pub size: usize,
}
impl Default for decompressIOVec {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Data callback"]
#[doc = ""]

pub type decompressCallback = ::core::option::Option<
    unsafe extern "C" fn(
        userdata: *mut ::libc::c_void,
        buffer: *mut ::libc::c_void,
        size: usize,
    ) -> isize,
>;
extern "C" {
    #[doc = "Decompression callback for file descriptors\n @param[in] userdata Address of file descriptor\n @param[in] buffer Buffer to write into\n @param[in] size Size to read from file descriptor\n @returns Number of bytes read"]
    #[doc = ""]
    pub fn decompressCallback_FD(
        userdata: *mut ::libc::c_void,
        buffer: *mut ::libc::c_void,
        size: usize,
    ) -> isize;
}
extern "C" {
    #[doc = "Decompression callback for stdio FILE*\n @param[in] userdata FILE*\n @param[in] buffer Buffer to write into\n @param[in] size Size to read from file descriptor\n @returns Number of bytes read"]
    #[doc = ""]
    pub fn decompressCallback_Stdio(
        userdata: *mut ::libc::c_void,
        buffer: *mut ::libc::c_void,
        size: usize,
    ) -> isize;
}
extern "C" {
    #[doc = "Decode decompression header\n @param[out] type Decompression type\n @param[out] size Decompressed size\n @param[in] callback Data callback (see decompressV())\n @param[in] userdata User data passed to callback (see decompressV())\n @param[in] insize Size of userdata (see decompressV())\n @returns Bytes consumed\n @retval -1 error"]
    #[doc = ""]
    pub fn decompressHeader(
        type_: *mut decompressType,
        size: *mut usize,
        callback: decompressCallback,
        userdata: *mut ::libc::c_void,
        insize: usize,
    ) -> isize;
}
extern "C" {
    #[doc = "Decompress data\n @param[in] iov Output vector\n @param[in] iovcnt Number of buffers\n @param[in] callback Data callback (see note)\n @param[in] userdata User data passed to callback (see note)\n @param[in] insize Size of userdata (see note)\n @returns Whether succeeded\n\n @note If callback is null, userdata is a pointer to memory to read from,\n and insize is the size of that data. If callback is not null,\n userdata is passed to callback to fetch more data, and insize is\n unused."]
    #[doc = ""]
    pub fn decompressV(
        iov: *const decompressIOVec,
        iovcnt: usize,
        callback: decompressCallback,
        userdata: *mut ::libc::c_void,
        insize: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "Decompress LZSS/LZ10\n @param[in] iov Output vector\n @param[in] iovcnt Number of buffers\n @param[in] callback Data callback (see decompressV())\n @param[in] userdata User data passed to callback (see decompressV())\n @param[in] insize Size of userdata (see decompressV())\n @returns Whether succeeded"]
    #[doc = ""]
    pub fn decompressV_LZSS(
        iov: *const decompressIOVec,
        iovcnt: usize,
        callback: decompressCallback,
        userdata: *mut ::libc::c_void,
        insize: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "Decompress LZ11\n @param[in] iov Output vector\n @param[in] iovcnt Number of buffers\n @param[in] callback Data callback (see decompressV())\n @param[in] userdata User data passed to callback (see decompressV())\n @param[in] insize Size of userdata (see decompressV())\n @returns Whether succeeded"]
    #[doc = ""]
    pub fn decompressV_LZ11(
        iov: *const decompressIOVec,
        iovcnt: usize,
        callback: decompressCallback,
        userdata: *mut ::libc::c_void,
        insize: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "Decompress Huffman\n @param[in] bits Data size in bits (usually 4 or 8)\n @param[in] iov Output vector\n @param[in] iovcnt Number of buffers\n @param[in] callback Data callback (see decompressV())\n @param[in] userdata User data passed to callback (see decompressV())\n @param[in] insize Size of userdata (see decompressV())\n @returns Whether succeeded"]
    #[doc = ""]
    pub fn decompressV_Huff(
        bits: usize,
        iov: *const decompressIOVec,
        iovcnt: usize,
        callback: decompressCallback,
        userdata: *mut ::libc::c_void,
        insize: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "Decompress run-length encoding\n @param[in] iov Output vector\n @param[in] iovcnt Number of buffers\n @param[in] callback Data callback (see decompressV())\n @param[in] userdata User data passed to callback (see decompressV())\n @param[in] insize Size of userdata (see decompressV())\n @returns Whether succeeded"]
    #[doc = ""]
    pub fn decompressV_RLE(
        iov: *const decompressIOVec,
        iovcnt: usize,
        callback: decompressCallback,
        userdata: *mut ::libc::c_void,
        insize: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "Convert a UTF-8 sequence into a UTF-32 codepoint\n\n @param[out] out Output codepoint\n @param[in] in Input sequence\n\n @returns number of input code units consumed\n @returns -1 for error"]
    #[doc = ""]
    pub fn decode_utf8(out: *mut u32, in_: *const u8) -> isize;
}
extern "C" {
    #[doc = "Convert a UTF-16 sequence into a UTF-32 codepoint\n\n @param[out] out Output codepoint\n @param[in] in Input sequence\n\n @returns number of input code units consumed\n @returns -1 for error"]
    #[doc = ""]
    pub fn decode_utf16(out: *mut u32, in_: *const u16) -> isize;
}
extern "C" {
    #[doc = "Convert a UTF-32 codepoint into a UTF-8 sequence\n\n @param[out] out Output sequence\n @param[in] in Input codepoint\n\n @returns number of output code units produced\n @returns -1 for error\n\n @note \\a out must be able to store 4 code units"]
    #[doc = ""]
    pub fn encode_utf8(out: *mut u8, in_: u32) -> isize;
}
extern "C" {
    #[doc = "Convert a UTF-32 codepoint into a UTF-16 sequence\n\n @param[out] out Output sequence\n @param[in] in Input codepoint\n\n @returns number of output code units produced\n @returns -1 for error\n\n @note \\a out must be able to store 2 code units"]
    #[doc = ""]
    pub fn encode_utf16(out: *mut u16, in_: u32) -> isize;
}
extern "C" {
    #[doc = "Convert a UTF-8 sequence into a UTF-16 sequence\n\n Fills the output buffer up to \\a len code units.\n Returns the number of code units that the input would produce;\n if it returns greater than \\a len, the output has been\n truncated.\n\n @param[out] out Output sequence\n @param[in] in Input sequence (null-terminated)\n @param[in] len Output length\n\n @returns number of output code units produced\n @returns -1 for error\n\n @note \\a out is not null-terminated"]
    #[doc = ""]
    pub fn utf8_to_utf16(out: *mut u16, in_: *const u8, len: usize) -> isize;
}
extern "C" {
    #[doc = "Convert a UTF-8 sequence into a UTF-32 sequence\n\n Fills the output buffer up to \\a len code units.\n Returns the number of code units that the input would produce;\n if it returns greater than \\a len, the output has been\n truncated.\n\n @param[out] out Output sequence\n @param[in] in Input sequence (null-terminated)\n @param[in] len Output length\n\n @returns number of output code units produced\n @returns -1 for error\n\n @note \\a out is not null-terminated"]
    #[doc = ""]
    pub fn utf8_to_utf32(out: *mut u32, in_: *const u8, len: usize) -> isize;
}
extern "C" {
    #[doc = "Convert a UTF-16 sequence into a UTF-8 sequence\n\n Fills the output buffer up to \\a len code units.\n Returns the number of code units that the input would produce;\n if it returns greater than \\a len, the output has been\n truncated.\n\n @param[out] out Output sequence\n @param[in] in Input sequence (null-terminated)\n @param[in] len Output length\n\n @returns number of output code units produced\n @returns -1 for error\n\n @note \\a out is not null-terminated"]
    #[doc = ""]
    pub fn utf16_to_utf8(out: *mut u8, in_: *const u16, len: usize) -> isize;
}
extern "C" {
    #[doc = "Convert a UTF-16 sequence into a UTF-32 sequence\n\n Fills the output buffer up to \\a len code units.\n Returns the number of code units that the input would produce;\n if it returns greater than \\a len, the output has been\n truncated.\n\n @param[out] out Output sequence\n @param[in] in Input sequence (null-terminated)\n @param[in] len Output length\n\n @returns number of output code units produced\n @returns -1 for error\n\n @note \\a out is not null-terminated"]
    #[doc = ""]
    pub fn utf16_to_utf32(out: *mut u32, in_: *const u16, len: usize) -> isize;
}
extern "C" {
    #[doc = "Convert a UTF-32 sequence into a UTF-8 sequence\n\n Fills the output buffer up to \\a len code units.\n Returns the number of code units that the input would produce;\n if it returns greater than \\a len, the output has been\n truncated.\n\n @param[out] out Output sequence\n @param[in] in Input sequence (null-terminated)\n @param[in] len Output length\n\n @returns number of output code units produced\n @returns -1 for error\n\n @note \\a out is not null-terminated"]
    #[doc = ""]
    pub fn utf32_to_utf8(out: *mut u8, in_: *const u32, len: usize) -> isize;
}
extern "C" {
    #[doc = "Convert a UTF-32 sequence into a UTF-16 sequence\n\n @param[out] out Output sequence\n @param[in] in Input sequence (null-terminated)\n @param[in] len Output length\n\n @returns number of output code units produced\n @returns -1 for error\n\n @note \\a out is not null-terminated"]
    #[doc = ""]
    pub fn utf32_to_utf16(out: *mut u16, in_: *const u32, len: usize) -> isize;
}
extern "C" {
    #[doc = "Allocates a 0x80-byte aligned buffer.\n @param size Size of the buffer to allocate.\n @return The allocated buffer."]
    #[doc = ""]
    pub fn linearAlloc(size: usize) -> *mut ::libc::c_void;
}
extern "C" {
    #[doc = "Allocates a buffer aligned to the given size.\n @param size Size of the buffer to allocate.\n @param alignment Alignment to use.\n @return The allocated buffer."]
    #[doc = ""]
    pub fn linearMemAlign(size: usize, alignment: usize) -> *mut ::libc::c_void;
}
extern "C" {
    #[doc = "Reallocates a buffer.\n Note: Not implemented yet.\n @param mem Buffer to reallocate.\n @param size Size of the buffer to allocate.\n @return The reallocated buffer."]
    #[doc = ""]
    pub fn linearRealloc(mem: *mut ::libc::c_void, size: usize) -> *mut ::libc::c_void;
}
extern "C" {
    #[doc = "Retrieves the allocated size of a buffer.\n @return The size of the buffer."]
    #[doc = ""]
    pub fn linearGetSize(mem: *mut ::libc::c_void) -> usize;
}
extern "C" {
    #[doc = "Frees a buffer.\n @param mem Buffer to free."]
    #[doc = ""]
    pub fn linearFree(mem: *mut ::libc::c_void);
}
extern "C" {
    #[doc = "Gets the current linear free space.\n @return The current linear free space."]
    #[doc = ""]
    pub fn linearSpaceFree() -> u32_;
}
extern "C" {
    #[doc = "Initializes the mappable allocator.\n @param addrMin Minimum address.\n @param addrMax Maxium address."]
    #[doc = ""]
    pub fn mappableInit(addrMin: u32_, addrMax: u32_);
}
extern "C" {
    #[doc = "Finds a mappable memory area.\n @param size Size of the area to find.\n @return The mappable area."]
    #[doc = ""]
    pub fn mappableAlloc(size: usize) -> *mut ::libc::c_void;
}
extern "C" {
    #[doc = "Frees a mappable area (stubbed).\n @param mem Mappable area to free."]
    #[doc = ""]
    pub fn mappableFree(mem: *mut ::libc::c_void);
}
pub const VRAM_ALLOC_A: vramAllocPos = 1;
pub const VRAM_ALLOC_B: vramAllocPos = 2;
pub const VRAM_ALLOC_ANY: vramAllocPos = 3;
pub type vramAllocPos = ::libc::c_uint;
extern "C" {
    #[doc = "Allocates a 0x80-byte aligned buffer.\n @param size Size of the buffer to allocate.\n @return The allocated buffer."]
    #[doc = ""]
    pub fn vramAlloc(size: usize) -> *mut ::libc::c_void;
}
extern "C" {
    #[doc = "Allocates a 0x80-byte aligned buffer in the given VRAM bank.\n @param size Size of the buffer to allocate.\n @param pos VRAM bank to use (see [`vramAllocPos).\n`] @return The allocated buffer."]
    #[doc = ""]
    pub fn vramAllocAt(size: usize, pos: vramAllocPos) -> *mut ::libc::c_void;
}
extern "C" {
    #[doc = "Allocates a buffer aligned to the given size.\n @param size Size of the buffer to allocate.\n @param alignment Alignment to use.\n @return The allocated buffer."]
    #[doc = ""]
    pub fn vramMemAlign(size: usize, alignment: usize) -> *mut ::libc::c_void;
}
extern "C" {
    #[doc = "Allocates a buffer aligned to the given size in the given VRAM bank.\n @param size Size of the buffer to allocate.\n @param alignment Alignment to use.\n @param pos VRAM bank to use (see [`vramAllocPos).\n`] @return The allocated buffer."]
    #[doc = ""]
    pub fn vramMemAlignAt(size: usize, alignment: usize, pos: vramAllocPos) -> *mut ::libc::c_void;
}
extern "C" {
    #[doc = "Reallocates a buffer.\n Note: Not implemented yet.\n @param mem Buffer to reallocate.\n @param size Size of the buffer to allocate.\n @return The reallocated buffer."]
    #[doc = ""]
    pub fn vramRealloc(mem: *mut ::libc::c_void, size: usize) -> *mut ::libc::c_void;
}
extern "C" {
    #[doc = "Retrieves the allocated size of a buffer.\n @return The size of the buffer."]
    #[doc = ""]
    pub fn vramGetSize(mem: *mut ::libc::c_void) -> usize;
}
extern "C" {
    #[doc = "Frees a buffer.\n @param mem Buffer to free."]
    #[doc = ""]
    pub fn vramFree(mem: *mut ::libc::c_void);
}
extern "C" {
    #[doc = "Gets the current VRAM free space.\n @return The current VRAM free space."]
    #[doc = ""]
    pub fn vramSpaceFree() -> u32_;
}
#[doc = "Open authentication."]
#[doc = ""]

pub const AC_OPEN: acSecurityMode = 0;
#[doc = "WEP 40-bit authentication."]
#[doc = ""]

pub const AC_WEP_40BIT: acSecurityMode = 1;
#[doc = "WEP 104-bit authentication."]
#[doc = ""]

pub const AC_WEP_104BIT: acSecurityMode = 2;
#[doc = "WEP 128-bit authentication."]
#[doc = ""]

pub const AC_WEP_128BIT: acSecurityMode = 3;
#[doc = "WPA TKIP authentication."]
#[doc = ""]

pub const AC_WPA_TKIP: acSecurityMode = 4;
#[doc = "WPA2 TKIP authentication."]
#[doc = ""]

pub const AC_WPA2_TKIP: acSecurityMode = 5;
#[doc = "WPA AES authentication."]
#[doc = ""]

pub const AC_WPA_AES: acSecurityMode = 6;
#[doc = "WPA2 AES authentication."]
#[doc = ""]

pub const AC_WPA2_AES: acSecurityMode = 7;
#[doc = "Wifi security modes."]
#[doc = ""]

pub type acSecurityMode = ::libc::c_uint;
#[doc = "Struct to contain the data for connecting to a Wifi network from a stored slot."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct acuConfig {
    pub reserved: [u8_; 512usize],
}
impl Default for acuConfig {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[must_use]
    #[doc = "Initializes AC."]
    #[doc = ""]
    pub fn acInit() -> Result;
}
extern "C" {
    #[doc = "Exits AC."]
    #[doc = ""]
    pub fn acExit();
}
extern "C" {
    #[must_use]
    #[doc = "Waits for the system to connect to the internet."]
    #[doc = ""]
    pub fn acWaitInternetConnection() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the connected Wifi status.\n @param out Pointer to output the connected Wifi status to. (0 = not connected, 1 = O3DS Internet, 2 = N3DS Internet)"]
    #[doc = ""]
    pub fn ACU_GetWifiStatus(out: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the connected Wifi status.\n @param out Pointer to output the connected Wifi status to. (1 = not connected, 3 = connected)"]
    #[doc = ""]
    pub fn ACU_GetStatus(out: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the connected Wifi security mode.\n @param mode Pointer to output the connected Wifi security mode to. (0 = Open Authentication, 1 = WEP 40-bit, 2 = WEP 104-bit, 3 = WEP 128-bit, 4 = WPA TKIP, 5 = WPA2 TKIP, 6 = WPA AES, 7 = WPA2 AES)"]
    #[doc = ""]
    pub fn ACU_GetSecurityMode(mode: *mut acSecurityMode) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the connected Wifi SSID.\n @param SSID Pointer to output the connected Wifi SSID to."]
    #[doc = ""]
    pub fn ACU_GetSSID(SSID: *mut ::libc::c_char) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the connected Wifi SSID length.\n @param out Pointer to output the connected Wifi SSID length to."]
    #[doc = ""]
    pub fn ACU_GetSSIDLength(out: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Determines whether proxy is enabled for the connected network.\n @param enable Pointer to output the proxy status to."]
    #[doc = ""]
    pub fn ACU_GetProxyEnable(enable: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the connected network's proxy port.\n @param out Pointer to output the proxy port to."]
    #[doc = ""]
    pub fn ACU_GetProxyPort(out: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the connected network's proxy username.\n @param username Pointer to output the proxy username to. (The size must be at least 0x20-bytes)"]
    #[doc = ""]
    pub fn ACU_GetProxyUserName(username: *mut ::libc::c_char) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the connected network's proxy password.\n @param password Pointer to output the proxy password to. (The size must be at least 0x20-bytes)"]
    #[doc = ""]
    pub fn ACU_GetProxyPassword(password: *mut ::libc::c_char) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the last error to occur during a connection.\n @param errorCode Pointer to output the error code to."]
    #[doc = ""]
    pub fn ACU_GetLastErrorCode(errorCode: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the last detailed error to occur during a connection.\n @param errorCode Pointer to output the error code to."]
    #[doc = ""]
    pub fn ACU_GetLastDetailErrorCode(errorCode: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Prepares a buffer to hold the configuration data to start a connection.\n @param config Pointer to an acuConfig struct to contain the data."]
    #[doc = ""]
    pub fn ACU_CreateDefaultConfig(config: *mut acuConfig) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets something that makes the connection reliable.\n @param config Pointer to an acuConfig struct used with ACU_CreateDefaultConfig previously.\n @param area Always 2 ?"]
    #[doc = ""]
    pub fn ACU_SetNetworkArea(config: *mut acuConfig, area: u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the slot to use when connecting.\n @param config Pointer to an acuConfig struct used with ACU_CreateDefaultConfig previously.\n @param type Allowed slots flag. BIT(0) for slot 1, BIT(1) for slot 2, BIT(2) for slot 3."]
    #[doc = ""]
    pub fn ACU_SetAllowApType(config: *mut acuConfig, type_: u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets something that makes the connection reliable.\n @param config Pointer to an acuConfig struct used with ACU_CreateDefaultConfig previously."]
    #[doc = ""]
    pub fn ACU_SetRequestEulaVersion(config: *mut acuConfig) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Starts the connection procedure.\n @param config Pointer to an acuConfig struct used with ACU_CreateDefaultConfig previously.\n @param connectionHandle Handle created with svcCreateEvent to wait on until the connection succeeds or fails."]
    #[doc = ""]
    pub fn ACU_ConnectAsync(config: *const acuConfig, connectionHandle: Handle) -> Result;
}
#[doc = "Open for reading."]
#[doc = ""]

pub const FS_OPEN_READ: _bindgen_ty_10 = 1;
#[doc = "Open for writing."]
#[doc = ""]

pub const FS_OPEN_WRITE: _bindgen_ty_10 = 2;
#[doc = "Create file."]
#[doc = ""]

pub const FS_OPEN_CREATE: _bindgen_ty_10 = 4;
#[doc = "Open flags."]
#[doc = ""]

pub type _bindgen_ty_10 = ::libc::c_uint;
#[doc = "Flush."]
#[doc = ""]

pub const FS_WRITE_FLUSH: _bindgen_ty_11 = 1;
#[doc = "Update file timestamp."]
#[doc = ""]

pub const FS_WRITE_UPDATE_TIME: _bindgen_ty_11 = 256;
#[doc = "Write flags."]
#[doc = ""]

pub type _bindgen_ty_11 = ::libc::c_uint;
#[doc = "Directory."]
#[doc = ""]

pub const FS_ATTRIBUTE_DIRECTORY: _bindgen_ty_12 = 1;
#[doc = "Hidden."]
#[doc = ""]

pub const FS_ATTRIBUTE_HIDDEN: _bindgen_ty_12 = 256;
#[doc = "Archive."]
#[doc = ""]

pub const FS_ATTRIBUTE_ARCHIVE: _bindgen_ty_12 = 65536;
#[doc = "Read-only."]
#[doc = ""]

pub const FS_ATTRIBUTE_READ_ONLY: _bindgen_ty_12 = 16777216;
#[doc = "Attribute flags."]
#[doc = ""]

pub type _bindgen_ty_12 = ::libc::c_uint;
#[doc = "NAND."]
#[doc = ""]

pub const MEDIATYPE_NAND: FS_MediaType = 0;
#[doc = "SD card."]
#[doc = ""]

pub const MEDIATYPE_SD: FS_MediaType = 1;
#[doc = "Game card."]
#[doc = ""]

pub const MEDIATYPE_GAME_CARD: FS_MediaType = 2;
#[doc = "Media types."]
#[doc = ""]

pub type FS_MediaType = ::libc::c_uint;
#[doc = "CTR NAND."]
#[doc = ""]

pub const SYSTEM_MEDIATYPE_CTR_NAND: FS_SystemMediaType = 0;
#[doc = "TWL NAND."]
#[doc = ""]

pub const SYSTEM_MEDIATYPE_TWL_NAND: FS_SystemMediaType = 1;
#[doc = "SD card."]
#[doc = ""]

pub const SYSTEM_MEDIATYPE_SD: FS_SystemMediaType = 2;
#[doc = "TWL Photo."]
#[doc = ""]

pub const SYSTEM_MEDIATYPE_TWL_PHOTO: FS_SystemMediaType = 3;
#[doc = "System media types."]
#[doc = ""]

pub type FS_SystemMediaType = ::libc::c_uint;
#[doc = "RomFS archive."]
#[doc = ""]

pub const ARCHIVE_ROMFS: FS_ArchiveID = 3;
#[doc = "Save data archive."]
#[doc = ""]

pub const ARCHIVE_SAVEDATA: FS_ArchiveID = 4;
#[doc = "Ext data archive."]
#[doc = ""]

pub const ARCHIVE_EXTDATA: FS_ArchiveID = 6;
#[doc = "Shared ext data archive."]
#[doc = ""]

pub const ARCHIVE_SHARED_EXTDATA: FS_ArchiveID = 7;
#[doc = "System save data archive."]
#[doc = ""]

pub const ARCHIVE_SYSTEM_SAVEDATA: FS_ArchiveID = 8;
#[doc = "SDMC archive."]
#[doc = ""]

pub const ARCHIVE_SDMC: FS_ArchiveID = 9;
#[doc = "Write-only SDMC archive."]
#[doc = ""]

pub const ARCHIVE_SDMC_WRITE_ONLY: FS_ArchiveID = 10;
#[doc = "BOSS ext data archive."]
#[doc = ""]

pub const ARCHIVE_BOSS_EXTDATA: FS_ArchiveID = 305419896;
#[doc = "Card SPI FS archive."]
#[doc = ""]

pub const ARCHIVE_CARD_SPIFS: FS_ArchiveID = 305419897;
#[doc = "Ext data and BOSS ext data archive."]
#[doc = ""]

pub const ARCHIVE_EXTDATA_AND_BOSS_EXTDATA: FS_ArchiveID = 305419899;
#[doc = "System save data archive."]
#[doc = ""]

pub const ARCHIVE_SYSTEM_SAVEDATA2: FS_ArchiveID = 305419900;
#[doc = "Read-write NAND archive."]
#[doc = ""]

pub const ARCHIVE_NAND_RW: FS_ArchiveID = 305419901;
#[doc = "Read-only NAND archive."]
#[doc = ""]

pub const ARCHIVE_NAND_RO: FS_ArchiveID = 305419902;
#[doc = "Read-only write access NAND archive."]
#[doc = ""]

pub const ARCHIVE_NAND_RO_WRITE_ACCESS: FS_ArchiveID = 305419903;
#[doc = "User save data and ExeFS/RomFS archive."]
#[doc = ""]

pub const ARCHIVE_SAVEDATA_AND_CONTENT: FS_ArchiveID = 591751050;
#[doc = "User save data and ExeFS/RomFS archive (only ExeFS for fs:LDR)."]
#[doc = ""]

pub const ARCHIVE_SAVEDATA_AND_CONTENT2: FS_ArchiveID = 591751054;
#[doc = "NAND CTR FS archive."]
#[doc = ""]

pub const ARCHIVE_NAND_CTR_FS: FS_ArchiveID = 1450741931;
#[doc = "TWL PHOTO archive."]
#[doc = ""]

pub const ARCHIVE_TWL_PHOTO: FS_ArchiveID = 1450741932;
#[doc = "TWL SOUND archive."]
#[doc = ""]

pub const ARCHIVE_TWL_SOUND: FS_ArchiveID = 1450741933;
#[doc = "NAND TWL FS archive."]
#[doc = ""]

pub const ARCHIVE_NAND_TWL_FS: FS_ArchiveID = 1450741934;
#[doc = "NAND W FS archive."]
#[doc = ""]

pub const ARCHIVE_NAND_W_FS: FS_ArchiveID = 1450741935;
#[doc = "Game card save data archive."]
#[doc = ""]

pub const ARCHIVE_GAMECARD_SAVEDATA: FS_ArchiveID = 1450741937;
#[doc = "User save data archive."]
#[doc = ""]

pub const ARCHIVE_USER_SAVEDATA: FS_ArchiveID = 1450741938;
#[doc = "Demo save data archive."]
#[doc = ""]

pub const ARCHIVE_DEMO_SAVEDATA: FS_ArchiveID = 1450741940;
#[doc = "Archive IDs."]
#[doc = ""]

pub type FS_ArchiveID = ::libc::c_uint;
#[doc = "Invalid path."]
#[doc = ""]

pub const PATH_INVALID: FS_PathType = 0;
#[doc = "Empty path."]
#[doc = ""]

pub const PATH_EMPTY: FS_PathType = 1;
#[doc = "Binary path. Meaning is per-archive."]
#[doc = ""]

pub const PATH_BINARY: FS_PathType = 2;
#[doc = "ASCII text path."]
#[doc = ""]

pub const PATH_ASCII: FS_PathType = 3;
#[doc = "UTF-16 text path."]
#[doc = ""]

pub const PATH_UTF16: FS_PathType = 4;
#[doc = "Path types."]
#[doc = ""]

pub type FS_PathType = ::libc::c_uint;
#[doc = "SD application."]
#[doc = ""]

pub const SECUREVALUE_SLOT_SD: FS_SecureValueSlot = 4096;
#[doc = "Secure value slot."]
#[doc = ""]

pub type FS_SecureValueSlot = ::libc::c_uint;
#[doc = "512KHz."]
#[doc = ""]

pub const BAUDRATE_512KHZ: FS_CardSpiBaudRate = 0;
#[doc = "1MHz."]
#[doc = ""]

pub const BAUDRATE_1MHZ: FS_CardSpiBaudRate = 1;
#[doc = "2MHz."]
#[doc = ""]

pub const BAUDRATE_2MHZ: FS_CardSpiBaudRate = 2;
#[doc = "4MHz."]
#[doc = ""]

pub const BAUDRATE_4MHZ: FS_CardSpiBaudRate = 3;
#[doc = "8MHz."]
#[doc = ""]

pub const BAUDRATE_8MHZ: FS_CardSpiBaudRate = 4;
#[doc = "16MHz."]
#[doc = ""]

pub const BAUDRATE_16MHZ: FS_CardSpiBaudRate = 5;
#[doc = "Card SPI baud rate."]
#[doc = ""]

pub type FS_CardSpiBaudRate = ::libc::c_uint;
#[doc = "1-bit."]
#[doc = ""]

pub const BUSMODE_1BIT: FS_CardSpiBusMode = 0;
#[doc = "4-bit."]
#[doc = ""]

pub const BUSMODE_4BIT: FS_CardSpiBusMode = 1;
#[doc = "Card SPI bus mode."]
#[doc = ""]

pub type FS_CardSpiBusMode = ::libc::c_uint;
#[doc = "Update."]
#[doc = ""]

pub const SPECIALCONTENT_UPDATE: FS_SpecialContentType = 1;
#[doc = "Manual."]
#[doc = ""]

pub const SPECIALCONTENT_MANUAL: FS_SpecialContentType = 2;
#[doc = "DLP child."]
#[doc = ""]

pub const SPECIALCONTENT_DLP_CHILD: FS_SpecialContentType = 3;
#[doc = "Card SPI bus mode."]
#[doc = ""]

pub type FS_SpecialContentType = ::libc::c_uint;
#[doc = "CTR card."]
#[doc = ""]

pub const CARD_CTR: FS_CardType = 0;
#[doc = "TWL card."]
#[doc = ""]

pub const CARD_TWL: FS_CardType = 1;
pub type FS_CardType = ::libc::c_uint;
pub const FS_ACTION_UNKNOWN: FS_Action = 0;
#[doc = "FS control actions."]
#[doc = ""]

pub type FS_Action = ::libc::c_uint;
#[doc = "Commits save data changes. No inputs/outputs."]
#[doc = ""]

pub const ARCHIVE_ACTION_COMMIT_SAVE_DATA: FS_ArchiveAction = 0;
#[doc = "Retrieves a file's last-modified timestamp. In: \"u16*, UTF-16 Path\", Out: \"u64, Time Stamp\"."]
#[doc = ""]

pub const ARCHIVE_ACTION_GET_TIMESTAMP: FS_ArchiveAction = 1;
pub const ARCHIVE_ACTION_UNKNOWN: FS_ArchiveAction = 30877;
#[doc = "Archive control actions."]
#[doc = ""]

pub type FS_ArchiveAction = ::libc::c_uint;
#[doc = "Deletes a save's secure value. In: \"u64, ((SecureValueSlot <32) | (TitleUniqueId <8) | TitleVariation)\", Out: \"u8, Value Existed\""]
#[doc = ""]

pub const SECURESAVE_ACTION_DELETE: FS_SecureSaveAction = 0;
#[doc = "Formats a save. No inputs/outputs."]
#[doc = ""]

pub const SECURESAVE_ACTION_FORMAT: FS_SecureSaveAction = 1;
#[doc = "Secure save control actions."]
#[doc = ""]

pub type FS_SecureSaveAction = ::libc::c_uint;
pub const FILE_ACTION_UNKNOWN: FS_FileAction = 0;
#[doc = "File control actions."]
#[doc = ""]

pub type FS_FileAction = ::libc::c_uint;
pub const DIRECTORY_ACTION_UNKNOWN: FS_DirectoryAction = 0;
#[doc = "Directory control actions."]
#[doc = ""]

pub type FS_DirectoryAction = ::libc::c_uint;
#[doc = "Directory entry."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FS_DirectoryEntry {
    #[doc = "UTF-16 directory name."]
    #[doc = ""]
    pub name: [u16_; 262usize],
    #[doc = "File name."]
    #[doc = ""]
    pub shortName: [::libc::c_char; 10usize],
    #[doc = "File extension."]
    #[doc = ""]
    pub shortExt: [::libc::c_char; 4usize],
    #[doc = "Valid flag. (Always 1)"]
    #[doc = ""]
    pub valid: u8_,
    #[doc = "Reserved."]
    #[doc = ""]
    pub reserved: u8_,
    #[doc = "Attributes."]
    #[doc = ""]
    pub attributes: u32_,
    #[doc = "File size."]
    #[doc = ""]
    pub fileSize: u64_,
}
impl Default for FS_DirectoryEntry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Archive resource information."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FS_ArchiveResource {
    #[doc = "Size of each sector, in bytes."]
    #[doc = ""]
    pub sectorSize: u32_,
    #[doc = "Size of each cluster, in bytes."]
    #[doc = ""]
    pub clusterSize: u32_,
    #[doc = "Total number of clusters."]
    #[doc = ""]
    pub totalClusters: u32_,
    #[doc = "Number of free clusters."]
    #[doc = ""]
    pub freeClusters: u32_,
}
#[doc = "Program information."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FS_ProgramInfo {
    #[doc = "Program ID."]
    #[doc = ""]
    pub programId: u64_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "Padding."]
    #[doc = ""]
    pub padding: [u8_; 7usize],
}
impl Default for FS_ProgramInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl FS_ProgramInfo {
    #[inline]
    pub fn mediaType(&self) -> FS_MediaType {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_mediaType(&mut self, val: FS_MediaType) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(mediaType: FS_MediaType) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let mediaType: u32 = unsafe { ::core::mem::transmute(mediaType) };
            mediaType as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "Product information."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FS_ProductInfo {
    #[doc = "Product code."]
    #[doc = ""]
    pub productCode: [::libc::c_char; 16usize],
    #[doc = "Company code."]
    #[doc = ""]
    pub companyCode: [::libc::c_char; 2usize],
    #[doc = "Remaster version."]
    #[doc = ""]
    pub remasterVersion: u16_,
}
#[doc = "Integrity verification seed."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FS_IntegrityVerificationSeed {
    #[doc = "AES-CBC MAC over a SHA256 hash, which hashes the first 0x110-bytes of the cleartext SEED."]
    #[doc = ""]
    pub aesCbcMac: [u8_; 16usize],
    #[doc = "The \"nand/private/movable.sed\", encrypted with AES-CTR using the above MAC for the counter."]
    #[doc = ""]
    pub movableSed: [u8_; 288usize],
}
impl Default for FS_IntegrityVerificationSeed {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Ext save data information."]
#[doc = ""]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct FS_ExtSaveDataInfo {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "Unknown."]
    #[doc = ""]
    pub unknown: u8_,
    #[doc = "Reserved."]
    #[doc = ""]
    pub reserved1: u16_,
    #[doc = "Save ID."]
    #[doc = ""]
    pub saveId: u64_,
    #[doc = "Reserved."]
    #[doc = ""]
    pub reserved2: u32_,
}
impl Default for FS_ExtSaveDataInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl FS_ExtSaveDataInfo {
    #[inline]
    pub fn mediaType(&self) -> FS_MediaType {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_mediaType(&mut self, val: FS_MediaType) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(mediaType: FS_MediaType) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let mediaType: u32 = unsafe { ::core::mem::transmute(mediaType) };
            mediaType as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "System save data information."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FS_SystemSaveDataInfo {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "Unknown."]
    #[doc = ""]
    pub unknown: u8_,
    #[doc = "Reserved."]
    #[doc = ""]
    pub reserved: u16_,
    #[doc = "Save ID."]
    #[doc = ""]
    pub saveId: u32_,
}
impl Default for FS_SystemSaveDataInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl FS_SystemSaveDataInfo {
    #[inline]
    pub fn mediaType(&self) -> FS_MediaType {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_mediaType(&mut self, val: FS_MediaType) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(mediaType: FS_MediaType) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let mediaType: u32 = unsafe { ::core::mem::transmute(mediaType) };
            mediaType as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "Device move context."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FS_DeviceMoveContext {
    #[doc = "IVs."]
    #[doc = ""]
    pub ivs: [u8_; 16usize],
    #[doc = "Encrypt parameter."]
    #[doc = ""]
    pub encryptParameter: [u8_; 16usize],
}
#[doc = "Filesystem path data, detailing the specific target of an operation."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FS_Path {
    #[doc = "FS path type."]
    #[doc = ""]
    pub type_: FS_PathType,
    #[doc = "FS path size."]
    #[doc = ""]
    pub size: u32_,
    #[doc = "Pointer to FS path data."]
    #[doc = ""]
    pub data: *const ::libc::c_void,
}
impl Default for FS_Path {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "SDMC/NAND speed information"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FS_SdMmcSpeedInfo {
    #[doc = "Whether or not High Speed Mode is enabled."]
    #[doc = ""]
    pub highSpeedModeEnabled: bool,
    #[doc = "Whether or not a clock divider of 2 is being used."]
    #[doc = ""]
    pub usesHighestClockRate: bool,
    #[doc = "The value of the SD_CLK_CTRL register."]
    #[doc = ""]
    pub sdClkCtrl: u16_,
}
#[doc = "Filesystem archive handle, providing access to a filesystem's contents."]
#[doc = ""]

pub type FS_Archive = u64_;
extern "C" {
    #[must_use]
    #[doc = "Initializes FS."]
    #[doc = ""]
    pub fn fsInit() -> Result;
}
extern "C" {
    #[doc = "Exits FS."]
    #[doc = ""]
    pub fn fsExit();
}
extern "C" {
    #[doc = "Sets the FSUSER session to use in the current thread.\n @param session The handle of the FSUSER session to use."]
    #[doc = ""]
    pub fn fsUseSession(session: Handle);
}
extern "C" {
    #[doc = "Disables the FSUSER session override in the current thread."]
    #[doc = ""]
    pub fn fsEndUseSession();
}
extern "C" {
    #[doc = "Exempts an archive from using alternate FS session handles provided with [`fsUseSession\n`] Instead, the archive will use the default FS session handle, opened with [`srvGetSessionHandle\n`] @param archive Archive to exempt."]
    #[doc = ""]
    pub fn fsExemptFromSession(archive: FS_Archive);
}
extern "C" {
    #[doc = "Unexempts an archive from using alternate FS session handles provided with [`fsUseSession\n`] @param archive Archive to remove from the exemption list."]
    #[doc = ""]
    pub fn fsUnexemptFromSession(archive: FS_Archive);
}
extern "C" {
    #[doc = "Creates an FS_Path instance.\n @param type Type of path.\n @param path Path to use.\n @return The created FS_Path instance."]
    #[doc = ""]
    pub fn fsMakePath(type_: FS_PathType, path: *const ::libc::c_void) -> FS_Path;
}
extern "C" {
    #[doc = "Gets the current FS session handle.\n @return The current FS session handle."]
    #[doc = ""]
    pub fn fsGetSessionHandle() -> *mut Handle;
}
extern "C" {
    #[must_use]
    #[doc = "Performs a control operation on the filesystem.\n @param action Action to perform.\n @param input Buffer to read input from.\n @param inputSize Size of the input.\n @param output Buffer to write output to.\n @param outputSize Size of the output."]
    #[doc = ""]
    pub fn FSUSER_Control(
        action: FS_Action,
        input: *mut ::libc::c_void,
        inputSize: u32_,
        output: *mut ::libc::c_void,
        outputSize: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initializes a FSUSER session.\n @param session The handle of the FSUSER session to initialize."]
    #[doc = ""]
    pub fn FSUSER_Initialize(session: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Opens a file.\n @param out Pointer to output the file handle to.\n @param archive Archive containing the file.\n @param path Path of the file.\n @param openFlags Flags to open the file with.\n @param attributes Attributes of the file."]
    #[doc = ""]
    pub fn FSUSER_OpenFile(
        out: *mut Handle,
        archive: FS_Archive,
        path: FS_Path,
        openFlags: u32_,
        attributes: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Opens a file directly, bypassing the requirement of an opened archive handle.\n @param out Pointer to output the file handle to.\n @param archiveId ID of the archive containing the file.\n @param archivePath Path of the archive containing the file.\n @param filePath Path of the file.\n @param openFlags Flags to open the file with.\n @param attributes Attributes of the file."]
    #[doc = ""]
    pub fn FSUSER_OpenFileDirectly(
        out: *mut Handle,
        archiveId: FS_ArchiveID,
        archivePath: FS_Path,
        filePath: FS_Path,
        openFlags: u32_,
        attributes: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Deletes a file.\n @param archive Archive containing the file.\n @param path Path of the file."]
    #[doc = ""]
    pub fn FSUSER_DeleteFile(archive: FS_Archive, path: FS_Path) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Renames a file.\n @param srcArchive Archive containing the source file.\n @param srcPath Path of the source file.\n @param dstArchive Archive containing the destination file.\n @param dstPath Path of the destination file."]
    #[doc = ""]
    pub fn FSUSER_RenameFile(
        srcArchive: FS_Archive,
        srcPath: FS_Path,
        dstArchive: FS_Archive,
        dstPath: FS_Path,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Deletes a directory, failing if it is not empty.\n @param archive Archive containing the directory.\n @param path Path of the directory."]
    #[doc = ""]
    pub fn FSUSER_DeleteDirectory(archive: FS_Archive, path: FS_Path) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Deletes a directory, also deleting its contents.\n @param archive Archive containing the directory.\n @param path Path of the directory."]
    #[doc = ""]
    pub fn FSUSER_DeleteDirectoryRecursively(archive: FS_Archive, path: FS_Path) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Creates a file.\n @param archive Archive to create the file in.\n @param path Path of the file.\n @param attributes Attributes of the file.\n @param fileSize Size of the file."]
    #[doc = ""]
    pub fn FSUSER_CreateFile(
        archive: FS_Archive,
        path: FS_Path,
        attributes: u32_,
        fileSize: u64_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Creates a directory\n @param archive Archive to create the directory in.\n @param path Path of the directory.\n @param attributes Attributes of the directory."]
    #[doc = ""]
    pub fn FSUSER_CreateDirectory(archive: FS_Archive, path: FS_Path, attributes: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Renames a directory.\n @param srcArchive Archive containing the source directory.\n @param srcPath Path of the source directory.\n @param dstArchive Archive containing the destination directory.\n @param dstPath Path of the destination directory."]
    #[doc = ""]
    pub fn FSUSER_RenameDirectory(
        srcArchive: FS_Archive,
        srcPath: FS_Path,
        dstArchive: FS_Archive,
        dstPath: FS_Path,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Opens a directory.\n @param out Pointer to output the directory handle to.\n @param archive Archive containing the directory.\n @param path Path of the directory."]
    #[doc = ""]
    pub fn FSUSER_OpenDirectory(out: *mut Handle, archive: FS_Archive, path: FS_Path) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Opens an archive.\n @param archive Pointer to output the opened archive to.\n @param id ID of the archive.\n @param path Path of the archive."]
    #[doc = ""]
    pub fn FSUSER_OpenArchive(archive: *mut FS_Archive, id: FS_ArchiveID, path: FS_Path) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Performs a control operation on an archive.\n @param archive Archive to control.\n @param action Action to perform.\n @param input Buffer to read input from.\n @param inputSize Size of the input.\n @param output Buffer to write output to.\n @param outputSize Size of the output."]
    #[doc = ""]
    pub fn FSUSER_ControlArchive(
        archive: FS_Archive,
        action: FS_ArchiveAction,
        input: *mut ::libc::c_void,
        inputSize: u32_,
        output: *mut ::libc::c_void,
        outputSize: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Closes an archive.\n @param archive Archive to close."]
    #[doc = ""]
    pub fn FSUSER_CloseArchive(archive: FS_Archive) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the number of free bytes within an archive.\n @param freeBytes Pointer to output the free bytes to.\n @param archive Archive to check."]
    #[doc = ""]
    pub fn FSUSER_GetFreeBytes(freeBytes: *mut u64_, archive: FS_Archive) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the inserted card type.\n @param type Pointer to output the card type to."]
    #[doc = ""]
    pub fn FSUSER_GetCardType(type_: *mut FS_CardType) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the SDMC archive resource information.\n @param archiveResource Pointer to output the archive resource information to."]
    #[doc = ""]
    pub fn FSUSER_GetSdmcArchiveResource(archiveResource: *mut FS_ArchiveResource) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the NAND archive resource information.\n @param archiveResource Pointer to output the archive resource information to."]
    #[doc = ""]
    pub fn FSUSER_GetNandArchiveResource(archiveResource: *mut FS_ArchiveResource) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the last SDMC fatfs error.\n @param error Pointer to output the error to."]
    #[doc = ""]
    pub fn FSUSER_GetSdmcFatfsError(error: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets whether an SD card is detected.\n @param detected Pointer to output the detection status to."]
    #[doc = ""]
    pub fn FSUSER_IsSdmcDetected(detected: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets whether the SD card is writable.\n @param writable Pointer to output the writable status to."]
    #[doc = ""]
    pub fn FSUSER_IsSdmcWritable(writable: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the SDMC CID.\n @param out Pointer to output the CID to.\n @param length Length of the CID buffer. (should be 0x10)"]
    #[doc = ""]
    pub fn FSUSER_GetSdmcCid(out: *mut u8_, length: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the NAND CID.\n @param out Pointer to output the CID to.\n @param length Length of the CID buffer. (should be 0x10)"]
    #[doc = ""]
    pub fn FSUSER_GetNandCid(out: *mut u8_, length: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the SDMC speed info.\n @param speedInfo Pointer to output the speed info to."]
    #[doc = ""]
    pub fn FSUSER_GetSdmcSpeedInfo(speedInfo: *mut FS_SdMmcSpeedInfo) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the NAND speed info.\n @param speedInfo Pointer to output the speed info to."]
    #[doc = ""]
    pub fn FSUSER_GetNandSpeedInfo(speedInfo: *mut FS_SdMmcSpeedInfo) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the SDMC log.\n @param out Pointer to output the log to.\n @param length Length of the log buffer."]
    #[doc = ""]
    pub fn FSUSER_GetSdmcLog(out: *mut u8_, length: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the NAND log.\n @param out Pointer to output the log to.\n @param length Length of the log buffer."]
    #[doc = ""]
    pub fn FSUSER_GetNandLog(out: *mut u8_, length: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Clears the SDMC log."]
    #[doc = ""]
    pub fn FSUSER_ClearSdmcLog() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Clears the NAND log."]
    #[doc = ""]
    pub fn FSUSER_ClearNandLog() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets whether a card is inserted.\n @param inserted Pointer to output the insertion status to."]
    #[doc = ""]
    pub fn FSUSER_CardSlotIsInserted(inserted: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Powers on the card slot.\n @param status Pointer to output the power status to."]
    #[doc = ""]
    pub fn FSUSER_CardSlotPowerOn(status: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Powers off the card slot.\n @param status Pointer to output the power status to."]
    #[doc = ""]
    pub fn FSUSER_CardSlotPowerOff(status: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the card's power status.\n @param status Pointer to output the power status to."]
    #[doc = ""]
    pub fn FSUSER_CardSlotGetCardIFPowerStatus(status: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Executes a CARDNOR direct command.\n @param commandId ID of the command."]
    #[doc = ""]
    pub fn FSUSER_CardNorDirectCommand(commandId: u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Executes a CARDNOR direct command with an address.\n @param commandId ID of the command.\n @param address Address to provide."]
    #[doc = ""]
    pub fn FSUSER_CardNorDirectCommandWithAddress(commandId: u8_, address: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Executes a CARDNOR direct read.\n @param commandId ID of the command.\n @param size Size of the output buffer.\n @param output Output buffer."]
    #[doc = ""]
    pub fn FSUSER_CardNorDirectRead(
        commandId: u8_,
        size: u32_,
        output: *mut ::libc::c_void,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Executes a CARDNOR direct read with an address.\n @param commandId ID of the command.\n @param address Address to provide.\n @param size Size of the output buffer.\n @param output Output buffer."]
    #[doc = ""]
    pub fn FSUSER_CardNorDirectReadWithAddress(
        commandId: u8_,
        address: u32_,
        size: u32_,
        output: *mut ::libc::c_void,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Executes a CARDNOR direct write.\n @param commandId ID of the command.\n @param size Size of the input buffer.\n @param output Input buffer."]
    #[doc = ""]
    pub fn FSUSER_CardNorDirectWrite(
        commandId: u8_,
        size: u32_,
        input: *const ::libc::c_void,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Executes a CARDNOR direct write with an address.\n @param commandId ID of the command.\n @param address Address to provide.\n @param size Size of the input buffer.\n @param input Input buffer."]
    #[doc = ""]
    pub fn FSUSER_CardNorDirectWriteWithAddress(
        commandId: u8_,
        address: u32_,
        size: u32_,
        input: *const ::libc::c_void,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Executes a CARDNOR 4xIO direct read.\n @param commandId ID of the command.\n @param address Address to provide.\n @param size Size of the output buffer.\n @param output Output buffer."]
    #[doc = ""]
    pub fn FSUSER_CardNorDirectRead_4xIO(
        commandId: u8_,
        address: u32_,
        size: u32_,
        output: *mut ::libc::c_void,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Executes a CARDNOR direct CPU write without verify.\n @param address Address to provide.\n @param size Size of the input buffer.\n @param output Input buffer."]
    #[doc = ""]
    pub fn FSUSER_CardNorDirectCpuWriteWithoutVerify(
        address: u32_,
        size: u32_,
        input: *const ::libc::c_void,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Executes a CARDNOR direct sector erase without verify.\n @param address Address to provide."]
    #[doc = ""]
    pub fn FSUSER_CardNorDirectSectorEraseWithoutVerify(address: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets a process's product info.\n @param info Pointer to output the product info to.\n @param processId ID of the process."]
    #[doc = ""]
    pub fn FSUSER_GetProductInfo(info: *mut FS_ProductInfo, processId: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets a process's program launch info.\n @param info Pointer to output the program launch info to.\n @param processId ID of the process."]
    #[doc = ""]
    pub fn FSUSER_GetProgramLaunchInfo(info: *mut FS_ProgramInfo, processId: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the CARDSPI baud rate.\n @param baudRate Baud rate to set."]
    #[doc = ""]
    pub fn FSUSER_SetCardSpiBaudRate(baudRate: FS_CardSpiBaudRate) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the CARDSPI bus mode.\n @param busMode Bus mode to set."]
    #[doc = ""]
    pub fn FSUSER_SetCardSpiBusMode(busMode: FS_CardSpiBusMode) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sends initialization info to ARM9."]
    #[doc = ""]
    pub fn FSUSER_SendInitializeInfoTo9() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets a special content's index.\n @param index Pointer to output the index to.\n @param mediaType Media type of the special content.\n @param programId Program ID owning the special content.\n @param type Type of special content."]
    #[doc = ""]
    pub fn FSUSER_GetSpecialContentIndex(
        index: *mut u16_,
        mediaType: FS_MediaType,
        programId: u64_,
        type_: FS_SpecialContentType,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the legacy ROM header of a program.\n @param mediaType Media type of the program.\n @param programId ID of the program.\n @param header Pointer to output the legacy ROM header to. (size = 0x3B4)"]
    #[doc = ""]
    pub fn FSUSER_GetLegacyRomHeader(
        mediaType: FS_MediaType,
        programId: u64_,
        header: *mut ::libc::c_void,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the legacy banner data of a program.\n @param mediaType Media type of the program.\n @param programId ID of the program.\n @param header Pointer to output the legacy banner data to. (size = 0x23C0)"]
    #[doc = ""]
    pub fn FSUSER_GetLegacyBannerData(
        mediaType: FS_MediaType,
        programId: u64_,
        banner: *mut ::libc::c_void,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Checks a process's authority to access a save data archive.\n @param access Pointer to output the access status to.\n @param mediaType Media type of the save data.\n @param saveId ID of the save data.\n @param processId ID of the process to check."]
    #[doc = ""]
    pub fn FSUSER_CheckAuthorityToAccessExtSaveData(
        access: *mut bool,
        mediaType: FS_MediaType,
        saveId: u64_,
        processId: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Queries the total quota size of a save data archive.\n @param quotaSize Pointer to output the quota size to.\n @param directories Number of directories.\n @param files Number of files.\n @param fileSizeCount Number of file sizes to provide.\n @param fileSizes File sizes to provide."]
    #[doc = ""]
    pub fn FSUSER_QueryTotalQuotaSize(
        quotaSize: *mut u64_,
        directories: u32_,
        files: u32_,
        fileSizeCount: u32_,
        fileSizes: *mut u64_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Abnegates an access right.\n @param accessRight Access right to abnegate."]
    #[doc = ""]
    pub fn FSUSER_AbnegateAccessRight(accessRight: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Deletes the 3DS SDMC root."]
    #[doc = ""]
    pub fn FSUSER_DeleteSdmcRoot() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Deletes all ext save data on the NAND."]
    #[doc = ""]
    pub fn FSUSER_DeleteAllExtSaveDataOnNand() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initializes the CTR file system."]
    #[doc = ""]
    pub fn FSUSER_InitializeCtrFileSystem() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Creates the FS seed."]
    #[doc = ""]
    pub fn FSUSER_CreateSeed() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Retrieves archive format info.\n @param totalSize Pointer to output the total size to.\n @param directories Pointer to output the number of directories to.\n @param files Pointer to output the number of files to.\n @param duplicateData Pointer to output whether to duplicate data to.\n @param archiveId ID of the archive.\n @param path Path of the archive."]
    #[doc = ""]
    pub fn FSUSER_GetFormatInfo(
        totalSize: *mut u32_,
        directories: *mut u32_,
        files: *mut u32_,
        duplicateData: *mut bool,
        archiveId: FS_ArchiveID,
        path: FS_Path,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the legacy ROM header of a program.\n @param headerSize Size of the ROM header.\n @param mediaType Media type of the program.\n @param programId ID of the program.\n @param header Pointer to output the legacy ROM header to."]
    #[doc = ""]
    pub fn FSUSER_GetLegacyRomHeader2(
        headerSize: u32_,
        mediaType: FS_MediaType,
        programId: u64_,
        header: *mut ::libc::c_void,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the CTR SDMC root path.\n @param out Pointer to output the root path to.\n @param length Length of the output buffer."]
    #[doc = ""]
    pub fn FSUSER_GetSdmcCtrRootPath(out: *mut u8_, length: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets an archive's resource information.\n @param archiveResource Pointer to output the archive resource information to.\n @param mediaType System media type to check."]
    #[doc = ""]
    pub fn FSUSER_GetArchiveResource(
        archiveResource: *mut FS_ArchiveResource,
        mediaType: FS_SystemMediaType,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Exports the integrity verification seed.\n @param seed Pointer to output the seed to."]
    #[doc = ""]
    pub fn FSUSER_ExportIntegrityVerificationSeed(
        seed: *mut FS_IntegrityVerificationSeed,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Imports an integrity verification seed.\n @param seed Seed to import."]
    #[doc = ""]
    pub fn FSUSER_ImportIntegrityVerificationSeed(
        seed: *mut FS_IntegrityVerificationSeed,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Formats save data.\n @param archiveId ID of the save data archive.\n @param path Path of the save data.\n @param blocks Size of the save data in blocks. (512 bytes)\n @param directories Number of directories.\n @param files Number of files.\n @param directoryBuckets Directory hash tree bucket count.\n @param fileBuckets File hash tree bucket count.\n @param duplicateData Whether to store an internal duplicate of the data."]
    #[doc = ""]
    pub fn FSUSER_FormatSaveData(
        archiveId: FS_ArchiveID,
        path: FS_Path,
        blocks: u32_,
        directories: u32_,
        files: u32_,
        directoryBuckets: u32_,
        fileBuckets: u32_,
        duplicateData: bool,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the legacy sub banner data of a program.\n @param bannerSize Size of the banner.\n @param mediaType Media type of the program.\n @param programId ID of the program.\n @param header Pointer to output the legacy sub banner data to."]
    #[doc = ""]
    pub fn FSUSER_GetLegacySubBannerData(
        bannerSize: u32_,
        mediaType: FS_MediaType,
        programId: u64_,
        banner: *mut ::libc::c_void,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Hashes the given data and outputs a SHA256 hash.\n @param data Pointer to the data to be hashed.\n @param inputSize The size of the data.\n @param hash Hash output pointer."]
    #[doc = ""]
    pub fn FSUSER_UpdateSha256Context(
        data: *const ::libc::c_void,
        inputSize: u32_,
        hash: *mut u8_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Reads from a special file.\n @param bytesRead Pointer to output the number of bytes read to.\n @param fileOffset Offset of the file.\n @param size Size of the buffer.\n @param data Buffer to read to."]
    #[doc = ""]
    pub fn FSUSER_ReadSpecialFile(
        bytesRead: *mut u32_,
        fileOffset: u64_,
        size: u32_,
        data: *mut ::libc::c_void,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the size of a special file.\n @param fileSize Pointer to output the size to."]
    #[doc = ""]
    pub fn FSUSER_GetSpecialFileSize(fileSize: *mut u64_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Creates ext save data.\n @param info Info of the save data.\n @param directories Number of directories.\n @param files Number of files.\n @param sizeLimit Size limit of the save data.\n @param smdhSize Size of the save data's SMDH data.\n @param smdh SMDH data."]
    #[doc = ""]
    pub fn FSUSER_CreateExtSaveData(
        info: FS_ExtSaveDataInfo,
        directories: u32_,
        files: u32_,
        sizeLimit: u64_,
        smdhSize: u32_,
        smdh: *mut u8_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Deletes ext save data.\n @param info Info of the save data."]
    #[doc = ""]
    pub fn FSUSER_DeleteExtSaveData(info: FS_ExtSaveDataInfo) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Reads the SMDH icon of ext save data.\n @param bytesRead Pointer to output the number of bytes read to.\n @param info Info of the save data.\n @param smdhSize Size of the save data SMDH.\n @param smdh Pointer to output SMDH data to."]
    #[doc = ""]
    pub fn FSUSER_ReadExtSaveDataIcon(
        bytesRead: *mut u32_,
        info: FS_ExtSaveDataInfo,
        smdhSize: u32_,
        smdh: *mut u8_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets an ext data archive's block information.\n @param totalBlocks Pointer to output the total blocks to.\n @param freeBlocks Pointer to output the free blocks to.\n @param blockSize Pointer to output the block size to.\n @param info Info of the save data."]
    #[doc = ""]
    pub fn FSUSER_GetExtDataBlockSize(
        totalBlocks: *mut u64_,
        freeBlocks: *mut u64_,
        blockSize: *mut u32_,
        info: FS_ExtSaveDataInfo,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Enumerates ext save data.\n @param idsWritten Pointer to output the number of IDs written to.\n @param idsSize Size of the IDs buffer.\n @param mediaType Media type to enumerate over.\n @param idSize Size of each ID element.\n @param shared Whether to enumerate shared ext save data.\n @param ids Pointer to output IDs to."]
    #[doc = ""]
    pub fn FSUSER_EnumerateExtSaveData(
        idsWritten: *mut u32_,
        idsSize: u32_,
        mediaType: FS_MediaType,
        idSize: u32_,
        shared: bool,
        ids: *mut u8_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Creates system save data.\n @param info Info of the save data.\n @param totalSize Total size of the save data.\n @param blockSize Block size of the save data. (usually 0x1000)\n @param directories Number of directories.\n @param files Number of files.\n @param directoryBuckets Directory hash tree bucket count.\n @param fileBuckets File hash tree bucket count.\n @param duplicateData Whether to store an internal duplicate of the data."]
    #[doc = ""]
    pub fn FSUSER_CreateSystemSaveData(
        info: FS_SystemSaveDataInfo,
        totalSize: u32_,
        blockSize: u32_,
        directories: u32_,
        files: u32_,
        directoryBuckets: u32_,
        fileBuckets: u32_,
        duplicateData: bool,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Deletes system save data.\n @param info Info of the save data."]
    #[doc = ""]
    pub fn FSUSER_DeleteSystemSaveData(info: FS_SystemSaveDataInfo) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initiates a device move as the source device.\n @param context Pointer to output the context to."]
    #[doc = ""]
    pub fn FSUSER_StartDeviceMoveAsSource(context: *mut FS_DeviceMoveContext) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initiates a device move as the destination device.\n @param context Context to use.\n @param clear Whether to clear the device's data first."]
    #[doc = ""]
    pub fn FSUSER_StartDeviceMoveAsDestination(
        context: FS_DeviceMoveContext,
        clear: bool,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets an archive's priority.\n @param archive Archive to use.\n @param priority Priority to set."]
    #[doc = ""]
    pub fn FSUSER_SetArchivePriority(archive: FS_Archive, priority: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets an archive's priority.\n @param priority Pointer to output the priority to.\n @param archive Archive to use."]
    #[doc = ""]
    pub fn FSUSER_GetArchivePriority(priority: *mut u32_, archive: FS_Archive) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Configures CTRCARD latency emulation.\n @param latency Latency to apply, in milliseconds.\n @param emulateEndurance Whether to emulate card endurance."]
    #[doc = ""]
    pub fn FSUSER_SetCtrCardLatencyParameter(latency: u64_, emulateEndurance: bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Toggles cleaning up invalid save data.\n @param enable Whether to enable cleaning up invalid save data."]
    #[doc = ""]
    pub fn FSUSER_SwitchCleanupInvalidSaveData(enable: bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Enumerates system save data.\n @param idsWritten Pointer to output the number of IDs written to.\n @param idsSize Size of the IDs buffer.\n @param ids Pointer to output IDs to."]
    #[doc = ""]
    pub fn FSUSER_EnumerateSystemSaveData(
        idsWritten: *mut u32_,
        idsSize: u32_,
        ids: *mut u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initializes a FSUSER session with an SDK version.\n @param session The handle of the FSUSER session to initialize.\n @param version SDK version to initialize with."]
    #[doc = ""]
    pub fn FSUSER_InitializeWithSdkVersion(session: Handle, version: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the file system priority.\n @param priority Priority to set."]
    #[doc = ""]
    pub fn FSUSER_SetPriority(priority: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the file system priority.\n @param priority Pointer to output the priority to."]
    #[doc = ""]
    pub fn FSUSER_GetPriority(priority: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the save data secure value.\n @param value Secure value to set.\n @param slot Slot of the secure value.\n @param titleUniqueId Unique ID of the title. (default = 0)\n @param titleVariation Variation of the title. (default = 0)"]
    #[doc = ""]
    pub fn FSUSER_SetSaveDataSecureValue(
        value: u64_,
        slot: FS_SecureValueSlot,
        titleUniqueId: u32_,
        titleVariation: u8_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the save data secure value.\n @param exists Pointer to output whether the secure value exists to.\n @param value Pointer to output the secure value to.\n @param slot Slot of the secure value.\n @param titleUniqueId Unique ID of the title. (default = 0)\n @param titleVariation Variation of the title. (default = 0)"]
    #[doc = ""]
    pub fn FSUSER_GetSaveDataSecureValue(
        exists: *mut bool,
        value: *mut u64_,
        slot: FS_SecureValueSlot,
        titleUniqueId: u32_,
        titleVariation: u8_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Performs a control operation on a secure save.\n @param action Action to perform.\n @param input Buffer to read input from.\n @param inputSize Size of the input.\n @param output Buffer to write output to.\n @param outputSize Size of the output."]
    #[doc = ""]
    pub fn FSUSER_ControlSecureSave(
        action: FS_SecureSaveAction,
        input: *mut ::libc::c_void,
        inputSize: u32_,
        output: *mut ::libc::c_void,
        outputSize: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the media type of the current application.\n @param mediaType Pointer to output the media type to."]
    #[doc = ""]
    pub fn FSUSER_GetMediaType(mediaType: *mut FS_MediaType) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Performs a control operation on a file.\n @param handle Handle of the file.\n @param action Action to perform.\n @param input Buffer to read input from.\n @param inputSize Size of the input.\n @param output Buffer to write output to.\n @param outputSize Size of the output."]
    #[doc = ""]
    pub fn FSFILE_Control(
        handle: Handle,
        action: FS_FileAction,
        input: *mut ::libc::c_void,
        inputSize: u32_,
        output: *mut ::libc::c_void,
        outputSize: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Opens a handle to a sub-section of a file.\n @param handle Handle of the file.\n @param subFile Pointer to output the sub-file to.\n @param offset Offset of the sub-section.\n @param size Size of the sub-section."]
    #[doc = ""]
    pub fn FSFILE_OpenSubFile(
        handle: Handle,
        subFile: *mut Handle,
        offset: u64_,
        size: u64_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Reads from a file.\n @param handle Handle of the file.\n @param bytesRead Pointer to output the number of bytes read to.\n @param offset Offset to read from.\n @param buffer Buffer to read to.\n @param size Size of the buffer."]
    #[doc = ""]
    pub fn FSFILE_Read(
        handle: Handle,
        bytesRead: *mut u32_,
        offset: u64_,
        buffer: *mut ::libc::c_void,
        size: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Writes to a file.\n @param handle Handle of the file.\n @param bytesWritten Pointer to output the number of bytes written to.\n @param offset Offset to write to.\n @param buffer Buffer to write from.\n @param size Size of the buffer.\n @param flags Flags to use when writing."]
    #[doc = ""]
    pub fn FSFILE_Write(
        handle: Handle,
        bytesWritten: *mut u32_,
        offset: u64_,
        buffer: *const ::libc::c_void,
        size: u32_,
        flags: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the size of a file.\n @param handle Handle of the file.\n @param size Pointer to output the size to."]
    #[doc = ""]
    pub fn FSFILE_GetSize(handle: Handle, size: *mut u64_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the size of a file.\n @param handle Handle of the file.\n @param size Size to set."]
    #[doc = ""]
    pub fn FSFILE_SetSize(handle: Handle, size: u64_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the attributes of a file.\n @param handle Handle of the file.\n @param attributes Pointer to output the attributes to."]
    #[doc = ""]
    pub fn FSFILE_GetAttributes(handle: Handle, attributes: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the attributes of a file.\n @param handle Handle of the file.\n @param attributes Attributes to set."]
    #[doc = ""]
    pub fn FSFILE_SetAttributes(handle: Handle, attributes: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Closes a file.\n @param handle Handle of the file."]
    #[doc = ""]
    pub fn FSFILE_Close(handle: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Flushes a file's contents.\n @param handle Handle of the file."]
    #[doc = ""]
    pub fn FSFILE_Flush(handle: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets a file's priority.\n @param handle Handle of the file.\n @param priority Priority to set."]
    #[doc = ""]
    pub fn FSFILE_SetPriority(handle: Handle, priority: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets a file's priority.\n @param handle Handle of the file.\n @param priority Pointer to output the priority to."]
    #[doc = ""]
    pub fn FSFILE_GetPriority(handle: Handle, priority: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Opens a duplicate handle to a file.\n @param handle Handle of the file.\n @param linkFile Pointer to output the link handle to."]
    #[doc = ""]
    pub fn FSFILE_OpenLinkFile(handle: Handle, linkFile: *mut Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Performs a control operation on a directory.\n @param handle Handle of the directory.\n @param action Action to perform.\n @param input Buffer to read input from.\n @param inputSize Size of the input.\n @param output Buffer to write output to.\n @param outputSize Size of the output."]
    #[doc = ""]
    pub fn FSDIR_Control(
        handle: Handle,
        action: FS_DirectoryAction,
        input: *mut ::libc::c_void,
        inputSize: u32_,
        output: *mut ::libc::c_void,
        outputSize: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Reads one or more directory entries.\n @param handle Handle of the directory.\n @param entriesRead Pointer to output the number of entries read to.\n @param entryCount Number of entries to read.\n @param entryOut Pointer to output directory entries to."]
    #[doc = ""]
    pub fn FSDIR_Read(
        handle: Handle,
        entriesRead: *mut u32_,
        entryCount: u32_,
        entries: *mut FS_DirectoryEntry,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Closes a directory.\n @param handle Handle of the directory."]
    #[doc = ""]
    pub fn FSDIR_Close(handle: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets a directory's priority.\n @param handle Handle of the directory.\n @param priority Priority to set."]
    #[doc = ""]
    pub fn FSDIR_SetPriority(handle: Handle, priority: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets a directory's priority.\n @param handle Handle of the directory.\n @param priority Pointer to output the priority to."]
    #[doc = ""]
    pub fn FSDIR_GetPriority(handle: Handle, priority: *mut u32_) -> Result;
}
#[doc = "Contains basic information about a title."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AM_TitleEntry {
    #[doc = "The title's ID."]
    #[doc = ""]
    pub titleID: u64_,
    #[doc = "The title's installed size."]
    #[doc = ""]
    pub size: u64_,
    #[doc = "The title's version."]
    #[doc = ""]
    pub version: u16_,
    #[doc = "Unknown title data."]
    #[doc = ""]
    pub unk: [u8_; 6usize],
}
#[doc = "Titles currently installing."]
#[doc = ""]

pub const AM_STATUS_MASK_INSTALLING: _bindgen_ty_13 = 1;
#[doc = "Titles awaiting finalization."]
#[doc = ""]

pub const AM_STATUS_MASK_AWAITING_FINALIZATION: _bindgen_ty_13 = 2;
#[doc = "Pending title status mask values."]
#[doc = ""]

pub type _bindgen_ty_13 = ::libc::c_uint;
#[doc = "Install aborted."]
#[doc = ""]

pub const AM_STATUS_ABORTED: AM_InstallStatus = 2;
#[doc = "Title saved, but not installed."]
#[doc = ""]

pub const AM_STATUS_SAVED: AM_InstallStatus = 3;
#[doc = "Install in progress."]
#[doc = ""]

pub const AM_STATUS_INSTALL_IN_PROGRESS: AM_InstallStatus = 2050;
#[doc = "Awaiting finalization."]
#[doc = ""]

pub const AM_STATUS_AWAITING_FINALIZATION: AM_InstallStatus = 2051;
#[doc = "Pending title status values."]
#[doc = ""]

pub type AM_InstallStatus = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AM_PendingTitleEntry {
    #[doc = "Title ID"]
    #[doc = ""]
    pub titleId: u64_,
    #[doc = "Version"]
    #[doc = ""]
    pub version: u16_,
    #[doc = "[`AM_InstallStatus`]"]
    #[doc = ""]
    pub status: u16_,
    #[doc = "Title Type"]
    #[doc = ""]
    pub titleType: u32_,
    #[doc = "Unknown"]
    #[doc = ""]
    pub unk: [u8_; 8usize],
}
#[doc = "Non-system titles."]
#[doc = ""]

pub const AM_DELETE_PENDING_NON_SYSTEM: _bindgen_ty_14 = 1;
#[doc = "System titles."]
#[doc = ""]

pub const AM_DELETE_PENDING_SYSTEM: _bindgen_ty_14 = 2;
#[doc = "Pending title deletion flags."]
#[doc = ""]

pub type _bindgen_ty_14 = ::libc::c_uint;
#[doc = "Information about the TWL NAND partition."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AM_TWLPartitionInfo {
    #[doc = "Total capacity."]
    #[doc = ""]
    pub capacity: u64_,
    #[doc = "Total free space."]
    #[doc = ""]
    pub freeSpace: u64_,
    #[doc = "Capacity for titles."]
    #[doc = ""]
    pub titlesCapacity: u64_,
    #[doc = "Free space for titles."]
    #[doc = ""]
    pub titlesFreeSpace: u64_,
}
#[doc = "Contains information about a title's content."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AM_ContentInfo {
    #[doc = "Index of the content in the title."]
    #[doc = ""]
    pub index: u16_,
    #[doc = "?"]
    #[doc = ""]
    pub type_: u16_,
    #[doc = "ID of the content in the title."]
    #[doc = ""]
    pub contentId: u32_,
    #[doc = "Size of the content in the title."]
    #[doc = ""]
    pub size: u64_,
    #[doc = "[`AM_ContentInfoFlags`]"]
    #[doc = ""]
    pub flags: u8_,
    #[doc = "Padding"]
    #[doc = ""]
    pub padding: [u8_; 7usize],
}
#[doc = "?"]
#[doc = ""]

pub const AM_CONTENT_DOWNLOADED: AM_ContentInfoFlags = 1;
#[doc = "?"]
#[doc = ""]

pub const AM_CONTENT_OWNED: AM_ContentInfoFlags = 2;
#[doc = "Title ContentInfo flags."]
#[doc = ""]

pub type AM_ContentInfoFlags = ::libc::c_uint;
extern "C" {
    #[must_use]
    #[doc = "Initializes AM. This doesn't initialize with \"am:app\", see amAppInit()."]
    #[doc = ""]
    pub fn amInit() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initializes AM with a service which has access to the amapp-commands. This should only be used when using the amapp commands, not non-amapp AM commands."]
    #[doc = ""]
    pub fn amAppInit() -> Result;
}
extern "C" {
    #[doc = "Exits AM."]
    #[doc = ""]
    pub fn amExit();
}
extern "C" {
    #[doc = "Gets the current AM session handle."]
    #[doc = ""]
    pub fn amGetSessionHandle() -> *mut Handle;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the number of titles for a given media type.\n @param mediatype Media type to get titles from.\n @param[out] count Pointer to write the title count to."]
    #[doc = ""]
    pub fn AM_GetTitleCount(mediatype: FS_MediaType, count: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets a list of title IDs present in a mediatype.\n @param[out] titlesRead Pointer to output the number of read titles to.\n @param mediatype Media type to get titles from.\n @param titleCount Number of title IDs to get.\n @param titleIds Buffer to output the retrieved title IDs to."]
    #[doc = ""]
    pub fn AM_GetTitleList(
        titlesRead: *mut u32_,
        mediatype: FS_MediaType,
        titleCount: u32_,
        titleIds: *mut u64_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets a list of details about installed titles.\n @param mediatype Media type to get titles from.\n @param titleCount Number of titles to list.\n @param titleIds List of title IDs to retrieve details for.\n @param titleInfo Buffer to write AM_TitleEntry's to."]
    #[doc = ""]
    pub fn AM_GetTitleInfo(
        mediatype: FS_MediaType,
        titleCount: u32_,
        titleIds: *mut u64_,
        titleInfo: *mut AM_TitleEntry,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the number of tickets installed on the system.\n @param[out] count Pointer to output the ticket count to."]
    #[doc = ""]
    pub fn AM_GetTicketCount(count: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets a list of tickets installed on the system.\n @param[out] ticketsRead Pointer to output the number of read tickets to.\n @param ticketCount Number of tickets to read.\n @param skip Number of tickets to skip.\n @param ticketIds Buffer to output the retrieved ticket IDs to."]
    #[doc = ""]
    pub fn AM_GetTicketList(
        ticketsRead: *mut u32_,
        ticketCount: u32_,
        skip: u32_,
        ticketIds: *mut u64_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the number of pending titles on this system.\n @param[out] count Pointer to output the pending title count to.\n @param mediatype Media type of pending titles to count.\n @param statusMask Bit mask of status values to include."]
    #[doc = ""]
    pub fn AM_GetPendingTitleCount(
        count: *mut u32_,
        mediatype: FS_MediaType,
        statusMask: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets a list of pending titles on this system.\n @param[out] titlesRead Pointer to output the number of read pending titles to.\n @param titleCount Number of pending titles to read.\n @param mediatype Media type of pending titles to list.\n @param statusMask Bit mask of status values to include.\n @param titleIds Buffer to output the retrieved pending title IDs to."]
    #[doc = ""]
    pub fn AM_GetPendingTitleList(
        titlesRead: *mut u32_,
        titleCount: u32_,
        mediatype: FS_MediaType,
        statusMask: u32_,
        titleIds: *mut u64_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets information about pending titles on this system.\n @param titleCount Number of pending titles to read.\n @param mediatype Media type of pending titles to get information on.\n @param titleIds IDs of the titles to get information about.\n @param titleInfo Buffer to output the retrieved pending title info to."]
    #[doc = ""]
    pub fn AM_GetPendingTitleInfo(
        titleCount: u32_,
        mediatype: FS_MediaType,
        titleIds: *mut u64_,
        titleInfo: *mut AM_PendingTitleEntry,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets a 32-bit device-specific ID.\n @param deviceID Pointer to write the device ID to."]
    #[doc = ""]
    pub fn AM_GetDeviceId(deviceID: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Exports DSiWare to the specified filepath.\n @param titleID TWL titleID.\n @param operation DSiWare operation type.\n @param workbuf Work buffer.\n @param workbuf_size Work buffer size, must be >=0x20000.\n @param filepath UTF-8 filepath(converted to UTF-16 internally)."]
    #[doc = ""]
    pub fn AM_ExportTwlBackup(
        titleID: u64_,
        operation: u8_,
        workbuf: *mut ::libc::c_void,
        workbuf_size: u32_,
        filepath: *const ::libc::c_char,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Imports DSiWare from the specified file.\n @param filehandle FSUSER file handle.\n @param operation DSiWare operation type.\n @param buffer Work buffer.\n @param size Buffer size, must be >=0x20000."]
    #[doc = ""]
    pub fn AM_ImportTwlBackup(
        filehandle: Handle,
        operation: u8_,
        buffer: *mut ::libc::c_void,
        size: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Reads info from the specified DSiWare export file. This can only be used with DSiWare exported with certain operation value(s).\n @param filehandle FSUSER file handle.\n @param outinfo Output info buffer.\n @param outinfo_size Output info buffer size.\n @param workbuf Work buffer.\n @param workbuf_size Work buffer size.\n @param banner Output banner buffer.\n @param banner_size Output banner buffer size."]
    #[doc = ""]
    pub fn AM_ReadTwlBackupInfo(
        filehandle: Handle,
        outinfo: *mut ::libc::c_void,
        outinfo_size: u32_,
        workbuf: *mut ::libc::c_void,
        workbuf_size: u32_,
        banner: *mut ::libc::c_void,
        banner_size: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Retrieves information about the NAND TWL partition.\n @param[out] info Pointer to output the TWL partition info to."]
    #[doc = ""]
    pub fn AM_GetTWLPartitionInfo(info: *mut AM_TWLPartitionInfo) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initializes the CIA install process, returning a handle to write CIA data to.\n @param mediatype Media type to install the CIA to.\n @param[out] ciaHandle Pointer to write the CIA handle to."]
    #[doc = ""]
    pub fn AM_StartCiaInstall(mediatype: FS_MediaType, ciaHandle: *mut Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initializes the CIA install process for Download Play CIAs, returning a handle to write CIA data to.\n @param[out] ciaHandle Pointer to write the CIA handle to."]
    #[doc = ""]
    pub fn AM_StartDlpChildCiaInstall(ciaHandle: *mut Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Aborts the CIA install process.\n @param ciaHandle CIA handle to cancel."]
    #[doc = ""]
    pub fn AM_CancelCIAInstall(ciaHandle: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Finalizes the CIA install process.\n @param ciaHandle CIA handle to finalize."]
    #[doc = ""]
    pub fn AM_FinishCiaInstall(ciaHandle: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Finalizes the CIA install process without committing the title to title.db or tmp*.db.\n @param ciaHandle CIA handle to finalize."]
    #[doc = ""]
    pub fn AM_FinishCiaInstallWithoutCommit(ciaHandle: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Commits installed CIAs.\n @param mediaType Location of the titles to finalize.\n @param titleCount Number of titles to finalize.\n @param temp Whether the titles being finalized are in the temporary database.\n @param titleIds Title IDs to finalize."]
    #[doc = ""]
    pub fn AM_CommitImportPrograms(
        mediaType: FS_MediaType,
        titleCount: u32_,
        temp: bool,
        titleIds: *const u64_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Deletes a title.\n @param mediatype Media type to delete from.\n @param titleID ID of the title to delete."]
    #[doc = ""]
    pub fn AM_DeleteTitle(mediatype: FS_MediaType, titleID: u64_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Deletes a title, provided that it is not a system title.\n @param mediatype Media type to delete from.\n @param titleID ID of the title to delete."]
    #[doc = ""]
    pub fn AM_DeleteAppTitle(mediatype: FS_MediaType, titleID: u64_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Deletes a ticket.\n @param titleID ID of the ticket to delete."]
    #[doc = ""]
    pub fn AM_DeleteTicket(ticketId: u64_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Deletes a pending title.\n @param mediatype Media type to delete from.\n @param titleId ID of the pending title to delete."]
    #[doc = ""]
    pub fn AM_DeletePendingTitle(mediatype: FS_MediaType, titleId: u64_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Deletes pending titles.\n @param mediatype Media type to delete from.\n @param flags Flags used to select pending titles."]
    #[doc = ""]
    pub fn AM_DeletePendingTitles(mediatype: FS_MediaType, flags: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Deletes all pending titles.\n @param mediatype Media type to delete from."]
    #[doc = ""]
    pub fn AM_DeleteAllPendingTitles(mediatype: FS_MediaType) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Installs the current NATIVE_FIRM title to NAND (firm0:/ & firm1:/)"]
    #[doc = ""]
    pub fn AM_InstallNativeFirm() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Installs a NATIVE_FIRM title to NAND. Accepts 0004013800000002 or 0004013820000002 (N3DS).\n @param titleID Title ID of the NATIVE_FIRM to install."]
    #[doc = ""]
    pub fn AM_InstallFirm(titleID: u64_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the product code of a title.\n @param mediatype Media type of the title.\n @param titleID ID of the title.\n @param[out] productCode Pointer to output the product code to. (length = 16)"]
    #[doc = ""]
    pub fn AM_GetTitleProductCode(
        mediatype: FS_MediaType,
        titleId: u64_,
        productCode: *mut ::libc::c_char,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the ext data ID of a title.\n @param[out] extDataId Pointer to output the ext data ID to.\n @param mediatype Media type of the title.\n @param titleID ID of the title."]
    #[doc = ""]
    pub fn AM_GetTitleExtDataId(
        extDataId: *mut u64_,
        mediatype: FS_MediaType,
        titleId: u64_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets an AM_TitleEntry instance for a CIA file.\n @param mediatype Media type that this CIA would be installed to.\n @param[out] titleEntry Pointer to write the AM_TitleEntry instance to.\n @param fileHandle Handle of the CIA file."]
    #[doc = ""]
    pub fn AM_GetCiaFileInfo(
        mediatype: FS_MediaType,
        titleEntry: *mut AM_TitleEntry,
        fileHandle: Handle,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the SMDH icon data of a CIA file.\n @param icon Buffer to store the icon data in. Must be of size 0x36C0 bytes.\n @param fileHandle Handle of the CIA file."]
    #[doc = ""]
    pub fn AM_GetCiaIcon(icon: *mut ::libc::c_void, fileHandle: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the title ID dependency list of a CIA file.\n @param dependencies Buffer to store dependency title IDs in. Must be of size 0x300 bytes.\n @param fileHandle Handle of the CIA file."]
    #[doc = ""]
    pub fn AM_GetCiaDependencies(dependencies: *mut u64_, fileHandle: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the meta section offset of a CIA file.\n @param[out] metaOffset Pointer to output the meta section offset to.\n @param fileHandle Handle of the CIA file."]
    #[doc = ""]
    pub fn AM_GetCiaMetaOffset(metaOffset: *mut u64_, fileHandle: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the core version of a CIA file.\n @param[out] coreVersion Pointer to output the core version to.\n @param fileHandle Handle of the CIA file."]
    #[doc = ""]
    pub fn AM_GetCiaCoreVersion(coreVersion: *mut u32_, fileHandle: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the free space, in bytes, required to install a CIA file.\n @param[out] requiredSpace Pointer to output the required free space to.\n @param mediaType Media type to check free space needed to install to.\n @param fileHandle Handle of the CIA file."]
    #[doc = ""]
    pub fn AM_GetCiaRequiredSpace(
        requiredSpace: *mut u64_,
        mediaType: FS_MediaType,
        fileHandle: Handle,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the full meta section of a CIA file.\n @param meta Buffer to store the meta section in.\n @param size Size of the buffer. Must be greater than or equal to the actual section data's size.\n @param fileHandle Handle of the CIA file."]
    #[doc = ""]
    pub fn AM_GetCiaMetaSection(
        meta: *mut ::libc::c_void,
        size: u32_,
        fileHandle: Handle,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initializes the external (SD) title database.\n @param overwrite Overwrites the database if it already exists."]
    #[doc = ""]
    pub fn AM_InitializeExternalTitleDatabase(overwrite: bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Queries whether the external title database is available.\n @param[out] available Pointer to output the availability status to."]
    #[doc = ""]
    pub fn AM_QueryAvailableExternalTitleDatabase(available: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Begins installing a ticket.\n @param[out] ticketHandle Pointer to output a handle to write ticket data to."]
    #[doc = ""]
    pub fn AM_InstallTicketBegin(ticketHandle: *mut Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Aborts installing a ticket.\n @param ticketHandle Handle of the installation to abort."]
    #[doc = ""]
    pub fn AM_InstallTicketAbort(ticketHandle: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Finishes installing a ticket.\n @param ticketHandle Handle of the installation to finalize."]
    #[doc = ""]
    pub fn AM_InstallTicketFinish(ticketHandle: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Begins installing a title.\n @param mediaType Destination to install to.\n @param titleId ID of the title to install.\n @param unk Unknown. (usually false)"]
    #[doc = ""]
    pub fn AM_InstallTitleBegin(mediaType: FS_MediaType, titleId: u64_, unk: bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Stops installing a title, generally to be resumed later."]
    #[doc = ""]
    pub fn AM_InstallTitleStop() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Resumes installing a title.\n @param mediaType Destination to install to.\n @param titleId ID of the title to install."]
    #[doc = ""]
    pub fn AM_InstallTitleResume(mediaType: FS_MediaType, titleId: u64_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Aborts installing a title."]
    #[doc = ""]
    pub fn AM_InstallTitleAbort() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Finishes installing a title."]
    #[doc = ""]
    pub fn AM_InstallTitleFinish() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Commits installed titles.\n @param mediaType Location of the titles to finalize.\n @param titleCount Number of titles to finalize.\n @param temp Whether the titles being finalized are in the temporary database.\n @param titleIds Title IDs to finalize."]
    #[doc = ""]
    pub fn AM_CommitImportTitles(
        mediaType: FS_MediaType,
        titleCount: u32_,
        temp: bool,
        titleIds: *const u64_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Begins installing a TMD.\n @param[out] tmdHandle Pointer to output a handle to write TMD data to."]
    #[doc = ""]
    pub fn AM_InstallTmdBegin(tmdHandle: *mut Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Aborts installing a TMD.\n @param tmdHandle Handle of the installation to abort."]
    #[doc = ""]
    pub fn AM_InstallTmdAbort(tmdHandle: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Finishes installing a TMD.\n @param tmdHandle Handle of the installation to finalize.\n @param unk Unknown. (usually true)"]
    #[doc = ""]
    pub fn AM_InstallTmdFinish(tmdHandle: Handle, unk: bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Prepares to import title contents.\n @param contentCount Number of contents to be imported.\n @param contentIndices Indices of the contents to be imported."]
    #[doc = ""]
    pub fn AM_CreateImportContentContexts(contentCount: u32_, contentIndices: *mut u16_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Begins installing title content.\n @param[out] contentHandle Pointer to output a handle to write content data to.\n @param index Index of the content to install."]
    #[doc = ""]
    pub fn AM_InstallContentBegin(contentHandle: *mut Handle, index: u16_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Stops installing title content, generally to be resumed later.\n @param contentHandle Handle of the installation to abort."]
    #[doc = ""]
    pub fn AM_InstallContentStop(contentHandle: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Resumes installing title content.\n @param[out] contentHandle Pointer to output a handle to write content data to.\n @param[out] resumeOffset Pointer to write the offset to resume content installation at to.\n @param index Index of the content to install."]
    #[doc = ""]
    pub fn AM_InstallContentResume(
        contentHandle: *mut Handle,
        resumeOffset: *mut u64_,
        index: u16_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Cancels installing title content.\n @param contentHandle Handle of the installation to finalize."]
    #[doc = ""]
    pub fn AM_InstallContentCancel(contentHandle: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Finishes installing title content.\n @param contentHandle Handle of the installation to finalize."]
    #[doc = ""]
    pub fn AM_InstallContentFinish(contentHandle: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Imports up to four certificates into the ticket certificate chain.\n @param cert1Size Size of the first certificate.\n @param cert1 Data of the first certificate.\n @param cert2Size Size of the second certificate.\n @param cert2 Data of the second certificate.\n @param cert3Size Size of the third certificate.\n @param cert3 Data of the third certificate.\n @param cert4Size Size of the fourth certificate.\n @param cert4 Data of the fourth certificate."]
    #[doc = ""]
    pub fn AM_ImportCertificates(
        cert1Size: u32_,
        cert1: *mut ::libc::c_void,
        cert2Size: u32_,
        cert2: *mut ::libc::c_void,
        cert3Size: u32_,
        cert3: *mut ::libc::c_void,
        cert4Size: u32_,
        cert4: *mut ::libc::c_void,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Imports a certificate into the ticket certificate chain.\n @param certSize Size of the certificate.\n @param cert Data of the certificate."]
    #[doc = ""]
    pub fn AM_ImportCertificate(certSize: u32_, cert: *mut ::libc::c_void) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Commits installed titles, and updates FIRM if necessary.\n @param mediaType Location of the titles to finalize.\n @param titleCount Number of titles to finalize.\n @param temp Whether the titles being finalized are in the temporary database.\n @param titleIds Title IDs to finalize."]
    #[doc = ""]
    pub fn AM_CommitImportTitlesAndUpdateFirmwareAuto(
        mediaType: FS_MediaType,
        titleCount: u32_,
        temp: bool,
        titleIds: *mut u64_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Resets play count of all installed demos by deleting their launch info."]
    #[doc = ""]
    pub fn AM_DeleteAllDemoLaunchInfos() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Deletes temporary titles."]
    #[doc = ""]
    pub fn AM_DeleteAllTemporaryTitles() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Deletes all expired titles.\n @param mediatype Media type to delete from."]
    #[doc = ""]
    pub fn AM_DeleteAllExpiredTitles(mediatype: FS_MediaType) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Deletes all TWL titles."]
    #[doc = ""]
    pub fn AM_DeleteAllTwlTitles() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the number of content index installed under the specified DLC title.\n @param[out] count Pointer to output the number of content indices to.\n @param mediatype Media type of the title.\n @param titleID Title ID to retrieve the count for (high-id is 0x0004008C)."]
    #[doc = ""]
    pub fn AMAPP_GetDLCContentInfoCount(
        count: *mut u32_,
        mediatype: FS_MediaType,
        titleID: u64_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets content infos installed under the specified DLC title.\n @param[out] contentInfoRead Pointer to output the number of content infos read to.\n @param mediatype Media type of the title.\n @param titleID Title ID to retrieve the content infos for (high-id is 0x0004008C).\n @param contentInfoCount Number of content infos to retrieve.\n @param offset Offset from the first content index the count starts at.\n @param[out] contentInfos Pointer to output the content infos read to."]
    #[doc = ""]
    pub fn AMAPP_ListDLCContentInfos(
        contentInfoRead: *mut u32_,
        mediatype: FS_MediaType,
        titleID: u64_,
        contentInfoCount: u32_,
        offset: u32_,
        contentInfos: *mut AM_ContentInfo,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initializes AMPXI.\n @param servhandle Optional service session handle to use for AMPXI, if zero srvGetServiceHandle() will be used."]
    #[doc = ""]
    pub fn ampxiInit(servhandle: Handle) -> Result;
}
extern "C" {
    #[doc = "Exits AMPXI."]
    #[doc = ""]
    pub fn ampxiExit();
}
extern "C" {
    #[must_use]
    #[doc = "Writes a TWL save-file to NAND. <https://www.3dbrew.org/wiki/AMPXI:WriteTWLSavedata\n> @param titleid ID of the TWL title.\n @param buffer Savedata buffer ptr.\n @param size Size of the savedata buffer.\n @param image_filepos Filepos to use for writing the data to the NAND savedata file.\n @param section_type <https://www.3dbrew.org/wiki/AMPXI:WriteTWLSavedata\n> @param operation <https://3dbrew.org/wiki/AM:ImportDSiWare>"]
    #[doc = ""]
    pub fn AMPXI_WriteTWLSavedata(
        titleid: u64_,
        buffer: *mut u8_,
        size: u32_,
        image_filepos: u32_,
        section_type: u8_,
        operation: u8_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Finalizes title installation. <https://3dbrew.org/wiki/AMPXI:InstallTitlesFinish\n> @param mediaType Mediatype of the titles to finalize.\n @param db Which title database to use.\n @param size Size of the savedata buffer.\n @param titlecount Total titles.\n @param tidlist List of titleIDs."]
    #[doc = ""]
    pub fn AMPXI_InstallTitlesFinish(
        mediaType: FS_MediaType,
        db: u8_,
        titlecount: u32_,
        tidlist: *mut u64_,
    ) -> Result;
}
pub const APPID_NONE: NS_APPID = 0;
#[doc = "Home Menu"]
#[doc = ""]

pub const APPID_HOMEMENU: NS_APPID = 257;
#[doc = "Camera applet"]
#[doc = ""]

pub const APPID_CAMERA: NS_APPID = 272;
#[doc = "Friends List applet"]
#[doc = ""]

pub const APPID_FRIENDS_LIST: NS_APPID = 274;
#[doc = "Game Notes applet"]
#[doc = ""]

pub const APPID_GAME_NOTES: NS_APPID = 275;
#[doc = "Internet Browser"]
#[doc = ""]

pub const APPID_WEB: NS_APPID = 276;
#[doc = "Instruction Manual applet"]
#[doc = ""]

pub const APPID_INSTRUCTION_MANUAL: NS_APPID = 277;
#[doc = "Notifications applet"]
#[doc = ""]

pub const APPID_NOTIFICATIONS: NS_APPID = 278;
#[doc = "Miiverse applet (olv)"]
#[doc = ""]

pub const APPID_MIIVERSE: NS_APPID = 279;
#[doc = "Miiverse posting applet (solv3)"]
#[doc = ""]

pub const APPID_MIIVERSE_POSTING: NS_APPID = 280;
#[doc = "Amiibo settings applet (cabinet)"]
#[doc = ""]

pub const APPID_AMIIBO_SETTINGS: NS_APPID = 281;
#[doc = "Application"]
#[doc = ""]

pub const APPID_APPLICATION: NS_APPID = 768;
#[doc = "eShop (tiger)"]
#[doc = ""]

pub const APPID_ESHOP: NS_APPID = 769;
#[doc = "Software Keyboard"]
#[doc = ""]

pub const APPID_SOFTWARE_KEYBOARD: NS_APPID = 1025;
#[doc = "appletEd"]
#[doc = ""]

pub const APPID_APPLETED: NS_APPID = 1026;
#[doc = "PNOTE_AP"]
#[doc = ""]

pub const APPID_PNOTE_AP: NS_APPID = 1028;
#[doc = "SNOTE_AP"]
#[doc = ""]

pub const APPID_SNOTE_AP: NS_APPID = 1029;
#[doc = "error"]
#[doc = ""]

pub const APPID_ERROR: NS_APPID = 1030;
#[doc = "mint"]
#[doc = ""]

pub const APPID_MINT: NS_APPID = 1031;
#[doc = "extrapad"]
#[doc = ""]

pub const APPID_EXTRAPAD: NS_APPID = 1032;
#[doc = "memolib"]
#[doc = ""]

pub const APPID_MEMOLIB: NS_APPID = 1033;
#[doc = "NS Application IDs.\n\n Retrieved from <http://3dbrew.org/wiki/NS_and_APT_Services#AppIDs>"]
#[doc = ""]

pub type NS_APPID = ::libc::c_uint;
#[doc = "No position specified."]
#[doc = ""]

pub const APTPOS_NONE: APT_AppletPos = -1;
#[doc = "Application."]
#[doc = ""]

pub const APTPOS_APP: APT_AppletPos = 0;
#[doc = "Application library (?)."]
#[doc = ""]

pub const APTPOS_APPLIB: APT_AppletPos = 1;
#[doc = "System applet."]
#[doc = ""]

pub const APTPOS_SYS: APT_AppletPos = 2;
#[doc = "System library (?)."]
#[doc = ""]

pub const APTPOS_SYSLIB: APT_AppletPos = 3;
#[doc = "Resident applet."]
#[doc = ""]

pub const APTPOS_RESIDENT: APT_AppletPos = 4;
#[doc = "APT applet position."]
#[doc = ""]

pub type APT_AppletPos = ::libc::c_int;
pub type APT_AppletAttr = u8_;
pub const APTREPLY_REJECT: APT_QueryReply = 0;
pub const APTREPLY_ACCEPT: APT_QueryReply = 1;
pub const APTREPLY_LATER: APT_QueryReply = 2;
#[doc = "APT query reply."]
#[doc = ""]

pub type APT_QueryReply = ::libc::c_uint;
#[doc = "No signal received."]
#[doc = ""]

pub const APTSIGNAL_NONE: APT_Signal = 0;
#[doc = "HOME button pressed."]
#[doc = ""]

pub const APTSIGNAL_HOMEBUTTON: APT_Signal = 1;
#[doc = "HOME button pressed (again?)."]
#[doc = ""]

pub const APTSIGNAL_HOMEBUTTON2: APT_Signal = 2;
#[doc = "Prepare to enter sleep mode."]
#[doc = ""]

pub const APTSIGNAL_SLEEP_QUERY: APT_Signal = 3;
#[doc = "Triggered when ptm:s GetShellStatus() returns 5."]
#[doc = ""]

pub const APTSIGNAL_SLEEP_CANCEL: APT_Signal = 4;
#[doc = "Enter sleep mode."]
#[doc = ""]

pub const APTSIGNAL_SLEEP_ENTER: APT_Signal = 5;
#[doc = "Wake from sleep mode."]
#[doc = ""]

pub const APTSIGNAL_SLEEP_WAKEUP: APT_Signal = 6;
#[doc = "Shutdown."]
#[doc = ""]

pub const APTSIGNAL_SHUTDOWN: APT_Signal = 7;
#[doc = "POWER button pressed."]
#[doc = ""]

pub const APTSIGNAL_POWERBUTTON: APT_Signal = 8;
#[doc = "POWER button cleared (?)."]
#[doc = ""]

pub const APTSIGNAL_POWERBUTTON2: APT_Signal = 9;
#[doc = "System sleeping (?)."]
#[doc = ""]

pub const APTSIGNAL_TRY_SLEEP: APT_Signal = 10;
#[doc = "Order to close (such as when an error happens?)."]
#[doc = ""]

pub const APTSIGNAL_ORDERTOCLOSE: APT_Signal = 11;
#[doc = "APT signals."]
#[doc = ""]

pub type APT_Signal = ::libc::c_uint;
#[doc = "No command received."]
#[doc = ""]

pub const APTCMD_NONE: APT_Command = 0;
#[doc = "Applet should wake up."]
#[doc = ""]

pub const APTCMD_WAKEUP: APT_Command = 1;
#[doc = "Source applet sent us a parameter."]
#[doc = ""]

pub const APTCMD_REQUEST: APT_Command = 2;
#[doc = "Target applet replied to our parameter."]
#[doc = ""]

pub const APTCMD_RESPONSE: APT_Command = 3;
#[doc = "Exit (??)"]
#[doc = ""]

pub const APTCMD_EXIT: APT_Command = 4;
#[doc = "Message (??)"]
#[doc = ""]

pub const APTCMD_MESSAGE: APT_Command = 5;
#[doc = "HOME button pressed once."]
#[doc = ""]

pub const APTCMD_HOMEBUTTON_ONCE: APT_Command = 6;
#[doc = "HOME button pressed twice (double-pressed)."]
#[doc = ""]

pub const APTCMD_HOMEBUTTON_TWICE: APT_Command = 7;
#[doc = "DSP should sleep (manual DSP rights related?)."]
#[doc = ""]

pub const APTCMD_DSP_SLEEP: APT_Command = 8;
#[doc = "DSP should wake up (manual DSP rights related?)."]
#[doc = ""]

pub const APTCMD_DSP_WAKEUP: APT_Command = 9;
#[doc = "Applet wakes up due to a different applet exiting."]
#[doc = ""]

pub const APTCMD_WAKEUP_EXIT: APT_Command = 10;
#[doc = "Applet wakes up after being paused through HOME menu."]
#[doc = ""]

pub const APTCMD_WAKEUP_PAUSE: APT_Command = 11;
#[doc = "Applet wakes up due to being cancelled."]
#[doc = ""]

pub const APTCMD_WAKEUP_CANCEL: APT_Command = 12;
#[doc = "Applet wakes up due to all applets being cancelled."]
#[doc = ""]

pub const APTCMD_WAKEUP_CANCELALL: APT_Command = 13;
#[doc = "Applet wakes up due to POWER button being pressed (?)."]
#[doc = ""]

pub const APTCMD_WAKEUP_POWERBUTTON: APT_Command = 14;
#[doc = "Applet wakes up and is instructed to jump to HOME menu (?)."]
#[doc = ""]

pub const APTCMD_WAKEUP_JUMPTOHOME: APT_Command = 15;
#[doc = "Request for sysapplet (?)."]
#[doc = ""]

pub const APTCMD_SYSAPPLET_REQUEST: APT_Command = 16;
#[doc = "Applet wakes up and is instructed to launch another applet (?)."]
#[doc = ""]

pub const APTCMD_WAKEUP_LAUNCHAPP: APT_Command = 17;
#[doc = "APT commands."]
#[doc = ""]

pub type APT_Command = ::libc::c_uint;
#[doc = "APT capture buffer information."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct aptCaptureBufInfo {
    pub size: u32_,
    pub is3D: u32_,
    pub top: aptCaptureBufInfo__bindgen_ty_1,
    pub bottom: aptCaptureBufInfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct aptCaptureBufInfo__bindgen_ty_1 {
    pub leftOffset: u32_,
    pub rightOffset: u32_,
    pub format: u32_,
}
#[doc = "App suspended."]
#[doc = ""]

pub const APTHOOK_ONSUSPEND: APT_HookType = 0;
#[doc = "App restored."]
#[doc = ""]

pub const APTHOOK_ONRESTORE: APT_HookType = 1;
#[doc = "App sleeping."]
#[doc = ""]

pub const APTHOOK_ONSLEEP: APT_HookType = 2;
#[doc = "App waking up."]
#[doc = ""]

pub const APTHOOK_ONWAKEUP: APT_HookType = 3;
#[doc = "App exiting."]
#[doc = ""]

pub const APTHOOK_ONEXIT: APT_HookType = 4;
#[doc = "Number of APT hook types."]
#[doc = ""]

pub const APTHOOK_COUNT: APT_HookType = 5;
#[doc = "APT hook types."]
#[doc = ""]

pub type APT_HookType = ::libc::c_uint;
#[doc = "APT hook function."]
#[doc = ""]

pub type aptHookFn =
    ::core::option::Option<unsafe extern "C" fn(hook: APT_HookType, param: *mut ::libc::c_void)>;
#[doc = "APT hook cookie."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tag_aptHookCookie {
    #[doc = "Next cookie."]
    #[doc = ""]
    pub next: *mut tag_aptHookCookie,
    #[doc = "Hook callback."]
    #[doc = ""]
    pub callback: aptHookFn,
    #[doc = "Callback parameter."]
    #[doc = ""]
    pub param: *mut ::libc::c_void,
}
impl Default for tag_aptHookCookie {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "APT hook cookie."]
#[doc = ""]

pub type aptHookCookie = tag_aptHookCookie;
#[doc = "APT message callback."]
#[doc = ""]

pub type aptMessageCb = ::core::option::Option<
    unsafe extern "C" fn(
        user: *mut ::libc::c_void,
        sender: NS_APPID,
        msg: *mut ::libc::c_void,
        msgsize: usize,
    ),
>;
extern "C" {
    #[must_use]
    #[doc = "Initializes APT."]
    #[doc = ""]
    pub fn aptInit() -> Result;
}
extern "C" {
    #[doc = "Exits APT."]
    #[doc = ""]
    pub fn aptExit();
}
extern "C" {
    #[must_use]
    #[doc = "Sends an APT command through IPC, taking care of locking, opening and closing an APT session.\n @param aptcmdbuf Pointer to command buffer (should have capacity for at least 16 words)."]
    #[doc = ""]
    pub fn aptSendCommand(aptcmdbuf: *mut u32_) -> Result;
}
extern "C" {
    #[doc = "Returns true if the application is currently in the foreground."]
    #[doc = ""]
    pub fn aptIsActive() -> bool;
}
extern "C" {
    #[doc = "Returns true if the system has told the application to close."]
    #[doc = ""]
    pub fn aptShouldClose() -> bool;
}
extern "C" {
    #[doc = "Returns true if the system can enter sleep mode while the application is active."]
    #[doc = ""]
    pub fn aptIsSleepAllowed() -> bool;
}
extern "C" {
    #[doc = "Configures whether the system can enter sleep mode while the application is active."]
    #[doc = ""]
    pub fn aptSetSleepAllowed(allowed: bool);
}
extern "C" {
    #[doc = "Handles incoming sleep mode requests."]
    #[doc = ""]
    pub fn aptHandleSleep();
}
extern "C" {
    #[doc = "Returns true if the user can press the HOME button to jump back to the HOME menu while the application is active."]
    #[doc = ""]
    pub fn aptIsHomeAllowed() -> bool;
}
extern "C" {
    #[doc = "Configures whether the user can press the HOME button to jump back to the HOME menu while the application is active."]
    #[doc = ""]
    pub fn aptSetHomeAllowed(allowed: bool);
}
extern "C" {
    #[doc = "Returns true if the system requires the application to jump back to the HOME menu."]
    #[doc = ""]
    pub fn aptShouldJumpToHome() -> bool;
}
extern "C" {
    #[doc = "Returns true if there is an incoming HOME button press rejected by the policy set by [`aptSetHomeAllowed`] (use this to show a \"no HOME allowed\" icon)."]
    #[doc = ""]
    pub fn aptCheckHomePressRejected() -> bool;
}
extern "C" {
    #[doc = "Jumps back to the HOME menu."]
    #[doc = ""]
    pub fn aptJumpToHomeMenu();
}
extern "C" {
    #[doc = "Main function which handles sleep mode and HOME/power buttons - call this at the beginning of every frame.\n @return true if the application should keep running, false otherwise (see [`aptShouldClose)`]"]
    #[doc = ""]
    pub fn aptMainLoop() -> bool;
}
extern "C" {
    #[doc = "Sets up an APT status hook.\n @param cookie Hook cookie to use.\n @param callback Function to call when APT's status changes.\n @param param User-defined parameter to pass to the callback."]
    #[doc = ""]
    pub fn aptHook(cookie: *mut aptHookCookie, callback: aptHookFn, param: *mut ::libc::c_void);
}
extern "C" {
    #[doc = "Removes an APT status hook.\n @param cookie Hook cookie to remove."]
    #[doc = ""]
    pub fn aptUnhook(cookie: *mut aptHookCookie);
}
extern "C" {
    #[doc = "Sets the function to be called when an APT message from another applet is received.\n @param callback Callback function.\n @param user User-defined data to be passed to the callback."]
    #[doc = ""]
    pub fn aptSetMessageCallback(callback: aptMessageCb, user: *mut ::libc::c_void);
}
extern "C" {
    #[doc = "Launches a library applet.\n @param appId ID of the applet to launch.\n @param buf Input/output buffer that contains launch parameters on entry and result data on exit.\n @param bufsize Size of the buffer.\n @param handle Handle to pass to the library applet."]
    #[doc = ""]
    pub fn aptLaunchLibraryApplet(
        appId: NS_APPID,
        buf: *mut ::libc::c_void,
        bufsize: usize,
        handle: Handle,
    );
}
extern "C" {
    #[doc = "Clears the chainloader state."]
    #[doc = ""]
    pub fn aptClearChainloader();
}
extern "C" {
    #[doc = "Configures the chainloader to launch a specific application.\n @param programID ID of the program to chainload to.\n @param mediatype Media type of the program to chainload to."]
    #[doc = ""]
    pub fn aptSetChainloader(programID: u64_, mediatype: u8_);
}
extern "C" {
    #[doc = "Configures the chainloader to relaunch the current application (i.e. soft-reset)"]
    #[doc = ""]
    pub fn aptSetChainloaderToSelf();
}
extern "C" {
    #[must_use]
    #[doc = "Gets an APT lock handle.\n @param flags Flags to use.\n @param lockHandle Pointer to output the lock handle to."]
    #[doc = ""]
    pub fn APT_GetLockHandle(flags: u16_, lockHandle: *mut Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initializes an application's registration with APT.\n @param appId ID of the application.\n @param attr Attributes of the application.\n @param signalEvent Pointer to output the signal event handle to.\n @param resumeEvent Pointer to output the resume event handle to."]
    #[doc = ""]
    pub fn APT_Initialize(
        appId: NS_APPID,
        attr: APT_AppletAttr,
        signalEvent: *mut Handle,
        resumeEvent: *mut Handle,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Terminates an application's registration with APT.\n @param appID ID of the application."]
    #[doc = ""]
    pub fn APT_Finalize(appId: NS_APPID) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Asynchronously resets the hardware."]
    #[doc = ""]
    pub fn APT_HardwareResetAsync() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Enables APT.\n @param attr Attributes of the application."]
    #[doc = ""]
    pub fn APT_Enable(attr: APT_AppletAttr) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets applet management info.\n @param inpos Requested applet position.\n @param outpos Pointer to output the position of the current applet to.\n @param req_appid Pointer to output the AppID of the applet at the requested position to.\n @param menu_appid Pointer to output the HOME menu AppID to.\n @param active_appid Pointer to output the AppID of the currently active applet to."]
    #[doc = ""]
    pub fn APT_GetAppletManInfo(
        inpos: APT_AppletPos,
        outpos: *mut APT_AppletPos,
        req_appid: *mut NS_APPID,
        menu_appid: *mut NS_APPID,
        active_appid: *mut NS_APPID,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets an applet's information.\n @param appID AppID of the applet.\n @param pProgramID Pointer to output the program ID to.\n @param pMediaType Pointer to output the media type to.\n @param pRegistered Pointer to output the registration status to.\n @param pLoadState Pointer to output the load state to.\n @param pAttributes Pointer to output the applet atrributes to."]
    #[doc = ""]
    pub fn APT_GetAppletInfo(
        appID: NS_APPID,
        pProgramID: *mut u64_,
        pMediaType: *mut u8_,
        pRegistered: *mut bool,
        pLoadState: *mut bool,
        pAttributes: *mut APT_AppletAttr,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets an applet's program information.\n @param id ID of the applet.\n @param flags Flags to use when retreiving the information.\n @param titleversion Pointer to output the applet's title version to.\n\n Flags:\n - 0x01: Use AM_ListTitles with NAND media type.\n - 0x02: Use AM_ListTitles with SDMC media type.\n - 0x04: Use AM_ListTitles with GAMECARD media type.\n - 0x10: Input ID is an app ID. Must be set if 0x20 is not.\n - 0x20: Input ID is a program ID. Must be set if 0x10 is not.\n - 0x100: Sets program ID high to 0x00040000, else it is 0x00040010. Only used when 0x20 is set."]
    #[doc = ""]
    pub fn APT_GetAppletProgramInfo(id: u32_, flags: u32_, titleversion: *mut u16_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the current application's program ID.\n @param pProgramID Pointer to output the program ID to."]
    #[doc = ""]
    pub fn APT_GetProgramID(pProgramID: *mut u64_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Prepares to jump to the home menu."]
    #[doc = ""]
    pub fn APT_PrepareToJumpToHomeMenu() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Jumps to the home menu.\n @param param Parameters to jump with.\n @param Size of the parameter buffer.\n @param handle Handle to pass."]
    #[doc = ""]
    pub fn APT_JumpToHomeMenu(
        param: *const ::libc::c_void,
        paramSize: usize,
        handle: Handle,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Prepares to jump to an application.\n @param exiting Specifies whether the applet is exiting."]
    #[doc = ""]
    pub fn APT_PrepareToJumpToApplication(exiting: bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Jumps to an application.\n @param param Parameters to jump with.\n @param Size of the parameter buffer.\n @param handle Handle to pass."]
    #[doc = ""]
    pub fn APT_JumpToApplication(
        param: *const ::libc::c_void,
        paramSize: usize,
        handle: Handle,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets whether an application is registered.\n @param appID ID of the application.\n @param out Pointer to output the registration state to."]
    #[doc = ""]
    pub fn APT_IsRegistered(appID: NS_APPID, out: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Inquires as to whether a signal has been received.\n @param appID ID of the application.\n @param signalType Pointer to output the signal type to."]
    #[doc = ""]
    pub fn APT_InquireNotification(appID: u32_, signalType: *mut APT_Signal) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Requests to enter sleep mode, and later sets wake events if allowed to.\n @param wakeEvents The wake events. Limited to \"shell\" (bit 1) for the PDN wake events part\n and \"shell opened\", \"shell closed\" and \"HOME button pressed\" for the MCU interrupts part."]
    #[doc = ""]
    pub fn APT_SleepSystem(wakeEvents: *const PtmWakeEvents) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Notifies an application to wait.\n @param appID ID of the application."]
    #[doc = ""]
    pub fn APT_NotifyToWait(appID: NS_APPID) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Calls an applet utility function.\n @param id Utility function to call.\n @param out Pointer to write output data to.\n @param outSize Size of the output buffer.\n @param in Pointer to the input data.\n @param inSize Size of the input buffer."]
    #[doc = ""]
    pub fn APT_AppletUtility(
        id: ::libc::c_int,
        out: *mut ::libc::c_void,
        outSize: usize,
        in_: *const ::libc::c_void,
        inSize: usize,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sleeps if shell is closed (?)."]
    #[doc = ""]
    pub fn APT_SleepIfShellClosed() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Locks a transition (?).\n @param transition Transition ID.\n @param flag Flag (?)"]
    #[doc = ""]
    pub fn APT_LockTransition(transition: u32_, flag: bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Tries to lock a transition (?).\n @param transition Transition ID.\n @param succeeded Pointer to output whether the lock was successfully applied."]
    #[doc = ""]
    pub fn APT_TryLockTransition(transition: u32_, succeeded: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Unlocks a transition (?).\n @param transition Transition ID."]
    #[doc = ""]
    pub fn APT_UnlockTransition(transition: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Glances at a receieved parameter without removing it from the queue.\n @param appID AppID of the application.\n @param buffer Buffer to receive to.\n @param bufferSize Size of the buffer.\n @param sender Pointer to output the sender's AppID to.\n @param command Pointer to output the command ID to.\n @param actualSize Pointer to output the actual received data size to.\n @param parameter Pointer to output the parameter handle to."]
    #[doc = ""]
    pub fn APT_GlanceParameter(
        appID: NS_APPID,
        buffer: *mut ::libc::c_void,
        bufferSize: usize,
        sender: *mut NS_APPID,
        command: *mut APT_Command,
        actualSize: *mut usize,
        parameter: *mut Handle,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Receives a parameter.\n @param appID AppID of the application.\n @param buffer Buffer to receive to.\n @param bufferSize Size of the buffer.\n @param sender Pointer to output the sender's AppID to.\n @param command Pointer to output the command ID to.\n @param actualSize Pointer to output the actual received data size to.\n @param parameter Pointer to output the parameter handle to."]
    #[doc = ""]
    pub fn APT_ReceiveParameter(
        appID: NS_APPID,
        buffer: *mut ::libc::c_void,
        bufferSize: usize,
        sender: *mut NS_APPID,
        command: *mut APT_Command,
        actualSize: *mut usize,
        parameter: *mut Handle,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sends a parameter.\n @param source AppID of the source application.\n @param dest AppID of the destination application.\n @param command Command to send.\n @param buffer Buffer to send.\n @param bufferSize Size of the buffer.\n @param parameter Parameter handle to pass."]
    #[doc = ""]
    pub fn APT_SendParameter(
        source: NS_APPID,
        dest: NS_APPID,
        command: APT_Command,
        buffer: *const ::libc::c_void,
        bufferSize: u32_,
        parameter: Handle,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Cancels a parameter which matches the specified source and dest AppIDs.\n @param source AppID of the source application (use APPID_NONE to disable the check).\n @param dest AppID of the destination application (use APPID_NONE to disable the check).\n @param success Pointer to output true if a parameter was cancelled, or false otherwise."]
    #[doc = ""]
    pub fn APT_CancelParameter(source: NS_APPID, dest: NS_APPID, success: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sends capture buffer information.\n @param captureBuf Capture buffer information to send."]
    #[doc = ""]
    pub fn APT_SendCaptureBufferInfo(captureBuf: *const aptCaptureBufInfo) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Replies to a sleep query.\n @param appID ID of the application.\n @param reply Query reply value."]
    #[doc = ""]
    pub fn APT_ReplySleepQuery(appID: NS_APPID, reply: APT_QueryReply) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Replies that a sleep notification has been completed.\n @param appID ID of the application."]
    #[doc = ""]
    pub fn APT_ReplySleepNotificationComplete(appID: NS_APPID) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Prepares to close the application.\n @param cancelPreload Whether applet preloads should be cancelled."]
    #[doc = ""]
    pub fn APT_PrepareToCloseApplication(cancelPreload: bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Closes the application.\n @param param Parameters to close with.\n @param paramSize Size of param.\n @param handle Handle to pass."]
    #[doc = ""]
    pub fn APT_CloseApplication(
        param: *const ::libc::c_void,
        paramSize: usize,
        handle: Handle,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the application's CPU time limit.\n @param percent CPU time limit percentage to set."]
    #[doc = ""]
    pub fn APT_SetAppCpuTimeLimit(percent: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the application's CPU time limit.\n @param percent Pointer to output the CPU time limit percentage to."]
    #[doc = ""]
    pub fn APT_GetAppCpuTimeLimit(percent: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Checks whether the system is a New 3DS.\n @param out Pointer to write the New 3DS flag to."]
    #[doc = ""]
    pub fn APT_CheckNew3DS(out: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Prepares for an applicaton jump.\n @param flags Flags to use.\n @param programID ID of the program to jump to.\n @param mediatype Media type of the program to jump to."]
    #[doc = ""]
    pub fn APT_PrepareToDoApplicationJump(flags: u8_, programID: u64_, mediatype: u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Performs an application jump.\n @param param Parameter buffer.\n @param paramSize Size of parameter buffer.\n @param hmac HMAC buffer (should be 0x20 bytes long)."]
    #[doc = ""]
    pub fn APT_DoApplicationJump(
        param: *const ::libc::c_void,
        paramSize: usize,
        hmac: *const ::libc::c_void,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Prepares to start a library applet.\n @param appID AppID of the applet to start."]
    #[doc = ""]
    pub fn APT_PrepareToStartLibraryApplet(appID: NS_APPID) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Starts a library applet.\n @param appID AppID of the applet to launch.\n @param param Buffer containing applet parameters.\n @param paramsize Size of the buffer.\n @param handle Handle to pass to the applet."]
    #[doc = ""]
    pub fn APT_StartLibraryApplet(
        appID: NS_APPID,
        param: *const ::libc::c_void,
        paramSize: usize,
        handle: Handle,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Prepares to start a system applet.\n @param appID AppID of the applet to start."]
    #[doc = ""]
    pub fn APT_PrepareToStartSystemApplet(appID: NS_APPID) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Starts a system applet.\n @param appID AppID of the applet to launch.\n @param param Buffer containing applet parameters.\n @param paramSize Size of the parameter buffer.\n @param handle Handle to pass to the applet."]
    #[doc = ""]
    pub fn APT_StartSystemApplet(
        appID: NS_APPID,
        param: *const ::libc::c_void,
        paramSize: usize,
        handle: Handle,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Retrieves the shared system font.\n @brief fontHandle Pointer to write the handle of the system font memory block to.\n @brief mapAddr Pointer to write the mapping address of the system font memory block to."]
    #[doc = ""]
    pub fn APT_GetSharedFont(fontHandle: *mut Handle, mapAddr: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Receives the deliver (launch) argument\n @param param Parameter buffer.\n @param paramSize Size of parameter buffer.\n @param hmac HMAC buffer (should be 0x20 bytes long).\n @param sender Pointer to output the sender's AppID to.\n @param received Pointer to output whether an argument was received to."]
    #[doc = ""]
    pub fn APT_ReceiveDeliverArg(
        param: *const ::libc::c_void,
        paramSize: usize,
        hmac: *const ::libc::c_void,
        sender: *mut u64_,
        received: *mut bool,
    ) -> Result;
}
#[doc = "BOSS context."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bossContext {
    pub property: [u32_; 7usize],
    pub url: [::libc::c_char; 512usize],
    pub property_x8: u32_,
    pub property_x9: u8_,
    pub property_xa: [u8_; 256usize],
    pub property_xb: [u8_; 512usize],
    pub property_xd: [::libc::c_char; 864usize],
    pub property_xe: u32_,
    pub property_xf: [u32_; 3usize],
    pub property_x10: u8_,
    pub property_x11: u8_,
    pub property_x12: u8_,
    pub property_x13: u32_,
    pub property_x14: u32_,
    pub property_x15: [u8_; 64usize],
    pub property_x16: u32_,
    pub property_x3b: u32_,
    pub property_x3e: [u8_; 512usize],
}
impl Default for bossContext {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const BOSSTASKSTATUS_STARTED: bossTaskStatus = 2;
pub const BOSSTASKSTATUS_ERROR: bossTaskStatus = 7;
#[doc = "BOSS task status."]
#[doc = ""]

pub type bossTaskStatus = ::libc::c_uint;
pub const bossNsDataHeaderInfoType_ContentSize: bossNsDataHeaderInfoTypes = 3;
#[doc = "Type values for bossGetNsDataHeaderInfo()."]
#[doc = ""]

pub type bossNsDataHeaderInfoTypes = ::libc::c_uint;
pub const bossNsDataHeaderInfoTypeSize_ContentSize: bossNsDataHeaderInfoTypeSizes = 4;
#[doc = "Size of the output data for bossGetNsDataHeaderInfo()."]
#[doc = ""]

pub type bossNsDataHeaderInfoTypeSizes = ::libc::c_uint;
extern "C" {
    #[must_use]
    #[doc = "Initializes BOSS.\n @param programID programID to use, 0 for the current process. Only used when BOSSP is available without *hax payload.\n @param force_user When true, just use bossU instead of trying to initialize with bossP first."]
    #[doc = ""]
    pub fn bossInit(programID: u64_, force_user: bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Run the InitializeSession service cmd. This is mainly for changing the programID associated with the current BOSS session.\n @param programID programID to use, 0 for the current process."]
    #[doc = ""]
    pub fn bossReinit(programID: u64_) -> Result;
}
extern "C" {
    #[doc = "Exits BOSS."]
    #[doc = ""]
    pub fn bossExit();
}
extern "C" {
    #[doc = "Returns the BOSS session handle."]
    #[doc = ""]
    pub fn bossGetSessionHandle() -> Handle;
}
extern "C" {
    #[must_use]
    #[doc = "Set the content data storage location.\n @param extdataID u64 extdataID, must have the high word set to the shared-extdata value when it's for NAND.\n @param boss_size Probably the max size in the extdata which BOSS can use.\n @param mediaType Roughly the same as FS mediatype."]
    #[doc = ""]
    pub fn bossSetStorageInfo(extdataID: u64_, boss_size: u32_, mediaType: u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Unregister the content data storage location, which includes unregistering the BOSS-session programID with BOSS."]
    #[doc = ""]
    pub fn bossUnregisterStorage() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Register a task.\n @param taskID BOSS taskID.\n @param unk0 Unknown, usually zero.\n @param unk1 Unknown, usually zero."]
    #[doc = ""]
    pub fn bossRegisterTask(taskID: *const ::libc::c_char, unk0: u8_, unk1: u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Send a property.\n @param PropertyID PropertyID\n @param buf Input buffer data.\n @param size Buffer size."]
    #[doc = ""]
    pub fn bossSendProperty(PropertyID: u16_, buf: *const ::libc::c_void, size: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Deletes the content file for the specified NsDataId.\n @param NsDataId NsDataId"]
    #[doc = ""]
    pub fn bossDeleteNsData(NsDataId: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets header info for the specified NsDataId.\n @param NsDataId NsDataId\n @param type Type of data to load.\n @param buffer Output buffer.\n @param size Output buffer size."]
    #[doc = ""]
    pub fn bossGetNsDataHeaderInfo(
        NsDataId: u32_,
        type_: u8_,
        buffer: *mut ::libc::c_void,
        size: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Reads data from the content for the specified NsDataId.\n @param NsDataId NsDataId\n @param offset Offset in the content.\n @param buffer Output buffer.\n @param size Output buffer size.\n @param transfer_total Optional output actual read size, can be NULL.\n @param unk_out Optional unknown output, can be NULL."]
    #[doc = ""]
    pub fn bossReadNsData(
        NsDataId: u32_,
        offset: u64_,
        buffer: *mut ::libc::c_void,
        size: u32_,
        transfer_total: *mut u32_,
        unk_out: *mut u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Starts a task soon after running this command.\n @param taskID BOSS taskID."]
    #[doc = ""]
    pub fn bossStartTaskImmediate(taskID: *const ::libc::c_char) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Similar to bossStartTaskImmediate?\n @param taskID BOSS taskID."]
    #[doc = ""]
    pub fn bossStartBgImmediate(taskID: *const ::libc::c_char) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Deletes a task by using CancelTask and UnregisterTask internally.\n @param taskID BOSS taskID.\n @param unk Unknown, usually zero?"]
    #[doc = ""]
    pub fn bossDeleteTask(taskID: *const ::libc::c_char, unk: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Returns task state.\n @param taskID BOSS taskID.\n @param inval Unknown, normally 0?\n @param status Output status, see bossTaskStatus.\n @param out1 Output field.\n @param out2 Output field."]
    #[doc = ""]
    pub fn bossGetTaskState(
        taskID: *const ::libc::c_char,
        inval: s8,
        status: *mut u8_,
        out1: *mut u32_,
        out2: *mut u8_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "This loads the current state of PropertyID 0x0 for the specified task.\n @param taskID BOSS taskID."]
    #[doc = ""]
    pub fn bossGetTaskProperty0(taskID: *const ::libc::c_char, out: *mut u8_) -> Result;
}
extern "C" {
    #[doc = "Setup a BOSS context with the default config.\n @param bossContext BOSS context.\n @param seconds_interval Interval in seconds for running the task automatically.\n @param url Task URL."]
    #[doc = ""]
    pub fn bossSetupContextDefault(
        ctx: *mut bossContext,
        seconds_interval: u32_,
        url: *const ::libc::c_char,
    );
}
extern "C" {
    #[must_use]
    #[doc = "Sends the config stored in the context. Used before registering a task.\n @param bossContext BOSS context."]
    #[doc = ""]
    pub fn bossSendContextConfig(ctx: *mut bossContext) -> Result;
}
#[doc = "8-bit per component, planar YUV 4:2:2, 16bpp, (1 Cr & Cb sample per 2x1 Y samples).\\n Usually named YUV422P."]
#[doc = ""]

pub const INPUT_YUV422_INDIV_8: Y2RU_InputFormat = 0;
#[doc = "8-bit per component, planar YUV 4:2:0, 12bpp, (1 Cr & Cb sample per 2x2 Y samples).\\n Usually named YUV420P."]
#[doc = ""]

pub const INPUT_YUV420_INDIV_8: Y2RU_InputFormat = 1;
#[doc = "16-bit per component, planar YUV 4:2:2, 32bpp, (1 Cr & Cb sample per 2x1 Y samples).\\n Usually named YUV422P16."]
#[doc = ""]

pub const INPUT_YUV422_INDIV_16: Y2RU_InputFormat = 2;
#[doc = "16-bit per component, planar YUV 4:2:0, 24bpp, (1 Cr & Cb sample per 2x2 Y samples).\\n Usually named YUV420P16."]
#[doc = ""]

pub const INPUT_YUV420_INDIV_16: Y2RU_InputFormat = 3;
#[doc = "8-bit per component, packed YUV 4:2:2, 16bpp, (Y0 Cb Y1 Cr).\\n Usually named YUYV422."]
#[doc = ""]

pub const INPUT_YUV422_BATCH: Y2RU_InputFormat = 4;
#[doc = "Input color formats\n\n For the 16-bit per component formats, bits 15-8 are padding and 7-0 contains the value."]
#[doc = ""]

pub type Y2RU_InputFormat = ::libc::c_uint;
#[doc = "32-bit RGBA8888. The alpha component is the 8-bit value set by [`Y2RU_SetAlpha`]"]
#[doc = ""]

pub const OUTPUT_RGB_32: Y2RU_OutputFormat = 0;
#[doc = "24-bit RGB888."]
#[doc = ""]

pub const OUTPUT_RGB_24: Y2RU_OutputFormat = 1;
#[doc = "16-bit RGBA5551. The alpha bit is the 7th bit of the alpha value set by [`Y2RU_SetAlpha`]"]
#[doc = ""]

pub const OUTPUT_RGB_16_555: Y2RU_OutputFormat = 2;
#[doc = "16-bit RGB565."]
#[doc = ""]

pub const OUTPUT_RGB_16_565: Y2RU_OutputFormat = 3;
#[doc = "Output color formats\n\n Those are the same as the framebuffer and GPU texture formats."]
#[doc = ""]

pub type Y2RU_OutputFormat = ::libc::c_uint;
#[doc = "No rotation."]
#[doc = ""]

pub const ROTATION_NONE: Y2RU_Rotation = 0;
#[doc = "Clockwise 90 degrees."]
#[doc = ""]

pub const ROTATION_CLOCKWISE_90: Y2RU_Rotation = 1;
#[doc = "Clockwise 180 degrees."]
#[doc = ""]

pub const ROTATION_CLOCKWISE_180: Y2RU_Rotation = 2;
#[doc = "Clockwise 270 degrees."]
#[doc = ""]

pub const ROTATION_CLOCKWISE_270: Y2RU_Rotation = 3;
#[doc = "Rotation to be applied to the output."]
#[doc = ""]

pub type Y2RU_Rotation = ::libc::c_uint;
#[doc = "The result buffer will be laid out in linear format, the usual way."]
#[doc = ""]

pub const BLOCK_LINE: Y2RU_BlockAlignment = 0;
#[doc = "The result will be stored as 8x8 blocks in Z-order.\\n Useful for textures since it is the format used by the PICA200."]
#[doc = ""]

pub const BLOCK_8_BY_8: Y2RU_BlockAlignment = 1;
#[doc = "Block alignment of output\n\n Defines the way the output will be laid out in memory."]
#[doc = ""]

pub type Y2RU_BlockAlignment = ::libc::c_uint;
#[doc = "Coefficients of the YUV->RGB conversion formula.\n\n A set of coefficients configuring the RGB to YUV conversion. Coefficients 0-4 are unsigned 2.8\n fixed pointer numbers representing entries on the conversion matrix, while coefficient 5-7 are\n signed 11.5 fixed point numbers added as offsets to the RGB result.\n\n The overall conversion process formula is:\n ``` R = trunc((rgb_Y * Y + r_V * V) + 0.75 + r_offset)\n G = trunc((rgb_Y * Y - g_U * U - g_V * V) + 0.75 + g_offset)\n B = trunc((rgb_Y * Y + b_U * U ) + 0.75 + b_offset)\n ```"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Y2RU_ColorCoefficients {
    #[doc = "RGB per unit Y."]
    #[doc = ""]
    pub rgb_Y: u16_,
    #[doc = "Red per unit V."]
    #[doc = ""]
    pub r_V: u16_,
    #[doc = "Green per unit V."]
    #[doc = ""]
    pub g_V: u16_,
    #[doc = "Green per unit U."]
    #[doc = ""]
    pub g_U: u16_,
    #[doc = "Blue per unit U."]
    #[doc = ""]
    pub b_U: u16_,
    #[doc = "Red offset."]
    #[doc = ""]
    pub r_offset: u16_,
    #[doc = "Green offset."]
    #[doc = ""]
    pub g_offset: u16_,
    #[doc = "Blue offset."]
    #[doc = ""]
    pub b_offset: u16_,
}
#[doc = "Coefficients from the ITU-R BT.601 standard with PC ranges."]
#[doc = ""]

pub const COEFFICIENT_ITU_R_BT_601: Y2RU_StandardCoefficient = 0;
#[doc = "Coefficients from the ITU-R BT.709 standard with PC ranges."]
#[doc = ""]

pub const COEFFICIENT_ITU_R_BT_709: Y2RU_StandardCoefficient = 1;
#[doc = "Coefficients from the ITU-R BT.601 standard with TV ranges."]
#[doc = ""]

pub const COEFFICIENT_ITU_R_BT_601_SCALING: Y2RU_StandardCoefficient = 2;
#[doc = "Coefficients from the ITU-R BT.709 standard with TV ranges."]
#[doc = ""]

pub const COEFFICIENT_ITU_R_BT_709_SCALING: Y2RU_StandardCoefficient = 3;
#[doc = "Preset conversion coefficients based on ITU standards for the YUV->RGB formula.\n\n For more details refer to [`Y2RU_ColorCoefficients`]"]
#[doc = ""]

pub type Y2RU_StandardCoefficient = ::libc::c_uint;
#[doc = "Structure used to configure all parameters at once.\n\n You can send a batch of configuration parameters using this structure and [`Y2RU_SetConversionParams`]"]
#[doc = ""]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct Y2RU_ConversionParams {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "Value passed to [`Y2RU_SetInputLineWidth`]"]
    #[doc = ""]
    pub input_line_width: s16,
    #[doc = "Value passed to [`Y2RU_SetInputLines`]"]
    #[doc = ""]
    pub input_lines: s16,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "Unused."]
    #[doc = ""]
    pub unused: u8_,
    #[doc = "Value passed to [`Y2RU_SetAlpha`]"]
    #[doc = ""]
    pub alpha: u16_,
}
impl Default for Y2RU_ConversionParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Y2RU_ConversionParams {
    #[inline]
    pub fn input_format(&self) -> Y2RU_InputFormat {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_input_format(&mut self, val: Y2RU_InputFormat) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn output_format(&self) -> Y2RU_OutputFormat {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_output_format(&mut self, val: Y2RU_OutputFormat) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn rotation(&self) -> Y2RU_Rotation {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_rotation(&mut self, val: Y2RU_Rotation) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn block_alignment(&self) -> Y2RU_BlockAlignment {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_block_alignment(&mut self, val: Y2RU_BlockAlignment) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        input_format: Y2RU_InputFormat,
        output_format: Y2RU_OutputFormat,
        rotation: Y2RU_Rotation,
        block_alignment: Y2RU_BlockAlignment,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let input_format: u32 = unsafe { ::core::mem::transmute(input_format) };
            input_format as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let output_format: u32 = unsafe { ::core::mem::transmute(output_format) };
            output_format as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let rotation: u32 = unsafe { ::core::mem::transmute(rotation) };
            rotation as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let block_alignment: u32 = unsafe { ::core::mem::transmute(block_alignment) };
            block_alignment as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn standard_coefficient(&self) -> Y2RU_StandardCoefficient {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_standard_coefficient(&mut self, val: Y2RU_StandardCoefficient) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        standard_coefficient: Y2RU_StandardCoefficient,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let standard_coefficient: u32 = unsafe { ::core::mem::transmute(standard_coefficient) };
            standard_coefficient as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "Dithering weights."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Y2RU_DitheringWeightParams {
    #[doc = "Weight 0 for even X, even Y."]
    #[doc = ""]
    pub w0_xEven_yEven: u16_,
    #[doc = "Weight 0 for odd X, even Y."]
    #[doc = ""]
    pub w0_xOdd_yEven: u16_,
    #[doc = "Weight 0 for even X, odd Y."]
    #[doc = ""]
    pub w0_xEven_yOdd: u16_,
    #[doc = "Weight 0 for odd X, odd Y."]
    #[doc = ""]
    pub w0_xOdd_yOdd: u16_,
    #[doc = "Weight 1 for even X, even Y."]
    #[doc = ""]
    pub w1_xEven_yEven: u16_,
    #[doc = "Weight 1 for odd X, even Y."]
    #[doc = ""]
    pub w1_xOdd_yEven: u16_,
    #[doc = "Weight 1 for even X, odd Y."]
    #[doc = ""]
    pub w1_xEven_yOdd: u16_,
    #[doc = "Weight 1 for odd X, odd Y."]
    #[doc = ""]
    pub w1_xOdd_yOdd: u16_,
    #[doc = "Weight 2 for even X, even Y."]
    #[doc = ""]
    pub w2_xEven_yEven: u16_,
    #[doc = "Weight 2 for odd X, even Y."]
    #[doc = ""]
    pub w2_xOdd_yEven: u16_,
    #[doc = "Weight 2 for even X, odd Y."]
    #[doc = ""]
    pub w2_xEven_yOdd: u16_,
    #[doc = "Weight 2 for odd X, odd Y."]
    #[doc = ""]
    pub w2_xOdd_yOdd: u16_,
    #[doc = "Weight 3 for even X, even Y."]
    #[doc = ""]
    pub w3_xEven_yEven: u16_,
    #[doc = "Weight 3 for odd X, even Y."]
    #[doc = ""]
    pub w3_xOdd_yEven: u16_,
    #[doc = "Weight 3 for even X, odd Y."]
    #[doc = ""]
    pub w3_xEven_yOdd: u16_,
    #[doc = "Weight 3 for odd X, odd Y."]
    #[doc = ""]
    pub w3_xOdd_yOdd: u16_,
}
extern "C" {
    #[must_use]
    #[doc = "Initializes the y2r service.\n\n This will internally get the handle of the service, and on success call Y2RU_DriverInitialize."]
    #[doc = ""]
    pub fn y2rInit() -> Result;
}
extern "C" {
    #[doc = "Closes the y2r service.\n\n This will internally call Y2RU_DriverFinalize and close the handle of the service."]
    #[doc = ""]
    pub fn y2rExit();
}
extern "C" {
    #[must_use]
    #[doc = "Used to configure the input format.\n @param format Input format to use.\n\n @note Prefer using [`Y2RU_SetConversionParams`] if you have to set multiple parameters."]
    #[doc = ""]
    pub fn Y2RU_SetInputFormat(format: Y2RU_InputFormat) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the configured input format.\n @param format Pointer to output the input format to."]
    #[doc = ""]
    pub fn Y2RU_GetInputFormat(format: *mut Y2RU_InputFormat) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Used to configure the output format.\n @param format Output format to use.\n\n @note Prefer using [`Y2RU_SetConversionParams`] if you have to set multiple parameters."]
    #[doc = ""]
    pub fn Y2RU_SetOutputFormat(format: Y2RU_OutputFormat) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the configured output format.\n @param format Pointer to output the output format to."]
    #[doc = ""]
    pub fn Y2RU_GetOutputFormat(format: *mut Y2RU_OutputFormat) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Used to configure the rotation of the output.\n @param rotation Rotation to use.\n\n It seems to apply the rotation per batch of 8 lines, so the output will be (height/8) images of size 8 x width.\n\n @note Prefer using [`Y2RU_SetConversionParams`] if you have to set multiple parameters."]
    #[doc = ""]
    pub fn Y2RU_SetRotation(rotation: Y2RU_Rotation) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the configured rotation.\n @param rotation Pointer to output the rotation to."]
    #[doc = ""]
    pub fn Y2RU_GetRotation(rotation: *mut Y2RU_Rotation) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Used to configure the alignment of the output buffer.\n @param alignment Alignment to use.\n\n @note Prefer using [`Y2RU_SetConversionParams`] if you have to set multiple parameters."]
    #[doc = ""]
    pub fn Y2RU_SetBlockAlignment(alignment: Y2RU_BlockAlignment) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the configured alignment.\n @param alignment Pointer to output the alignment to."]
    #[doc = ""]
    pub fn Y2RU_GetBlockAlignment(alignment: *mut Y2RU_BlockAlignment) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets whether to use spacial dithering.\n @param enable Whether to use spacial dithering."]
    #[doc = ""]
    pub fn Y2RU_SetSpacialDithering(enable: bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets whether to use spacial dithering.\n @param enable Pointer to output the spacial dithering state to."]
    #[doc = ""]
    pub fn Y2RU_GetSpacialDithering(enabled: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets whether to use temporal dithering.\n @param enable Whether to use temporal dithering."]
    #[doc = ""]
    pub fn Y2RU_SetTemporalDithering(enable: bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets whether to use temporal dithering.\n @param enable Pointer to output the temporal dithering state to."]
    #[doc = ""]
    pub fn Y2RU_GetTemporalDithering(enabled: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Used to configure the width of the image.\n @param line_width Width of the image in pixels. Must be a multiple of 8, up to 1024.\n\n @note Prefer using [`Y2RU_SetConversionParams`] if you have to set multiple parameters."]
    #[doc = ""]
    pub fn Y2RU_SetInputLineWidth(line_width: u16_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the configured input line width.\n @param line_width Pointer to output the line width to."]
    #[doc = ""]
    pub fn Y2RU_GetInputLineWidth(line_width: *mut u16_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Used to configure the height of the image.\n @param num_lines Number of lines to be converted.\n\n A multiple of 8 seems to be preferred.\n If using the [`BLOCK_8_BY_8`] mode, it must be a multiple of 8.\n\n @note Prefer using [`Y2RU_SetConversionParams`] if you have to set multiple parameters."]
    #[doc = ""]
    pub fn Y2RU_SetInputLines(num_lines: u16_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the configured number of input lines.\n @param num_lines Pointer to output the input lines to."]
    #[doc = ""]
    pub fn Y2RU_GetInputLines(num_lines: *mut u16_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Used to configure the color conversion formula.\n @param coefficients Coefficients to use.\n\n See [`Y2RU_ColorCoefficients`] for more information about the coefficients.\n\n @note Prefer using [`Y2RU_SetConversionParams`] if you have to set multiple parameters."]
    #[doc = ""]
    pub fn Y2RU_SetCoefficients(coefficients: *const Y2RU_ColorCoefficients) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the configured color coefficients.\n @param num_lines Pointer to output the coefficients to."]
    #[doc = ""]
    pub fn Y2RU_GetCoefficients(coefficients: *mut Y2RU_ColorCoefficients) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Used to configure the color conversion formula with ITU stantards coefficients.\n @param coefficient Standard coefficient to use.\n\n See [`Y2RU_ColorCoefficients`] for more information about the coefficients.\n\n @note Prefer using [`Y2RU_SetConversionParams`] if you have to set multiple parameters."]
    #[doc = ""]
    pub fn Y2RU_SetStandardCoefficient(coefficient: Y2RU_StandardCoefficient) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the color coefficient parameters of a standard coefficient.\n @param coefficients Pointer to output the coefficients to.\n @param standardCoeff Standard coefficient to check."]
    #[doc = ""]
    pub fn Y2RU_GetStandardCoefficient(
        coefficients: *mut Y2RU_ColorCoefficients,
        standardCoeff: Y2RU_StandardCoefficient,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Used to configure the alpha value of the output.\n @param alpha 8-bit value to be used for the output when the format requires it.\n\n @note Prefer using [`Y2RU_SetConversionParams`] if you have to set multiple parameters."]
    #[doc = ""]
    pub fn Y2RU_SetAlpha(alpha: u16_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the configured output alpha value.\n @param alpha Pointer to output the alpha value to."]
    #[doc = ""]
    pub fn Y2RU_GetAlpha(alpha: *mut u16_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Used to enable the end of conversion interrupt.\n @param should_interrupt Enables the interrupt if true, disable it if false.\n\n It is possible to fire an interrupt when the conversion is finished, and that the DMA is done copying the data.\n This interrupt will then be used to fire an event. See [`Y2RU_GetTransferEndEvent.\n`] By default the interrupt is enabled.\n\n @note It seems that the event can be fired too soon in some cases, depending the transfer_unit size.\\n Please see the note at [`Y2RU_SetReceiving`]"]
    #[doc = ""]
    pub fn Y2RU_SetTransferEndInterrupt(should_interrupt: bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets whether the transfer end interrupt is enabled.\n @param should_interrupt Pointer to output the interrupt state to."]
    #[doc = ""]
    pub fn Y2RU_GetTransferEndInterrupt(should_interrupt: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets an handle to the end of conversion event.\n @param end_event Pointer to the event handle to be set to the end of conversion event. It isn't necessary to create or close this handle.\n\n To enable this event you have to use ``` ``` The event will be triggered when the corresponding interrupt is fired.\n\n @note It is recommended to use a timeout when waiting on this event, as it sometimes (but rarely) isn't triggered."]
    #[doc = ""]
    pub fn Y2RU_GetTransferEndEvent(end_event: *mut Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Configures the Y plane buffer.\n @param src_buf A pointer to the beginning of your Y data buffer.\n @param image_size The total size of the data buffer.\n @param transfer_unit Specifies the size of 1 DMA transfer. Usually set to 1 line. This has to be a divisor of image_size.\n @param transfer_gap Specifies the gap (offset) to be added after each transfer. Can be used to convert images with stride or only a part of it.\n\n @warning transfer_unit+transfer_gap must be less than 32768 (0x8000)\n\n This specifies the Y data buffer for the planar input formats (INPUT_YUV42*_INDIV_*).\n The actual transfer will only happen after calling [`Y2RU_StartConversion`]"]
    #[doc = ""]
    pub fn Y2RU_SetSendingY(
        src_buf: *const ::libc::c_void,
        image_size: u32_,
        transfer_unit: s16,
        transfer_gap: s16,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Configures the U plane buffer.\n @param src_buf A pointer to the beginning of your Y data buffer.\n @param image_size The total size of the data buffer.\n @param transfer_unit Specifies the size of 1 DMA transfer. Usually set to 1 line. This has to be a divisor of image_size.\n @param transfer_gap Specifies the gap (offset) to be added after each transfer. Can be used to convert images with stride or only a part of it.\n\n @warning transfer_unit+transfer_gap must be less than 32768 (0x8000)\n\n This specifies the U data buffer for the planar input formats (INPUT_YUV42*_INDIV_*).\n The actual transfer will only happen after calling [`Y2RU_StartConversion`]"]
    #[doc = ""]
    pub fn Y2RU_SetSendingU(
        src_buf: *const ::libc::c_void,
        image_size: u32_,
        transfer_unit: s16,
        transfer_gap: s16,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Configures the V plane buffer.\n @param src_buf A pointer to the beginning of your Y data buffer.\n @param image_size The total size of the data buffer.\n @param transfer_unit Specifies the size of 1 DMA transfer. Usually set to 1 line. This has to be a divisor of image_size.\n @param transfer_gap Specifies the gap (offset) to be added after each transfer. Can be used to convert images with stride or only a part of it.\n\n @warning transfer_unit+transfer_gap must be less than 32768 (0x8000)\n\n This specifies the V data buffer for the planar input formats (INPUT_YUV42*_INDIV_*).\n The actual transfer will only happen after calling [`Y2RU_StartConversion`]"]
    #[doc = ""]
    pub fn Y2RU_SetSendingV(
        src_buf: *const ::libc::c_void,
        image_size: u32_,
        transfer_unit: s16,
        transfer_gap: s16,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Configures the YUYV source buffer.\n @param src_buf A pointer to the beginning of your Y data buffer.\n @param image_size The total size of the data buffer.\n @param transfer_unit Specifies the size of 1 DMA transfer. Usually set to 1 line. This has to be a divisor of image_size.\n @param transfer_gap Specifies the gap (offset) to be added after each transfer. Can be used to convert images with stride or only a part of it.\n\n @warning transfer_unit+transfer_gap must be less than 32768 (0x8000)\n\n This specifies the YUYV data buffer for the packed input format [`INPUT_YUV422_BATCH.\n`] The actual transfer will only happen after calling [`Y2RU_StartConversion`]"]
    #[doc = ""]
    pub fn Y2RU_SetSendingYUYV(
        src_buf: *const ::libc::c_void,
        image_size: u32_,
        transfer_unit: s16,
        transfer_gap: s16,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Configures the destination buffer.\n @param src_buf A pointer to the beginning of your destination buffer in FCRAM\n @param image_size The total size of the data buffer.\n @param transfer_unit Specifies the size of 1 DMA transfer. Usually set to 1 line. This has to be a divisor of image_size.\n @param transfer_gap Specifies the gap (offset) to be added after each transfer. Can be used to convert images with stride or only a part of it.\n\n This specifies the destination buffer of the conversion.\n The actual transfer will only happen after calling [`Y2RU_StartConversion.\n`] The buffer does NOT need to be allocated in the linear heap.\n\n @warning transfer_unit+transfer_gap must be less than 32768 (0x8000)\n\n @note\n It seems that depending on the size of the image and of the transfer unit,\\n\n it is possible for the end of conversion interrupt to be triggered right after the conversion began.\\n\n One line as transfer_unit seems to trigger this issue for 400x240, setting to 2/4/8 lines fixes it.\n\n @note Setting a transfer_unit of 4 or 8 lines seems to bring the best results in terms of speed for a 400x240 image."]
    #[doc = ""]
    pub fn Y2RU_SetReceiving(
        dst_buf: *mut ::libc::c_void,
        image_size: u32_,
        transfer_unit: s16,
        transfer_gap: s16,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Checks if the DMA has finished sending the Y buffer.\n @param is_done Pointer to the boolean that will hold the result.\n\n True if the DMA has finished transferring the Y plane, false otherwise. To be used with [`Y2RU_SetSendingY`]"]
    #[doc = ""]
    pub fn Y2RU_IsDoneSendingY(is_done: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Checks if the DMA has finished sending the U buffer.\n @param is_done Pointer to the boolean that will hold the result.\n\n True if the DMA has finished transferring the U plane, false otherwise. To be used with [`Y2RU_SetSendingU`]"]
    #[doc = ""]
    pub fn Y2RU_IsDoneSendingU(is_done: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Checks if the DMA has finished sending the V buffer.\n @param is_done Pointer to the boolean that will hold the result.\n\n True if the DMA has finished transferring the V plane, false otherwise. To be used with [`Y2RU_SetSendingV`]"]
    #[doc = ""]
    pub fn Y2RU_IsDoneSendingV(is_done: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Checks if the DMA has finished sending the YUYV buffer.\n @param is_done Pointer to the boolean that will hold the result.\n\n True if the DMA has finished transferring the YUYV buffer, false otherwise. To be used with [`Y2RU_SetSendingYUYV`]"]
    #[doc = ""]
    pub fn Y2RU_IsDoneSendingYUYV(is_done: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Checks if the DMA has finished sending the converted result.\n @param is_done Pointer to the boolean that will hold the result.\n\n True if the DMA has finished transferring data to your destination buffer, false otherwise."]
    #[doc = ""]
    pub fn Y2RU_IsDoneReceiving(is_done: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Configures the dithering weight parameters.\n @param params Dithering weight parameters to use."]
    #[doc = ""]
    pub fn Y2RU_SetDitheringWeightParams(params: *const Y2RU_DitheringWeightParams) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the configured dithering weight parameters.\n @param params Pointer to output the dithering weight parameters to."]
    #[doc = ""]
    pub fn Y2RU_GetDitheringWeightParams(params: *mut Y2RU_DitheringWeightParams) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets all of the parameters of Y2RU_ConversionParams at once.\n @param params Conversion parameters to set.\n\n Faster than calling the individual value through Y2R_Set* because only one system call is made."]
    #[doc = ""]
    pub fn Y2RU_SetConversionParams(params: *const Y2RU_ConversionParams) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Starts the conversion process"]
    #[doc = ""]
    pub fn Y2RU_StartConversion() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Cancels the conversion"]
    #[doc = ""]
    pub fn Y2RU_StopConversion() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Checks if the conversion and DMA transfer are finished.\n @param is_busy Pointer to output the busy state to.\n\n This can have the same problems as the event and interrupt. See [`Y2RU_SetTransferEndInterrupt`]"]
    #[doc = ""]
    pub fn Y2RU_IsBusyConversion(is_busy: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Checks whether Y2R is ready to be used.\n @param ping Pointer to output the ready status to."]
    #[doc = ""]
    pub fn Y2RU_PingProcess(ping: *mut u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initializes the Y2R driver."]
    #[doc = ""]
    pub fn Y2RU_DriverInitialize() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Terminates the Y2R driver."]
    #[doc = ""]
    pub fn Y2RU_DriverFinalize() -> Result;
}
#[doc = "No port."]
#[doc = ""]

pub const PORT_NONE: _bindgen_ty_15 = 0;
#[doc = "CAM1 port."]
#[doc = ""]

pub const PORT_CAM1: _bindgen_ty_15 = 1;
#[doc = "CAM2 port."]
#[doc = ""]

pub const PORT_CAM2: _bindgen_ty_15 = 2;
#[doc = "Both ports."]
#[doc = ""]

pub const PORT_BOTH: _bindgen_ty_15 = 3;
#[doc = "Camera connection target ports."]
#[doc = ""]

pub type _bindgen_ty_15 = ::libc::c_uint;
#[doc = "No camera."]
#[doc = ""]

pub const SELECT_NONE: _bindgen_ty_16 = 0;
#[doc = "Outer camera 1."]
#[doc = ""]

pub const SELECT_OUT1: _bindgen_ty_16 = 1;
#[doc = "Inner camera 1."]
#[doc = ""]

pub const SELECT_IN1: _bindgen_ty_16 = 2;
#[doc = "Outer camera 2."]
#[doc = ""]

pub const SELECT_OUT2: _bindgen_ty_16 = 4;
#[doc = "Outer camera 1 and inner camera 1."]
#[doc = ""]

pub const SELECT_IN1_OUT1: _bindgen_ty_16 = 3;
#[doc = "Both outer cameras."]
#[doc = ""]

pub const SELECT_OUT1_OUT2: _bindgen_ty_16 = 5;
#[doc = "Inner camera 1 and outer camera 2."]
#[doc = ""]

pub const SELECT_IN1_OUT2: _bindgen_ty_16 = 6;
#[doc = "All cameras."]
#[doc = ""]

pub const SELECT_ALL: _bindgen_ty_16 = 7;
#[doc = "Camera combinations."]
#[doc = ""]

pub type _bindgen_ty_16 = ::libc::c_uint;
#[doc = "No context."]
#[doc = ""]

pub const CONTEXT_NONE: CAMU_Context = 0;
#[doc = "Context A."]
#[doc = ""]

pub const CONTEXT_A: CAMU_Context = 1;
#[doc = "Context B."]
#[doc = ""]

pub const CONTEXT_B: CAMU_Context = 2;
#[doc = "Both contexts."]
#[doc = ""]

pub const CONTEXT_BOTH: CAMU_Context = 3;
#[doc = "Camera contexts."]
#[doc = ""]

pub type CAMU_Context = ::libc::c_uint;
#[doc = "No flip."]
#[doc = ""]

pub const FLIP_NONE: CAMU_Flip = 0;
#[doc = "Horizontal flip."]
#[doc = ""]

pub const FLIP_HORIZONTAL: CAMU_Flip = 1;
#[doc = "Vertical flip."]
#[doc = ""]

pub const FLIP_VERTICAL: CAMU_Flip = 2;
#[doc = "Reverse flip."]
#[doc = ""]

pub const FLIP_REVERSE: CAMU_Flip = 3;
#[doc = "Ways to flip the camera image."]
#[doc = ""]

pub type CAMU_Flip = ::libc::c_uint;
#[doc = "VGA size. (640x480)"]
#[doc = ""]

pub const SIZE_VGA: CAMU_Size = 0;
#[doc = "QVGA size. (320x240)"]
#[doc = ""]

pub const SIZE_QVGA: CAMU_Size = 1;
#[doc = "QQVGA size. (160x120)"]
#[doc = ""]

pub const SIZE_QQVGA: CAMU_Size = 2;
#[doc = "CIF size. (352x288)"]
#[doc = ""]

pub const SIZE_CIF: CAMU_Size = 3;
#[doc = "QCIF size. (176x144)"]
#[doc = ""]

pub const SIZE_QCIF: CAMU_Size = 4;
#[doc = "DS LCD size. (256x192)"]
#[doc = ""]

pub const SIZE_DS_LCD: CAMU_Size = 5;
#[doc = "DS LCD x4 size. (512x384)"]
#[doc = ""]

pub const SIZE_DS_LCDx4: CAMU_Size = 6;
#[doc = "CTR Top LCD size. (400x240)"]
#[doc = ""]

pub const SIZE_CTR_TOP_LCD: CAMU_Size = 7;
#[doc = "CTR Bottom LCD size. (320x240)"]
#[doc = ""]

pub const SIZE_CTR_BOTTOM_LCD: CAMU_Size = 1;
#[doc = "Camera image resolutions."]
#[doc = ""]

pub type CAMU_Size = ::libc::c_uint;
#[doc = "15 FPS."]
#[doc = ""]

pub const FRAME_RATE_15: CAMU_FrameRate = 0;
#[doc = "15-5 FPS."]
#[doc = ""]

pub const FRAME_RATE_15_TO_5: CAMU_FrameRate = 1;
#[doc = "15-2 FPS."]
#[doc = ""]

pub const FRAME_RATE_15_TO_2: CAMU_FrameRate = 2;
#[doc = "10 FPS."]
#[doc = ""]

pub const FRAME_RATE_10: CAMU_FrameRate = 3;
#[doc = "8.5 FPS."]
#[doc = ""]

pub const FRAME_RATE_8_5: CAMU_FrameRate = 4;
#[doc = "5 FPS."]
#[doc = ""]

pub const FRAME_RATE_5: CAMU_FrameRate = 5;
#[doc = "20 FPS."]
#[doc = ""]

pub const FRAME_RATE_20: CAMU_FrameRate = 6;
#[doc = "20-5 FPS."]
#[doc = ""]

pub const FRAME_RATE_20_TO_5: CAMU_FrameRate = 7;
#[doc = "30 FPS."]
#[doc = ""]

pub const FRAME_RATE_30: CAMU_FrameRate = 8;
#[doc = "30-5 FPS."]
#[doc = ""]

pub const FRAME_RATE_30_TO_5: CAMU_FrameRate = 9;
#[doc = "15-10 FPS."]
#[doc = ""]

pub const FRAME_RATE_15_TO_10: CAMU_FrameRate = 10;
#[doc = "20-10 FPS."]
#[doc = ""]

pub const FRAME_RATE_20_TO_10: CAMU_FrameRate = 11;
#[doc = "30-10 FPS."]
#[doc = ""]

pub const FRAME_RATE_30_TO_10: CAMU_FrameRate = 12;
#[doc = "Camera capture frame rates."]
#[doc = ""]

pub type CAMU_FrameRate = ::libc::c_uint;
#[doc = "Auto white balance."]
#[doc = ""]

pub const WHITE_BALANCE_AUTO: CAMU_WhiteBalance = 0;
#[doc = "3200K white balance."]
#[doc = ""]

pub const WHITE_BALANCE_3200K: CAMU_WhiteBalance = 1;
#[doc = "4150K white balance."]
#[doc = ""]

pub const WHITE_BALANCE_4150K: CAMU_WhiteBalance = 2;
#[doc = "5200K white balance."]
#[doc = ""]

pub const WHITE_BALANCE_5200K: CAMU_WhiteBalance = 3;
#[doc = "6000K white balance."]
#[doc = ""]

pub const WHITE_BALANCE_6000K: CAMU_WhiteBalance = 4;
#[doc = "7000K white balance."]
#[doc = ""]

pub const WHITE_BALANCE_7000K: CAMU_WhiteBalance = 5;
pub const WHITE_BALANCE_NORMAL: CAMU_WhiteBalance = 0;
pub const WHITE_BALANCE_TUNGSTEN: CAMU_WhiteBalance = 1;
pub const WHITE_BALANCE_WHITE_FLUORESCENT_LIGHT: CAMU_WhiteBalance = 2;
pub const WHITE_BALANCE_DAYLIGHT: CAMU_WhiteBalance = 3;
pub const WHITE_BALANCE_CLOUDY: CAMU_WhiteBalance = 4;
pub const WHITE_BALANCE_HORIZON: CAMU_WhiteBalance = 4;
pub const WHITE_BALANCE_SHADE: CAMU_WhiteBalance = 5;
#[doc = "Camera white balance modes."]
#[doc = ""]

pub type CAMU_WhiteBalance = ::libc::c_uint;
#[doc = "Normal mode."]
#[doc = ""]

pub const PHOTO_MODE_NORMAL: CAMU_PhotoMode = 0;
#[doc = "Portrait mode."]
#[doc = ""]

pub const PHOTO_MODE_PORTRAIT: CAMU_PhotoMode = 1;
#[doc = "Landscape mode."]
#[doc = ""]

pub const PHOTO_MODE_LANDSCAPE: CAMU_PhotoMode = 2;
#[doc = "Night mode."]
#[doc = ""]

pub const PHOTO_MODE_NIGHTVIEW: CAMU_PhotoMode = 3;
#[doc = "Letter mode."]
#[doc = ""]

pub const PHOTO_MODE_LETTER: CAMU_PhotoMode = 4;
#[doc = "Camera photo modes."]
#[doc = ""]

pub type CAMU_PhotoMode = ::libc::c_uint;
#[doc = "No effects."]
#[doc = ""]

pub const EFFECT_NONE: CAMU_Effect = 0;
#[doc = "Mono effect."]
#[doc = ""]

pub const EFFECT_MONO: CAMU_Effect = 1;
#[doc = "Sepia effect."]
#[doc = ""]

pub const EFFECT_SEPIA: CAMU_Effect = 2;
#[doc = "Negative effect."]
#[doc = ""]

pub const EFFECT_NEGATIVE: CAMU_Effect = 3;
#[doc = "Negative film effect."]
#[doc = ""]

pub const EFFECT_NEGAFILM: CAMU_Effect = 4;
#[doc = "Sepia effect."]
#[doc = ""]

pub const EFFECT_SEPIA01: CAMU_Effect = 5;
#[doc = "Camera special effects."]
#[doc = ""]

pub type CAMU_Effect = ::libc::c_uint;
#[doc = "Pattern 1."]
#[doc = ""]

pub const CONTRAST_PATTERN_01: CAMU_Contrast = 0;
#[doc = "Pattern 2."]
#[doc = ""]

pub const CONTRAST_PATTERN_02: CAMU_Contrast = 1;
#[doc = "Pattern 3."]
#[doc = ""]

pub const CONTRAST_PATTERN_03: CAMU_Contrast = 2;
#[doc = "Pattern 4."]
#[doc = ""]

pub const CONTRAST_PATTERN_04: CAMU_Contrast = 3;
#[doc = "Pattern 5."]
#[doc = ""]

pub const CONTRAST_PATTERN_05: CAMU_Contrast = 4;
#[doc = "Pattern 6."]
#[doc = ""]

pub const CONTRAST_PATTERN_06: CAMU_Contrast = 5;
#[doc = "Pattern 7."]
#[doc = ""]

pub const CONTRAST_PATTERN_07: CAMU_Contrast = 6;
#[doc = "Pattern 8."]
#[doc = ""]

pub const CONTRAST_PATTERN_08: CAMU_Contrast = 7;
#[doc = "Pattern 9."]
#[doc = ""]

pub const CONTRAST_PATTERN_09: CAMU_Contrast = 8;
#[doc = "Pattern 10."]
#[doc = ""]

pub const CONTRAST_PATTERN_10: CAMU_Contrast = 9;
#[doc = "Pattern 11."]
#[doc = ""]

pub const CONTRAST_PATTERN_11: CAMU_Contrast = 10;
#[doc = "Low contrast. (5)"]
#[doc = ""]

pub const CONTRAST_LOW: CAMU_Contrast = 4;
#[doc = "Normal contrast. (6)"]
#[doc = ""]

pub const CONTRAST_NORMAL: CAMU_Contrast = 5;
#[doc = "High contrast. (7)"]
#[doc = ""]

pub const CONTRAST_HIGH: CAMU_Contrast = 6;
#[doc = "Camera contrast patterns."]
#[doc = ""]

pub type CAMU_Contrast = ::libc::c_uint;
#[doc = "No lens correction."]
#[doc = ""]

pub const LENS_CORRECTION_OFF: CAMU_LensCorrection = 0;
#[doc = "Edge-to-center brightness ratio of 70."]
#[doc = ""]

pub const LENS_CORRECTION_ON_70: CAMU_LensCorrection = 1;
#[doc = "Edge-to-center brightness ratio of 90."]
#[doc = ""]

pub const LENS_CORRECTION_ON_90: CAMU_LensCorrection = 2;
#[doc = "Dark lens correction. (OFF)"]
#[doc = ""]

pub const LENS_CORRECTION_DARK: CAMU_LensCorrection = 0;
#[doc = "Normal lens correction. (70)"]
#[doc = ""]

pub const LENS_CORRECTION_NORMAL: CAMU_LensCorrection = 1;
#[doc = "Bright lens correction. (90)"]
#[doc = ""]

pub const LENS_CORRECTION_BRIGHT: CAMU_LensCorrection = 2;
#[doc = "Camera lens correction modes."]
#[doc = ""]

pub type CAMU_LensCorrection = ::libc::c_uint;
#[doc = "YUV422"]
#[doc = ""]

pub const OUTPUT_YUV_422: CAMU_OutputFormat = 0;
#[doc = "RGB565"]
#[doc = ""]

pub const OUTPUT_RGB_565: CAMU_OutputFormat = 1;
#[doc = "Camera image output formats."]
#[doc = ""]

pub type CAMU_OutputFormat = ::libc::c_uint;
#[doc = "Normal shutter sound."]
#[doc = ""]

pub const SHUTTER_SOUND_TYPE_NORMAL: CAMU_ShutterSoundType = 0;
#[doc = "Shutter sound to begin a movie."]
#[doc = ""]

pub const SHUTTER_SOUND_TYPE_MOVIE: CAMU_ShutterSoundType = 1;
#[doc = "Shutter sound to end a movie."]
#[doc = ""]

pub const SHUTTER_SOUND_TYPE_MOVIE_END: CAMU_ShutterSoundType = 2;
#[doc = "Camera shutter sounds."]
#[doc = ""]

pub type CAMU_ShutterSoundType = ::libc::c_uint;
#[doc = "Image quality calibration data."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CAMU_ImageQualityCalibrationData {
    #[doc = "Auto exposure base target brightness."]
    #[doc = ""]
    pub aeBaseTarget: s16,
    #[doc = "Left color correction matrix red normalization coefficient."]
    #[doc = ""]
    pub kRL: s16,
    #[doc = "Left color correction matrix green normalization coefficient."]
    #[doc = ""]
    pub kGL: s16,
    #[doc = "Left color correction matrix blue normalization coefficient."]
    #[doc = ""]
    pub kBL: s16,
    #[doc = "Color correction matrix position."]
    #[doc = ""]
    pub ccmPosition: s16,
    #[doc = "Right camera, left color correction matrix red/green gain."]
    #[doc = ""]
    pub awbCcmL9Right: u16_,
    #[doc = "Left camera, left color correction matrix red/green gain."]
    #[doc = ""]
    pub awbCcmL9Left: u16_,
    #[doc = "Right camera, left color correction matrix blue/green gain."]
    #[doc = ""]
    pub awbCcmL10Right: u16_,
    #[doc = "Left camera, left color correction matrix blue/green gain."]
    #[doc = ""]
    pub awbCcmL10Left: u16_,
    #[doc = "Right camera, color correction matrix position threshold."]
    #[doc = ""]
    pub awbX0Right: u16_,
    #[doc = "Left camera, color correction matrix position threshold."]
    #[doc = ""]
    pub awbX0Left: u16_,
}
#[doc = "Stereo camera calibration data."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CAMU_StereoCameraCalibrationData {
    #[doc = "#bool Whether the X and Y rotation data is valid."]
    #[doc = ""]
    pub isValidRotationXY: u8_,
    #[doc = "Padding. (Aligns isValidRotationXY to 4 bytes)"]
    #[doc = ""]
    pub padding: [u8_; 3usize],
    #[doc = "Scale to match the left camera image with the right."]
    #[doc = ""]
    pub scale: f32,
    #[doc = "Z axis rotation to match the left camera image with the right."]
    #[doc = ""]
    pub rotationZ: f32,
    #[doc = "X axis translation to match the left camera image with the right."]
    #[doc = ""]
    pub translationX: f32,
    #[doc = "Y axis translation to match the left camera image with the right."]
    #[doc = ""]
    pub translationY: f32,
    #[doc = "X axis rotation to match the left camera image with the right."]
    #[doc = ""]
    pub rotationX: f32,
    #[doc = "Y axis rotation to match the left camera image with the right."]
    #[doc = ""]
    pub rotationY: f32,
    #[doc = "Right camera angle of view."]
    #[doc = ""]
    pub angleOfViewRight: f32,
    #[doc = "Left camera angle of view."]
    #[doc = ""]
    pub angleOfViewLeft: f32,
    #[doc = "Distance between cameras and measurement chart."]
    #[doc = ""]
    pub distanceToChart: f32,
    #[doc = "Distance between left and right cameras."]
    #[doc = ""]
    pub distanceCameras: f32,
    #[doc = "Image width."]
    #[doc = ""]
    pub imageWidth: s16,
    #[doc = "Image height."]
    #[doc = ""]
    pub imageHeight: s16,
    #[doc = "Reserved for future use. (unused)"]
    #[doc = ""]
    pub reserved: [u8_; 16usize],
}
#[doc = "Batch camera configuration for use without a context."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CAMU_PackageParameterCameraSelect {
    #[doc = "Selected camera."]
    #[doc = ""]
    pub camera: u8_,
    #[doc = "Camera exposure."]
    #[doc = ""]
    pub exposure: s8,
    #[doc = "#CAMU_WhiteBalance Camera white balance."]
    #[doc = ""]
    pub whiteBalance: u8_,
    #[doc = "Camera sharpness."]
    #[doc = ""]
    pub sharpness: s8,
    #[doc = "#bool Whether to automatically determine the proper exposure."]
    #[doc = ""]
    pub autoExposureOn: u8_,
    #[doc = "#bool Whether to automatically determine the white balance mode."]
    #[doc = ""]
    pub autoWhiteBalanceOn: u8_,
    #[doc = "#CAMU_FrameRate Camera frame rate."]
    #[doc = ""]
    pub frameRate: u8_,
    #[doc = "#CAMU_PhotoMode Camera photo mode."]
    #[doc = ""]
    pub photoMode: u8_,
    #[doc = "#CAMU_Contrast Camera contrast."]
    #[doc = ""]
    pub contrast: u8_,
    #[doc = "#CAMU_LensCorrection Camera lens correction."]
    #[doc = ""]
    pub lensCorrection: u8_,
    #[doc = "#bool Whether to enable the camera's noise filter."]
    #[doc = ""]
    pub noiseFilterOn: u8_,
    #[doc = "Padding. (Aligns last 3 fields to 4 bytes)"]
    #[doc = ""]
    pub padding: u8_,
    #[doc = "X of the region to use for auto exposure."]
    #[doc = ""]
    pub autoExposureWindowX: s16,
    #[doc = "Y of the region to use for auto exposure."]
    #[doc = ""]
    pub autoExposureWindowY: s16,
    #[doc = "Width of the region to use for auto exposure."]
    #[doc = ""]
    pub autoExposureWindowWidth: s16,
    #[doc = "Height of the region to use for auto exposure."]
    #[doc = ""]
    pub autoExposureWindowHeight: s16,
    #[doc = "X of the region to use for auto white balance."]
    #[doc = ""]
    pub autoWhiteBalanceWindowX: s16,
    #[doc = "Y of the region to use for auto white balance."]
    #[doc = ""]
    pub autoWhiteBalanceWindowY: s16,
    #[doc = "Width of the region to use for auto white balance."]
    #[doc = ""]
    pub autoWhiteBalanceWindowWidth: s16,
    #[doc = "Height of the region to use for auto white balance."]
    #[doc = ""]
    pub autoWhiteBalanceWindowHeight: s16,
}
#[doc = "Batch camera configuration for use with a context."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CAMU_PackageParameterContext {
    #[doc = "Selected camera."]
    #[doc = ""]
    pub camera: u8_,
    #[doc = "#CAMU_Context Selected context."]
    #[doc = ""]
    pub context: u8_,
    #[doc = "#CAMU_Flip Camera image flip mode."]
    #[doc = ""]
    pub flip: u8_,
    #[doc = "#CAMU_Effect Camera image special effects."]
    #[doc = ""]
    pub effect: u8_,
    #[doc = "#CAMU_Size Camera image resolution."]
    #[doc = ""]
    pub size: u8_,
}
#[doc = "Batch camera configuration for use with a context and with detailed size information."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CAMU_PackageParameterContextDetail {
    #[doc = "Selected camera."]
    #[doc = ""]
    pub camera: u8_,
    #[doc = "#CAMU_Context Selected context."]
    #[doc = ""]
    pub context: u8_,
    #[doc = "#CAMU_Flip Camera image flip mode."]
    #[doc = ""]
    pub flip: u8_,
    #[doc = "#CAMU_Effect Camera image special effects."]
    #[doc = ""]
    pub effect: u8_,
    #[doc = "Image width."]
    #[doc = ""]
    pub width: s16,
    #[doc = "Image height."]
    #[doc = ""]
    pub height: s16,
    #[doc = "First crop point X."]
    #[doc = ""]
    pub cropX0: s16,
    #[doc = "First crop point Y."]
    #[doc = ""]
    pub cropY0: s16,
    #[doc = "Second crop point X."]
    #[doc = ""]
    pub cropX1: s16,
    #[doc = "Second crop point Y."]
    #[doc = ""]
    pub cropY1: s16,
}
extern "C" {
    #[must_use]
    #[doc = "Initializes the cam service.\n\n This will internally get the handle of the service, and on success call CAMU_DriverInitialize."]
    #[doc = ""]
    pub fn camInit() -> Result;
}
extern "C" {
    #[doc = "Closes the cam service.\n\n This will internally call CAMU_DriverFinalize and close the handle of the service."]
    #[doc = ""]
    pub fn camExit();
}
extern "C" {
    #[must_use]
    #[doc = "Begins capture on the specified camera port.\n @param port Port to begin capture on."]
    #[doc = ""]
    pub fn CAMU_StartCapture(port: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Terminates capture on the specified camera port.\n @param port Port to terminate capture on."]
    #[doc = ""]
    pub fn CAMU_StopCapture(port: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets whether the specified camera port is busy.\n @param busy Pointer to output the busy state to.\n @param port Port to check."]
    #[doc = ""]
    pub fn CAMU_IsBusy(busy: *mut bool, port: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Clears the buffer and error flags of the specified camera port.\n @param port Port to clear."]
    #[doc = ""]
    pub fn CAMU_ClearBuffer(port: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets a handle to the event signaled on vsync interrupts.\n @param event Pointer to output the event handle to.\n @param port Port to use."]
    #[doc = ""]
    pub fn CAMU_GetVsyncInterruptEvent(event: *mut Handle, port: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets a handle to the event signaled on camera buffer errors.\n @param event Pointer to output the event handle to.\n @param port Port to use."]
    #[doc = ""]
    pub fn CAMU_GetBufferErrorInterruptEvent(event: *mut Handle, port: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initiates the process of receiving a camera frame.\n @param event Pointer to output the completion event handle to.\n @param dst Buffer to write data to.\n @param port Port to receive from.\n @param imageSize Size of the image to receive.\n @param transferUnit Transfer unit to use when receiving."]
    #[doc = ""]
    pub fn CAMU_SetReceiving(
        event: *mut Handle,
        dst: *mut ::libc::c_void,
        port: u32_,
        imageSize: u32_,
        transferUnit: s16,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets whether the specified camera port has finished receiving image data.\n @param finishedReceiving Pointer to output the receiving status to.\n @param port Port to check."]
    #[doc = ""]
    pub fn CAMU_IsFinishedReceiving(finishedReceiving: *mut bool, port: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the number of lines to transfer into an image buffer.\n @param port Port to use.\n @param lines Lines to transfer.\n @param width Width of the image.\n @param height Height of the image."]
    #[doc = ""]
    pub fn CAMU_SetTransferLines(port: u32_, lines: s16, width: s16, height: s16) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the maximum number of lines that can be saved to an image buffer.\n @param maxLines Pointer to write the maximum number of lines to.\n @param width Width of the image.\n @param height Height of the image."]
    #[doc = ""]
    pub fn CAMU_GetMaxLines(maxLines: *mut s16, width: s16, height: s16) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the number of bytes to transfer into an image buffer.\n @param port Port to use.\n @param bytes Bytes to transfer.\n @param width Width of the image.\n @param height Height of the image."]
    #[doc = ""]
    pub fn CAMU_SetTransferBytes(port: u32_, bytes: u32_, width: s16, height: s16) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the number of bytes to transfer into an image buffer.\n @param transferBytes Pointer to write the number of bytes to.\n @param port Port to use."]
    #[doc = ""]
    pub fn CAMU_GetTransferBytes(transferBytes: *mut u32_, port: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the maximum number of bytes that can be saved to an image buffer.\n @param maxBytes Pointer to write the maximum number of bytes to.\n @param width Width of the image.\n @param height Height of the image."]
    #[doc = ""]
    pub fn CAMU_GetMaxBytes(maxBytes: *mut u32_, width: s16, height: s16) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets whether image trimming is enabled.\n @param port Port to use.\n @param trimming Whether image trimming is enabled."]
    #[doc = ""]
    pub fn CAMU_SetTrimming(port: u32_, trimming: bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets whether image trimming is enabled.\n @param trimming Pointer to output the trim state to.\n @param port Port to use."]
    #[doc = ""]
    pub fn CAMU_IsTrimming(trimming: *mut bool, port: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the parameters used for trimming images.\n @param port Port to use.\n @param xStart Start X coordinate.\n @param yStart Start Y coordinate.\n @param xEnd End X coordinate.\n @param yEnd End Y coordinate."]
    #[doc = ""]
    pub fn CAMU_SetTrimmingParams(
        port: u32_,
        xStart: s16,
        yStart: s16,
        xEnd: s16,
        yEnd: s16,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the parameters used for trimming images.\n @param xStart Pointer to write the start X coordinate to.\n @param yStart Pointer to write the start Y coordinate to.\n @param xEnd Pointer to write the end X coordinate to.\n @param yEnd Pointer to write the end Y coordinate to.\n @param port Port to use."]
    #[doc = ""]
    pub fn CAMU_GetTrimmingParams(
        xStart: *mut s16,
        yStart: *mut s16,
        xEnd: *mut s16,
        yEnd: *mut s16,
        port: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the parameters used for trimming images, relative to the center of the image.\n @param port Port to use.\n @param trimWidth Trim width.\n @param trimHeight Trim height.\n @param camWidth Camera width.\n @param camHeight Camera height."]
    #[doc = ""]
    pub fn CAMU_SetTrimmingParamsCenter(
        port: u32_,
        trimWidth: s16,
        trimHeight: s16,
        camWidth: s16,
        camHeight: s16,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Activates the specified camera.\n @param select Camera to use."]
    #[doc = ""]
    pub fn CAMU_Activate(select: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Switches the specified camera's active context.\n @param select Camera to use.\n @param context Context to use."]
    #[doc = ""]
    pub fn CAMU_SwitchContext(select: u32_, context: CAMU_Context) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the exposure value of the specified camera.\n @param select Camera to use.\n @param exposure Exposure value to use."]
    #[doc = ""]
    pub fn CAMU_SetExposure(select: u32_, exposure: s8) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the white balance mode of the specified camera.\n @param select Camera to use.\n @param whiteBalance White balance mode to use."]
    #[doc = ""]
    pub fn CAMU_SetWhiteBalance(select: u32_, whiteBalance: CAMU_WhiteBalance) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the white balance mode of the specified camera.\n TODO: Explain \"without base up\"?\n @param select Camera to use.\n @param whiteBalance White balance mode to use."]
    #[doc = ""]
    pub fn CAMU_SetWhiteBalanceWithoutBaseUp(
        select: u32_,
        whiteBalance: CAMU_WhiteBalance,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the sharpness of the specified camera.\n @param select Camera to use.\n @param sharpness Sharpness to use."]
    #[doc = ""]
    pub fn CAMU_SetSharpness(select: u32_, sharpness: s8) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets whether auto exposure is enabled on the specified camera.\n @param select Camera to use.\n @param autoWhiteBalance Whether auto exposure is enabled."]
    #[doc = ""]
    pub fn CAMU_SetAutoExposure(select: u32_, autoExposure: bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets whether auto exposure is enabled on the specified camera.\n @param autoExposure Pointer to output the auto exposure state to.\n @param select Camera to use."]
    #[doc = ""]
    pub fn CAMU_IsAutoExposure(autoExposure: *mut bool, select: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets whether auto white balance is enabled on the specified camera.\n @param select Camera to use.\n @param autoWhiteBalance Whether auto white balance is enabled."]
    #[doc = ""]
    pub fn CAMU_SetAutoWhiteBalance(select: u32_, autoWhiteBalance: bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets whether auto white balance is enabled on the specified camera.\n @param autoWhiteBalance Pointer to output the auto white balance state to.\n @param select Camera to use."]
    #[doc = ""]
    pub fn CAMU_IsAutoWhiteBalance(autoWhiteBalance: *mut bool, select: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Flips the image of the specified camera in the specified context.\n @param select Camera to use.\n @param flip Flip mode to use.\n @param context Context to use."]
    #[doc = ""]
    pub fn CAMU_FlipImage(select: u32_, flip: CAMU_Flip, context: CAMU_Context) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the image resolution of the given camera in the given context, in detail.\n @param select Camera to use.\n @param width Width to use.\n @param height Height to use.\n @param cropX0 First crop point X.\n @param cropY0 First crop point Y.\n @param cropX1 Second crop point X.\n @param cropY1 Second crop point Y.\n @param context Context to use."]
    #[doc = ""]
    pub fn CAMU_SetDetailSize(
        select: u32_,
        width: s16,
        height: s16,
        cropX0: s16,
        cropY0: s16,
        cropX1: s16,
        cropY1: s16,
        context: CAMU_Context,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the image resolution of the given camera in the given context.\n @param select Camera to use.\n @param size Size to use.\n @param context Context to use."]
    #[doc = ""]
    pub fn CAMU_SetSize(select: u32_, size: CAMU_Size, context: CAMU_Context) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the frame rate of the given camera.\n @param select Camera to use.\n @param frameRate Frame rate to use."]
    #[doc = ""]
    pub fn CAMU_SetFrameRate(select: u32_, frameRate: CAMU_FrameRate) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the photo mode of the given camera.\n @param select Camera to use.\n @param photoMode Photo mode to use."]
    #[doc = ""]
    pub fn CAMU_SetPhotoMode(select: u32_, photoMode: CAMU_PhotoMode) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the special effects of the given camera in the given context.\n @param select Camera to use.\n @param effect Effect to use.\n @param context Context to use."]
    #[doc = ""]
    pub fn CAMU_SetEffect(select: u32_, effect: CAMU_Effect, context: CAMU_Context) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the contrast mode of the given camera.\n @param select Camera to use.\n @param contrast Contrast mode to use."]
    #[doc = ""]
    pub fn CAMU_SetContrast(select: u32_, contrast: CAMU_Contrast) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the lens correction mode of the given camera.\n @param select Camera to use.\n @param lensCorrection Lens correction mode to use."]
    #[doc = ""]
    pub fn CAMU_SetLensCorrection(select: u32_, lensCorrection: CAMU_LensCorrection) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the output format of the given camera in the given context.\n @param select Camera to use.\n @param format Format to output.\n @param context Context to use."]
    #[doc = ""]
    pub fn CAMU_SetOutputFormat(
        select: u32_,
        format: CAMU_OutputFormat,
        context: CAMU_Context,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the region to base auto exposure off of for the specified camera.\n @param select Camera to use.\n @param x X of the region.\n @param y Y of the region.\n @param width Width of the region.\n @param height Height of the region."]
    #[doc = ""]
    pub fn CAMU_SetAutoExposureWindow(
        select: u32_,
        x: s16,
        y: s16,
        width: s16,
        height: s16,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the region to base auto white balance off of for the specified camera.\n @param select Camera to use.\n @param x X of the region.\n @param y Y of the region.\n @param width Width of the region.\n @param height Height of the region."]
    #[doc = ""]
    pub fn CAMU_SetAutoWhiteBalanceWindow(
        select: u32_,
        x: s16,
        y: s16,
        width: s16,
        height: s16,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets whether the specified camera's noise filter is enabled.\n @param select Camera to use.\n @param noiseFilter Whether the noise filter is enabled."]
    #[doc = ""]
    pub fn CAMU_SetNoiseFilter(select: u32_, noiseFilter: bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Synchronizes the specified cameras' vsync timing.\n @param select1 First camera.\n @param select2 Second camera."]
    #[doc = ""]
    pub fn CAMU_SynchronizeVsyncTiming(select1: u32_, select2: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the vsync timing record of the specified camera for the specified number of signals.\n @param timing Pointer to write timing data to. (size \"past * sizeof(s64)\")\n @param port Port to use.\n @param past Number of past timings to retrieve."]
    #[doc = ""]
    pub fn CAMU_GetLatestVsyncTiming(timing: *mut s64, port: u32_, past: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the specified camera's stereo camera calibration data.\n @param data Pointer to output the stereo camera data to."]
    #[doc = ""]
    pub fn CAMU_GetStereoCameraCalibrationData(
        data: *mut CAMU_StereoCameraCalibrationData,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the specified camera's stereo camera calibration data.\n @param data Data to set."]
    #[doc = ""]
    pub fn CAMU_SetStereoCameraCalibrationData(data: CAMU_StereoCameraCalibrationData) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Writes to the specified I2C register of the specified camera.\n @param select Camera to write to.\n @param addr Address to write to.\n @param data Data to write."]
    #[doc = ""]
    pub fn CAMU_WriteRegisterI2c(select: u32_, addr: u16_, data: u16_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Writes to the specified MCU variable of the specified camera.\n @param select Camera to write to.\n @param addr Address to write to.\n @param data Data to write."]
    #[doc = ""]
    pub fn CAMU_WriteMcuVariableI2c(select: u32_, addr: u16_, data: u16_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Reads the specified I2C register of the specified camera.\n @param data Pointer to read data to.\n @param select Camera to read from.\n @param addr Address to read."]
    #[doc = ""]
    pub fn CAMU_ReadRegisterI2cExclusive(data: *mut u16_, select: u32_, addr: u16_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Reads the specified MCU variable of the specified camera.\n @param data Pointer to read data to.\n @param select Camera to read from.\n @param addr Address to read."]
    #[doc = ""]
    pub fn CAMU_ReadMcuVariableI2cExclusive(data: *mut u16_, select: u32_, addr: u16_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the specified camera's image quality calibration data.\n @param data Data to set."]
    #[doc = ""]
    pub fn CAMU_SetImageQualityCalibrationData(data: CAMU_ImageQualityCalibrationData) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the specified camera's image quality calibration data.\n @param data Pointer to write the quality data to."]
    #[doc = ""]
    pub fn CAMU_GetImageQualityCalibrationData(
        data: *mut CAMU_ImageQualityCalibrationData,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Configures a camera with pre-packaged configuration data without a context.\n @param Parameter to use."]
    #[doc = ""]
    pub fn CAMU_SetPackageParameterWithoutContext(
        param: CAMU_PackageParameterCameraSelect,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Configures a camera with pre-packaged configuration data with a context.\n @param Parameter to use."]
    #[doc = ""]
    pub fn CAMU_SetPackageParameterWithContext(param: CAMU_PackageParameterContext) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Configures a camera with pre-packaged configuration data without a context and extra resolution details.\n @param Parameter to use."]
    #[doc = ""]
    pub fn CAMU_SetPackageParameterWithContextDetail(
        param: CAMU_PackageParameterContextDetail,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the Y2R coefficient applied to image data by the camera.\n @param coefficient Pointer to output the Y2R coefficient to."]
    #[doc = ""]
    pub fn CAMU_GetSuitableY2rStandardCoefficient(
        coefficient: *mut Y2RU_StandardCoefficient,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Plays the specified shutter sound.\n @param sound Shutter sound to play."]
    #[doc = ""]
    pub fn CAMU_PlayShutterSound(sound: CAMU_ShutterSoundType) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initializes the camera driver."]
    #[doc = ""]
    pub fn CAMU_DriverInitialize() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Finalizes the camera driver."]
    #[doc = ""]
    pub fn CAMU_DriverFinalize() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the current activated camera.\n @param select Pointer to output the current activated camera to."]
    #[doc = ""]
    pub fn CAMU_GetActivatedCamera(select: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the current sleep camera.\n @param select Pointer to output the current sleep camera to."]
    #[doc = ""]
    pub fn CAMU_GetSleepCamera(select: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the current sleep camera.\n @param select Camera to set."]
    #[doc = ""]
    pub fn CAMU_SetSleepCamera(select: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets whether to enable synchronization of left and right camera brightnesses.\n @param brightnessSynchronization Whether to enable brightness synchronization."]
    #[doc = ""]
    pub fn CAMU_SetBrightnessSynchronization(brightnessSynchronization: bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initializes CFGNOR.\n @param value Unknown, usually 1."]
    #[doc = ""]
    pub fn cfgnorInit(value: u8_) -> Result;
}
extern "C" {
    #[doc = "Exits CFGNOR"]
    #[doc = ""]
    pub fn cfgnorExit();
}
extern "C" {
    #[must_use]
    #[doc = "Dumps the NOR flash.\n @param buf Buffer to dump to.\n @param size Size of the buffer."]
    #[doc = ""]
    pub fn cfgnorDumpFlash(buf: *mut u32_, size: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Writes the NOR flash.\n @param buf Buffer to write from.\n @param size Size of the buffer."]
    #[doc = ""]
    pub fn cfgnorWriteFlash(buf: *mut u32_, size: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initializes the CFGNOR session.\n @param value Unknown, usually 1."]
    #[doc = ""]
    pub fn CFGNOR_Initialize(value: u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Shuts down the CFGNOR session."]
    #[doc = ""]
    pub fn CFGNOR_Shutdown() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Reads data from NOR.\n @param offset Offset to read from.\n @param buf Buffer to read data to.\n @param size Size of the buffer."]
    #[doc = ""]
    pub fn CFGNOR_ReadData(offset: u32_, buf: *mut u32_, size: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Writes data to NOR.\n @param offset Offset to write to.\n @param buf Buffer to write data from.\n @param size Size of the buffer."]
    #[doc = ""]
    pub fn CFGNOR_WriteData(offset: u32_, buf: *mut u32_, size: u32_) -> Result;
}
#[doc = "Japan"]
#[doc = ""]

pub const CFG_REGION_JPN: CFG_Region = 0;
#[doc = "USA"]
#[doc = ""]

pub const CFG_REGION_USA: CFG_Region = 1;
#[doc = "Europe"]
#[doc = ""]

pub const CFG_REGION_EUR: CFG_Region = 2;
#[doc = "Australia"]
#[doc = ""]

pub const CFG_REGION_AUS: CFG_Region = 3;
#[doc = "China"]
#[doc = ""]

pub const CFG_REGION_CHN: CFG_Region = 4;
#[doc = "Korea"]
#[doc = ""]

pub const CFG_REGION_KOR: CFG_Region = 5;
#[doc = "Taiwan"]
#[doc = ""]

pub const CFG_REGION_TWN: CFG_Region = 6;
#[doc = "Configuration region values."]
#[doc = ""]

pub type CFG_Region = ::libc::c_uint;
#[doc = "Japanese"]
#[doc = ""]

pub const CFG_LANGUAGE_JP: CFG_Language = 0;
#[doc = "English"]
#[doc = ""]

pub const CFG_LANGUAGE_EN: CFG_Language = 1;
#[doc = "French"]
#[doc = ""]

pub const CFG_LANGUAGE_FR: CFG_Language = 2;
#[doc = "German"]
#[doc = ""]

pub const CFG_LANGUAGE_DE: CFG_Language = 3;
#[doc = "Italian"]
#[doc = ""]

pub const CFG_LANGUAGE_IT: CFG_Language = 4;
#[doc = "Spanish"]
#[doc = ""]

pub const CFG_LANGUAGE_ES: CFG_Language = 5;
#[doc = "Simplified Chinese"]
#[doc = ""]

pub const CFG_LANGUAGE_ZH: CFG_Language = 6;
#[doc = "Korean"]
#[doc = ""]

pub const CFG_LANGUAGE_KO: CFG_Language = 7;
#[doc = "Dutch"]
#[doc = ""]

pub const CFG_LANGUAGE_NL: CFG_Language = 8;
#[doc = "Portugese"]
#[doc = ""]

pub const CFG_LANGUAGE_PT: CFG_Language = 9;
#[doc = "Russian"]
#[doc = ""]

pub const CFG_LANGUAGE_RU: CFG_Language = 10;
#[doc = "Traditional Chinese"]
#[doc = ""]

pub const CFG_LANGUAGE_TW: CFG_Language = 11;
#[doc = "Configuration language values."]
#[doc = ""]

pub type CFG_Language = ::libc::c_uint;
#[doc = "Old 3DS (CTR)"]
#[doc = ""]

pub const CFG_MODEL_3DS: CFG_SystemModel = 0;
#[doc = "Old 3DS XL (SPR)"]
#[doc = ""]

pub const CFG_MODEL_3DSXL: CFG_SystemModel = 1;
#[doc = "New 3DS (KTR)"]
#[doc = ""]

pub const CFG_MODEL_N3DS: CFG_SystemModel = 2;
#[doc = "Old 2DS (FTR)"]
#[doc = ""]

pub const CFG_MODEL_2DS: CFG_SystemModel = 3;
#[doc = "New 3DS XL (RED)"]
#[doc = ""]

pub const CFG_MODEL_N3DSXL: CFG_SystemModel = 4;
#[doc = "New 2DS XL (JAN)"]
#[doc = ""]

pub const CFG_MODEL_N2DSXL: CFG_SystemModel = 5;
pub type CFG_SystemModel = ::libc::c_uint;
extern "C" {
    #[must_use]
    #[doc = "Initializes CFGU."]
    #[doc = ""]
    pub fn cfguInit() -> Result;
}
extern "C" {
    #[doc = "Exits CFGU."]
    #[doc = ""]
    pub fn cfguExit();
}
extern "C" {
    #[must_use]
    #[doc = "Gets the system's region from secure info.\n @param region Pointer to output the region to. (see [`CFG_Region)`]"]
    #[doc = ""]
    pub fn CFGU_SecureInfoGetRegion(region: *mut u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Generates a console-unique hash.\n @param appIDSalt Salt to use.\n @param hash Pointer to output the hash to."]
    #[doc = ""]
    pub fn CFGU_GenHashConsoleUnique(appIDSalt: u32_, hash: *mut u64_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets whether the system's region is Canada or USA.\n @param value Pointer to output the result to. (0 = no, 1 = yes)"]
    #[doc = ""]
    pub fn CFGU_GetRegionCanadaUSA(value: *mut u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the system's model.\n @param model Pointer to output the model to. (see [`CFG_SystemModel)`]"]
    #[doc = ""]
    pub fn CFGU_GetSystemModel(model: *mut u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets whether the system is a 2DS.\n @param value Pointer to output the result to. (0 = yes, 1 = no)"]
    #[doc = ""]
    pub fn CFGU_GetModelNintendo2DS(value: *mut u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets a string representing a country code.\n @param code Country code to use.\n @param string Pointer to output the string to."]
    #[doc = ""]
    pub fn CFGU_GetCountryCodeString(code: u16_, string: *mut u16_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets a country code ID from its string.\n @param string String to use.\n @param code Pointer to output the country code to."]
    #[doc = ""]
    pub fn CFGU_GetCountryCodeID(string: u16_, code: *mut u16_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Checks if NFC (code name: fangate) is supported.\n @param isSupported pointer to the output the result to."]
    #[doc = ""]
    pub fn CFGU_IsNFCSupported(isSupported: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets a config info block with flags = 2.\n @param size Size of the data to retrieve.\n @param blkID ID of the block to retrieve.\n @param outData Pointer to write the block data to."]
    #[doc = ""]
    pub fn CFGU_GetConfigInfoBlk2(size: u32_, blkID: u32_, outData: *mut ::libc::c_void) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets a config info block with flags = 4.\n @param size Size of the data to retrieve.\n @param blkID ID of the block to retrieve.\n @param outData Pointer to write the block data to."]
    #[doc = ""]
    pub fn CFG_GetConfigInfoBlk4(size: u32_, blkID: u32_, outData: *mut ::libc::c_void) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets a config info block with flags = 8.\n @param size Size of the data to retrieve.\n @param blkID ID of the block to retrieve.\n @param outData Pointer to write the block data to."]
    #[doc = ""]
    pub fn CFG_GetConfigInfoBlk8(size: u32_, blkID: u32_, outData: *mut ::libc::c_void) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets a config info block with flags = 4.\n @param size Size of the data to retrieve.\n @param blkID ID of the block to retrieve.\n @param inData Pointer to block data to write."]
    #[doc = ""]
    pub fn CFG_SetConfigInfoBlk4(size: u32_, blkID: u32_, inData: *const ::libc::c_void) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets a config info block with flags = 8.\n @param size Size of the data to retrieve.\n @param blkID ID of the block to retrieve.\n @param inData Pointer to block data to write."]
    #[doc = ""]
    pub fn CFG_SetConfigInfoBlk8(size: u32_, blkID: u32_, inData: *const ::libc::c_void) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Writes the CFG buffer in memory to the savegame in NAND."]
    #[doc = ""]
    pub fn CFG_UpdateConfigSavegame() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the system's language.\n @param language Pointer to write the language to. (see [`CFG_Language)`]"]
    #[doc = ""]
    pub fn CFGU_GetSystemLanguage(language: *mut u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Deletes the NAND LocalFriendCodeSeed file, then recreates it using the LocalFriendCodeSeed data stored in memory."]
    #[doc = ""]
    pub fn CFGI_RestoreLocalFriendCodeSeed() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Deletes the NAND SecureInfo file, then recreates it using the SecureInfo data stored in memory."]
    #[doc = ""]
    pub fn CFGI_RestoreSecureInfo() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Deletes the \"config\" file stored in the NAND Config_Savegame."]
    #[doc = ""]
    pub fn CFGI_DeleteConfigSavefile() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Formats Config_Savegame."]
    #[doc = ""]
    pub fn CFGI_FormatConfig() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Clears parental controls"]
    #[doc = ""]
    pub fn CFGI_ClearParentalControls() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Verifies the RSA signature for the LocalFriendCodeSeed data already stored in memory."]
    #[doc = ""]
    pub fn CFGI_VerifySigLocalFriendCodeSeed() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Verifies the RSA signature for the SecureInfo data already stored in memory."]
    #[doc = ""]
    pub fn CFGI_VerifySigSecureInfo() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the system's serial number.\n @param serial Pointer to output the serial to. (This is normally 0xF)"]
    #[doc = ""]
    pub fn CFGI_SecureInfoGetSerialNumber(serial: *mut u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the 0x110-byte buffer containing the data for the LocalFriendCodeSeed.\n @param data Pointer to output the buffer. (The size must be at least 0x110-bytes)"]
    #[doc = ""]
    pub fn CFGI_GetLocalFriendCodeSeedData(data: *mut u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the 64-bit local friend code seed.\n @param seed Pointer to write the friend code seed to."]
    #[doc = ""]
    pub fn CFGI_GetLocalFriendCodeSeed(seed: *mut u64_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the 0x11-byte data following the SecureInfo signature.\n @param data Pointer to output the buffer. (The size must be at least 0x11-bytes)"]
    #[doc = ""]
    pub fn CFGI_GetSecureInfoData(data: *mut u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the 0x100-byte RSA-2048 SecureInfo signature.\n @param data Pointer to output the buffer. (The size must be at least 0x100-bytes)"]
    #[doc = ""]
    pub fn CFGI_GetSecureInfoSignature(data: *mut u8_) -> Result;
}
#[doc = "PCM8"]
#[doc = ""]

pub const CSND_ENCODING_PCM8: _bindgen_ty_17 = 0;
#[doc = "PCM16"]
#[doc = ""]

pub const CSND_ENCODING_PCM16: _bindgen_ty_17 = 1;
#[doc = "IMA-ADPCM"]
#[doc = ""]

pub const CSND_ENCODING_ADPCM: _bindgen_ty_17 = 2;
#[doc = "PSG (Similar to DS?)"]
#[doc = ""]

pub const CSND_ENCODING_PSG: _bindgen_ty_17 = 3;
#[doc = "CSND encodings."]
#[doc = ""]

pub type _bindgen_ty_17 = ::libc::c_uint;
#[doc = "Manual loop."]
#[doc = ""]

pub const CSND_LOOPMODE_MANUAL: _bindgen_ty_18 = 0;
#[doc = "Normal loop."]
#[doc = ""]

pub const CSND_LOOPMODE_NORMAL: _bindgen_ty_18 = 1;
#[doc = "Do not loop."]
#[doc = ""]

pub const CSND_LOOPMODE_ONESHOT: _bindgen_ty_18 = 2;
#[doc = "Don't reload."]
#[doc = ""]

pub const CSND_LOOPMODE_NORELOAD: _bindgen_ty_18 = 3;
#[doc = "CSND loop modes."]
#[doc = ""]

pub type _bindgen_ty_18 = ::libc::c_uint;
#[doc = "Linear interpolation."]
#[doc = ""]

pub const SOUND_LINEAR_INTERP: _bindgen_ty_19 = 64;
#[doc = "Repeat the sound."]
#[doc = ""]

pub const SOUND_REPEAT: _bindgen_ty_19 = 1024;
#[doc = "Play the sound once."]
#[doc = ""]

pub const SOUND_ONE_SHOT: _bindgen_ty_19 = 2048;
#[doc = "PCM8"]
#[doc = ""]

pub const SOUND_FORMAT_8BIT: _bindgen_ty_19 = 0;
#[doc = "PCM16"]
#[doc = ""]

pub const SOUND_FORMAT_16BIT: _bindgen_ty_19 = 4096;
#[doc = "ADPCM"]
#[doc = ""]

pub const SOUND_FORMAT_ADPCM: _bindgen_ty_19 = 8192;
#[doc = "PSG"]
#[doc = ""]

pub const SOUND_FORMAT_PSG: _bindgen_ty_19 = 12288;
#[doc = "Enable sound."]
#[doc = ""]

pub const SOUND_ENABLE: _bindgen_ty_19 = 16384;
#[doc = "Sound flags."]
#[doc = ""]

pub type _bindgen_ty_19 = ::libc::c_uint;
#[doc = "Repeat capture."]
#[doc = ""]

pub const CAPTURE_REPEAT: _bindgen_ty_20 = 0;
#[doc = "Capture once."]
#[doc = ""]

pub const CAPTURE_ONE_SHOT: _bindgen_ty_20 = 1;
#[doc = "PCM16"]
#[doc = ""]

pub const CAPTURE_FORMAT_16BIT: _bindgen_ty_20 = 0;
#[doc = "PCM8"]
#[doc = ""]

pub const CAPTURE_FORMAT_8BIT: _bindgen_ty_20 = 2;
#[doc = "Enable capture."]
#[doc = ""]

pub const CAPTURE_ENABLE: _bindgen_ty_20 = 32768;
#[doc = "Capture modes."]
#[doc = ""]

pub type _bindgen_ty_20 = ::libc::c_uint;
#[doc = "0.0% duty cycle"]
#[doc = ""]

pub const DutyCycle_0: CSND_DutyCycle = 7;
#[doc = "12.5% duty cycle"]
#[doc = ""]

pub const DutyCycle_12: CSND_DutyCycle = 0;
#[doc = "25.0% duty cycle"]
#[doc = ""]

pub const DutyCycle_25: CSND_DutyCycle = 1;
#[doc = "37.5% duty cycle"]
#[doc = ""]

pub const DutyCycle_37: CSND_DutyCycle = 2;
#[doc = "50.0% duty cycle"]
#[doc = ""]

pub const DutyCycle_50: CSND_DutyCycle = 3;
#[doc = "62.5% duty cycle"]
#[doc = ""]

pub const DutyCycle_62: CSND_DutyCycle = 4;
#[doc = "75.0% duty cycle"]
#[doc = ""]

pub const DutyCycle_75: CSND_DutyCycle = 5;
#[doc = "87.5% duty cycle"]
#[doc = ""]

pub const DutyCycle_87: CSND_DutyCycle = 6;
#[doc = "Duty cycles for a PSG channel."]
#[doc = ""]

pub type CSND_DutyCycle = ::libc::c_uint;
#[doc = "Channel info."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub union CSND_ChnInfo {
    #[doc = "Raw values."]
    #[doc = ""]
    pub value: [u32_; 3usize],
    pub __bindgen_anon_1: CSND_ChnInfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CSND_ChnInfo__bindgen_ty_1 {
    #[doc = "Channel active."]
    #[doc = ""]
    pub active: u8_,
    #[doc = "Padding."]
    #[doc = ""]
    pub _pad1: u8_,
    #[doc = "Padding."]
    #[doc = ""]
    pub _pad2: u16_,
    #[doc = "Current ADPCM sample."]
    #[doc = ""]
    pub adpcmSample: s16,
    #[doc = "Current ADPCM index."]
    #[doc = ""]
    pub adpcmIndex: u8_,
    #[doc = "Padding."]
    #[doc = ""]
    pub _pad3: u8_,
    #[doc = "Unknown."]
    #[doc = ""]
    pub unknownZero: u32_,
}
impl Default for CSND_ChnInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Capture info."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub union CSND_CapInfo {
    #[doc = "Raw values."]
    #[doc = ""]
    pub value: [u32_; 2usize],
    pub __bindgen_anon_1: CSND_CapInfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CSND_CapInfo__bindgen_ty_1 {
    #[doc = "Capture active."]
    #[doc = ""]
    pub active: u8_,
    #[doc = "Padding."]
    #[doc = ""]
    pub _pad1: u8_,
    #[doc = "Padding."]
    #[doc = ""]
    pub _pad2: u16_,
    #[doc = "Unknown."]
    #[doc = ""]
    pub unknownZero: u32_,
}
impl Default for CSND_CapInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = "CSND shared memory."]
    #[doc = ""]
    pub static mut csndSharedMem: *mut vu32;
}
extern "C" {
    #[doc = "CSND shared memory size."]
    #[doc = ""]
    pub static mut csndSharedMemSize: u32_;
}
extern "C" {
    #[doc = "Bitmask of channels that are allowed for usage."]
    #[doc = ""]
    pub static mut csndChannels: u32_;
}
extern "C" {
    #[must_use]
    #[doc = "Acquires a capture unit.\n @param capUnit Pointer to output the capture unit to."]
    #[doc = ""]
    pub fn CSND_AcquireCapUnit(capUnit: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Releases a capture unit.\n @param capUnit Capture unit to release."]
    #[doc = ""]
    pub fn CSND_ReleaseCapUnit(capUnit: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Flushes the data cache of a memory region.\n @param adr Address of the memory region.\n @param size Size of the memory region."]
    #[doc = ""]
    pub fn CSND_FlushDataCache(adr: *const ::libc::c_void, size: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Stores the data cache of a memory region.\n @param adr Address of the memory region.\n @param size Size of the memory region."]
    #[doc = ""]
    pub fn CSND_StoreDataCache(adr: *const ::libc::c_void, size: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Invalidates the data cache of a memory region.\n @param adr Address of the memory region.\n @param size Size of the memory region."]
    #[doc = ""]
    pub fn CSND_InvalidateDataCache(adr: *const ::libc::c_void, size: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Resets CSND.\n Note: Currently breaks sound, don't use for now!"]
    #[doc = ""]
    pub fn CSND_Reset() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initializes CSND."]
    #[doc = ""]
    pub fn csndInit() -> Result;
}
extern "C" {
    #[doc = "Exits CSND."]
    #[doc = ""]
    pub fn csndExit();
}
extern "C" {
    #[doc = "Adds a command to the list, returning a buffer to write arguments to.\n @param cmdid ID of the command to add.\n @return A buffer to write command arguments to."]
    #[doc = ""]
    pub fn csndAddCmd(cmdid: ::libc::c_int) -> *mut u32_;
}
extern "C" {
    #[doc = "Adds a command to the list, copying its arguments from a buffer.\n @param cmdid ID of the command to add.\n @param cmdparams Buffer containing the command's parameters."]
    #[doc = ""]
    pub fn csndWriteCmd(cmdid: ::libc::c_int, cmdparams: *mut u8_);
}
extern "C" {
    #[must_use]
    #[doc = "Executes pending CSND commands.\n @param waitDone Whether to wait until the commands have finished executing."]
    #[doc = ""]
    pub fn csndExecCmds(waitDone: bool) -> Result;
}
extern "C" {
    #[doc = "Sets a channel's play state, resetting registers on stop.\n @param channel Channel to use.\n @param value Play state to set."]
    #[doc = ""]
    pub fn CSND_SetPlayStateR(channel: u32_, value: u32_);
}
extern "C" {
    #[doc = "Sets a channel's play state.\n @param channel Channel to use.\n @param value Play state to set."]
    #[doc = ""]
    pub fn CSND_SetPlayState(channel: u32_, value: u32_);
}
extern "C" {
    #[doc = "Sets a channel's encoding.\n @param channel Channel to use.\n @param value Encoding to set."]
    #[doc = ""]
    pub fn CSND_SetEncoding(channel: u32_, value: u32_);
}
extern "C" {
    #[doc = "Sets the data of a channel's block.\n @param channel Channel to use.\n @param block Block to set.\n @param physaddr Physical address to set the block to.\n @param size Size of the block."]
    #[doc = ""]
    pub fn CSND_SetBlock(channel: u32_, block: ::libc::c_int, physaddr: u32_, size: u32_);
}
extern "C" {
    #[doc = "Sets whether to loop a channel.\n @param channel Channel to use.\n @param value Whether to loop the channel."]
    #[doc = ""]
    pub fn CSND_SetLooping(channel: u32_, value: u32_);
}
extern "C" {
    #[doc = "Sets bit 7 of a channel.\n @param channel Channel to use.\n @param set Value to set."]
    #[doc = ""]
    pub fn CSND_SetBit7(channel: u32_, set: bool);
}
extern "C" {
    #[doc = "Sets whether a channel should use interpolation.\n @param channel Channel to use.\n @param interp Whether to use interpolation."]
    #[doc = ""]
    pub fn CSND_SetInterp(channel: u32_, interp: bool);
}
extern "C" {
    #[doc = "Sets a channel's duty.\n @param channel Channel to use.\n @param duty Duty to set."]
    #[doc = ""]
    pub fn CSND_SetDuty(channel: u32_, duty: CSND_DutyCycle);
}
extern "C" {
    #[doc = "Sets a channel's timer.\n @param channel Channel to use.\n @param timer Timer to set."]
    #[doc = ""]
    pub fn CSND_SetTimer(channel: u32_, timer: u32_);
}
extern "C" {
    #[doc = "Sets a channel's volume.\n @param channel Channel to use.\n @param chnVolumes Channel volume data to set.\n @param capVolumes Capture volume data to set."]
    #[doc = ""]
    pub fn CSND_SetVol(channel: u32_, chnVolumes: u32_, capVolumes: u32_);
}
extern "C" {
    #[doc = "Sets a channel's ADPCM state.\n @param channel Channel to use.\n @param block Current block.\n @param sample Current sample.\n @param index Current index."]
    #[doc = ""]
    pub fn CSND_SetAdpcmState(
        channel: u32_,
        block: ::libc::c_int,
        sample: ::libc::c_int,
        index: ::libc::c_int,
    );
}
extern "C" {
    #[doc = "Sets a whether channel's ADPCM data should be reloaded when the second block is played.\n @param channel Channel to use.\n @param reload Whether to reload ADPCM data."]
    #[doc = ""]
    pub fn CSND_SetAdpcmReload(channel: u32_, reload: bool);
}
extern "C" {
    #[doc = "Sets CSND's channel registers.\n @param flags Flags to set.\n @param physaddr0 Physical address of the first buffer to play.\n @param physaddr1 Physical address of the second buffer to play.\n @param totalbytesize Total size of the data to play.\n @param chnVolumes Channel volume data.\n @param capVolumes Capture volume data."]
    #[doc = ""]
    pub fn CSND_SetChnRegs(
        flags: u32_,
        physaddr0: u32_,
        physaddr1: u32_,
        totalbytesize: u32_,
        chnVolumes: u32_,
        capVolumes: u32_,
    );
}
extern "C" {
    #[doc = "Sets CSND's PSG channel registers.\n @param flags Flags to set.\n @param chnVolumes Channel volume data.\n @param capVolumes Capture volume data.\n @param duty Duty value to set."]
    #[doc = ""]
    pub fn CSND_SetChnRegsPSG(
        flags: u32_,
        chnVolumes: u32_,
        capVolumes: u32_,
        duty: CSND_DutyCycle,
    );
}
extern "C" {
    #[doc = "Sets CSND's noise channel registers.\n @param flags Flags to set.\n @param chnVolumes Channel volume data.\n @param capVolumes Capture volume data."]
    #[doc = ""]
    pub fn CSND_SetChnRegsNoise(flags: u32_, chnVolumes: u32_, capVolumes: u32_);
}
extern "C" {
    #[doc = "Sets whether a capture unit is enabled.\n @param capUnit Capture unit to use.\n @param enable Whether to enable the capture unit."]
    #[doc = ""]
    pub fn CSND_CapEnable(capUnit: u32_, enable: bool);
}
extern "C" {
    #[doc = "Sets whether a capture unit should repeat.\n @param capUnit Capture unit to use.\n @param repeat Whether the capture unit should repeat."]
    #[doc = ""]
    pub fn CSND_CapSetRepeat(capUnit: u32_, repeat: bool);
}
extern "C" {
    #[doc = "Sets a capture unit's format.\n @param capUnit Capture unit to use.\n @param eightbit Format to use."]
    #[doc = ""]
    pub fn CSND_CapSetFormat(capUnit: u32_, eightbit: bool);
}
extern "C" {
    #[doc = "Sets a capture unit's second bit.\n @param capUnit Capture unit to use.\n @param set Value to set."]
    #[doc = ""]
    pub fn CSND_CapSetBit2(capUnit: u32_, set: bool);
}
extern "C" {
    #[doc = "Sets a capture unit's timer.\n @param capUnit Capture unit to use.\n @param timer Timer to set."]
    #[doc = ""]
    pub fn CSND_CapSetTimer(capUnit: u32_, timer: u32_);
}
extern "C" {
    #[doc = "Sets a capture unit's buffer.\n @param capUnit Capture unit to use.\n @param addr Buffer address to use.\n @param size Size of the buffer."]
    #[doc = ""]
    pub fn CSND_CapSetBuffer(capUnit: u32_, addr: u32_, size: u32_);
}
extern "C" {
    #[doc = "Sets a capture unit's capture registers.\n @param capUnit Capture unit to use.\n @param flags Capture unit flags.\n @param addr Capture unit buffer address.\n @param size Buffer size."]
    #[doc = ""]
    pub fn CSND_SetCapRegs(capUnit: u32_, flags: u32_, addr: u32_, size: u32_);
}
extern "C" {
    #[must_use]
    #[doc = "Sets up DSP flags.\n @param waitDone Whether to wait for completion."]
    #[doc = ""]
    pub fn CSND_SetDspFlags(waitDone: bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Updates CSND information.\n @param waitDone Whether to wait for completion."]
    #[doc = ""]
    pub fn CSND_UpdateInfo(waitDone: bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Plays a sound.\n @param chn Channel to play the sound on.\n @param flags Flags containing information about the sound.\n @param sampleRate Sample rate of the sound.\n @param vol The volume, ranges from 0.0 to 1.0 included.\n @param pan The pan, ranges from -1.0 to 1.0 included.\n @param data0 First block of sound data.\n @param data1 Second block of sound data. This is the block that will be looped over.\n @param size Size of the sound data.\n\n In this implementation if the loop mode is used, data1 must be in the range [data0 ; data0 + size]. Sound will be played once from data0 to data0 + size and then loop between data1 and data0+size."]
    #[doc = ""]
    pub fn csndPlaySound(
        chn: ::libc::c_int,
        flags: u32_,
        sampleRate: u32_,
        vol: f32,
        pan: f32,
        data0: *mut ::libc::c_void,
        data1: *mut ::libc::c_void,
        size: u32_,
    ) -> Result;
}
extern "C" {
    #[doc = "Gets CSND's DSP flags.\n Note: Requires previous CSND_UpdateInfo()\n @param outSemFlags Pointer to write semaphore flags to.\n @param outIrqFlags Pointer to write interrupt flags to."]
    #[doc = ""]
    pub fn csndGetDspFlags(outSemFlags: *mut u32_, outIrqFlags: *mut u32_);
}
extern "C" {
    #[doc = "Gets a channel's information.\n Note: Requires previous CSND_UpdateInfo()\n @param channel Channel to get information for.\n @return The channel's information."]
    #[doc = ""]
    pub fn csndGetChnInfo(channel: u32_) -> *mut CSND_ChnInfo;
}
extern "C" {
    #[doc = "Gets a capture unit's information.\n Note: Requires previous CSND_UpdateInfo()\n @param capUnit Capture unit to get information for.\n @return The capture unit's information."]
    #[doc = ""]
    pub fn csndGetCapInfo(capUnit: u32_) -> *mut CSND_CapInfo;
}
extern "C" {
    #[must_use]
    #[doc = "Gets a channel's state.\n @param channel Channel to get the state of.\n @param out Pointer to output channel information to."]
    #[doc = ""]
    pub fn csndGetState(channel: u32_, out: *mut CSND_ChnInfo) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets whether a channel is playing.\n @param channel Channel to check.\n @param status Pointer to output the channel status to."]
    #[doc = ""]
    pub fn csndIsPlaying(channel: u32_, status: *mut u8_) -> Result;
}
#[doc = "Pipe interrupt."]
#[doc = ""]

pub const DSP_INTERRUPT_PIPE: DSP_InterruptType = 2;
#[doc = "DSP interrupt types."]
#[doc = ""]

pub type DSP_InterruptType = ::libc::c_uint;
#[doc = "DSP is going to sleep."]
#[doc = ""]

pub const DSPHOOK_ONSLEEP: DSP_HookType = 0;
#[doc = "DSP is waking up."]
#[doc = ""]

pub const DSPHOOK_ONWAKEUP: DSP_HookType = 1;
#[doc = "DSP was sleeping and the app was cancelled."]
#[doc = ""]

pub const DSPHOOK_ONCANCEL: DSP_HookType = 2;
#[doc = "DSP hook types."]
#[doc = ""]

pub type DSP_HookType = ::libc::c_uint;
#[doc = "DSP hook function."]
#[doc = ""]

pub type dspHookFn = ::core::option::Option<unsafe extern "C" fn(hook: DSP_HookType)>;
#[doc = "DSP hook cookie."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tag_dspHookCookie {
    #[doc = "Next cookie."]
    #[doc = ""]
    pub next: *mut tag_dspHookCookie,
    #[doc = "Hook callback."]
    #[doc = ""]
    pub callback: dspHookFn,
}
impl Default for tag_dspHookCookie {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "DSP hook cookie."]
#[doc = ""]

pub type dspHookCookie = tag_dspHookCookie;
extern "C" {
    #[must_use]
    #[doc = "Initializes the dsp service.\n\n Call this before calling any DSP_* function.\n @note This will also unload any previously loaded DSP binary.\n It is done this way since you have to provide your binary when the 3DS leaves sleep mode anyway."]
    #[doc = ""]
    pub fn dspInit() -> Result;
}
extern "C" {
    #[doc = "Closes the dsp service.\n @note This will also unload the DSP binary."]
    #[doc = ""]
    pub fn dspExit();
}
extern "C" {
    #[doc = "Returns true if a component is loaded, false otherwise."]
    #[doc = ""]
    pub fn dspIsComponentLoaded() -> bool;
}
extern "C" {
    #[doc = "Sets up a DSP status hook.\n @param cookie Hook cookie to use.\n @param callback Function to call when DSP's status changes."]
    #[doc = ""]
    pub fn dspHook(cookie: *mut dspHookCookie, callback: dspHookFn);
}
extern "C" {
    #[doc = "Removes a DSP status hook.\n @param cookie Hook cookie to remove."]
    #[doc = ""]
    pub fn dspUnhook(cookie: *mut dspHookCookie);
}
extern "C" {
    #[must_use]
    #[doc = "Checks if a headphone is inserted.\n @param is_inserted Pointer to output the insertion status to."]
    #[doc = ""]
    pub fn DSP_GetHeadphoneStatus(is_inserted: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Flushes the cache\n @param address Beginning of the memory range to flush, inside the Linear or DSP memory regions\n @param size Size of the memory range to flush\n\n Flushes the cache for the specified memory range and invalidates the cache"]
    #[doc = ""]
    pub fn DSP_FlushDataCache(address: *const ::libc::c_void, size: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Invalidates the cache\n @param address Beginning of the memory range to invalidate, inside the Linear or DSP memory regions\n @param size Size of the memory range to flush\n\n Invalidates the cache for the specified memory range"]
    #[doc = ""]
    pub fn DSP_InvalidateDataCache(address: *const ::libc::c_void, size: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Retrieves the handle of the DSP semaphore.\n @param semaphore Pointer to output the semaphore to."]
    #[doc = ""]
    pub fn DSP_GetSemaphoreHandle(semaphore: *mut Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the DSP hardware semaphore value.\n @param value Value to set."]
    #[doc = ""]
    pub fn DSP_SetSemaphore(value: u16_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Masks the DSP hardware semaphore value.\n @param mask Mask to apply."]
    #[doc = ""]
    pub fn DSP_SetSemaphoreMask(mask: u16_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Loads a DSP binary and starts the DSP\n @param component The program file address in memory\n @param size The size of the program\n @param prog_mask DSP memory block related ? Default is 0xff.\n @param data_mask DSP memory block related ? Default is 0xff.\n @param is_loaded Indicates if the DSP was succesfully loaded.\n\n @note The binary must be signed (http://3dbrew.org/wiki/DSP_Binary)\n @note Seems to be called when the 3ds leaves the Sleep mode"]
    #[doc = ""]
    pub fn DSP_LoadComponent(
        component: *const ::libc::c_void,
        size: u32_,
        prog_mask: u16_,
        data_mask: u16_,
        is_loaded: *mut bool,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Stops the DSP by unloading the binary."]
    #[doc = ""]
    pub fn DSP_UnloadComponent() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Registers an event handle with the DSP through IPC\n @param handle Event handle to register.\n @param interrupt The type of interrupt that will trigger the event. Usual value is DSP_INTERRUPT_PIPE.\n @param channel The pipe channel. Usual value is 2\n\n @note It is possible that interrupt are inverted"]
    #[doc = ""]
    pub fn DSP_RegisterInterruptEvents(handle: Handle, interrupt: u32_, channel: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Reads a pipe if possible.\n @param channel unknown. Usually 2\n @param peer unknown. Usually 0\n @param buffer The buffer that will store the values read from the pipe\n @param length Length of the buffer\n @param length_read Number of bytes read by the command"]
    #[doc = ""]
    pub fn DSP_ReadPipeIfPossible(
        channel: u32_,
        peer: u32_,
        buffer: *mut ::libc::c_void,
        length: u16_,
        length_read: *mut u16_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Writes to a pipe.\n @param channel unknown. Usually 2\n @param buffer The message to send to the DSP process\n @param length Length of the message"]
    #[doc = ""]
    pub fn DSP_WriteProcessPipe(
        channel: u32_,
        buffer: *const ::libc::c_void,
        length: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Converts a DSP memory address to a virtual address usable by the process.\n @param dsp_address Address to convert.\n @param arm_address Pointer to output the converted address to."]
    #[doc = ""]
    pub fn DSP_ConvertProcessAddressFromDspDram(
        dsp_address: u32_,
        arm_address: *mut u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Reads a DSP register\n @param regNo Offset of the hardware register, base address is 0x1EC40000\n @param value Pointer to read the register value to."]
    #[doc = ""]
    pub fn DSP_RecvData(regNo: u16_, value: *mut u16_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Checks if you can read a DSP register\n @param regNo Offset of the hardware register, base address is 0x1EC40000\n @param is_ready Pointer to write the ready status to.\n\n @warning This call might hang if the data is not ready. See [`DSP_SendDataIsEmpty`]"]
    #[doc = ""]
    pub fn DSP_RecvDataIsReady(regNo: u16_, is_ready: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Writes to a DSP register\n @param regNo Offset of the hardware register, base address is 0x1EC40000\n @param value Value to write.\n\n @warning This call might hang if the SendData is not empty. See [`DSP_SendDataIsEmpty`]"]
    #[doc = ""]
    pub fn DSP_SendData(regNo: u16_, value: u16_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Checks if you can write to a DSP register ?\n @param regNo Offset of the hardware register, base address is 0x1EC40000\n @param is_empty Pointer to write the empty status to."]
    #[doc = ""]
    pub fn DSP_SendDataIsEmpty(regNo: u16_, is_empty: *mut bool) -> Result;
}
pub type FSPXI_Archive = u64_;
pub type FSPXI_File = u64_;
pub type FSPXI_Directory = u64_;
extern "C" {
    #[must_use]
    #[doc = "Opens a file.\n @param out Pointer to output the file handle to.\n @param archive Archive containing the file.\n @param path Path of the file.\n @param flags Flags to open the file with.\n @param attributes Attributes of the file."]
    #[doc = ""]
    pub fn FSPXI_OpenFile(
        serviceHandle: Handle,
        out: *mut FSPXI_File,
        archive: FSPXI_Archive,
        path: FS_Path,
        flags: u32_,
        attributes: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Deletes a file.\n @param archive Archive containing the file.\n @param path Path of the file."]
    #[doc = ""]
    pub fn FSPXI_DeleteFile(serviceHandle: Handle, archive: FSPXI_Archive, path: FS_Path)
        -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Renames a file.\n @param srcArchive Archive containing the source file.\n @param srcPath Path of the source file.\n @param dstArchive Archive containing the destination file.\n @param dstPath Path of the destination file."]
    #[doc = ""]
    pub fn FSPXI_RenameFile(
        serviceHandle: Handle,
        srcArchive: FSPXI_Archive,
        srcPath: FS_Path,
        dstArchive: FSPXI_Archive,
        dstPath: FS_Path,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Deletes a directory.\n @param archive Archive containing the directory.\n @param path Path of the directory."]
    #[doc = ""]
    pub fn FSPXI_DeleteDirectory(
        serviceHandle: Handle,
        archive: FSPXI_Archive,
        path: FS_Path,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Creates a file.\n @param archive Archive to create the file in.\n @param path Path of the file.\n @param attributes Attributes of the file.\n @param size Size of the file."]
    #[doc = ""]
    pub fn FSPXI_CreateFile(
        serviceHandle: Handle,
        archive: FSPXI_Archive,
        path: FS_Path,
        attributes: u32_,
        fileSize: u64_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Creates a directory.\n @param archive Archive to create the directory in.\n @param path Path of the directory.\n @param attributes Attributes of the directory."]
    #[doc = ""]
    pub fn FSPXI_CreateDirectory(
        serviceHandle: Handle,
        archive: FSPXI_Archive,
        path: FS_Path,
        attributes: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Renames a directory.\n @param srcArchive Archive containing the source directory.\n @param srcPath Path of the source directory.\n @param dstArchive Archive containing the destination directory.\n @param dstPath Path of the destination directory."]
    #[doc = ""]
    pub fn FSPXI_RenameDirectory(
        serviceHandle: Handle,
        srcArchive: FSPXI_Archive,
        srcPath: FS_Path,
        dstArchive: FSPXI_Archive,
        dstPath: FS_Path,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Opens a directory.\n @param out Pointer to output the directory handle to.\n @param archive Archive containing the directory.\n @param path Path of the directory."]
    #[doc = ""]
    pub fn FSPXI_OpenDirectory(
        serviceHandle: Handle,
        out: *mut FSPXI_Directory,
        archive: FSPXI_Archive,
        path: FS_Path,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Reads from a file.\n @param file File to read from.\n @param bytesRead Pointer to output the number of read bytes to.\n @param offset Offset to read from.\n @param buffer Buffer to read to.\n @param size Size of the buffer."]
    #[doc = ""]
    pub fn FSPXI_ReadFile(
        serviceHandle: Handle,
        file: FSPXI_File,
        bytesRead: *mut u32_,
        offset: u64_,
        buffer: *mut ::libc::c_void,
        size: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Calculate SHA256 of a file.\n @param file File to calculate the hash of.\n @param buffer Buffer to output the hash to.\n @param size Size of the buffer."]
    #[doc = ""]
    pub fn FSPXI_CalculateFileHashSHA256(
        serviceHandle: Handle,
        file: FSPXI_File,
        buffer: *mut ::libc::c_void,
        size: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Writes to a file.\n @param file File to write to.\n @param bytesWritten Pointer to output the number of bytes written to.\n @param offset Offset to write to.\n @param buffer Buffer to write from.\n @param size Size of the buffer.\n @param flags Flags to use when writing."]
    #[doc = ""]
    pub fn FSPXI_WriteFile(
        serviceHandle: Handle,
        file: FSPXI_File,
        bytesWritten: *mut u32_,
        offset: u64_,
        buffer: *const ::libc::c_void,
        size: u32_,
        flags: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Calculates the MAC used in a DISA/DIFF header?\n @param file Unsure\n @param inBuffer 0x100-byte DISA/DIFF input buffer.\n @param inSize Size of inBuffer.\n @param outBuffer Buffer to write MAC to.\n @param outSize Size of outBuffer."]
    #[doc = ""]
    pub fn FSPXI_CalcSavegameMAC(
        serviceHandle: Handle,
        file: FSPXI_File,
        inBuffer: *const ::libc::c_void,
        inSize: u32_,
        outBuffer: *mut ::libc::c_void,
        outSize: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Get size of a file\n @param file File to get the size of.\n @param size Pointer to output size to."]
    #[doc = ""]
    pub fn FSPXI_GetFileSize(serviceHandle: Handle, file: FSPXI_File, size: *mut u64_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Set size of a file\n @param file File to set the size of\n @param size Size to set the file to"]
    #[doc = ""]
    pub fn FSPXI_SetFileSize(serviceHandle: Handle, file: FSPXI_File, size: u64_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Close a file\n @param file File to close"]
    #[doc = ""]
    pub fn FSPXI_CloseFile(serviceHandle: Handle, file: FSPXI_File) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Reads one or more directory entries.\n @param directory Directory to read from.\n @param entriesRead Pointer to output the number of entries read to.\n @param entryCount Number of entries to read.\n @param entryOut Pointer to output directory entries to."]
    #[doc = ""]
    pub fn FSPXI_ReadDirectory(
        serviceHandle: Handle,
        directory: FSPXI_Directory,
        entriesRead: *mut u32_,
        entryCount: u32_,
        entries: *mut FS_DirectoryEntry,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Close a directory\n @param directory Directory to close."]
    #[doc = ""]
    pub fn FSPXI_CloseDirectory(serviceHandle: Handle, directory: FSPXI_Directory) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Opens an archive.\n @param archive Pointer to output the opened archive to.\n @param id ID of the archive.\n @param path Path of the archive."]
    #[doc = ""]
    pub fn FSPXI_OpenArchive(
        serviceHandle: Handle,
        archive: *mut FSPXI_Archive,
        archiveID: FS_ArchiveID,
        path: FS_Path,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Checks if the archive contains a file at path.\n @param archive Archive to check.\n @param out Pointer to output existence to.\n @param path Path to check for file"]
    #[doc = ""]
    pub fn FSPXI_HasFile(
        serviceHandle: Handle,
        archive: FSPXI_Archive,
        out: *mut bool,
        path: FS_Path,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Checks if the archive contains a directory at path.\n @param archive Archive to check.\n @param out Pointer to output existence to.\n @param path Path to check for directory"]
    #[doc = ""]
    pub fn FSPXI_HasDirectory(
        serviceHandle: Handle,
        archive: FSPXI_Archive,
        out: *mut bool,
        path: FS_Path,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Commits an archive's save data.\n @param archive Archive to commit.\n @param id Archive action sent by FSUSER_ControlArchive. Must not be 0 or 0x789D\n @remark Unsure why id is sent. This appears to be the default action for FSUSER_ControlArchive, with every action other than 0 and 0x789D being sent to this command."]
    #[doc = ""]
    pub fn FSPXI_CommitSaveData(serviceHandle: Handle, archive: FSPXI_Archive, id: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Close an archive\n @param archive Archive to close."]
    #[doc = ""]
    pub fn FSPXI_CloseArchive(serviceHandle: Handle, archive: FSPXI_Archive) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Unknown 0x17. Appears to be an \"is archive handle valid\" command?\n @param archive Archive handle to check validity of.\n @param out Pointer to output validity to."]
    #[doc = ""]
    pub fn FSPXI_Unknown0x17(
        serviceHandle: Handle,
        archive: FSPXI_Archive,
        out: *mut bool,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the inserted card type.\n @param out Pointer to output the card type to."]
    #[doc = ""]
    pub fn FSPXI_GetCardType(serviceHandle: Handle, out: *mut FS_CardType) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the SDMC archive resource information.\n @param out Pointer to output the archive resource information to."]
    #[doc = ""]
    pub fn FSPXI_GetSdmcArchiveResource(
        serviceHandle: Handle,
        out: *mut FS_ArchiveResource,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the NAND archive resource information.\n @param out Pointer to output the archive resource information to."]
    #[doc = ""]
    pub fn FSPXI_GetNandArchiveResource(
        serviceHandle: Handle,
        out: *mut FS_ArchiveResource,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the error code from the SDMC FatFS driver\n @param out Pointer to output the error code to"]
    #[doc = ""]
    pub fn FSPXI_GetSdmcFatFsError(serviceHandle: Handle, out: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets whether PXIFS0 detects the SD\n @param out Pointer to output the detection status to"]
    #[doc = ""]
    pub fn FSPXI_IsSdmcDetected(serviceHandle: Handle, out: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets whether PXIFS0 can write to the SD\n @param out Pointer to output the writable status to"]
    #[doc = ""]
    pub fn FSPXI_IsSdmcWritable(serviceHandle: Handle, out: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the SDMC CID\n @param out Buffer to output the CID to.\n @param size Size of buffer."]
    #[doc = ""]
    pub fn FSPXI_GetSdmcCid(serviceHandle: Handle, out: *mut ::libc::c_void, size: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the NAND CID\n @param out Buffer to output the CID to.\n @param size Size of buffer."]
    #[doc = ""]
    pub fn FSPXI_GetNandCid(serviceHandle: Handle, out: *mut ::libc::c_void, size: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the SDMC speed info\n @param out Buffer to output the speed info to."]
    #[doc = ""]
    pub fn FSPXI_GetSdmcSpeedInfo(serviceHandle: Handle, out: *mut FS_SdMmcSpeedInfo) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the NAND speed info\n @param out Buffer to output the speed info to."]
    #[doc = ""]
    pub fn FSPXI_GetNandSpeedInfo(serviceHandle: Handle, out: *mut FS_SdMmcSpeedInfo) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the SDMC log\n @param out Buffer to output the log to.\n @param size Size of buffer."]
    #[doc = ""]
    pub fn FSPXI_GetSdmcLog(serviceHandle: Handle, out: *mut ::libc::c_void, size: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the NAND log\n @param out Buffer to output the log to.\n @param size Size of buffer."]
    #[doc = ""]
    pub fn FSPXI_GetNandLog(serviceHandle: Handle, out: *mut ::libc::c_void, size: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Clears the SDMC log"]
    #[doc = ""]
    pub fn FSPXI_ClearSdmcLog(serviceHandle: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Clears the NAND log"]
    #[doc = ""]
    pub fn FSPXI_ClearNandLog(serviceHandle: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets whether a card is inserted.\n @param inserted Pointer to output the insertion status to."]
    #[doc = ""]
    pub fn FSPXI_CardSlotIsInserted(serviceHandle: Handle, inserted: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Powers on the card slot.\n @param status Pointer to output the power status to."]
    #[doc = ""]
    pub fn FSPXI_CardSlotPowerOn(serviceHandle: Handle, status: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Powers off the card slot.\n @param status Pointer to output the power status to."]
    #[doc = ""]
    pub fn FSPXI_CardSlotPowerOff(serviceHandle: Handle, status: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the card's power status.\n @param status Pointer to output the power status to."]
    #[doc = ""]
    pub fn FSPXI_CardSlotGetCardIFPowerStatus(serviceHandle: Handle, status: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Executes a CARDNOR direct command.\n @param commandId ID of the command."]
    #[doc = ""]
    pub fn FSPXI_CardNorDirectCommand(serviceHandle: Handle, commandId: u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Executes a CARDNOR direct command with an address.\n @param commandId ID of the command.\n @param address Address to provide."]
    #[doc = ""]
    pub fn FSPXI_CardNorDirectCommandWithAddress(
        serviceHandle: Handle,
        commandId: u8_,
        address: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Executes a CARDNOR direct read.\n @param commandId ID of the command.\n @param size Size of the output buffer.\n @param output Output buffer."]
    #[doc = ""]
    pub fn FSPXI_CardNorDirectRead(
        serviceHandle: Handle,
        commandId: u8_,
        size: u32_,
        output: *mut ::libc::c_void,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Executes a CARDNOR direct read with an address.\n @param commandId ID of the command.\n @param address Address to provide.\n @param size Size of the output buffer.\n @param output Output buffer."]
    #[doc = ""]
    pub fn FSPXI_CardNorDirectReadWithAddress(
        serviceHandle: Handle,
        commandId: u8_,
        address: u32_,
        size: u32_,
        output: *mut ::libc::c_void,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Executes a CARDNOR direct write.\n @param commandId ID of the command.\n @param size Size of the input buffer.\n @param output Input buffer.\n @remark Stubbed in latest firmware, since ?.?.?"]
    #[doc = ""]
    pub fn FSPXI_CardNorDirectWrite(
        serviceHandle: Handle,
        commandId: u8_,
        size: u32_,
        input: *const ::libc::c_void,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Executes a CARDNOR direct write with an address.\n @param commandId ID of the command.\n @param address Address to provide.\n @param size Size of the input buffer.\n @param input Input buffer."]
    #[doc = ""]
    pub fn FSPXI_CardNorDirectWriteWithAddress(
        serviceHandle: Handle,
        commandId: u8_,
        address: u32_,
        size: u32_,
        input: *const ::libc::c_void,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Executes a CARDNOR 4xIO direct read.\n @param commandId ID of the command.\n @param address Address to provide.\n @param size Size of the output buffer.\n @param output Output buffer."]
    #[doc = ""]
    pub fn FSPXI_CardNorDirectRead_4xIO(
        serviceHandle: Handle,
        commandId: u8_,
        address: u32_,
        size: u32_,
        output: *mut ::libc::c_void,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Executes a CARDNOR direct CPU write without verify.\n @param address Address to provide.\n @param size Size of the input buffer.\n @param output Input buffer."]
    #[doc = ""]
    pub fn FSPXI_CardNorDirectCpuWriteWithoutVerify(
        serviceHandle: Handle,
        address: u32_,
        size: u32_,
        input: *const ::libc::c_void,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Executes a CARDNOR direct sector erase without verify.\n @param address Address to provide."]
    #[doc = ""]
    pub fn FSPXI_CardNorDirectSectorEraseWithoutVerify(
        serviceHandle: Handle,
        address: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets an NCCH's product info\n @param info Pointer to output the product info to.\n @param archive Open NCCH content archive"]
    #[doc = ""]
    pub fn FSPXI_GetProductInfo(
        serviceHandle: Handle,
        info: *mut FS_ProductInfo,
        archive: FSPXI_Archive,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the CARDSPI baud rate.\n @param baudRate Baud rate to set."]
    #[doc = ""]
    pub fn FSPXI_SetCardSpiBaudrate(serviceHandle: Handle, baudRate: FS_CardSpiBaudRate) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the CARDSPI bus mode.\n @param busMode Bus mode to set."]
    #[doc = ""]
    pub fn FSPXI_SetCardSpiBusMode(serviceHandle: Handle, busMode: FS_CardSpiBusMode) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sends initialization info to ARM9\n @param unk FS sends *(0x1FF81086)"]
    #[doc = ""]
    pub fn FSPXI_SendInitializeInfoTo9(serviceHandle: Handle, unk: u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Creates ext save data.\n @param info Info of the save data."]
    #[doc = ""]
    pub fn FSPXI_CreateExtSaveData(serviceHandle: Handle, info: FS_ExtSaveDataInfo) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Deletes ext save data.\n @param info Info of the save data."]
    #[doc = ""]
    pub fn FSPXI_DeleteExtSaveData(serviceHandle: Handle, info: FS_ExtSaveDataInfo) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Enumerates ext save data.\n @param idsWritten Pointer to output the number of IDs written to.\n @param idsSize Size of the IDs buffer.\n @param mediaType Media type to enumerate over.\n @param idSize Size of each ID element.\n @param shared Whether to enumerate shared ext save data.\n @param ids Pointer to output IDs to."]
    #[doc = ""]
    pub fn FSPXI_EnumerateExtSaveData(
        serviceHandle: Handle,
        idsWritten: *mut u32_,
        idsSize: u32_,
        mediaType: FS_MediaType,
        idSize: u32_,
        shared: bool,
        ids: *mut u8_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets a special content's index.\n @param index Pointer to output the index to.\n @param mediaType Media type of the special content.\n @param programId Program ID owning the special content.\n @param type Type of special content."]
    #[doc = ""]
    pub fn FSPXI_GetSpecialContentIndex(
        serviceHandle: Handle,
        index: *mut u16_,
        mediaType: FS_MediaType,
        programId: u64_,
        type_: FS_SpecialContentType,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the legacy ROM header of a program.\n @param mediaType Media type of the program.\n @param programId ID of the program.\n @param header Pointer to output the legacy ROM header to. (size = 0x3B4)"]
    #[doc = ""]
    pub fn FSPXI_GetLegacyRomHeader(
        serviceHandle: Handle,
        mediaType: FS_MediaType,
        programId: u64_,
        header: *mut ::libc::c_void,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the legacy banner data of a program.\n @param mediaType Media type of the program.\n @param programId ID of the program.\n @param banner Pointer to output the legacy banner data to. (size = 0x23C0)\n @param unk Unknown. Always 1?"]
    #[doc = ""]
    pub fn FSPXI_GetLegacyBannerData(
        serviceHandle: Handle,
        mediaType: FS_MediaType,
        programId: u64_,
        banner: *mut ::libc::c_void,
        unk: u8_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Formats the CARDNOR device.\n @param unk Unknown. Transaction?"]
    #[doc = ""]
    pub fn FSPXI_FormatCardNorDevice(serviceHandle: Handle, unk: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Deletes the 3DS SDMC root."]
    #[doc = ""]
    pub fn FSPXI_DeleteSdmcRoot(serviceHandle: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Deletes all ext save data on the NAND."]
    #[doc = ""]
    pub fn FSPXI_DeleteAllExtSaveDataOnNand(serviceHandle: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initializes the CTR file system."]
    #[doc = ""]
    pub fn FSPXI_InitializeCtrFilesystem(serviceHandle: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Creates the FS seed."]
    #[doc = ""]
    pub fn FSPXI_CreateSeed(serviceHandle: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the CTR SDMC root path.\n @param out Pointer to output the root path to.\n @param length Length of the output buffer in bytes."]
    #[doc = ""]
    pub fn FSPXI_GetSdmcCtrRootPath(serviceHandle: Handle, out: *mut u16_, length: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets an archive's resource information.\n @param archiveResource Pointer to output the archive resource information to.\n @param mediaType System media type to check."]
    #[doc = ""]
    pub fn FSPXI_GetArchiveResource(
        serviceHandle: Handle,
        archiveResource: *mut FS_ArchiveResource,
        mediaType: FS_SystemMediaType,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Exports the integrity verification seed.\n @param seed Pointer to output the seed to."]
    #[doc = ""]
    pub fn FSPXI_ExportIntegrityVerificationSeed(
        serviceHandle: Handle,
        seed: *mut FS_IntegrityVerificationSeed,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Imports an integrity verification seed.\n @param seed Seed to import."]
    #[doc = ""]
    pub fn FSPXI_ImportIntegrityVerificationSeed(
        serviceHandle: Handle,
        seed: *const FS_IntegrityVerificationSeed,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the legacy sub banner data of a program.\n @param bannerSize Size of the banner.\n @param mediaType Media type of the program.\n @param programId ID of the program.\n @param header Pointer to output the legacy sub banner data to."]
    #[doc = ""]
    pub fn FSPXI_GetLegacySubBannerData(
        serviceHandle: Handle,
        bannerSize: u32_,
        mediaType: FS_MediaType,
        programId: u64_,
        banner: *mut ::libc::c_void,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Generates random bytes. Uses same code as PSPXI_GenerateRandomBytes\n @param buf Buffer to output random bytes to.\n @param size Size of buffer."]
    #[doc = ""]
    pub fn FSPXI_GenerateRandomBytes(
        serviceHandle: Handle,
        buffer: *mut ::libc::c_void,
        size: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the last modified time of a file in an archive.\n @param archive The archive that contains the file.\n @param out The pointer to write the timestamp to.\n @param path The UTF-16 path of the file.\n @param size The size of the path."]
    #[doc = ""]
    pub fn FSPXI_GetFileLastModified(
        serviceHandle: Handle,
        archive: FSPXI_Archive,
        out: *mut u64_,
        path: *const u16_,
        size: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Reads from a special file.\n @param bytesRead Pointer to output the number of bytes read to.\n @param fileOffset Offset of the file.\n @param size Size of the buffer.\n @param data Buffer to read to."]
    #[doc = ""]
    pub fn FSPXI_ReadSpecialFile(
        serviceHandle: Handle,
        bytesRead: *mut u32_,
        fileOffset: u64_,
        size: u32_,
        data: *mut ::libc::c_void,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the size of a special file.\n @param fileSize Pointer to output the size to."]
    #[doc = ""]
    pub fn FSPXI_GetSpecialFileSize(serviceHandle: Handle, fileSize: *mut u64_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initiates a device move as the source device.\n @param context Pointer to output the context to."]
    #[doc = ""]
    pub fn FSPXI_StartDeviceMoveAsSource(
        serviceHandle: Handle,
        context: *mut FS_DeviceMoveContext,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initiates a device move as the destination device.\n @param context Context to use.\n @param clear Whether to clear the device's data first."]
    #[doc = ""]
    pub fn FSPXI_StartDeviceMoveAsDestination(
        serviceHandle: Handle,
        context: FS_DeviceMoveContext,
        clear: bool,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Reads data and stores SHA256 hashes of blocks\n @param file File to read from.\n @param bytesRead Pointer to output the number of read bytes to.\n @param offset Offset to read from.\n @param readBuffer Pointer to store read data in.\n @param readBufferSize Size of readBuffer.\n @param hashtable Pointer to store SHA256 hashes in.\n @param hashtableSize Size of hashtable.\n @param unk Unknown. Always 0x00001000? Possibly block size?"]
    #[doc = ""]
    pub fn FSPXI_ReadFileSHA256(
        serviceHandle: Handle,
        file: FSPXI_File,
        bytesRead: *mut u32_,
        offset: u64_,
        readBuffer: *mut ::libc::c_void,
        readBufferSize: u32_,
        hashtable: *mut ::libc::c_void,
        hashtableSize: u32_,
        unk: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Assumedly writes data and stores SHA256 hashes of blocks\n @param file File to write to.\n @param bytesWritten Pointer to output the number of written bytes to.\n @param offset Offset to write to.\n @param writeBuffer Buffer to write from.\n @param writeBufferSize Size of writeBuffer.\n @param hashtable Pointer to store SHA256 hashes in.\n @param hashtableSize Size of hashtable\n @param unk1 Unknown. Might match with ReadFileSHA256's unknown?\n @param unk2 Unknown. Might match with ReadFileSHA256's unknown?"]
    #[doc = ""]
    pub fn FSPXI_WriteFileSHA256(
        serviceHandle: Handle,
        file: FSPXI_File,
        bytesWritten: *mut u32_,
        offset: u64_,
        writeBuffer: *const ::libc::c_void,
        writeBufferSize: u32_,
        hashtable: *mut ::libc::c_void,
        hashtableSize: u32_,
        unk1: u32_,
        unk2: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Configures CTRCARD latency emulation.\n @param latency Latency to apply."]
    #[doc = ""]
    pub fn FSPXI_SetCtrCardLatencyParameter(serviceHandle: Handle, latency: u64_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the file system priority.\n @param priority Priority to set."]
    #[doc = ""]
    pub fn FSPXI_SetPriority(serviceHandle: Handle, priority: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Toggles cleaning up invalid save data.\n @param enable Whether to enable cleaning up invalid save data."]
    #[doc = ""]
    pub fn FSPXI_SwitchCleanupInvalidSaveData(serviceHandle: Handle, enable: bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Enumerates system save data.\n @param idsWritten Pointer to output the number of IDs written to.\n @param idsSize Size of the IDs buffer.\n @param ids Pointer to output IDs to."]
    #[doc = ""]
    pub fn FSPXI_EnumerateSystemSaveData(
        serviceHandle: Handle,
        idsWritten: *mut u32_,
        idsSize: u32_,
        ids: *mut u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Reads the NAND report.\n @param unk Unknown\n @param buffer Buffer to write the report to.\n @param size Size of buffer"]
    #[doc = ""]
    pub fn FSPXI_ReadNandReport(
        serviceHandle: Handle,
        buffer: *mut ::libc::c_void,
        size: u32_,
        unk: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Unknown command 0x56\n @remark Called by FSUSER_ControlArchive with ArchiveAction 0x789D"]
    #[doc = ""]
    pub fn FSPXI_Unknown0x56(
        serviceHandle: Handle,
        out: *mut u32_,
        archive: FS_Archive,
        path: FS_Path,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initializes fs:REG."]
    #[doc = ""]
    pub fn fsRegInit() -> Result;
}
extern "C" {
    #[doc = "Exits fs:REG."]
    #[doc = ""]
    pub fn fsRegExit();
}
extern "C" {
    #[doc = "Gets the current fs:REG session handle.\n @return The current fs:REG session handle."]
    #[doc = ""]
    pub fn fsRegGetSessionHandle() -> *mut Handle;
}
extern "C" {
    #[must_use]
    #[doc = "Registers a program's storage information.\n @param pid The Process ID of the program.\n @param programHandle The program handle.\n @param programInfo Information about the program.\n @param storageInfo Storage information to register."]
    #[doc = ""]
    pub fn FSREG_Register(
        pid: u32_,
        programHandle: u64_,
        programInfo: *const FS_ProgramInfo,
        storageInfo: *const ExHeader_Arm11StorageInfo,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Unregisters a program's storage information.\n @param pid The Process ID of the program."]
    #[doc = ""]
    pub fn FSREG_Unregister(pid: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Retrives the exheader information set(s) (SCI+ACI) about a program.\n @param exheaderInfos[out] Pointer to the output exheader information set(s).\n @param maxNumEntries The maximum number of entries.\n @param programHandle The program handle."]
    #[doc = ""]
    pub fn FSREG_GetProgramInfo(
        exheaderInfos: *mut ExHeader_Info,
        maxNumEntries: u32_,
        programHandle: u64_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Loads a program.\n @param programHandle[out] Pointer to the output the program handle to.\n @param programInfo Information about the program to load."]
    #[doc = ""]
    pub fn FSREG_LoadProgram(
        programHandle: *mut u64_,
        programInfo: *const FS_ProgramInfo,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Unloads a program.\n @param programHandle The program handle."]
    #[doc = ""]
    pub fn FSREG_UnloadProgram(programHandle: u64_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Checks if a program has been loaded by fs:REG.\n @param programHandle The program handle."]
    #[doc = ""]
    pub fn FSREG_CheckHostLoadId(programHandle: u64_) -> Result;
}
#[doc = "Shared Mii struct"]
#[doc = ""]
#[repr(C)]
#[repr(align(1))]
pub struct MiiData {
    pub _bindgen_opaque_blob: [u8; 92usize],
}
#[doc = "Mii options"]
#[doc = ""]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MiiData__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl MiiData__bindgen_ty_1 {
    #[inline]
    pub fn allow_copying(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_allow_copying(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_private_name(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_private_name(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn region_lock(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_region_lock(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn char_set(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_char_set(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        allow_copying: bool,
        is_private_name: bool,
        region_lock: u8_,
        char_set: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let allow_copying: u8 = unsafe { ::core::mem::transmute(allow_copying) };
            allow_copying as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let is_private_name: u8 = unsafe { ::core::mem::transmute(is_private_name) };
            is_private_name as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let region_lock: u8 = unsafe { ::core::mem::transmute(region_lock) };
            region_lock as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let char_set: u8 = unsafe { ::core::mem::transmute(char_set) };
            char_set as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "Mii position in Mii selector or Mii maker"]
#[doc = ""]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MiiData__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl MiiData__bindgen_ty_2 {
    #[inline]
    pub fn page_index(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_page_index(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn slot_index(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_slot_index(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(page_index: u8_, slot_index: u8_) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let page_index: u8 = unsafe { ::core::mem::transmute(page_index) };
            page_index as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let slot_index: u8 = unsafe { ::core::mem::transmute(slot_index) };
            slot_index as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "Console Identity"]
#[doc = ""]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MiiData__bindgen_ty_3 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl MiiData__bindgen_ty_3 {
    #[inline]
    pub fn unknown0(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_unknown0(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn origin_console(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_origin_console(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        unknown0: u8_,
        origin_console: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let unknown0: u8 = unsafe { ::core::mem::transmute(unknown0) };
            unknown0 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 3u8, {
            let origin_console: u8 = unsafe { ::core::mem::transmute(origin_console) };
            origin_console as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "Mii details"]
#[doc = ""]
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone)]
pub struct MiiData__bindgen_ty_4 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl MiiData__bindgen_ty_4 {
    #[inline]
    pub fn sex(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sex(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bday_month(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_bday_month(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn bday_day(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_bday_day(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn shirt_color(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_shirt_color(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn favorite(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_favorite(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sex: bool,
        bday_month: u16_,
        bday_day: u16_,
        shirt_color: u16_,
        favorite: bool,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let sex: u8 = unsafe { ::core::mem::transmute(sex) };
            sex as u64
        });
        __bindgen_bitfield_unit.set(1usize, 4u8, {
            let bday_month: u16 = unsafe { ::core::mem::transmute(bday_month) };
            bday_month as u64
        });
        __bindgen_bitfield_unit.set(5usize, 5u8, {
            let bday_day: u16 = unsafe { ::core::mem::transmute(bday_day) };
            bday_day as u64
        });
        __bindgen_bitfield_unit.set(10usize, 4u8, {
            let shirt_color: u16 = unsafe { ::core::mem::transmute(shirt_color) };
            shirt_color as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let favorite: u8 = unsafe { ::core::mem::transmute(favorite) };
            favorite as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "Face style"]
#[doc = ""]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MiiData__bindgen_ty_5 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl MiiData__bindgen_ty_5 {
    #[inline]
    pub fn disable_sharing(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_disable_sharing(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shape(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_shape(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn skinColor(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_skinColor(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        disable_sharing: bool,
        shape: u8_,
        skinColor: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let disable_sharing: u8 = unsafe { ::core::mem::transmute(disable_sharing) };
            disable_sharing as u64
        });
        __bindgen_bitfield_unit.set(1usize, 4u8, {
            let shape: u8 = unsafe { ::core::mem::transmute(shape) };
            shape as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let skinColor: u8 = unsafe { ::core::mem::transmute(skinColor) };
            skinColor as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "Face details"]
#[doc = ""]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MiiData__bindgen_ty_6 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl MiiData__bindgen_ty_6 {
    #[inline]
    pub fn wrinkles(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_wrinkles(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn makeup(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_makeup(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(wrinkles: u8_, makeup: u8_) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let wrinkles: u8 = unsafe { ::core::mem::transmute(wrinkles) };
            wrinkles as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let makeup: u8 = unsafe { ::core::mem::transmute(makeup) };
            makeup as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "Hair details"]
#[doc = ""]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MiiData__bindgen_ty_7 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl MiiData__bindgen_ty_7 {
    #[inline]
    pub fn color(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_color(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn flip(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_flip(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(color: u8_, flip: bool) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let color: u8 = unsafe { ::core::mem::transmute(color) };
            color as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let flip: u8 = unsafe { ::core::mem::transmute(flip) };
            flip as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "Eye details"]
#[doc = ""]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct MiiData__bindgen_ty_8 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl MiiData__bindgen_ty_8 {
    #[inline]
    pub fn style(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_style(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn color(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_color(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn scale(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_scale(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn yscale(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_yscale(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn rotation(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_rotation(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn xspacing(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_xspacing(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn yposition(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_yposition(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        style: u32_,
        color: u32_,
        scale: u32_,
        yscale: u32_,
        rotation: u32_,
        xspacing: u32_,
        yposition: u32_,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let style: u32 = unsafe { ::core::mem::transmute(style) };
            style as u64
        });
        __bindgen_bitfield_unit.set(6usize, 3u8, {
            let color: u32 = unsafe { ::core::mem::transmute(color) };
            color as u64
        });
        __bindgen_bitfield_unit.set(9usize, 4u8, {
            let scale: u32 = unsafe { ::core::mem::transmute(scale) };
            scale as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let yscale: u32 = unsafe { ::core::mem::transmute(yscale) };
            yscale as u64
        });
        __bindgen_bitfield_unit.set(16usize, 5u8, {
            let rotation: u32 = unsafe { ::core::mem::transmute(rotation) };
            rotation as u64
        });
        __bindgen_bitfield_unit.set(21usize, 4u8, {
            let xspacing: u32 = unsafe { ::core::mem::transmute(xspacing) };
            xspacing as u64
        });
        __bindgen_bitfield_unit.set(25usize, 5u8, {
            let yposition: u32 = unsafe { ::core::mem::transmute(yposition) };
            yposition as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "Eyebrow details"]
#[doc = ""]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct MiiData__bindgen_ty_9 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl MiiData__bindgen_ty_9 {
    #[inline]
    pub fn style(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_style(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn color(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_color(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn scale(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_scale(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn yscale(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_yscale(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn pad(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pad(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rotation(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_rotation(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn xspacing(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_xspacing(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn yposition(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_yposition(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        style: u32_,
        color: u32_,
        scale: u32_,
        yscale: u32_,
        pad: u32_,
        rotation: u32_,
        xspacing: u32_,
        yposition: u32_,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let style: u32 = unsafe { ::core::mem::transmute(style) };
            style as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let color: u32 = unsafe { ::core::mem::transmute(color) };
            color as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let scale: u32 = unsafe { ::core::mem::transmute(scale) };
            scale as u64
        });
        __bindgen_bitfield_unit.set(12usize, 3u8, {
            let yscale: u32 = unsafe { ::core::mem::transmute(yscale) };
            yscale as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let pad: u32 = unsafe { ::core::mem::transmute(pad) };
            pad as u64
        });
        __bindgen_bitfield_unit.set(16usize, 5u8, {
            let rotation: u32 = unsafe { ::core::mem::transmute(rotation) };
            rotation as u64
        });
        __bindgen_bitfield_unit.set(21usize, 4u8, {
            let xspacing: u32 = unsafe { ::core::mem::transmute(xspacing) };
            xspacing as u64
        });
        __bindgen_bitfield_unit.set(25usize, 5u8, {
            let yposition: u32 = unsafe { ::core::mem::transmute(yposition) };
            yposition as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "Nose details"]
#[doc = ""]
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone)]
pub struct MiiData__bindgen_ty_10 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl MiiData__bindgen_ty_10 {
    #[inline]
    pub fn style(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_style(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn scale(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_scale(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn yposition(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_yposition(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        style: u16_,
        scale: u16_,
        yposition: u16_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let style: u16 = unsafe { ::core::mem::transmute(style) };
            style as u64
        });
        __bindgen_bitfield_unit.set(5usize, 4u8, {
            let scale: u16 = unsafe { ::core::mem::transmute(scale) };
            scale as u64
        });
        __bindgen_bitfield_unit.set(9usize, 5u8, {
            let yposition: u16 = unsafe { ::core::mem::transmute(yposition) };
            yposition as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "Mouth details"]
#[doc = ""]
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone)]
pub struct MiiData__bindgen_ty_11 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl MiiData__bindgen_ty_11 {
    #[inline]
    pub fn style(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u16) }
    }
    #[inline]
    pub fn set_style(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn color(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_color(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn scale(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_scale(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn yscale(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_yscale(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        style: u16_,
        color: u16_,
        scale: u16_,
        yscale: u16_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let style: u16 = unsafe { ::core::mem::transmute(style) };
            style as u64
        });
        __bindgen_bitfield_unit.set(6usize, 3u8, {
            let color: u16 = unsafe { ::core::mem::transmute(color) };
            color as u64
        });
        __bindgen_bitfield_unit.set(9usize, 4u8, {
            let scale: u16 = unsafe { ::core::mem::transmute(scale) };
            scale as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let yscale: u16 = unsafe { ::core::mem::transmute(yscale) };
            yscale as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "Mustache details"]
#[doc = ""]
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone)]
pub struct MiiData__bindgen_ty_12 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl MiiData__bindgen_ty_12 {
    #[inline]
    pub fn mouth_yposition(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_mouth_yposition(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn mustach_style(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_mustach_style(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn pad(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_pad(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mouth_yposition: u16_,
        mustach_style: u16_,
        pad: u16_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let mouth_yposition: u16 = unsafe { ::core::mem::transmute(mouth_yposition) };
            mouth_yposition as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let mustach_style: u16 = unsafe { ::core::mem::transmute(mustach_style) };
            mustach_style as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let pad: u16 = unsafe { ::core::mem::transmute(pad) };
            pad as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "Beard details"]
#[doc = ""]
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone)]
pub struct MiiData__bindgen_ty_13 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl MiiData__bindgen_ty_13 {
    #[inline]
    pub fn style(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_style(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn color(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_color(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn scale(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_scale(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn ypos(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_ypos(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        style: u16_,
        color: u16_,
        scale: u16_,
        ypos: u16_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let style: u16 = unsafe { ::core::mem::transmute(style) };
            style as u64
        });
        __bindgen_bitfield_unit.set(3usize, 3u8, {
            let color: u16 = unsafe { ::core::mem::transmute(color) };
            color as u64
        });
        __bindgen_bitfield_unit.set(6usize, 4u8, {
            let scale: u16 = unsafe { ::core::mem::transmute(scale) };
            scale as u64
        });
        __bindgen_bitfield_unit.set(10usize, 5u8, {
            let ypos: u16 = unsafe { ::core::mem::transmute(ypos) };
            ypos as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "Glasses details"]
#[doc = ""]
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone)]
pub struct MiiData__bindgen_ty_14 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl MiiData__bindgen_ty_14 {
    #[inline]
    pub fn style(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_style(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn color(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_color(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn scale(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_scale(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn ypos(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_ypos(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        style: u16_,
        color: u16_,
        scale: u16_,
        ypos: u16_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let style: u16 = unsafe { ::core::mem::transmute(style) };
            style as u64
        });
        __bindgen_bitfield_unit.set(4usize, 3u8, {
            let color: u16 = unsafe { ::core::mem::transmute(color) };
            color as u64
        });
        __bindgen_bitfield_unit.set(7usize, 4u8, {
            let scale: u16 = unsafe { ::core::mem::transmute(scale) };
            scale as u64
        });
        __bindgen_bitfield_unit.set(11usize, 5u8, {
            let ypos: u16 = unsafe { ::core::mem::transmute(ypos) };
            ypos as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "Mole details"]
#[doc = ""]
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone)]
pub struct MiiData__bindgen_ty_15 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl MiiData__bindgen_ty_15 {
    #[inline]
    pub fn enable(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_enable(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scale(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_scale(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn xpos(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_xpos(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn ypos(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_ypos(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        enable: bool,
        scale: u16_,
        xpos: u16_,
        ypos: u16_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enable: u8 = unsafe { ::core::mem::transmute(enable) };
            enable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 5u8, {
            let scale: u16 = unsafe { ::core::mem::transmute(scale) };
            scale as u64
        });
        __bindgen_bitfield_unit.set(6usize, 5u8, {
            let xpos: u16 = unsafe { ::core::mem::transmute(xpos) };
            xpos as u64
        });
        __bindgen_bitfield_unit.set(11usize, 5u8, {
            let ypos: u16 = unsafe { ::core::mem::transmute(ypos) };
            ypos as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for MiiData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Friend key data"]
#[doc = ""]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FriendKey {
    pub principalId: u32_,
    pub padding: u32_,
    pub localFriendCode: u64_,
}
#[doc = "Friend Title data"]
#[doc = ""]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TitleData {
    pub tid: u64_,
    pub version: u32_,
    pub unk: u32_,
}
#[doc = "Friend profile data"]
#[doc = ""]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FriendProfile {
    #[doc = "The region code for the hardware."]
    #[doc = ""]
    pub region: u8_,
    #[doc = "Country code."]
    #[doc = ""]
    pub country: u8_,
    #[doc = "Area code."]
    #[doc = ""]
    pub area: u8_,
    #[doc = "Language code."]
    #[doc = ""]
    pub language: u8_,
    #[doc = "Platform code."]
    #[doc = ""]
    pub platform: u8_,
    pub padding: u32_,
}
#[doc = "Game Description structure"]
#[doc = ""]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct GameDescription {
    pub data: TitleData,
    pub desc: [u16_; 128usize],
}
impl Default for GameDescription {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Friend Notification Event structure"]
#[doc = ""]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NotificationEvent {
    pub type_: u8_,
    pub padding3: [u8_; 3usize],
    pub padding: u32_,
    pub key: FriendKey,
}
#[doc = "Self went online"]
#[doc = ""]

pub const USER_WENT_ONLINE: NotificationTypes = 1;
#[doc = "Self went offline"]
#[doc = ""]

pub const USER_WENT_OFFLINE: NotificationTypes = 2;
#[doc = "Friend Went Online"]
#[doc = ""]

pub const FRIEND_WENT_ONLINE: NotificationTypes = 3;
#[doc = "Friend Presence changed"]
#[doc = ""]

pub const FRIEND_UPDATED_PRESENCE: NotificationTypes = 4;
#[doc = "Friend Mii changed"]
#[doc = ""]

pub const FRIEND_UPDATED_MII: NotificationTypes = 5;
#[doc = "Friend Profile changed"]
#[doc = ""]

pub const FRIEND_UPDATED_PROFILE: NotificationTypes = 6;
#[doc = "Friend went offline"]
#[doc = ""]

pub const FRIEND_WENT_OFFLINE: NotificationTypes = 7;
#[doc = "Friend registered self as friend"]
#[doc = ""]

pub const FRIEND_REGISTERED_USER: NotificationTypes = 8;
#[doc = "Friend Sent invitation"]
#[doc = ""]

pub const FRIEND_SENT_INVITATION: NotificationTypes = 9;
#[doc = "Enum to use with FRD_GetNotificationEvent"]
#[doc = ""]

pub type NotificationTypes = ::libc::c_uint;
extern "C" {
    #[must_use]
    #[doc = "Initializes FRD service."]
    #[doc = ""]
    pub fn frdInit() -> Result;
}
extern "C" {
    #[doc = "Exists FRD."]
    #[doc = ""]
    pub fn frdExit();
}
extern "C" {
    #[doc = "Get FRD handle."]
    #[doc = ""]
    pub fn frdGetSessionHandle() -> *mut Handle;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the login status of the current user.\n @param state Pointer to write the current user's login status to."]
    #[doc = ""]
    pub fn FRDU_HasLoggedIn(state: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the online status of the current user.\n @param state Pointer to write the current user's online status to."]
    #[doc = ""]
    pub fn FRDU_IsOnline(state: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Logs out of Nintendo's friend server."]
    #[doc = ""]
    pub fn FRD_Logout() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Log in to Nintendo's friend server.\n @param event Event to signal when Login is done."]
    #[doc = ""]
    pub fn FRD_Login(event: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the current user's friend key.\n @param key Pointer to write the current user's friend key to."]
    #[doc = ""]
    pub fn FRD_GetMyFriendKey(key: *mut FriendKey) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the current user's privacy information.\n @param isPublicMode Determines whether friends are notified of the current user's online status.\n @param isShowGameName Determines whether friends are notified of the application that the current user is running.\n @param isShowPlayedGame Determiens whether to display the current user's game history."]
    #[doc = ""]
    pub fn FRD_GetMyPreference(
        isPublicMode: *mut bool,
        isShowGameName: *mut bool,
        isShowPlayedGame: *mut bool,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the current user's profile information.\n @param profile Pointer to write the current user's profile information to."]
    #[doc = ""]
    pub fn FRD_GetMyProfile(profile: *mut FriendProfile) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the current user's screen name.\n @param name Pointer to write the current user's screen name to.\n @param max_size Max size of the screen name."]
    #[doc = ""]
    pub fn FRD_GetMyScreenName(name: *mut ::libc::c_char, max_size: usize) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the current user's Mii data.\n @param mii Pointer to write the current user's mii data to."]
    #[doc = ""]
    pub fn FRD_GetMyMii(mii: *mut MiiData) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the current user's playing game.\n @param titleId Pointer to write the current user's playing game to."]
    #[doc = ""]
    pub fn FRD_GetMyPlayingGame(titleId: *mut u64_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the current user's favourite game.\n @param titleId Pointer to write the title ID of current user's favourite game to."]
    #[doc = ""]
    pub fn FRD_GetMyFavoriteGame(titleId: *mut u64_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the current user's comment on their friend profile.\n @param comment Pointer to write the current user's comment to.\n @param max_size Max size of the comment."]
    #[doc = ""]
    pub fn FRD_GetMyComment(comment: *mut ::libc::c_char, max_size: usize) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the current user's friend key list.\n @param friendKeyList Pointer to write the friend key list to.\n @param num Stores the number of friend keys obtained.\n @param offset The index of the friend key to start with.\n @param size Size of the friend key list. (FRIEND_LIST_SIZE)"]
    #[doc = ""]
    pub fn FRD_GetFriendKeyList(
        friendKeyList: *mut FriendKey,
        num: *mut u32_,
        offset: u32_,
        size: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the current user's friends' Mii data.\n @param miiDataList Pointer to write Mii data to.\n @param friendKeyList Pointer to FriendKeys.\n @param size Number of Friendkeys."]
    #[doc = ""]
    pub fn FRD_GetFriendMii(
        miiDataList: *mut MiiData,
        friendKeyList: *const FriendKey,
        size: usize,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Get the current user's friends' profile data.\n @param profile Pointer to write profile data to.\n @param friendKeyList Pointer to FriendKeys.\n @param size Number of FriendKeys."]
    #[doc = ""]
    pub fn FRD_GetFriendProfile(
        profile: *mut FriendProfile,
        friendKeyList: *const FriendKey,
        size: usize,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Get the current user's friends' playing game.\n @param desc Pointer to write Game Description data to.\n @param friendKeyList Pointer to FriendKeys,\n @param size Number Of FriendKeys."]
    #[doc = ""]
    pub fn FRD_GetFriendPlayingGame(
        desc: *mut GameDescription,
        friendKeyList: *const FriendKey,
        size: usize,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Get the current user's friends' favourite game.\n @param desc Pointer to write Game Description data to.\n @param friendKeyList Pointer to FriendKeys,\n @param count Number Of FriendKeys."]
    #[doc = ""]
    pub fn FRD_GetFriendFavouriteGame(
        desc: *mut GameDescription,
        friendKeyList: *const FriendKey,
        count: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets whether a friend key is included in the current user's friend list.\n @param friendKeyList Pointer to a list of friend keys.\n @param isFromList Pointer to a write the friendship status to."]
    #[doc = ""]
    pub fn FRD_IsInFriendList(friendKeyList: *mut FriendKey, isFromList: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Updates the game mode description string.\n @param desc Pointer to write the game mode description to."]
    #[doc = ""]
    pub fn FRD_UpdateGameModeDescription(desc: *const ::libc::c_char) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Event which is signaled when friend login states change.\n @param event event which will be signaled."]
    #[doc = ""]
    pub fn FRD_AttachToEventNotification(event: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Get Latest Event Notification\n @param event Pointer to write recieved notification event struct to.\n @param count Number of events\n @param recievedNotifCount Number of notification reccieved."]
    #[doc = ""]
    pub fn FRD_GetEventNotification(
        event: *mut NotificationEvent,
        count: u32_,
        recievedNotifCount: *mut u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Returns the friend code using the given principal ID.\n @param principalId The principal ID being used.\n @param friendCode Pointer to write the friend code to."]
    #[doc = ""]
    pub fn FRD_PrincipalIdToFriendCode(principalId: u32_, friendCode: *mut u64_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Returns the principal ID using the given friend code.\n @param friendCode The friend code being used.\n @param principalId Pointer to write the principal ID to."]
    #[doc = ""]
    pub fn FRD_FriendCodeToPrincipalId(friendCode: u64_, principalId: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Checks if the friend code is valid.\n @param friendCode The friend code being used.\n @param isValid Pointer to write the validity of the friend code to."]
    #[doc = ""]
    pub fn FRD_IsValidFriendCode(friendCode: u64_, isValid: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the Friend API to use a specific SDK version.\n @param sdkVer The SDK version needed to be used."]
    #[doc = ""]
    pub fn FRD_SetClientSdkVersion(sdkVer: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Add a Friend online.\n @param event Event signaled when friend is registered.\n @param principalId PrincipalId of the friend to add."]
    #[doc = ""]
    pub fn FRD_AddFriendOnline(event: Handle, principalId: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Remove a Friend.\n @param principalId PrinipalId of the friend code to remove.\n @param localFriendCode LocalFriendCode of the friend code to remove."]
    #[doc = ""]
    pub fn FRD_RemoveFriend(principalId: u32_, localFriendCode: u64_) -> Result;
}
#[doc = "Top screen."]
#[doc = ""]

pub const GSPLCD_SCREEN_TOP: _bindgen_ty_21 = 1;
#[doc = "Bottom screen."]
#[doc = ""]

pub const GSPLCD_SCREEN_BOTTOM: _bindgen_ty_21 = 2;
#[doc = "Both screens."]
#[doc = ""]

pub const GSPLCD_SCREEN_BOTH: _bindgen_ty_21 = 3;
#[doc = "LCD screens."]
#[doc = ""]

pub type _bindgen_ty_21 = ::libc::c_uint;
extern "C" {
    #[must_use]
    #[doc = "Initializes GSPLCD."]
    #[doc = ""]
    pub fn gspLcdInit() -> Result;
}
extern "C" {
    #[doc = "Exits GSPLCD."]
    #[doc = ""]
    pub fn gspLcdExit();
}
extern "C" {
    #[doc = "Gets a pointer to the current gsp::Lcd session handle.\n @return A pointer to the current gsp::Lcd session handle."]
    #[doc = ""]
    pub fn gspLcdGetSessionHandle() -> *mut Handle;
}
extern "C" {
    #[must_use]
    #[doc = "Powers on both backlights."]
    #[doc = ""]
    pub fn GSPLCD_PowerOnAllBacklights() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Powers off both backlights."]
    #[doc = ""]
    pub fn GSPLCD_PowerOffAllBacklights() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Powers on the backlight.\n @param screen Screen to power on."]
    #[doc = ""]
    pub fn GSPLCD_PowerOnBacklight(screen: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Powers off the backlight.\n @param screen Screen to power off."]
    #[doc = ""]
    pub fn GSPLCD_PowerOffBacklight(screen: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets 3D_LEDSTATE to the input state value.\n @param disable False = 3D LED enable, true = 3D LED disable."]
    #[doc = ""]
    pub fn GSPLCD_SetLedForceOff(disable: bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the LCD screens' vendors. Stubbed on old 3ds.\n @param vendor Pointer to output the screen vendors to."]
    #[doc = ""]
    pub fn GSPLCD_GetVendors(vendors: *mut u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the LCD screens' brightness. Stubbed on old 3ds.\n @param screen Screen to get the brightness value of.\n @param brightness Brightness value returned."]
    #[doc = ""]
    pub fn GSPLCD_GetBrightness(screen: u32_, brightness: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the LCD screens' brightness.\n @param screen Screen to set the brightness value of.\n @param brightness Brightness value set."]
    #[doc = ""]
    pub fn GSPLCD_SetBrightness(screen: u32_, brightness: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the LCD screens' raw brightness.\n @param screen Screen to set the brightness value of.\n @param brightness Brightness value set."]
    #[doc = ""]
    pub fn GSPLCD_SetBrightnessRaw(screen: u32_, brightness: u32_) -> Result;
}
#[doc = "A"]
#[doc = ""]

pub const KEY_A: _bindgen_ty_22 = 1;
#[doc = "B"]
#[doc = ""]

pub const KEY_B: _bindgen_ty_22 = 2;
#[doc = "Select"]
#[doc = ""]

pub const KEY_SELECT: _bindgen_ty_22 = 4;
#[doc = "Start"]
#[doc = ""]

pub const KEY_START: _bindgen_ty_22 = 8;
#[doc = "D-Pad Right"]
#[doc = ""]

pub const KEY_DRIGHT: _bindgen_ty_22 = 16;
#[doc = "D-Pad Left"]
#[doc = ""]

pub const KEY_DLEFT: _bindgen_ty_22 = 32;
#[doc = "D-Pad Up"]
#[doc = ""]

pub const KEY_DUP: _bindgen_ty_22 = 64;
#[doc = "D-Pad Down"]
#[doc = ""]

pub const KEY_DDOWN: _bindgen_ty_22 = 128;
#[doc = "R"]
#[doc = ""]

pub const KEY_R: _bindgen_ty_22 = 256;
#[doc = "L"]
#[doc = ""]

pub const KEY_L: _bindgen_ty_22 = 512;
#[doc = "X"]
#[doc = ""]

pub const KEY_X: _bindgen_ty_22 = 1024;
#[doc = "Y"]
#[doc = ""]

pub const KEY_Y: _bindgen_ty_22 = 2048;
#[doc = "ZL (New 3DS only)"]
#[doc = ""]

pub const KEY_ZL: _bindgen_ty_22 = 16384;
#[doc = "ZR (New 3DS only)"]
#[doc = ""]

pub const KEY_ZR: _bindgen_ty_22 = 32768;
#[doc = "Touch (Not actually provided by HID)"]
#[doc = ""]

pub const KEY_TOUCH: _bindgen_ty_22 = 1048576;
#[doc = "C-Stick Right (New 3DS only)"]
#[doc = ""]

pub const KEY_CSTICK_RIGHT: _bindgen_ty_22 = 16777216;
#[doc = "C-Stick Left (New 3DS only)"]
#[doc = ""]

pub const KEY_CSTICK_LEFT: _bindgen_ty_22 = 33554432;
#[doc = "C-Stick Up (New 3DS only)"]
#[doc = ""]

pub const KEY_CSTICK_UP: _bindgen_ty_22 = 67108864;
#[doc = "C-Stick Down (New 3DS only)"]
#[doc = ""]

pub const KEY_CSTICK_DOWN: _bindgen_ty_22 = 134217728;
#[doc = "Circle Pad Right"]
#[doc = ""]

pub const KEY_CPAD_RIGHT: _bindgen_ty_22 = 268435456;
#[doc = "Circle Pad Left"]
#[doc = ""]

pub const KEY_CPAD_LEFT: _bindgen_ty_22 = 536870912;
#[doc = "Circle Pad Up"]
#[doc = ""]

pub const KEY_CPAD_UP: _bindgen_ty_22 = 1073741824;
#[doc = "Circle Pad Down"]
#[doc = ""]

pub const KEY_CPAD_DOWN: _bindgen_ty_22 = 2147483648;
#[doc = "D-Pad Up or Circle Pad Up"]
#[doc = ""]

pub const KEY_UP: _bindgen_ty_22 = 1073741888;
#[doc = "D-Pad Down or Circle Pad Down"]
#[doc = ""]

pub const KEY_DOWN: _bindgen_ty_22 = 2147483776;
#[doc = "D-Pad Left or Circle Pad Left"]
#[doc = ""]

pub const KEY_LEFT: _bindgen_ty_22 = 536870944;
#[doc = "D-Pad Right or Circle Pad Right"]
#[doc = ""]

pub const KEY_RIGHT: _bindgen_ty_22 = 268435472;
#[doc = "Key values."]
#[doc = ""]

pub type _bindgen_ty_22 = ::libc::c_uint;
#[doc = "Touch position."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct touchPosition {
    #[doc = "Touch X"]
    #[doc = ""]
    pub px: u16_,
    #[doc = "Touch Y"]
    #[doc = ""]
    pub py: u16_,
}
#[doc = "Circle Pad position."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct circlePosition {
    #[doc = "Pad X"]
    #[doc = ""]
    pub dx: s16,
    #[doc = "Pad Y"]
    #[doc = ""]
    pub dy: s16,
}
#[doc = "Accelerometer vector."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct accelVector {
    #[doc = "Accelerometer X"]
    #[doc = ""]
    pub x: s16,
    #[doc = "Accelerometer Y"]
    #[doc = ""]
    pub y: s16,
    #[doc = "Accelerometer Z"]
    #[doc = ""]
    pub z: s16,
}
#[doc = "Gyroscope angular rate."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct angularRate {
    #[doc = "Roll"]
    #[doc = ""]
    pub x: s16,
    #[doc = "Yaw"]
    #[doc = ""]
    pub z: s16,
    #[doc = "Pitch"]
    #[doc = ""]
    pub y: s16,
}
#[doc = "Event signaled by HID-module, when the sharedmem+0(PAD/circle-pad)/+0xA8(touch-screen) region was updated."]
#[doc = ""]

pub const HIDEVENT_PAD0: HID_Event = 0;
#[doc = "Event signaled by HID-module, when the sharedmem+0(PAD/circle-pad)/+0xA8(touch-screen) region was updated."]
#[doc = ""]

pub const HIDEVENT_PAD1: HID_Event = 1;
#[doc = "Event signaled by HID-module, when the sharedmem accelerometer state was updated."]
#[doc = ""]

pub const HIDEVENT_Accel: HID_Event = 2;
#[doc = "Event signaled by HID-module, when the sharedmem gyroscope state was updated."]
#[doc = ""]

pub const HIDEVENT_Gyro: HID_Event = 3;
#[doc = "Event signaled by HID-module, when the sharedmem DebugPad state was updated."]
#[doc = ""]

pub const HIDEVENT_DebugPad: HID_Event = 4;
#[doc = "Used to know how many events there are."]
#[doc = ""]

pub const HIDEVENT_MAX: HID_Event = 5;
#[doc = "HID events."]
#[doc = ""]

pub type HID_Event = ::libc::c_uint;
extern "C" {
    #[doc = "HID shared memory handle."]
    #[doc = ""]
    pub static mut hidMemHandle: Handle;
}
extern "C" {
    #[doc = "HID shared memory."]
    #[doc = ""]
    pub static mut hidSharedMem: *mut vu32;
}
extern "C" {
    #[must_use]
    #[doc = "Initializes HID."]
    #[doc = ""]
    pub fn hidInit() -> Result;
}
extern "C" {
    #[doc = "Exits HID."]
    #[doc = ""]
    pub fn hidExit();
}
extern "C" {
    #[doc = "Sets the key repeat parameters for [`hidKeysRepeat.\n`] @param delay Initial delay.\n @param interval Repeat interval."]
    #[doc = ""]
    pub fn hidSetRepeatParameters(delay: u32_, interval: u32_);
}
extern "C" {
    #[doc = "Scans HID for input data."]
    #[doc = ""]
    pub fn hidScanInput();
}
extern "C" {
    #[doc = "Returns a bitmask of held buttons.\n Individual buttons can be extracted using binary AND.\n @return 32-bit bitmask of held buttons (1+ frames)."]
    #[doc = ""]
    pub fn hidKeysHeld() -> u32_;
}
extern "C" {
    #[doc = "Returns a bitmask of newly pressed buttons, this frame.\n Individual buttons can be extracted using binary AND.\n @return 32-bit bitmask of newly pressed buttons."]
    #[doc = ""]
    pub fn hidKeysDown() -> u32_;
}
extern "C" {
    #[doc = "Returns a bitmask of newly pressed or repeated buttons, this frame.\n Individual buttons can be extracted using binary AND.\n @return 32-bit bitmask of newly pressed or repeated buttons."]
    #[doc = ""]
    pub fn hidKeysDownRepeat() -> u32_;
}
extern "C" {
    #[doc = "Returns a bitmask of newly released buttons, this frame.\n Individual buttons can be extracted using binary AND.\n @return 32-bit bitmask of newly released buttons."]
    #[doc = ""]
    pub fn hidKeysUp() -> u32_;
}
extern "C" {
    #[doc = "Reads the current touch position.\n @param pos Pointer to output the touch position to."]
    #[doc = ""]
    pub fn hidTouchRead(pos: *mut touchPosition);
}
extern "C" {
    #[doc = "Reads the current circle pad position.\n @param pos Pointer to output the circle pad position to."]
    #[doc = ""]
    pub fn hidCircleRead(pos: *mut circlePosition);
}
extern "C" {
    #[doc = "Reads the current accelerometer data.\n @param vector Pointer to output the accelerometer data to."]
    #[doc = ""]
    pub fn hidAccelRead(vector: *mut accelVector);
}
extern "C" {
    #[doc = "Reads the current gyroscope data.\n @param rate Pointer to output the gyroscope data to."]
    #[doc = ""]
    pub fn hidGyroRead(rate: *mut angularRate);
}
extern "C" {
    #[doc = "Waits for an HID event.\n @param id ID of the event.\n @param nextEvent Whether to discard the current event and wait for the next event."]
    #[doc = ""]
    pub fn hidWaitForEvent(id: HID_Event, nextEvent: bool);
}
extern "C" {
    #[must_use]
    #[doc = "Waits for any HID or IRRST event.\n @param nextEvents Whether to discard the current events and wait for the next events.\n @param cancelEvent Optional additional handle to wait on, otherwise 0.\n @param timeout Timeout."]
    #[doc = ""]
    pub fn hidWaitForAnyEvent(nextEvents: bool, cancelEvent: Handle, timeout: s64) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the handles for HID operation.\n @param outMemHandle Pointer to output the shared memory handle to.\n @param eventpad0 Pointer to output the pad 0 event handle to.\n @param eventpad1 Pointer to output the pad 1 event handle to.\n @param eventaccel Pointer to output the accelerometer event handle to.\n @param eventgyro Pointer to output the gyroscope event handle to.\n @param eventdebugpad Pointer to output the debug pad event handle to."]
    #[doc = ""]
    pub fn HIDUSER_GetHandles(
        outMemHandle: *mut Handle,
        eventpad0: *mut Handle,
        eventpad1: *mut Handle,
        eventaccel: *mut Handle,
        eventgyro: *mut Handle,
        eventdebugpad: *mut Handle,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Enables the accelerometer."]
    #[doc = ""]
    pub fn HIDUSER_EnableAccelerometer() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Disables the accelerometer."]
    #[doc = ""]
    pub fn HIDUSER_DisableAccelerometer() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Enables the gyroscope."]
    #[doc = ""]
    pub fn HIDUSER_EnableGyroscope() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Disables the gyroscope."]
    #[doc = ""]
    pub fn HIDUSER_DisableGyroscope() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the gyroscope raw to dps coefficient.\n @param coeff Pointer to output the coefficient to."]
    #[doc = ""]
    pub fn HIDUSER_GetGyroscopeRawToDpsCoefficient(coeff: *mut f32) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the current volume slider value. (0-63)\n @param volume Pointer to write the volume slider value to."]
    #[doc = ""]
    pub fn HIDUSER_GetSoundVolume(volume: *mut u8_) -> Result;
}
extern "C" {
    #[doc = "IRRST's shared memory handle."]
    #[doc = ""]
    pub static mut irrstMemHandle: Handle;
}
extern "C" {
    #[doc = "IRRST's shared memory."]
    #[doc = ""]
    pub static mut irrstSharedMem: *mut vu32;
}
extern "C" {
    #[doc = "IRRST's state update event"]
    #[doc = ""]
    pub static mut irrstEvent: Handle;
}
extern "C" {
    #[must_use]
    #[doc = "Initializes IRRST."]
    #[doc = ""]
    pub fn irrstInit() -> Result;
}
extern "C" {
    #[doc = "Exits IRRST."]
    #[doc = ""]
    pub fn irrstExit();
}
extern "C" {
    #[doc = "Scans IRRST for input."]
    #[doc = ""]
    pub fn irrstScanInput();
}
extern "C" {
    #[doc = "Gets IRRST's held keys.\n @return IRRST's held keys."]
    #[doc = ""]
    pub fn irrstKeysHeld() -> u32_;
}
extern "C" {
    #[doc = "Reads the current c-stick position.\n @param pos Pointer to output the current c-stick position to."]
    #[doc = ""]
    pub fn irrstCstickRead(pos: *mut circlePosition);
}
extern "C" {
    #[doc = "Waits for the IRRST input event to trigger.\n @param nextEvent Whether to discard the current event and wait until the next event."]
    #[doc = ""]
    pub fn irrstWaitForEvent(nextEvent: bool);
}
extern "C" {
    #[must_use]
    #[doc = "Gets the shared memory and event handles for IRRST.\n @param outMemHandle Pointer to write the shared memory handle to.\n @param outEventHandle Pointer to write the event handle to."]
    #[doc = ""]
    pub fn IRRST_GetHandles(outMemHandle: *mut Handle, outEventHandle: *mut Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initializes IRRST.\n @param unk1 Unknown.\n @param unk2 Unknown."]
    #[doc = ""]
    pub fn IRRST_Initialize(unk1: u32_, unk2: u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Shuts down IRRST."]
    #[doc = ""]
    pub fn IRRST_Shutdown() -> Result;
}
#[doc = "sslc context."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sslcContext {
    #[doc = "Service handle."]
    #[doc = ""]
    pub servhandle: Handle,
    #[doc = "SSLC handle."]
    #[doc = ""]
    pub sslchandle: u32_,
    pub sharedmem_handle: Handle,
}
pub const SSLC_DefaultRootCert_Nintendo_CA: SSLC_DefaultRootCert = 1;
pub const SSLC_DefaultRootCert_Nintendo_CA_G2: SSLC_DefaultRootCert = 2;
pub const SSLC_DefaultRootCert_Nintendo_CA_G3: SSLC_DefaultRootCert = 3;
pub const SSLC_DefaultRootCert_Nintendo_Class2_CA: SSLC_DefaultRootCert = 4;
pub const SSLC_DefaultRootCert_Nintendo_Class2_CA_G2: SSLC_DefaultRootCert = 5;
pub const SSLC_DefaultRootCert_Nintendo_Class2_CA_G3: SSLC_DefaultRootCert = 6;
pub const SSLC_DefaultRootCert_CyberTrust: SSLC_DefaultRootCert = 7;
pub const SSLC_DefaultRootCert_AddTrust_External_CA: SSLC_DefaultRootCert = 8;
pub const SSLC_DefaultRootCert_COMODO: SSLC_DefaultRootCert = 9;
pub const SSLC_DefaultRootCert_USERTrust: SSLC_DefaultRootCert = 10;
pub const SSLC_DefaultRootCert_DigiCert_EV: SSLC_DefaultRootCert = 11;
pub type SSLC_DefaultRootCert = ::libc::c_uint;
pub const SSLC_DefaultClientCert_ClCertA: SSLC_DefaultClientCert = 64;
pub type SSLC_DefaultClientCert = ::libc::c_uint;
pub const SSLCOPT_Default: _bindgen_ty_23 = 0;
pub const SSLCOPT_DisableVerify: _bindgen_ty_23 = 512;
pub const SSLCOPT_TLSv10: _bindgen_ty_23 = 2048;
#[doc = "sslc options. <https://www.3dbrew.org/wiki/SSL_Services#SSLOpt>"]
#[doc = ""]

pub type _bindgen_ty_23 = ::libc::c_uint;
extern "C" {
    #[must_use]
    #[doc = "Initializes SSLC. Normally session_handle should be 0. When non-zero this will use the specified handle for the main-service-session without using the Initialize command, instead of using srvGetServiceHandle."]
    #[doc = ""]
    pub fn sslcInit(session_handle: Handle) -> Result;
}
extern "C" {
    #[doc = "Exits SSLC."]
    #[doc = ""]
    pub fn sslcExit();
}
extern "C" {
    #[must_use]
    #[doc = "Creates a RootCertChain.\n @param RootCertChain_contexthandle Output contexthandle."]
    #[doc = ""]
    pub fn sslcCreateRootCertChain(RootCertChain_contexthandle: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Destroys a RootCertChain.\n @param RootCertChain_contexthandle RootCertChain contexthandle."]
    #[doc = ""]
    pub fn sslcDestroyRootCertChain(RootCertChain_contexthandle: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Adds a trusted RootCA cert to a RootCertChain.\n @param RootCertChain_contexthandle RootCertChain to use.\n @param cert Pointer to the DER cert.\n @param certsize Size of the DER cert."]
    #[doc = ""]
    pub fn sslcAddTrustedRootCA(
        RootCertChain_contexthandle: u32_,
        cert: *const u8_,
        certsize: u32_,
        cert_contexthandle: *mut u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Adds a default RootCA cert to a RootCertChain.\n @param RootCertChain_contexthandle RootCertChain to use.\n @param certID ID of the cert to add.\n @param cert_contexthandle Optional, the cert contexthandle can be written here."]
    #[doc = ""]
    pub fn sslcRootCertChainAddDefaultCert(
        RootCertChain_contexthandle: u32_,
        certID: SSLC_DefaultRootCert,
        cert_contexthandle: *mut u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Removes the specified cert from the RootCertChain.\n @param RootCertChain_contexthandle RootCertChain to use.\n @param cert_contexthandle Cert contexthandle to remove from the RootCertChain."]
    #[doc = ""]
    pub fn sslcRootCertChainRemoveCert(
        RootCertChain_contexthandle: u32_,
        cert_contexthandle: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Creates an unknown CertChain.\n @param CertChain_contexthandle Output contexthandle."]
    #[doc = ""]
    pub fn sslcCreate8CertChain(CertChain_contexthandle: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Destroys a CertChain from sslcCreate8CertChain().\n @param CertChain_contexthandle CertChain contexthandle."]
    #[doc = ""]
    pub fn sslcDestroy8CertChain(CertChain_contexthandle: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Adds a cert to a CertChain from sslcCreate8CertChain().\n @param CertChain_contexthandle CertChain to use.\n @param cert Pointer to the cert.\n @param certsize Size of the cert."]
    #[doc = ""]
    pub fn sslc8CertChainAddCert(
        CertChain_contexthandle: u32_,
        cert: *const u8_,
        certsize: u32_,
        cert_contexthandle: *mut u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Adds a default cert to a CertChain from sslcCreate8CertChain(). Not actually usable since no certIDs are implemented in SSL-module for this.\n @param CertChain_contexthandle CertChain to use.\n @param certID ID of the cert to add.\n @param cert_contexthandle Optional, the cert contexthandle can be written here."]
    #[doc = ""]
    pub fn sslc8CertChainAddDefaultCert(
        CertChain_contexthandle: u32_,
        certID: u8_,
        cert_contexthandle: *mut u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Removes the specified cert from the CertChain from sslcCreate8CertChain().\n @param CertChain_contexthandle CertChain to use.\n @param cert_contexthandle Cert contexthandle to remove from the CertChain."]
    #[doc = ""]
    pub fn sslc8CertChainRemoveCert(
        CertChain_contexthandle: u32_,
        cert_contexthandle: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Opens a new ClientCert-context.\n @param cert Pointer to the DER cert.\n @param certsize Size of the DER cert.\n @param key Pointer to the DER key.\n @param keysize Size of the DER key.\n @param ClientCert_contexthandle Output contexthandle."]
    #[doc = ""]
    pub fn sslcOpenClientCertContext(
        cert: *const u8_,
        certsize: u32_,
        key: *const u8_,
        keysize: u32_,
        ClientCert_contexthandle: *mut u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Opens a ClientCert-context with a default certID.\n @param certID ID of the ClientCert to use.\n @param ClientCert_contexthandle Output contexthandle."]
    #[doc = ""]
    pub fn sslcOpenDefaultClientCertContext(
        certID: SSLC_DefaultClientCert,
        ClientCert_contexthandle: *mut u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Closes the specified ClientCert-context.\n @param ClientCert_contexthandle ClientCert-context to use."]
    #[doc = ""]
    pub fn sslcCloseClientCertContext(ClientCert_contexthandle: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "This uses ps:ps SeedRNG internally."]
    #[doc = ""]
    pub fn sslcSeedRNG() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "This uses ps:ps GenerateRandomData internally.\n @param buf Output buffer.\n @param size Output size."]
    #[doc = ""]
    pub fn sslcGenerateRandomData(buf: *mut u8_, size: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Creates a sslc context.\n @param context sslc context.\n @param sockfd Socket fd, this code automatically uses the required SOC command before using the actual sslc command.\n @param input_opt Input sslc options bitmask.\n @param hostname Server hostname."]
    #[doc = ""]
    pub fn sslcCreateContext(
        context: *mut sslcContext,
        sockfd: ::libc::c_int,
        input_opt: u32_,
        hostname: *const ::libc::c_char,
    ) -> Result;
}
extern "C" {
    #[must_use]
    pub fn sslcDestroyContext(context: *mut sslcContext) -> Result;
}
extern "C" {
    #[must_use]
    pub fn sslcStartConnection(
        context: *mut sslcContext,
        internal_retval: *mut ::libc::c_int,
        out: *mut u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    pub fn sslcRead(
        context: *mut sslcContext,
        buf: *mut ::libc::c_void,
        len: usize,
        peek: bool,
    ) -> Result;
}
extern "C" {
    #[must_use]
    pub fn sslcWrite(context: *mut sslcContext, buf: *const ::libc::c_void, len: usize) -> Result;
}
extern "C" {
    #[must_use]
    pub fn sslcContextSetRootCertChain(context: *mut sslcContext, handle: u32_) -> Result;
}
extern "C" {
    #[must_use]
    pub fn sslcContextSetClientCert(context: *mut sslcContext, handle: u32_) -> Result;
}
extern "C" {
    #[must_use]
    pub fn sslcContextSetHandle8(context: *mut sslcContext, handle: u32_) -> Result;
}
extern "C" {
    #[must_use]
    pub fn sslcContextClearOpt(context: *mut sslcContext, bitmask: u32_) -> Result;
}
extern "C" {
    #[must_use]
    pub fn sslcContextGetProtocolCipher(
        context: *mut sslcContext,
        outprotocols: *mut ::libc::c_char,
        outprotocols_maxsize: u32_,
        outcipher: *mut ::libc::c_char,
        outcipher_maxsize: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    pub fn sslcContextGetState(context: *mut sslcContext, out: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    pub fn sslcContextInitSharedmem(context: *mut sslcContext, buf: *mut u8_, size: u32_)
        -> Result;
}
extern "C" {
    #[must_use]
    pub fn sslcAddCert(context: *mut sslcContext, buf: *const u8_, size: u32_) -> Result;
}
#[doc = "HTTP context."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct httpcContext {
    #[doc = "Service handle."]
    #[doc = ""]
    pub servhandle: Handle,
    #[doc = "HTTP handle."]
    #[doc = ""]
    pub httphandle: u32_,
}
pub const HTTPC_METHOD_GET: HTTPC_RequestMethod = 1;
pub const HTTPC_METHOD_POST: HTTPC_RequestMethod = 2;
pub const HTTPC_METHOD_HEAD: HTTPC_RequestMethod = 3;
pub const HTTPC_METHOD_PUT: HTTPC_RequestMethod = 4;
pub const HTTPC_METHOD_DELETE: HTTPC_RequestMethod = 5;
#[doc = "HTTP request method."]
#[doc = ""]

pub type HTTPC_RequestMethod = ::libc::c_uint;
#[doc = "Request in progress."]
#[doc = ""]

pub const HTTPC_STATUS_REQUEST_IN_PROGRESS: HTTPC_RequestStatus = 5;
#[doc = "Download ready."]
#[doc = ""]

pub const HTTPC_STATUS_DOWNLOAD_READY: HTTPC_RequestStatus = 7;
#[doc = "HTTP request status."]
#[doc = ""]

pub type HTTPC_RequestStatus = ::libc::c_uint;
pub const HTTPC_KEEPALIVE_DISABLED: HTTPC_KeepAlive = 0;
pub const HTTPC_KEEPALIVE_ENABLED: HTTPC_KeepAlive = 1;
#[doc = "HTTP KeepAlive option."]
#[doc = ""]

pub type HTTPC_KeepAlive = ::libc::c_uint;
extern "C" {
    #[must_use]
    #[doc = "Initializes HTTPC. For HTTP GET the sharedmem_size can be zero. The sharedmem contains data which will be later uploaded for HTTP POST. sharedmem_size should be aligned to 0x1000-bytes."]
    #[doc = ""]
    pub fn httpcInit(sharedmem_size: u32_) -> Result;
}
extern "C" {
    #[doc = "Exits HTTPC."]
    #[doc = ""]
    pub fn httpcExit();
}
extern "C" {
    #[must_use]
    #[doc = "Opens a HTTP context.\n @param context Context to open.\n @param url URL to connect to.\n @param use_defaultproxy Whether the default proxy should be used (0 for default)"]
    #[doc = ""]
    pub fn httpcOpenContext(
        context: *mut httpcContext,
        method: HTTPC_RequestMethod,
        url: *const ::libc::c_char,
        use_defaultproxy: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Closes a HTTP context.\n @param context Context to close."]
    #[doc = ""]
    pub fn httpcCloseContext(context: *mut httpcContext) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Cancels a HTTP connection.\n @param context Context to close."]
    #[doc = ""]
    pub fn httpcCancelConnection(context: *mut httpcContext) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Adds a request header field to a HTTP context.\n @param context Context to use.\n @param name Name of the field.\n @param value Value of the field."]
    #[doc = ""]
    pub fn httpcAddRequestHeaderField(
        context: *mut httpcContext,
        name: *const ::libc::c_char,
        value: *const ::libc::c_char,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Adds a POST form field to a HTTP context.\n @param context Context to use.\n @param name Name of the field.\n @param value Value of the field."]
    #[doc = ""]
    pub fn httpcAddPostDataAscii(
        context: *mut httpcContext,
        name: *const ::libc::c_char,
        value: *const ::libc::c_char,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Adds a POST form field with binary data to a HTTP context.\n @param context Context to use.\n @param name Name of the field.\n @param value The binary data to pass as a value.\n @param len Length of the binary data which has been passed."]
    #[doc = ""]
    pub fn httpcAddPostDataBinary(
        context: *mut httpcContext,
        name: *const ::libc::c_char,
        value: *const u8_,
        len: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Adds a POST body to a HTTP context.\n @param context Context to use.\n @param data The data to be passed as raw into the body of the post request.\n @param len Length of data passed by data param."]
    #[doc = ""]
    pub fn httpcAddPostDataRaw(context: *mut httpcContext, data: *const u32_, len: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Begins a HTTP request.\n @param context Context to use."]
    #[doc = ""]
    pub fn httpcBeginRequest(context: *mut httpcContext) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Receives data from a HTTP context.\n @param context Context to use.\n @param buffer Buffer to receive data to.\n @param size Size of the buffer."]
    #[doc = ""]
    pub fn httpcReceiveData(context: *mut httpcContext, buffer: *mut u8_, size: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Receives data from a HTTP context with a timeout value.\n @param context Context to use.\n @param buffer Buffer to receive data to.\n @param size Size of the buffer.\n @param timeout Maximum time in nanoseconds to wait for a reply."]
    #[doc = ""]
    pub fn httpcReceiveDataTimeout(
        context: *mut httpcContext,
        buffer: *mut u8_,
        size: u32_,
        timeout: u64_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the request state of a HTTP context.\n @param context Context to use.\n @param out Pointer to output the HTTP request state to."]
    #[doc = ""]
    pub fn httpcGetRequestState(
        context: *mut httpcContext,
        out: *mut HTTPC_RequestStatus,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the download size state of a HTTP context.\n @param context Context to use.\n @param downloadedsize Pointer to output the downloaded size to.\n @param contentsize Pointer to output the total content size to."]
    #[doc = ""]
    pub fn httpcGetDownloadSizeState(
        context: *mut httpcContext,
        downloadedsize: *mut u32_,
        contentsize: *mut u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the response code of the HTTP context.\n @param context Context to get the response code of.\n @param out Pointer to write the response code to."]
    #[doc = ""]
    pub fn httpcGetResponseStatusCode(context: *mut httpcContext, out: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the response code of the HTTP context with a timeout value.\n @param context Context to get the response code of.\n @param out Pointer to write the response code to.\n @param timeout Maximum time in nanoseconds to wait for a reply."]
    #[doc = ""]
    pub fn httpcGetResponseStatusCodeTimeout(
        context: *mut httpcContext,
        out: *mut u32_,
        timeout: u64_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets a response header field from a HTTP context.\n @param context Context to use.\n @param name Name of the field.\n @param value Pointer to output the value of the field to.\n @param valuebuf_maxsize Maximum size of the value buffer."]
    #[doc = ""]
    pub fn httpcGetResponseHeader(
        context: *mut httpcContext,
        name: *const ::libc::c_char,
        value: *mut ::libc::c_char,
        valuebuf_maxsize: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Adds a trusted RootCA cert to a HTTP context.\n @param context Context to use.\n @param cert Pointer to DER cert.\n @param certsize Size of the DER cert."]
    #[doc = ""]
    pub fn httpcAddTrustedRootCA(
        context: *mut httpcContext,
        cert: *const u8_,
        certsize: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Adds a default RootCA cert to a HTTP context.\n @param context Context to use.\n @param certID ID of the cert to add, see sslc.h."]
    #[doc = ""]
    pub fn httpcAddDefaultCert(context: *mut httpcContext, certID: SSLC_DefaultRootCert) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the RootCertChain for a HTTP context.\n @param context Context to use.\n @param RootCertChain_contexthandle Contexthandle for the RootCertChain."]
    #[doc = ""]
    pub fn httpcSelectRootCertChain(
        context: *mut httpcContext,
        RootCertChain_contexthandle: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the ClientCert for a HTTP context.\n @param context Context to use.\n @param cert Pointer to DER cert.\n @param certsize Size of the DER cert.\n @param privk Pointer to the DER private key.\n @param privk_size Size of the privk."]
    #[doc = ""]
    pub fn httpcSetClientCert(
        context: *mut httpcContext,
        cert: *const u8_,
        certsize: u32_,
        privk: *const u8_,
        privk_size: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the default clientcert for a HTTP context.\n @param context Context to use.\n @param certID ID of the cert to add, see sslc.h."]
    #[doc = ""]
    pub fn httpcSetClientCertDefault(
        context: *mut httpcContext,
        certID: SSLC_DefaultClientCert,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the ClientCert contexthandle for a HTTP context.\n @param context Context to use.\n @param ClientCert_contexthandle Contexthandle for the ClientCert."]
    #[doc = ""]
    pub fn httpcSetClientCertContext(
        context: *mut httpcContext,
        ClientCert_contexthandle: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets SSL options for the context.\n The HTTPC SSL option bits are the same as those defined in sslc.h\n @param context Context to set flags on.\n @param options SSL option flags."]
    #[doc = ""]
    pub fn httpcSetSSLOpt(context: *mut httpcContext, options: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the SSL options which will be cleared for the context.\n The HTTPC SSL option bits are the same as those defined in sslc.h\n @param context Context to clear flags on.\n @param options SSL option flags."]
    #[doc = ""]
    pub fn httpcSetSSLClearOpt(context: *mut httpcContext, options: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Creates a RootCertChain. Up to 2 RootCertChains can be created under this user-process.\n @param RootCertChain_contexthandle Output RootCertChain contexthandle."]
    #[doc = ""]
    pub fn httpcCreateRootCertChain(RootCertChain_contexthandle: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Destroy a RootCertChain.\n @param RootCertChain_contexthandle RootCertChain to use."]
    #[doc = ""]
    pub fn httpcDestroyRootCertChain(RootCertChain_contexthandle: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Adds a RootCA cert to a RootCertChain.\n @param RootCertChain_contexthandle RootCertChain to use.\n @param cert Pointer to DER cert.\n @param certsize Size of the DER cert.\n @param cert_contexthandle Optional output ptr for the cert contexthandle(this can be NULL)."]
    #[doc = ""]
    pub fn httpcRootCertChainAddCert(
        RootCertChain_contexthandle: u32_,
        cert: *const u8_,
        certsize: u32_,
        cert_contexthandle: *mut u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Adds a default RootCA cert to a RootCertChain.\n @param RootCertChain_contexthandle RootCertChain to use.\n @param certID ID of the cert to add, see sslc.h.\n @param cert_contexthandle Optional output ptr for the cert contexthandle(this can be NULL)."]
    #[doc = ""]
    pub fn httpcRootCertChainAddDefaultCert(
        RootCertChain_contexthandle: u32_,
        certID: SSLC_DefaultRootCert,
        cert_contexthandle: *mut u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Removes a cert from a RootCertChain.\n @param RootCertChain_contexthandle RootCertChain to use.\n @param cert_contexthandle Contexthandle of the cert to remove."]
    #[doc = ""]
    pub fn httpcRootCertChainRemoveCert(
        RootCertChain_contexthandle: u32_,
        cert_contexthandle: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Opens a ClientCert-context. Up to 2 ClientCert-contexts can be open under this user-process.\n @param cert Pointer to DER cert.\n @param certsize Size of the DER cert.\n @param privk Pointer to the DER private key.\n @param privk_size Size of the privk.\n @param ClientCert_contexthandle Output ClientCert context handle."]
    #[doc = ""]
    pub fn httpcOpenClientCertContext(
        cert: *const u8_,
        certsize: u32_,
        privk: *const u8_,
        privk_size: u32_,
        ClientCert_contexthandle: *mut u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Opens a ClientCert-context with a default clientclient. Up to 2 ClientCert-contexts can be open under this user-process.\n @param certID ID of the cert to add, see sslc.h.\n @param ClientCert_contexthandle Output ClientCert context handle."]
    #[doc = ""]
    pub fn httpcOpenDefaultClientCertContext(
        certID: SSLC_DefaultClientCert,
        ClientCert_contexthandle: *mut u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Closes a ClientCert context.\n @param ClientCert_contexthandle ClientCert context to use."]
    #[doc = ""]
    pub fn httpcCloseClientCertContext(ClientCert_contexthandle: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Downloads data from the HTTP context into a buffer.\n The *entire* content must be downloaded before using httpcCloseContext(), otherwise httpcCloseContext() will hang.\n @param context Context to download data from.\n @param buffer Buffer to write data to.\n @param size Size of the buffer.\n @param downloadedsize Pointer to write the size of the downloaded data to."]
    #[doc = ""]
    pub fn httpcDownloadData(
        context: *mut httpcContext,
        buffer: *mut u8_,
        size: u32_,
        downloadedsize: *mut u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets Keep-Alive for the context.\n @param context Context to set the KeepAlive flag on.\n @param option HTTPC_KeepAlive option."]
    #[doc = ""]
    pub fn httpcSetKeepAlive(context: *mut httpcContext, option: HTTPC_KeepAlive) -> Result;
}
#[doc = "Node info struct."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct udsNodeInfo {
    pub uds_friendcodeseed: u64_,
    pub __bindgen_anon_1: udsNodeInfo__bindgen_ty_1,
    pub NetworkNodeID: u16_,
    pub pad_x22: u16_,
    pub word_x24: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union udsNodeInfo__bindgen_ty_1 {
    pub usercfg: [u8_; 24usize],
    pub __bindgen_anon_1: udsNodeInfo__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct udsNodeInfo__bindgen_ty_1__bindgen_ty_1 {
    pub username: [u16_; 10usize],
    pub unk_x1c: u16_,
    pub flag: u8_,
    pub pad_x1f: u8_,
}
impl Default for udsNodeInfo__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for udsNodeInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Connection status struct."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct udsConnectionStatus {
    pub status: u32_,
    pub unk_x4: u32_,
    pub cur_NetworkNodeID: u16_,
    pub unk_xa: u16_,
    pub unk_xc: [u32_; 8usize],
    pub total_nodes: u8_,
    pub max_nodes: u8_,
    pub node_bitmask: u16_,
}
#[doc = "Network struct stored as big-endian."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct udsNetworkStruct {
    pub host_macaddress: [u8_; 6usize],
    pub channel: u8_,
    pub pad_x7: u8_,
    pub initialized_flag: u8_,
    pub unk_x9: [u8_; 3usize],
    pub oui_value: [u8_; 3usize],
    pub oui_type: u8_,
    pub wlancommID: u32_,
    pub id8: u8_,
    pub unk_x15: u8_,
    pub attributes: u16_,
    pub networkID: u32_,
    pub total_nodes: u8_,
    pub max_nodes: u8_,
    pub unk_x1e: u8_,
    pub unk_x1f: u8_,
    pub unk_x20: [u8_; 31usize],
    pub appdata_size: u8_,
    pub appdata: [u8_; 200usize],
}
impl Default for udsNetworkStruct {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct udsBindContext {
    pub BindNodeID: u32_,
    pub event: Handle,
    pub spectator: bool,
}
#[doc = "General NWM input structure used for AP scanning."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nwmScanInputStruct {
    pub unk_x0: u16_,
    pub unk_x2: u16_,
    pub unk_x4: u16_,
    pub unk_x6: u16_,
    pub mac_address: [u8_; 6usize],
    pub unk_xe: [u8_; 38usize],
}
impl Default for nwmScanInputStruct {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "General NWM output structure from AP scanning."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nwmBeaconDataReplyHeader {
    pub maxsize: u32_,
    pub size: u32_,
    pub total_entries: u32_,
}
#[doc = "General NWM output structure from AP scanning, for each entry."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nwmBeaconDataReplyEntry {
    pub size: u32_,
    pub unk_x4: u8_,
    pub channel: u8_,
    pub unk_x6: u8_,
    pub unk_x7: u8_,
    pub mac_address: [u8_; 6usize],
    pub unk_xe: [u8_; 6usize],
    pub unk_x14: u32_,
    pub val_x1c: u32_,
}
#[doc = "Output structure generated from host scanning output."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct udsNetworkScanInfo {
    pub datareply_entry: nwmBeaconDataReplyEntry,
    pub network: udsNetworkStruct,
    pub nodes: [udsNodeInfo; 16usize],
}
impl Default for udsNetworkScanInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const UDSNETATTR_DisableConnectSpectators: _bindgen_ty_24 = 1;
pub const UDSNETATTR_DisableConnectClients: _bindgen_ty_24 = 2;
pub const UDSNETATTR_x4: _bindgen_ty_24 = 4;
pub const UDSNETATTR_Default: _bindgen_ty_24 = 32768;
pub type _bindgen_ty_24 = ::libc::c_uint;
pub const UDS_SENDFLAG_Default: _bindgen_ty_25 = 1;
pub const UDS_SENDFLAG_Broadcast: _bindgen_ty_25 = 2;
pub type _bindgen_ty_25 = ::libc::c_uint;
pub const UDSCONTYPE_Client: udsConnectionType = 1;
pub const UDSCONTYPE_Spectator: udsConnectionType = 2;
pub type udsConnectionType = ::libc::c_uint;
extern "C" {
    #[must_use]
    #[doc = "Initializes UDS.\n @param sharedmem_size This must be 0x1000-byte aligned.\n @param username Optional custom UTF-8 username(converted to UTF-16 internally) that other nodes on the UDS network can use. If not set the username from system-config is used. Max len is 10 characters without NUL-terminator."]
    #[doc = ""]
    pub fn udsInit(sharedmem_size: usize, username: *const ::libc::c_char) -> Result;
}
extern "C" {
    #[doc = "Exits UDS."]
    #[doc = ""]
    pub fn udsExit();
}
extern "C" {
    #[must_use]
    #[doc = "Generates a NodeInfo struct with data loaded from system-config.\n @param nodeinfo Output NodeInfo struct.\n @param username If set, this is the UTF-8 string to convert for use in the struct. Max len is 10 characters without NUL-terminator."]
    #[doc = ""]
    pub fn udsGenerateNodeInfo(
        nodeinfo: *mut udsNodeInfo,
        username: *const ::libc::c_char,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Loads the UTF-16 username stored in the input NodeInfo struct, converted to UTF-8.\n @param nodeinfo Input NodeInfo struct.\n @param username This is the output UTF-8 string. Max len is 10 characters without NUL-terminator."]
    #[doc = ""]
    pub fn udsGetNodeInfoUsername(
        nodeinfo: *const udsNodeInfo,
        username: *mut ::libc::c_char,
    ) -> Result;
}
extern "C" {
    #[doc = "Checks whether a NodeInfo struct was initialized by NWM-module(not any output from udsGenerateNodeInfo()).\n @param nodeinfo Input NodeInfo struct."]
    #[doc = ""]
    pub fn udsCheckNodeInfoInitialized(nodeinfo: *const udsNodeInfo) -> bool;
}
extern "C" {
    #[doc = "Generates a default NetworkStruct for creating networks.\n @param network The output struct.\n @param wlancommID Unique local-WLAN communications ID for each application.\n @param id8 Additional ID that can be used by the application for different types of networks.\n @param max_nodes Maximum number of nodes(devices) that can be connected to the network, including the host."]
    #[doc = ""]
    pub fn udsGenerateDefaultNetworkStruct(
        network: *mut udsNetworkStruct,
        wlancommID: u32_,
        id8: u8_,
        max_nodes: u8_,
    );
}
extern "C" {
    #[must_use]
    #[doc = "Scans for networks via beacon-scanning.\n @param outbuf Buffer which will be used by the beacon-scanning command and for the data parsing afterwards. Normally there's no need to use the contents of this buffer once this function returns.\n @param maxsize Max size of the buffer.\n @Param networks Ptr where the allocated udsNetworkScanInfo array buffer is written. The allocsize is sizeof(udsNetworkScanInfo)*total_networks.\n @Param total_networks Total number of networks stored under the networks buffer.\n @param wlancommID Unique local-WLAN communications ID for each application.\n @param id8 Additional ID that can be used by the application for different types of networks.\n @param host_macaddress When set, this code will only return network info from the specified host MAC address.\n @connected When not connected to a network this *must* be false. When connected to a network this *must* be true."]
    #[doc = ""]
    pub fn udsScanBeacons(
        outbuf: *mut ::libc::c_void,
        maxsize: usize,
        networks: *mut *mut udsNetworkScanInfo,
        total_networks: *mut usize,
        wlancommID: u32_,
        id8: u8_,
        host_macaddress: *const u8_,
        connected: bool,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "This can be used by the host to set the appdata contained in the broadcasted beacons.\n @param buf Appdata buffer.\n @param size Size of the input appdata."]
    #[doc = ""]
    pub fn udsSetApplicationData(buf: *const ::libc::c_void, size: usize) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "This can be used while on a network(host/client) to get the appdata from the current beacon.\n @param buf Appdata buffer.\n @param size Max size of the output buffer.\n @param actual_size If set, the actual size of the appdata written into the buffer is stored here."]
    #[doc = ""]
    pub fn udsGetApplicationData(
        buf: *mut ::libc::c_void,
        size: usize,
        actual_size: *mut usize,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "This can be used with a NetworkStruct, from udsScanBeacons() mainly, for getting the appdata.\n @param buf Appdata buffer.\n @param size Max size of the output buffer.\n @param actual_size If set, the actual size of the appdata written into the buffer is stored here."]
    #[doc = ""]
    pub fn udsGetNetworkStructApplicationData(
        network: *const udsNetworkStruct,
        buf: *mut ::libc::c_void,
        size: usize,
        actual_size: *mut usize,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Create a bind.\n @param bindcontext The output bind context.\n @param NetworkNodeID This is the NetworkNodeID which this bind can receive data from.\n @param spectator False for a regular bind, true for a spectator.\n @param data_channel This is an arbitrary value to use for data-frame filtering. This bind will only receive data frames which contain a matching data_channel value, which was specified by udsSendTo(). The data_channel must be non-zero.\n @param recv_buffer_size Size of the buffer under sharedmem used for temporarily storing received data-frames which are then loaded by udsPullPacket(). The system requires this to be >=0x5F4. UDS_DEFAULT_RECVBUFSIZE can be used for this."]
    #[doc = ""]
    pub fn udsBind(
        bindcontext: *mut udsBindContext,
        NetworkNodeID: u16_,
        spectator: bool,
        data_channel: u8_,
        recv_buffer_size: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Remove a bind.\n @param bindcontext The bind context."]
    #[doc = ""]
    pub fn udsUnbind(bindcontext: *mut udsBindContext) -> Result;
}
extern "C" {
    #[doc = "Waits for the bind event to occur, or checks if the event was signaled. This event is signaled every time new data is available via udsPullPacket().\n @return Always true. However if wait=false, this will return false if the event wasn't signaled.\n @param bindcontext The bind context.\n @param nextEvent Whether to discard the current event and wait for the next event.\n @param wait When true this will not return until the event is signaled. When false this checks if the event was signaled without waiting for it."]
    #[doc = ""]
    pub fn udsWaitDataAvailable(
        bindcontext: *const udsBindContext,
        nextEvent: bool,
        wait: bool,
    ) -> bool;
}
extern "C" {
    #[must_use]
    #[doc = "Receives data over the network. This data is loaded from the recv_buffer setup by udsBind(). When a node disconnects, this will still return data from that node until there's no more frames from that node in the recv_buffer.\n @param bindcontext Bind context.\n @param buf Output receive buffer.\n @param size Size of the buffer.\n @param actual_size If set, the actual size written into the output buffer is stored here. This is zero when no data was received.\n @param src_NetworkNodeID If set, the source NetworkNodeID is written here. This is zero when no data was received."]
    #[doc = ""]
    pub fn udsPullPacket(
        bindcontext: *const udsBindContext,
        buf: *mut ::libc::c_void,
        size: usize,
        actual_size: *mut usize,
        src_NetworkNodeID: *mut u16_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sends data over the network.\n @param dst_NetworkNodeID Destination NetworkNodeID.\n @param data_channel See udsBind().\n @param flags Send flags, see the UDS_SENDFLAG enum values.\n @param buf Input send buffer.\n @param size Size of the buffer."]
    #[doc = ""]
    pub fn udsSendTo(
        dst_NetworkNodeID: u16_,
        data_channel: u8_,
        flags: u8_,
        buf: *const ::libc::c_void,
        size: usize,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the wifi channel currently being used.\n @param channel Output channel."]
    #[doc = ""]
    pub fn udsGetChannel(channel: *mut u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Starts hosting a new network.\n @param network The NetworkStruct, you can use udsGenerateDefaultNetworkStruct() for generating this.\n @param passphrase Raw input passphrase buffer.\n @param passphrase_size Size of the passphrase buffer.\n @param context Optional output bind context which will be created for this host, with NetworkNodeID=UDS_BROADCAST_NETWORKNODEID.\n @param data_channel This is the data_channel value which will be passed to udsBind() internally.\n @param recv_buffer_size This is the recv_buffer_size value which will be passed to udsBind() internally."]
    #[doc = ""]
    pub fn udsCreateNetwork(
        network: *const udsNetworkStruct,
        passphrase: *const ::libc::c_void,
        passphrase_size: usize,
        context: *mut udsBindContext,
        data_channel: u8_,
        recv_buffer_size: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Connect to a network.\n @param network The NetworkStruct, you can use udsScanBeacons() for this.\n @param passphrase Raw input passphrase buffer.\n @param passphrase_size Size of the passphrase buffer.\n @param context Optional output bind context which will be created for this host.\n @param recv_NetworkNodeID This is the NetworkNodeID passed to udsBind() internally.\n @param connection_type Type of connection, see the udsConnectionType enum values.\n @param data_channel This is the data_channel value which will be passed to udsBind() internally.\n @param recv_buffer_size This is the recv_buffer_size value which will be passed to udsBind() internally."]
    #[doc = ""]
    pub fn udsConnectNetwork(
        network: *const udsNetworkStruct,
        passphrase: *const ::libc::c_void,
        passphrase_size: usize,
        context: *mut udsBindContext,
        recv_NetworkNodeID: u16_,
        connection_type: udsConnectionType,
        data_channel: u8_,
        recv_buffer_size: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Stop hosting the network."]
    #[doc = ""]
    pub fn udsDestroyNetwork() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Disconnect this client device from the network."]
    #[doc = ""]
    pub fn udsDisconnectNetwork() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "This can be used by the host to force-disconnect client(s).\n @param NetworkNodeID Target NetworkNodeID. UDS_BROADCAST_NETWORKNODEID can be used to disconnect all clients."]
    #[doc = ""]
    pub fn udsEjectClient(NetworkNodeID: u16_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "This can be used by the host to force-disconnect the spectators. Afterwards new spectators will not be allowed to connect until udsAllowSpectators() is used."]
    #[doc = ""]
    pub fn udsEjectSpectator() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "This can be used by the host to update the network attributes. If bitmask 0x4 is clear in the input bitmask, this clears that bit in the value before actually writing the value into state. Normally you should use the below wrapper functions.\n @param bitmask Bitmask to clear/set in the attributes. See the UDSNETATTR enum values.\n @param flag When false, bit-clear, otherwise bit-set."]
    #[doc = ""]
    pub fn udsUpdateNetworkAttribute(bitmask: u16_, flag: bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "This uses udsUpdateNetworkAttribute() for (un)blocking new connections to this host.\n @param block When true, block the specified connection types(bitmask set). Otherwise allow them(bitmask clear).\n @param clients When true, (un)block regular clients.\n @param flag When true, update UDSNETATTR_x4. Normally this should be false."]
    #[doc = ""]
    pub fn udsSetNewConnectionsBlocked(block: bool, clients: bool, flag: bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "This uses udsUpdateNetworkAttribute() for unblocking new spectator connections to this host. See udsEjectSpectator() for blocking new spectators."]
    #[doc = ""]
    pub fn udsAllowSpectators() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "This loads the current ConnectionStatus struct.\n @param output Output ConnectionStatus struct."]
    #[doc = ""]
    pub fn udsGetConnectionStatus(output: *mut udsConnectionStatus) -> Result;
}
extern "C" {
    #[doc = "Waits for the ConnectionStatus event to occur, or checks if the event was signaled. This event is signaled when the data from udsGetConnectionStatus() was updated internally.\n @return Always true. However if wait=false, this will return false if the event wasn't signaled.\n @param nextEvent Whether to discard the current event and wait for the next event.\n @param wait When true this will not return until the event is signaled. When false this checks if the event was signaled without waiting for it."]
    #[doc = ""]
    pub fn udsWaitConnectionStatusEvent(nextEvent: bool, wait: bool) -> bool;
}
extern "C" {
    #[must_use]
    #[doc = "This loads a NodeInfo struct for the specified NetworkNodeID. The broadcast alias can't be used with this.\n @param NetworkNodeID Target NetworkNodeID.\n @param output Output NodeInfo struct."]
    #[doc = ""]
    pub fn udsGetNodeInformation(NetworkNodeID: u16_, output: *mut udsNodeInfo) -> Result;
}
pub const NDM_EXCLUSIVE_STATE_NONE: ndmExclusiveState = 0;
pub const NDM_EXCLUSIVE_STATE_INFRASTRUCTURE: ndmExclusiveState = 1;
pub const NDM_EXCLUSIVE_STATE_LOCAL_COMMUNICATIONS: ndmExclusiveState = 2;
pub const NDM_EXCLUSIVE_STATE_STREETPASS: ndmExclusiveState = 3;
pub const NDM_EXCLUSIVE_STATE_STREETPASS_DATA: ndmExclusiveState = 4;
#[doc = "Exclusive states."]
#[doc = ""]

pub type ndmExclusiveState = ::libc::c_uint;
pub const NDM_STATE_INITIAL: ndmState = 0;
pub const NDM_STATE_SUSPENDED: ndmState = 1;
pub const NDM_STATE_INFRASTRUCTURE_CONNECTING: ndmState = 2;
pub const NDM_STATE_INFRASTRUCTURE_CONNECTED: ndmState = 3;
pub const NDM_STATE_INFRASTRUCTURE_WORKING: ndmState = 4;
pub const NDM_STATE_INFRASTRUCTURE_SUSPENDING: ndmState = 5;
pub const NDM_STATE_INFRASTRUCTURE_FORCE_SUSPENDING: ndmState = 6;
pub const NDM_STATE_INFRASTRUCTURE_DISCONNECTING: ndmState = 7;
pub const NDM_STATE_INFRASTRUCTURE_FORCE_DISCONNECTING: ndmState = 8;
pub const NDM_STATE_CEC_WORKING: ndmState = 9;
pub const NDM_STATE_CEC_FORCE_SUSPENDING: ndmState = 10;
pub const NDM_STATE_CEC_SUSPENDING: ndmState = 11;
#[doc = "Current states."]
#[doc = ""]

pub type ndmState = ::libc::c_uint;
pub const NDM_DAEMON_CEC: ndmDaemon = 0;
pub const NDM_DAEMON_BOSS: ndmDaemon = 1;
pub const NDM_DAEMON_NIM: ndmDaemon = 2;
pub const NDM_DAEMON_FRIENDS: ndmDaemon = 3;
pub type ndmDaemon = ::libc::c_uint;
pub const NDM_DAEMON_MASK_CEC: ndmDaemonMask = 1;
pub const NDM_DAEMON_MASK_BOSS: ndmDaemonMask = 2;
pub const NDM_DAEMON_MASK_NIM: ndmDaemonMask = 4;
pub const NDM_DAEMON_MASK_FRIENDS: ndmDaemonMask = 8;
pub const NDM_DAEMON_MASK_BACKGROUOND: ndmDaemonMask = 7;
pub const NDM_DAEMON_MASK_ALL: ndmDaemonMask = 15;
pub const NDM_DAEMON_MASK_DEFAULT: ndmDaemonMask = 9;
#[doc = "Used to specify multiple daemons."]
#[doc = ""]

pub type ndmDaemonMask = ::libc::c_uint;
pub const NDM_DAEMON_STATUS_BUSY: ndmDaemonStatus = 0;
pub const NDM_DAEMON_STATUS_IDLE: ndmDaemonStatus = 1;
pub const NDM_DAEMON_STATUS_SUSPENDING: ndmDaemonStatus = 2;
pub const NDM_DAEMON_STATUS_SUSPENDED: ndmDaemonStatus = 3;
pub type ndmDaemonStatus = ::libc::c_uint;
extern "C" {
    #[must_use]
    #[doc = "Initializes ndmu."]
    #[doc = ""]
    pub fn ndmuInit() -> Result;
}
extern "C" {
    #[doc = "Exits ndmu."]
    #[doc = ""]
    pub fn ndmuExit();
}
extern "C" {
    #[must_use]
    #[doc = "Sets the network daemon to an exclusive state.\n @param state State specified in the ndmExclusiveState enumerator."]
    #[doc = ""]
    pub fn NDMU_EnterExclusiveState(state: ndmExclusiveState) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Cancels an exclusive state for the network daemon."]
    #[doc = ""]
    pub fn NDMU_LeaveExclusiveState() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Returns the exclusive state for the network daemon.\n @param state Pointer to write the exclsuive state to."]
    #[doc = ""]
    pub fn NDMU_GetExclusiveState(state: *mut ndmExclusiveState) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Locks the exclusive state."]
    #[doc = ""]
    pub fn NDMU_LockState() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Unlocks the exclusive state."]
    #[doc = ""]
    pub fn NDMU_UnlockState() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Suspends network daemon.\n @param mask The specified daemon."]
    #[doc = ""]
    pub fn NDMU_SuspendDaemons(mask: ndmDaemonMask) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Resumes network daemon.\n @param mask The specified daemon."]
    #[doc = ""]
    pub fn NDMU_ResumeDaemons(mask: ndmDaemonMask) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Suspends scheduling for all network daemons.\n @param flag 0 = Wait for completion, 1 = Perform in background."]
    #[doc = ""]
    pub fn NDMU_SuspendScheduler(flag: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Resumes daemon scheduling."]
    #[doc = ""]
    pub fn NDMU_ResumeScheduler() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Returns the current state for the network daemon.\n @param state Pointer to write the current state to."]
    #[doc = ""]
    pub fn NDMU_GetCurrentState(state: *mut ndmState) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Returns the daemon state.\n @param state Pointer to write the daemons state to."]
    #[doc = ""]
    pub fn NDMU_QueryStatus(status: *mut ndmDaemonStatus) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the scan interval.\n @param interval Value to set the scan interval to."]
    #[doc = ""]
    pub fn NDMU_SetScanInterval(interval: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Returns the scan interval.\n @param interval Pointer to write the interval value to."]
    #[doc = ""]
    pub fn NDMU_GetScanInterval(interval: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Returns the retry interval.\n @param interval Pointer to write the interval value to."]
    #[doc = ""]
    pub fn NDMU_GetRetryInterval(interval: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Reverts network daemon to defaults."]
    #[doc = ""]
    pub fn NDMU_ResetDaemons() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the current default daemon bit mask.\n @param interval Pointer to write the default daemon mask value to. The default value is (DAEMONMASK_CEC | DAEMONMASK_FRIENDS)"]
    #[doc = ""]
    pub fn NDMU_GetDefaultDaemons(mask: *mut ndmDaemonMask) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Clears half awake mac filter."]
    #[doc = ""]
    pub fn NDMU_ClearMacFilter() -> Result;
}
#[doc = "Initial installation"]
#[doc = ""]

pub const IM_DEFAULT: NIM_InstallationMode = 0;
#[doc = "Unknown"]
#[doc = ""]

pub const IM_UNKNOWN1: NIM_InstallationMode = 1;
#[doc = "Unknown"]
#[doc = ""]

pub const IM_UNKNOWN2: NIM_InstallationMode = 2;
#[doc = "Reinstall currently installed title; use this if the title is already installed (including updates)"]
#[doc = ""]

pub const IM_REINSTALL: NIM_InstallationMode = 3;
#[doc = "Mode that NIM downloads/installs a title with."]
#[doc = ""]

pub type NIM_InstallationMode = ::libc::c_uint;
#[doc = "Download not yet initialized"]
#[doc = ""]

pub const DS_NOT_INITIALIZED: NIM_DownloadState = 0;
#[doc = "Download initialized"]
#[doc = ""]

pub const DS_INITIALIZED: NIM_DownloadState = 1;
#[doc = "Downloading and installing TMD"]
#[doc = ""]

pub const DS_DOWNLOAD_TMD: NIM_DownloadState = 2;
#[doc = "Initializing save data"]
#[doc = ""]

pub const DS_PREPARE_SAVE_DATA: NIM_DownloadState = 3;
#[doc = "Downloading and installing contents"]
#[doc = ""]

pub const DS_DOWNLOAD_CONTENTS: NIM_DownloadState = 4;
#[doc = "Waiting before calling AM_CommitImportTitles"]
#[doc = ""]

pub const DS_WAIT_COMMIT: NIM_DownloadState = 5;
#[doc = "Running AM_CommitImportTitles"]
#[doc = ""]

pub const DS_COMMITTING: NIM_DownloadState = 6;
#[doc = "Title installation finished"]
#[doc = ""]

pub const DS_FINISHED: NIM_DownloadState = 7;
#[doc = "(unknown error regarding title version)"]
#[doc = ""]

pub const DS_VERSION_ERROR: NIM_DownloadState = 8;
#[doc = "Creating the .ctx file?"]
#[doc = ""]

pub const DS_CREATE_CONTEXT: NIM_DownloadState = 9;
#[doc = "Irrecoverable error encountered (e.g. out of space)"]
#[doc = ""]

pub const DS_CANNOT_RECOVER: NIM_DownloadState = 10;
#[doc = "Invalid state"]
#[doc = ""]

pub const DS_INVALID: NIM_DownloadState = 11;
#[doc = "Current state of a NIM download/installation."]
#[doc = ""]

pub type NIM_DownloadState = ::libc::c_uint;
#[doc = "Input configuration for NIM download/installation tasks."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NIM_TitleConfig {
    #[doc = "Title ID"]
    #[doc = ""]
    pub titleId: u64_,
    #[doc = "Title version"]
    #[doc = ""]
    pub version: u32_,
    #[doc = "Always 0"]
    #[doc = ""]
    pub unknown_0: u32_,
    #[doc = "Age for the HOME Menu parental controls"]
    #[doc = ""]
    pub ratingAge: u8_,
    #[doc = "Media type, see [`FS_MediaType`] enum"]
    #[doc = ""]
    pub mediaType: u8_,
    #[doc = "Padding"]
    #[doc = ""]
    pub padding: [u8_; 2usize],
    #[doc = "Unknown input, seems to be always 0"]
    #[doc = ""]
    pub unknown_1: u32_,
}
#[doc = "Output struct for NIM downloads/installations in progress."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NIM_TitleProgress {
    #[doc = "State, see NIM_DownloadState enum"]
    #[doc = ""]
    pub state: u32_,
    #[doc = "Last result code in NIM"]
    #[doc = ""]
    pub lastResult: Result,
    #[doc = "Amount of bytes that have been downloaded"]
    #[doc = ""]
    pub downloadedSize: u64_,
    #[doc = "Amount of bytes that need to be downloaded in total"]
    #[doc = ""]
    pub totalSize: u64_,
}
extern "C" {
    #[must_use]
    #[doc = "Initializes nim:s. This uses networking and is blocking.\n @param buffer A buffer for internal use. It must be at least 0x20000 bytes long.\n @param buffer_len Length of the passed buffer."]
    #[doc = ""]
    pub fn nimsInit(buffer: *mut ::libc::c_void, buffer_len: usize) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initializes nim:s with the given TIN. This uses networking and is blocking.\n @param buffer A buffer for internal use. It must be at least 0x20000 bytes long.\n @param buffer_len Length of the passed buffer.\n @param TIN The TIN to initialize nim:s with. If you do not know what a TIN is or why you would want to change it, use [`nimsInit`] instead."]
    #[doc = ""]
    pub fn nimsInitWithTIN(
        buffer: *mut ::libc::c_void,
        buffer_len: usize,
        TIN: *const ::libc::c_char,
    ) -> Result;
}
extern "C" {
    #[doc = "Exits nim:s."]
    #[doc = ""]
    pub fn nimsExit();
}
extern "C" {
    #[doc = "Gets the current nim:s session handle."]
    #[doc = ""]
    pub fn nimsGetSessionHandle() -> *mut Handle;
}
extern "C" {
    #[must_use]
    #[doc = "Sets an attribute.\n @param attr Name of the attribute.\n @param val Value of the attribute."]
    #[doc = ""]
    pub fn NIMS_SetAttribute(attr: *const ::libc::c_char, val: *const ::libc::c_char) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Checks if nim wants a system update.\n @param want_update Set to true if a system update is required. Can be NULL."]
    #[doc = ""]
    pub fn NIMS_WantUpdate(want_update: *mut bool) -> Result;
}
extern "C" {
    #[doc = "Makes a TitleConfig struct for use with [`NIMS_RegisterTask`] [`NIMS_StartDownload`] or [`NIMS_StartDownloadSimple.\n`] @param cfg Struct to initialize.\n @param titleId Title ID to download and install.\n @param version Version of the title to download and install.\n @param ratingAge Age for which the title is aged; used by parental controls in HOME Menu.\n @param mediaType Media type of the title to download and install."]
    #[doc = ""]
    pub fn NIMS_MakeTitleConfig(
        cfg: *mut NIM_TitleConfig,
        titleId: u64_,
        version: u32_,
        ratingAge: u8_,
        mediaType: FS_MediaType,
    );
}
extern "C" {
    #[must_use]
    #[doc = "Registers a background download task with NIM. These are processed in sleep mode only.\n @param cfg Title config to use. See [`NIMS_MakeTitleConfig.\n`] @param name Name of the title in UTF-8. Will be displayed on the HOME Menu. Maximum 73 characters.\n @param maker Name of the maker/publisher in UTF-8. Will be displayed on the HOME Menu. Maximum 37 characters."]
    #[doc = ""]
    pub fn NIMS_RegisterTask(
        cfg: *const NIM_TitleConfig,
        name: *const ::libc::c_char,
        maker: *const ::libc::c_char,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Checks whether a background download task for the given title is registered with NIM.\n @param titleId Title ID to check for.\n @param registered Whether there is a background download task registered."]
    #[doc = ""]
    pub fn NIMS_IsTaskRegistered(titleId: u64_, registered: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Unregisters a background download task.\n @param titleId Title ID whose background download task to cancel."]
    #[doc = ""]
    pub fn NIMS_UnregisterTask(titleId: u64_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Starts an active download with NIM. Progress can be checked with [`NIMS_GetProcess`] Do not exit the process while a download is in progress without calling [`NIMS_CancelDownload.\n`] @param cfg Title config to use. See [`NIMS_MakeTitleConfig.\n`] @param mode The installation mode to use. See [`NIM_InstallationMode`]"]
    #[doc = ""]
    pub fn NIMS_StartDownload(cfg: *const NIM_TitleConfig, mode: NIM_InstallationMode) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Starts an active download with NIM with default installation mode; cannot reinstall titles. Progress can be checked with [`NIMS_GetProcess`] Do not exit the process while a download is in progress without calling [`NIMS_CancelDownload.\n`] @param cfg Title config to use. See [`NIMS_MakeTitleConfig`]"]
    #[doc = ""]
    pub fn NIMS_StartDownloadSimple(cfg: *const NIM_TitleConfig) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Checks the status of the current active download.\n @param tp Title progress struct to write to. See [`NIM_TitleProgress`]"]
    #[doc = ""]
    pub fn NIMS_GetProgress(tp: *mut NIM_TitleProgress) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Cancels the current active download with NIM."]
    #[doc = ""]
    pub fn NIMS_CancelDownload() -> Result;
}
extern "C" {
    #[must_use]
    pub fn nwmExtInit() -> Result;
}
extern "C" {
    pub fn nwmExtExit();
}
extern "C" {
    #[must_use]
    #[doc = "Turns wireless on or off.\n @param enableWifi True enables it, false disables it."]
    #[doc = ""]
    pub fn NWMEXT_ControlWirelessEnabled(enableWifi: bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initializes IRU.\n The permissions for the specified memory is set to RO. This memory must be already mapped.\n @param sharedmem_addr Address of the shared memory block to use.\n @param sharedmem_size Size of the shared memory block."]
    #[doc = ""]
    pub fn iruInit(sharedmem_addr: *mut u32_, sharedmem_size: u32_) -> Result;
}
extern "C" {
    #[doc = "Shuts down IRU."]
    #[doc = ""]
    pub fn iruExit();
}
extern "C" {
    #[doc = "Gets the IRU service handle.\n @return The IRU service handle."]
    #[doc = ""]
    pub fn iruGetServHandle() -> Handle;
}
extern "C" {
    #[must_use]
    #[doc = "Sends IR data.\n @param buf Buffer to send data from.\n @param size Size of the buffer.\n @param wait Whether to wait for the data to be sent."]
    #[doc = ""]
    pub fn iruSendData(buf: *mut u8_, size: u32_, wait: bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Receives IR data.\n @param buf Buffer to receive data to.\n @param size Size of the buffer.\n @param flag Flags to receive data with.\n @param transfercount Pointer to output the number of bytes read to.\n @param wait Whether to wait for the data to be received."]
    #[doc = ""]
    pub fn iruRecvData(
        buf: *mut u8_,
        size: u32_,
        flag: u8_,
        transfercount: *mut u32_,
        wait: bool,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initializes the IR session."]
    #[doc = ""]
    pub fn IRU_Initialize() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Shuts down the IR session."]
    #[doc = ""]
    pub fn IRU_Shutdown() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Begins sending data.\n @param buf Buffer to send.\n @param size Size of the buffer."]
    #[doc = ""]
    pub fn IRU_StartSendTransfer(buf: *mut u8_, size: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Waits for a send operation to complete."]
    #[doc = ""]
    pub fn IRU_WaitSendTransfer() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Begins receiving data.\n @param size Size of the data to receive.\n @param flag Flags to use when receiving."]
    #[doc = ""]
    pub fn IRU_StartRecvTransfer(size: u32_, flag: u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Waits for a receive operation to complete.\n @param transfercount Pointer to output the number of bytes read to."]
    #[doc = ""]
    pub fn IRU_WaitRecvTransfer(transfercount: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the IR bit rate.\n @param value Bit rate to set."]
    #[doc = ""]
    pub fn IRU_SetBitRate(value: u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the IR bit rate.\n @param out Pointer to write the bit rate to."]
    #[doc = ""]
    pub fn IRU_GetBitRate(out: *mut u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the IR LED state.\n @param value IR LED state to set."]
    #[doc = ""]
    pub fn IRU_SetIRLEDState(value: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the IR LED state.\n @param out Pointer to write the IR LED state to."]
    #[doc = ""]
    pub fn IRU_GetIRLEDRecvState(out: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets an event which is signaled once a send finishes.\n @param out Pointer to write the event handle to."]
    #[doc = ""]
    pub fn IRU_GetSendFinishedEvent(out: *mut Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets an event which is signaled once a receive finishes.\n @param out Pointer to write the event handle to."]
    #[doc = ""]
    pub fn IRU_GetRecvFinishedEvent(out: *mut Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initializes NS."]
    #[doc = ""]
    pub fn nsInit() -> Result;
}
extern "C" {
    #[doc = "Exits NS."]
    #[doc = ""]
    pub fn nsExit();
}
extern "C" {
    #[must_use]
    #[doc = "Launches a title and the required firmware (only if necessary).\n @param titleid ID of the title to launch, 0 for gamecard, JPN System Settings' titleID for System Settings."]
    #[doc = ""]
    pub fn NS_LaunchFIRM(titleid: u64_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Launches a title.\n @param titleid ID of the title to launch, or 0 for gamecard.\n @param launch_flags Flags used when launching the title.\n @param procid Pointer to write the process ID of the launched title to."]
    #[doc = ""]
    pub fn NS_LaunchTitle(titleid: u64_, launch_flags: u32_, procid: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Terminates the application from which this function is called"]
    #[doc = ""]
    pub fn NS_TerminateTitle() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Launches a title and the required firmware.\n @param titleid ID of the title to launch, 0 for gamecard.\n @param flags Flags for firm-launch. bit0: require an application title-info structure in FIRM paramters to be specified via FIRM parameters. bit1: if clear, NS will check certain Configuration Memory fields."]
    #[doc = ""]
    pub fn NS_LaunchApplicationFIRM(titleid: u64_, flags: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Reboots to a title.\n @param mediatype Mediatype of the title.\n @param titleid ID of the title to launch."]
    #[doc = ""]
    pub fn NS_RebootToTitle(mediatype: u8_, titleid: u64_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Terminates the process with the specified titleid.\n @param titleid ID of the title to terminate.\n @param timeout Timeout in nanoseconds. Pass 0 if not required."]
    #[doc = ""]
    pub fn NS_TerminateProcessTID(titleid: u64_, timeout: u64_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Reboots the system"]
    #[doc = ""]
    pub fn NS_RebootSystem() -> Result;
}
pub const PMLAUNCHFLAG_NORMAL_APPLICATION: _bindgen_ty_26 = 1;
pub const PMLAUNCHFLAG_LOAD_DEPENDENCIES: _bindgen_ty_26 = 2;
pub const PMLAUNCHFLAG_NOTIFY_TERMINATION: _bindgen_ty_26 = 4;
pub const PMLAUNCHFLAG_QUEUE_DEBUG_APPLICATION: _bindgen_ty_26 = 8;
pub const PMLAUNCHFLAG_TERMINATION_NOTIFICATION_MASK: _bindgen_ty_26 = 240;
#[doc = "Forces the usage of the O3DS system mode app memory setting even if N3DS system mode is not \"Legacy\". Dev4 and Dev5 not supported. N3DS only."]
#[doc = ""]

pub const PMLAUNCHFLAG_FORCE_USE_O3DS_APP_MEM: _bindgen_ty_26 = 256;
#[doc = "In conjunction with the above, forces the 96MB app memory setting. N3DS only."]
#[doc = ""]

pub const PMLAUNCHFLAG_FORCE_USE_O3DS_MAX_APP_MEM: _bindgen_ty_26 = 512;
pub const PMLAUNCHFLAG_USE_UPDATE_TITLE: _bindgen_ty_26 = 65536;
#[doc = "Launch flags for PM launch commands."]
#[doc = ""]

pub type _bindgen_ty_26 = ::libc::c_uint;
extern "C" {
    #[must_use]
    #[doc = "Initializes pm:app."]
    #[doc = ""]
    pub fn pmAppInit() -> Result;
}
extern "C" {
    #[doc = "Exits pm:app."]
    #[doc = ""]
    pub fn pmAppExit();
}
extern "C" {
    #[doc = "Gets the current pm:app session handle.\n @return The current pm:app session handle."]
    #[doc = ""]
    pub fn pmAppGetSessionHandle() -> *mut Handle;
}
extern "C" {
    #[must_use]
    #[doc = "Launches a title.\n @param programInfo Program information of the title.\n @param launchFlags Flags to launch the title with."]
    #[doc = ""]
    pub fn PMAPP_LaunchTitle(programInfo: *const FS_ProgramInfo, launchFlags: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Launches a title, applying patches.\n @param programInfo Program information of the title.\n @param programInfoUpdate Program information of the update title.\n @param launchFlags Flags to launch the title with."]
    #[doc = ""]
    pub fn PMAPP_LaunchTitleUpdate(
        programInfo: *const FS_ProgramInfo,
        programInfoUpdate: *const FS_ProgramInfo,
        launchFlags: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets a title's ExHeader Arm11CoreInfo and SystemInfo flags.\n @param[out] outCoreInfo Pointer to write the ExHeader Arm11CoreInfo to.\n @param[out] outSiFlags Pointer to write the ExHeader SystemInfo flags to.\n @param programInfo Program information of the title."]
    #[doc = ""]
    pub fn PMAPP_GetTitleExheaderFlags(
        outCoreInfo: *mut ExHeader_Arm11CoreInfo,
        outSiFlags: *mut ExHeader_SystemInfoFlags,
        programInfo: *const FS_ProgramInfo,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the current FIRM launch parameters.\n @param size Size of the FIRM launch parameter buffer.\n @param in Buffer to retrieve the launch parameters from."]
    #[doc = ""]
    pub fn PMAPP_SetFIRMLaunchParams(size: u32_, in_: *const ::libc::c_void) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the current FIRM launch parameters.\n @param size Size of the FIRM launch parameter buffer.\n @param[out] out Buffer to write the launch parameters to."]
    #[doc = ""]
    pub fn PMAPP_GetFIRMLaunchParams(out: *mut ::libc::c_void, size: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the current FIRM launch parameters.\n @param firmTidLow Low Title ID of the FIRM title to launch.\n @param size Size of the FIRM launch parameter buffer.\n @param in Buffer to retrieve the launch parameters from."]
    #[doc = ""]
    pub fn PMAPP_LaunchFIRMSetParams(
        firmTidLow: u32_,
        size: u32_,
        in_: *const ::libc::c_void,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Terminate most processes, to prepare for a reboot or a shutdown.\n @param timeout Time limit in ns for process termination, after which the remaining processes are killed."]
    #[doc = ""]
    pub fn PMAPP_PrepareForReboot(timeout: s64) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Terminates the current Application\n @param timeout Timeout in nanoseconds"]
    #[doc = ""]
    pub fn PMAPP_TerminateCurrentApplication(timeout: s64) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Terminates the processes having the specified titleId.\n @param titleId Title ID of the processes to terminate\n @param timeout Timeout in nanoseconds"]
    #[doc = ""]
    pub fn PMAPP_TerminateTitle(titleId: u64_, timeout: s64) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Terminates the specified process\n @param pid Process-ID of the process to terminate\n @param timeout Timeout in nanoseconds"]
    #[doc = ""]
    pub fn PMAPP_TerminateProcess(pid: u32_, timeout: s64) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Unregisters a process\n @param tid TitleID of the process to unregister"]
    #[doc = ""]
    pub fn PMAPP_UnregisterProcess(tid: u64_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the APPLICATION cputime reslimit.\n @param cpuTime Reslimit value.\n @note cpuTime can be no higher than reslimitdesc[0] & 0x7F in exheader (or 80 if the latter is 0)."]
    #[doc = ""]
    pub fn PMAPP_SetAppResourceLimit(cpuTime: s64) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the APPLICATION cputime reslimit.\n @param[out] cpuTime Pointer to write the reslimit value to."]
    #[doc = ""]
    pub fn PMAPP_GetAppResourceLimit(outCpuTime: *mut s64) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initializes pm:dbg."]
    #[doc = ""]
    pub fn pmDbgInit() -> Result;
}
extern "C" {
    #[doc = "Exits pm:dbg."]
    #[doc = ""]
    pub fn pmDbgExit();
}
extern "C" {
    #[doc = "Gets the current pm:dbg session handle.\n @return The current pm:dbg session handle."]
    #[doc = ""]
    pub fn pmDbgGetSessionHandle() -> *mut Handle;
}
extern "C" {
    #[must_use]
    #[doc = "Enqueues an application for debug after setting cpuTime to 0, and returns a debug handle to it.\n If another process was enqueued, this just calls [`RunQueuedProcess`] instead.\n @param[out] Pointer to output the debug handle to.\n @param programInfo Program information of the title.\n @param launchFlags Flags to launch the title with."]
    #[doc = ""]
    pub fn PMDBG_LaunchAppDebug(
        outDebug: *mut Handle,
        programInfo: *const FS_ProgramInfo,
        launchFlags: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Launches an application for debug after setting cpuTime to 0.\n @param programInfo Program information of the title.\n @param launchFlags Flags to launch the title with."]
    #[doc = ""]
    pub fn PMDBG_LaunchApp(programInfo: *const FS_ProgramInfo, launchFlags: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Runs the queued process and returns a debug handle to it.\n @param[out] Pointer to output the debug handle to."]
    #[doc = ""]
    pub fn PMDBG_RunQueuedProcess(outDebug: *mut Handle) -> Result;
}
#[doc = "CBC encryption."]
#[doc = ""]

pub const PS_ALGORITHM_CBC_ENC: PS_AESAlgorithm = 0;
#[doc = "CBC decryption."]
#[doc = ""]

pub const PS_ALGORITHM_CBC_DEC: PS_AESAlgorithm = 1;
#[doc = "CTR encryption."]
#[doc = ""]

pub const PS_ALGORITHM_CTR_ENC: PS_AESAlgorithm = 2;
#[doc = "CTR decryption(same as PS_ALGORITHM_CTR_ENC)."]
#[doc = ""]

pub const PS_ALGORITHM_CTR_DEC: PS_AESAlgorithm = 3;
#[doc = "CCM encryption."]
#[doc = ""]

pub const PS_ALGORITHM_CCM_ENC: PS_AESAlgorithm = 4;
#[doc = "CCM decryption."]
#[doc = ""]

pub const PS_ALGORITHM_CCM_DEC: PS_AESAlgorithm = 5;
#[doc = "PS AES algorithms."]
#[doc = ""]

pub type PS_AESAlgorithm = ::libc::c_uint;
#[doc = "Key slot 0x0D."]
#[doc = ""]

pub const PS_KEYSLOT_0D: PS_AESKeyType = 0;
#[doc = "Key slot 0x2D."]
#[doc = ""]

pub const PS_KEYSLOT_2D: PS_AESKeyType = 1;
#[doc = "Key slot 0x31."]
#[doc = ""]

pub const PS_KEYSLOT_31: PS_AESKeyType = 2;
#[doc = "Key slot 0x38."]
#[doc = ""]

pub const PS_KEYSLOT_38: PS_AESKeyType = 3;
#[doc = "Key slot 0x32."]
#[doc = ""]

pub const PS_KEYSLOT_32: PS_AESKeyType = 4;
#[doc = "Key slot 0x39. (DLP)"]
#[doc = ""]

pub const PS_KEYSLOT_39_DLP: PS_AESKeyType = 5;
#[doc = "Key slot 0x2E."]
#[doc = ""]

pub const PS_KEYSLOT_2E: PS_AESKeyType = 6;
#[doc = "Invalid key slot."]
#[doc = ""]

pub const PS_KEYSLOT_INVALID: PS_AESKeyType = 7;
#[doc = "Key slot 0x36."]
#[doc = ""]

pub const PS_KEYSLOT_36: PS_AESKeyType = 8;
#[doc = "Key slot 0x39. (NFC)"]
#[doc = ""]

pub const PS_KEYSLOT_39_NFC: PS_AESKeyType = 9;
#[doc = "PS key slots."]
#[doc = ""]

pub type PS_AESKeyType = ::libc::c_uint;
#[doc = "RSA context."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct psRSAContext {
    pub modulo: [u8_; 256usize],
    pub exponent: [u8_; 256usize],
    pub rsa_bitsize: u32_,
    pub unk: u32_,
}
impl Default for psRSAContext {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[must_use]
    #[doc = "Initializes PS."]
    #[doc = ""]
    pub fn psInit() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initializes PS with the specified session handle.\n @param handle Session handle."]
    #[doc = ""]
    pub fn psInitHandle(handle: Handle) -> Result;
}
extern "C" {
    #[doc = "Exits PS."]
    #[doc = ""]
    pub fn psExit();
}
extern "C" {
    #[doc = "Returns the PS session handle."]
    #[doc = ""]
    pub fn psGetSessionHandle() -> Handle;
}
extern "C" {
    #[must_use]
    #[doc = "Signs a RSA signature.\n @param hash SHA256 hash to sign.\n @param ctx RSA context.\n @param signature RSA signature."]
    #[doc = ""]
    pub fn PS_SignRsaSha256(hash: *mut u8_, ctx: *mut psRSAContext, signature: *mut u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Verifies a RSA signature.\n @param hash SHA256 hash to compare with.\n @param ctx RSA context.\n @param signature RSA signature."]
    #[doc = ""]
    pub fn PS_VerifyRsaSha256(
        hash: *mut u8_,
        ctx: *mut psRSAContext,
        signature: *mut u8_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Encrypts/Decrypts AES data. Does not support AES CCM.\n @param size Size of the data.\n @param in Input buffer.\n @param out Output buffer.\n @param aes_algo AES algorithm to use.\n @param key_type Key type to use.\n @param iv Pointer to the CTR/IV. The output CTR/IV is also written here."]
    #[doc = ""]
    pub fn PS_EncryptDecryptAes(
        size: u32_,
        in_: *mut u8_,
        out: *mut u8_,
        aes_algo: PS_AESAlgorithm,
        key_type: PS_AESKeyType,
        iv: *mut u8_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Encrypts/Decrypts signed AES CCM data.\n When decrypting, if the MAC is invalid, 0xC9010401 is returned. After encrypting the MAC is located at inputbufptr.\n @param in Input buffer.\n @param in_size Size of the input buffer. Must include MAC size when decrypting.\n @param out Output buffer.\n @param out_size Size of the output buffer. Must include MAC size when encrypting.\n @param data_len Length of the data to be encrypted/decrypted.\n @param mac_data_len Length of the MAC data.\n @param mac_len Length of the MAC.\n @param aes_algo AES algorithm to use.\n @param key_type Key type to use.\n @param nonce Pointer to the nonce."]
    #[doc = ""]
    pub fn PS_EncryptSignDecryptVerifyAesCcm(
        in_: *mut u8_,
        in_size: u32_,
        out: *mut u8_,
        out_size: u32_,
        data_len: u32_,
        mac_data_len: u32_,
        mac_len: u32_,
        aes_algo: PS_AESAlgorithm,
        key_type: PS_AESKeyType,
        nonce: *mut u8_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the 64-bit console friend code seed.\n @param seed Pointer to write the friend code seed to."]
    #[doc = ""]
    pub fn PS_GetLocalFriendCodeSeed(seed: *mut u64_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the 32-bit device ID.\n @param device_id Pointer to write the device ID to."]
    #[doc = ""]
    pub fn PS_GetDeviceId(device_id: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Generates cryptographically secure random bytes.\n @param out Pointer to the buffer to write the bytes to.\n @param len Number of bytes to write."]
    #[doc = ""]
    pub fn PS_GenerateRandomBytes(out: *mut ::libc::c_void, len: usize) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initializes PTMU."]
    #[doc = ""]
    pub fn ptmuInit() -> Result;
}
extern "C" {
    #[doc = "Exits PTMU."]
    #[doc = ""]
    pub fn ptmuExit();
}
extern "C" {
    #[doc = "Gets a pointer to the current ptm:u session handle.\n @return A pointer to the current ptm:u session handle."]
    #[doc = ""]
    pub fn ptmuGetSessionHandle() -> *mut Handle;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the system's current shell state.\n @param out Pointer to write the current shell state to. (0 = closed, 1 = open)"]
    #[doc = ""]
    pub fn PTMU_GetShellState(out: *mut u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the system's current battery level.\n @param out Pointer to write the current battery level to. (0-5)"]
    #[doc = ""]
    pub fn PTMU_GetBatteryLevel(out: *mut u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the system's current battery charge state.\n @param out Pointer to write the current battery charge state to. (0 = not charging, 1 = charging)"]
    #[doc = ""]
    pub fn PTMU_GetBatteryChargeState(out: *mut u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the system's current pedometer state.\n @param out Pointer to write the current pedometer state to. (0 = not counting, 1 = counting)"]
    #[doc = ""]
    pub fn PTMU_GetPedometerState(out: *mut u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the pedometer's total step count.\n @param steps Pointer to write the total step count to."]
    #[doc = ""]
    pub fn PTMU_GetTotalStepCount(steps: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets whether the adapter is plugged in or not\n @param out Pointer to write the adapter state to."]
    #[doc = ""]
    pub fn PTMU_GetAdapterState(out: *mut bool) -> Result;
}
#[doc = "PDN wake events and MCU interrupts to select, combined with those of other processes"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PtmWakeEvents {
    #[doc = "Written to PDN_WAKE_EVENTS. Don't select bit26 (MCU), PTM will do it automatically."]
    #[doc = ""]
    pub pdn_wake_events: u32_,
    #[doc = "MCU interrupts to check when a MCU wake event happens."]
    #[doc = ""]
    pub mcu_interupt_mask: u32_,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PtmSleepConfig {
    #[doc = "Wake events for which the system should fully wake up."]
    #[doc = ""]
    pub exit_sleep_events: PtmWakeEvents,
    #[doc = "Wake events for which the system should return to sleep."]
    #[doc = ""]
    pub continue_sleep_events: PtmWakeEvents,
}
#[doc = "[`PTMSYSM_RequestSleep`] has been called (ack = 3)"]
#[doc = ""]

pub const PTMNOTIFID_SLEEP_REQUESTED: _bindgen_ty_27 = 257;
#[doc = "The sleep request has been denied by [`PTMSYSM_ReplyToSleepQuery(true)`] (no ack required)."]
#[doc = ""]

pub const PTMNOTIFID_SLEEP_DENIED: _bindgen_ty_27 = 258;
#[doc = "The sleep request has been allowed by [`PTMSYSM_ReplyToSleepQuery(false)`] (ack = 1)."]
#[doc = ""]

pub const PTMNOTIFID_SLEEP_ALLOWED: _bindgen_ty_27 = 259;
#[doc = "All processes not having \"RunnableOnSleep\" have been paused & the system is about to go to sleep (ack = 0)."]
#[doc = ""]

pub const PTMNOTIFID_GOING_TO_SLEEP: _bindgen_ty_27 = 260;
#[doc = "The system has been woken up, and the paused processes are about to be unpaused (ack = 1)."]
#[doc = ""]

pub const PTMNOTIFID_FULLY_WAKING_UP: _bindgen_ty_27 = 261;
#[doc = "The system is fully awake (no ack required)."]
#[doc = ""]

pub const PTMNOTIFID_FULLY_AWAKE: _bindgen_ty_27 = 262;
#[doc = "The system has been woken up but is about to go to sleep again (ack = 2)."]
#[doc = ""]

pub const PTMNOTIFID_HALF_AWAKE: _bindgen_ty_27 = 263;
#[doc = "The system is about to power off or reboot."]
#[doc = ""]

pub const PTMNOTIFID_SHUTDOWN: _bindgen_ty_27 = 264;
#[doc = "The battery level has reached 5% or below."]
#[doc = ""]

pub const PTMNOTIFID_BATTERY_VERY_LOW: _bindgen_ty_27 = 529;
#[doc = "The battery level has reached 10% or below."]
#[doc = ""]

pub const PTMNOTIFID_BATTERY_LOW: _bindgen_ty_27 = 530;
pub type _bindgen_ty_27 = ::libc::c_uint;
extern "C" {
    #[must_use]
    #[doc = "Initializes ptm:sysm."]
    #[doc = ""]
    pub fn ptmSysmInit() -> Result;
}
extern "C" {
    #[doc = "Exits ptm:sysm."]
    #[doc = ""]
    pub fn ptmSysmExit();
}
extern "C" {
    #[doc = "Gets a pointer to the current ptm:sysm session handle.\n @return A pointer to the current ptm:sysm session handle."]
    #[doc = ""]
    pub fn ptmSysmGetSessionHandle() -> *mut Handle;
}
extern "C" {
    #[must_use]
    #[doc = "Requests to enter sleep mode."]
    #[doc = ""]
    pub fn PTMSYSM_RequestSleep() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Accepts or denies the incoming sleep mode request.\n @param deny Whether or not to deny the sleep request.\n @note If deny = false, this is equivalent to calling [`PTMSYSM_NotifySleepPreparationComplete(3)`]"]
    #[doc = ""]
    pub fn PTMSYSM_ReplyToSleepQuery(deny: bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Acknowledges the current sleep notification and advance the internal sleep mode FSM. All subscribers must reply.\n @param ackValue Use [`ptmSysmGetNotificationAckValue\n`] @note [`PTMNOTIFID_SLEEP_DENIED`] and [`PTMNOTIFID_FULLY_AWAKE`] don't require this."]
    #[doc = ""]
    pub fn PTMSYSM_NotifySleepPreparationComplete(ackValue: s32) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the wake events (two sets: when to fully wake up and when to return to sleep).\n @param sleepConfig Pointer to the two sets of wake events.\n @note Can only be called just before acknowledging [`PTMNOTIFID_GOING_TO_SLEEP`] or [`PTMNOTIFID_HALF_AWAKE`]"]
    #[doc = ""]
    pub fn PTMSYSM_SetWakeEvents(sleepConfig: *const PtmSleepConfig) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the wake reason (only the first applicable wake event is taken into account).\n @param sleepConfig Pointer to the two sets of wake events. Only the relevant set will be filled."]
    #[doc = ""]
    pub fn PTMSYSM_GetWakeReason(outSleepConfig: *mut PtmSleepConfig) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Cancels the \"half-awake\" state and fully wakes up the 3DS after some delay."]
    #[doc = ""]
    pub fn PTMSYSM_Awaken() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the user time by updating the user time offset.\n @param msY2k The number of milliseconds since 01/01/2000."]
    #[doc = ""]
    pub fn PTMSYSM_SetUserTime(msY2k: s64) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Invalidates the \"system time\" (cfg block 0x30002)"]
    #[doc = ""]
    pub fn PTMSYSM_InvalidateSystemTime() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Reads the time and date coming from the RTC and converts the result.\n @param[out] outMsY2k The pointer to write the number of milliseconds since 01/01/2000 to."]
    #[doc = ""]
    pub fn PTMSYSM_GetRtcTime(outMsY2k: *mut s64) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Writes the time and date coming to the RTC, after conversion.\n @param msY2k The number of milliseconds since 01/01/2000."]
    #[doc = ""]
    pub fn PTMSYSM_SetRtcTime(msY2k: s64) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Returns 1 if it's a New 3DS, otherwise 0."]
    #[doc = ""]
    pub fn PTMSYSM_CheckNew3DS() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Configures the New 3DS' CPU clock speed and L2 cache.\n @param value Bit0: enable higher clock, Bit1: enable L2 cache."]
    #[doc = ""]
    pub fn PTMSYSM_ConfigureNew3DSCPU(value: u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Trigger a hardware system shutdown via the MCU.\n @param timeout: timeout passed to PMApp:ShutdownAsync (PrepareForReboot)."]
    #[doc = ""]
    pub fn PTMSYSM_ShutdownAsync(timeout: u64_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Trigger a hardware system reboot via the MCU.\n @param timeout: timeout passed to PMApp:ShutdownAsync (PrepareForReboot)."]
    #[doc = ""]
    pub fn PTMSYSM_RebootAsync(timeout: u64_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initializes PTMGETS."]
    #[doc = ""]
    pub fn ptmGetsInit() -> Result;
}
extern "C" {
    #[doc = "Exits PTMGETS."]
    #[doc = ""]
    pub fn ptmGetsExit();
}
extern "C" {
    #[doc = "Gets a pointer to the current ptm:gets session handle.\n @return A pointer to the current ptm:gets session handle."]
    #[doc = ""]
    pub fn ptmGetsGetSessionHandle() -> *mut Handle;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the system time.\n @param[out] outMsY2k The pointer to write the number of milliseconds since 01/01/2000 to."]
    #[doc = ""]
    pub fn PTMGETS_GetSystemTime(outMsY2k: *mut s64) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initializes PTMSETS."]
    #[doc = ""]
    pub fn ptmSetsInit() -> Result;
}
extern "C" {
    #[doc = "Exits PTMSETS."]
    #[doc = ""]
    pub fn ptmSetsExit();
}
extern "C" {
    #[doc = "Gets a pointer to the current ptm:sets session handle.\n @return A pointer to the current ptm:sets session handle."]
    #[doc = ""]
    pub fn ptmSetsGetSessionHandle() -> *mut Handle;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the system time.\n @param msY2k The number of milliseconds since 01/01/2000."]
    #[doc = ""]
    pub fn PTMSETS_SetSystemTime(msY2k: s64) -> Result;
}
#[doc = "Do not wait."]
#[doc = ""]

pub const WAIT_NONE: PXIDEV_WaitType = 0;
#[doc = "Sleep for the specified number of nanoseconds."]
#[doc = ""]

pub const WAIT_SLEEP: PXIDEV_WaitType = 1;
#[doc = "Wait for IREQ, return if timeout."]
#[doc = ""]

pub const WAIT_IREQ_RETURN: PXIDEV_WaitType = 2;
#[doc = "Wait for IREQ, continue if timeout."]
#[doc = ""]

pub const WAIT_IREQ_CONTINUE: PXIDEV_WaitType = 3;
#[doc = "Card SPI wait operation type."]
#[doc = ""]

pub type PXIDEV_WaitType = ::libc::c_uint;
#[doc = "Do not deassert."]
#[doc = ""]

pub const DEASSERT_NONE: PXIDEV_DeassertType = 0;
#[doc = "Deassert before waiting."]
#[doc = ""]

pub const DEASSERT_BEFORE_WAIT: PXIDEV_DeassertType = 1;
#[doc = "Deassert after waiting."]
#[doc = ""]

pub const DEASSERT_AFTER_WAIT: PXIDEV_DeassertType = 2;
#[doc = "Card SPI register deassertion type."]
#[doc = ""]

pub type PXIDEV_DeassertType = ::libc::c_uint;
#[doc = "Card SPI transfer buffer."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PXIDEV_SPIBuffer {
    #[doc = "Data pointer."]
    #[doc = ""]
    pub ptr: *mut ::libc::c_void,
    #[doc = "Data size."]
    #[doc = ""]
    pub size: u32_,
    #[doc = "Transfer options. See [`pxiDevMakeTransferOption`]"]
    #[doc = ""]
    pub transferOption: u8_,
    #[doc = "Wait operation. See [`pxiDevMakeWaitOperation`]"]
    #[doc = ""]
    pub waitOperation: u64_,
}
impl Default for PXIDEV_SPIBuffer {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[must_use]
    #[doc = "Initializes pxi:dev."]
    #[doc = ""]
    pub fn pxiDevInit() -> Result;
}
extern "C" {
    #[doc = "Shuts down pxi:dev."]
    #[doc = ""]
    pub fn pxiDevExit();
}
extern "C" {
    #[must_use]
    #[doc = "Performs multiple card SPI writes and reads.\n @param header Header to lead the transfers with. Must be, at most, 8 bytes in size.\n @param writeBuffer1 Buffer to make first transfer from.\n @param readBuffer1 Buffer to receive first response to.\n @param writeBuffer2 Buffer to make second transfer from.\n @param readBuffer2 Buffer to receive second response to.\n @param footer Footer to follow the transfers with. Must be, at most, 8 bytes in size. Wait operation is unused."]
    #[doc = ""]
    pub fn PXIDEV_SPIMultiWriteRead(
        header: *mut PXIDEV_SPIBuffer,
        writeBuffer1: *mut PXIDEV_SPIBuffer,
        readBuffer1: *mut PXIDEV_SPIBuffer,
        writeBuffer2: *mut PXIDEV_SPIBuffer,
        readBuffer2: *mut PXIDEV_SPIBuffer,
        footer: *mut PXIDEV_SPIBuffer,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Performs a single card SPI write and read.\n @param bytesRead Pointer to output the number of bytes received to.\n @param initialWaitOperation Wait operation to perform before transferring data.\n @param writeBuffer Buffer to transfer data from.\n @param readBuffer Buffer to receive data to."]
    #[doc = ""]
    pub fn PXIDEV_SPIWriteRead(
        bytesRead: *mut u32_,
        initialWaitOperation: u64_,
        writeBuffer: *mut PXIDEV_SPIBuffer,
        readBuffer: *mut PXIDEV_SPIBuffer,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initializes PxiPM."]
    #[doc = ""]
    pub fn pxiPmInit() -> Result;
}
extern "C" {
    #[doc = "Exits PxiPM."]
    #[doc = ""]
    pub fn pxiPmExit();
}
extern "C" {
    #[doc = "Gets the current PxiPM session handle.\n @return The current PxiPM session handle."]
    #[doc = ""]
    pub fn pxiPmGetSessionHandle() -> *mut Handle;
}
extern "C" {
    #[must_use]
    #[doc = "Retrives the exheader information set(s) (SCI+ACI) about a program.\n @param exheaderInfos[out] Pointer to the output exheader information set.\n @param programHandle The program handle."]
    #[doc = ""]
    pub fn PXIPM_GetProgramInfo(exheaderInfo: *mut ExHeader_Info, programHandle: u64_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Loads a program and registers it to Process9.\n @param programHandle[out] Pointer to the output the program handle to.\n @param programInfo Information about the program to load.\n @param updateInfo Information about the program update to load."]
    #[doc = ""]
    pub fn PXIPM_RegisterProgram(
        programHandle: *mut u64_,
        programInfo: *const FS_ProgramInfo,
        updateInfo: *const FS_ProgramInfo,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Unloads a program and unregisters it from Process9.\n @param programHandle The program handle."]
    #[doc = ""]
    pub fn PXIPM_UnregisterProgram(programHandle: u64_) -> Result;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timezone {
    pub tz_minuteswest: ::libc::c_int,
    pub tz_dsttime: ::libc::c_int,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct bintime {
    pub sec: time_t,
    pub frac: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
pub type __ULong = ::libc::c_ulong;
pub type _flock_t = _LOCK_RECURSIVE_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Bigint {
    pub _next: *mut _Bigint,
    pub _k: ::libc::c_int,
    pub _maxwds: ::libc::c_int,
    pub _sign: ::libc::c_int,
    pub _wds: ::libc::c_int,
    pub _x: [__ULong; 1usize],
}
impl Default for _Bigint {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __tm {
    pub __tm_sec: ::libc::c_int,
    pub __tm_min: ::libc::c_int,
    pub __tm_hour: ::libc::c_int,
    pub __tm_mday: ::libc::c_int,
    pub __tm_mon: ::libc::c_int,
    pub __tm_year: ::libc::c_int,
    pub __tm_wday: ::libc::c_int,
    pub __tm_yday: ::libc::c_int,
    pub __tm_isdst: ::libc::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _on_exit_args {
    pub _fnargs: [*mut ::libc::c_void; 32usize],
    pub _dso_handle: [*mut ::libc::c_void; 32usize],
    pub _fntypes: __ULong,
    pub _is_cxa: __ULong,
}
impl Default for _on_exit_args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _atexit {
    pub _next: *mut _atexit,
    pub _ind: ::libc::c_int,
    pub _fns: [::core::option::Option<unsafe extern "C" fn()>; 32usize],
    pub _on_exit_args: _on_exit_args,
}
impl Default for _atexit {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut ::libc::c_uchar,
    pub _size: ::libc::c_int,
}
impl Default for __sbuf {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut ::libc::c_uchar,
    pub _r: ::libc::c_int,
    pub _w: ::libc::c_int,
    pub _flags: ::libc::c_short,
    pub _file: ::libc::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::libc::c_int,
    pub _cookie: *mut ::libc::c_void,
    pub _read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::libc::c_void,
            arg3: *mut ::libc::c_char,
            arg4: ::libc::c_int,
        ) -> ::libc::c_int,
    >,
    pub _write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::libc::c_void,
            arg3: *const ::libc::c_char,
            arg4: ::libc::c_int,
        ) -> ::libc::c_int,
    >,
    pub _seek: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::libc::c_void,
            arg3: _fpos_t,
            arg4: ::libc::c_int,
        ) -> _fpos_t,
    >,
    pub _close: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut _reent, arg2: *mut ::libc::c_void) -> ::libc::c_int,
    >,
    pub _ub: __sbuf,
    pub _up: *mut ::libc::c_uchar,
    pub _ur: ::libc::c_int,
    pub _ubuf: [::libc::c_uchar; 3usize],
    pub _nbuf: [::libc::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::libc::c_int,
    pub _offset: _off_t,
    pub _data: *mut _reent,
    pub _lock: _flock_t,
    pub _mbstate: _mbstate_t,
    pub _flags2: ::libc::c_int,
}
impl Default for __sFILE {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __FILE = __sFILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _glue {
    pub _next: *mut _glue,
    pub _niobs: ::libc::c_int,
    pub _iobs: *mut __FILE,
}
impl Default for _glue {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _rand48 {
    pub _seed: [::libc::c_ushort; 3usize],
    pub _mult: [::libc::c_ushort; 3usize],
    pub _add: ::libc::c_ushort,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _reent {
    pub _errno: ::libc::c_int,
    pub _stdin: *mut __FILE,
    pub _stdout: *mut __FILE,
    pub _stderr: *mut __FILE,
    pub _inc: ::libc::c_int,
    pub _emergency: [::libc::c_char; 25usize],
    pub _unspecified_locale_info: ::libc::c_int,
    pub _locale: *mut __locale_t,
    pub __sdidinit: ::libc::c_int,
    pub __cleanup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut _reent)>,
    pub _result: *mut _Bigint,
    pub _result_k: ::libc::c_int,
    pub _p5s: *mut _Bigint,
    pub _freelist: *mut *mut _Bigint,
    pub _cvtlen: ::libc::c_int,
    pub _cvtbuf: *mut ::libc::c_char,
    pub _new: _reent__bindgen_ty_1,
    pub _atexit: *mut _atexit,
    pub _atexit0: _atexit,
    pub _sig_func: *mut ::core::option::Option<unsafe extern "C" fn(arg1: ::libc::c_int)>,
    pub __sglue: _glue,
    pub __sf: [__FILE; 3usize],
    pub deviceData: *mut ::libc::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _reent__bindgen_ty_1 {
    pub _reent: _reent__bindgen_ty_1__bindgen_ty_1,
    pub _unused: _reent__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _reent__bindgen_ty_1__bindgen_ty_1 {
    pub _unused_rand: ::libc::c_uint,
    pub _strtok_last: *mut ::libc::c_char,
    pub _asctime_buf: [::libc::c_char; 26usize],
    pub _localtime_buf: __tm,
    pub _gamma_signgam: ::libc::c_int,
    pub _rand_next: ::libc::c_ulonglong,
    pub _r48: _rand48,
    pub _mblen_state: _mbstate_t,
    pub _mbtowc_state: _mbstate_t,
    pub _wctomb_state: _mbstate_t,
    pub _l64a_buf: [::libc::c_char; 8usize],
    pub _signal_buf: [::libc::c_char; 24usize],
    pub _getdate_err: ::libc::c_int,
    pub _mbrlen_state: _mbstate_t,
    pub _mbrtowc_state: _mbstate_t,
    pub _mbsrtowcs_state: _mbstate_t,
    pub _wcrtomb_state: _mbstate_t,
    pub _wcsrtombs_state: _mbstate_t,
    pub _h_errno: ::libc::c_int,
}
impl Default for _reent__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _reent__bindgen_ty_1__bindgen_ty_2 {
    pub _nextf: [*mut ::libc::c_uchar; 30usize],
    pub _nmalloc: [::libc::c_uint; 30usize],
}
impl Default for _reent__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _reent__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _reent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut _impure_ptr: *mut _reent;
}
extern "C" {
    pub static _global_impure_ptr: *mut _reent;
}
extern "C" {
    pub fn _reclaim_reent(arg1: *mut _reent);
}
extern "C" {
    pub fn __getreent() -> *mut _reent;
}
pub type locale_t = *mut __locale_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::libc::c_int,
    pub tm_min: ::libc::c_int,
    pub tm_hour: ::libc::c_int,
    pub tm_mday: ::libc::c_int,
    pub tm_mon: ::libc::c_int,
    pub tm_year: ::libc::c_int,
    pub tm_wday: ::libc::c_int,
    pub tm_yday: ::libc::c_int,
    pub tm_isdst: ::libc::c_int,
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn difftime(_time2: time_t, _time1: time_t) -> f64;
}
extern "C" {
    pub fn mktime(_timeptr: *mut tm) -> time_t;
}
extern "C" {
    pub fn time(_timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn asctime(_tblock: *const tm) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn ctime(_time: *const time_t) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn gmtime(_timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(_timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn strftime(
        _s: *mut ::libc::c_char,
        _maxsize: usize,
        _fmt: *const ::libc::c_char,
        _t: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn strftime_l(
        _s: *mut ::libc::c_char,
        _maxsize: usize,
        _fmt: *const ::libc::c_char,
        _t: *const tm,
        _l: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn asctime_r(arg1: *const tm, arg2: *mut ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn ctime_r(arg1: *const time_t, arg2: *mut ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn gmtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub fn _tzset_r(arg1: *mut _reent);
}
extern "C" {
    pub static mut _timezone: ::libc::c_long;
}
extern "C" {
    pub static mut _daylight: ::libc::c_int;
}
extern "C" {
    pub static mut _tzname: [*mut ::libc::c_char; 2usize];
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ::libc::c_int,
    pub sival_ptr: *mut ::libc::c_void,
}
impl Default for sigval {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_notify: ::libc::c_int,
    pub sigev_signo: ::libc::c_int,
    pub sigev_value: sigval,
}
impl Default for sigevent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t {
    pub si_signo: ::libc::c_int,
    pub si_code: ::libc::c_int,
    pub si_value: sigval,
}
impl Default for siginfo_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type _sig_func_ptr = ::core::option::Option<unsafe extern "C" fn(arg1: ::libc::c_int)>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sigaction {
    pub sa_handler: _sig_func_ptr,
    pub sa_mask: sigset_t,
    pub sa_flags: ::libc::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigaltstack {
    pub ss_sp: *mut ::libc::c_void,
    pub ss_flags: ::libc::c_int,
    pub ss_size: usize,
}
impl Default for sigaltstack {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type stack_t = sigaltstack;
extern "C" {
    pub fn sigprocmask(
        arg1: ::libc::c_int,
        arg2: *const sigset_t,
        arg3: *mut sigset_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_sigmask(
        arg1: ::libc::c_int,
        arg2: *const sigset_t,
        arg3: *mut sigset_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn kill(arg1: pid_t, arg2: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn killpg(arg1: pid_t, arg2: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn sigaction(
        arg1: ::libc::c_int,
        arg2: *const sigaction,
        arg3: *mut sigaction,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn sigaddset(arg1: *mut sigset_t, arg2: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn sigdelset(arg1: *mut sigset_t, arg2: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn sigismember(arg1: *const sigset_t, arg2: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn sigfillset(arg1: *mut sigset_t) -> ::libc::c_int;
}
extern "C" {
    pub fn sigemptyset(arg1: *mut sigset_t) -> ::libc::c_int;
}
extern "C" {
    pub fn sigpending(arg1: *mut sigset_t) -> ::libc::c_int;
}
extern "C" {
    pub fn sigsuspend(arg1: *const sigset_t) -> ::libc::c_int;
}
extern "C" {
    pub fn sigwait(arg1: *const sigset_t, arg2: *mut ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn sigpause(arg1: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn sigaltstack(arg1: *const stack_t, arg2: *mut stack_t) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_kill(arg1: pthread_t, arg2: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn sigwaitinfo(arg1: *const sigset_t, arg2: *mut siginfo_t) -> ::libc::c_int;
}
extern "C" {
    pub fn sigtimedwait(
        arg1: *const sigset_t,
        arg2: *mut siginfo_t,
        arg3: *const timespec,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn sigqueue(arg1: pid_t, arg2: ::libc::c_int, arg3: sigval) -> ::libc::c_int;
}
extern "C" {
    pub fn sig2str(arg1: ::libc::c_int, arg2: *mut ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn str2sig(arg1: *const ::libc::c_char, arg2: *mut ::libc::c_int) -> ::libc::c_int;
}
pub type sig_atomic_t = ::libc::c_int;
pub type sig_t = _sig_func_ptr;
extern "C" {
    pub fn _signal_r(arg1: *mut _reent, arg2: ::libc::c_int, arg3: _sig_func_ptr) -> _sig_func_ptr;
}
extern "C" {
    pub fn _raise_r(arg1: *mut _reent, arg2: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn signal(arg1: ::libc::c_int, arg2: _sig_func_ptr) -> _sig_func_ptr;
}
extern "C" {
    pub fn raise(arg1: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn psignal(arg1: ::libc::c_int, arg2: *const ::libc::c_char);
}
extern "C" {
    pub fn clock_settime(clock_id: clockid_t, tp: *const timespec) -> ::libc::c_int;
}
extern "C" {
    pub fn clock_gettime(clock_id: clockid_t, tp: *mut timespec) -> ::libc::c_int;
}
extern "C" {
    pub fn clock_getres(clock_id: clockid_t, res: *mut timespec) -> ::libc::c_int;
}
extern "C" {
    pub fn timer_create(
        clock_id: clockid_t,
        evp: *mut sigevent,
        timerid: *mut timer_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn timer_delete(timerid: timer_t) -> ::libc::c_int;
}
extern "C" {
    pub fn timer_settime(
        timerid: timer_t,
        flags: ::libc::c_int,
        value: *const itimerspec,
        ovalue: *mut itimerspec,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn timer_gettime(timerid: timer_t, value: *mut itimerspec) -> ::libc::c_int;
}
extern "C" {
    pub fn timer_getoverrun(timerid: timer_t) -> ::libc::c_int;
}
extern "C" {
    pub fn nanosleep(rqtp: *const timespec, rmtp: *mut timespec) -> ::libc::c_int;
}
extern "C" {
    pub fn utimes(arg1: *const ::libc::c_char, arg2: *const timeval) -> ::libc::c_int;
}
extern "C" {
    pub fn adjtime(arg1: *const timeval, arg2: *mut timeval) -> ::libc::c_int;
}
extern "C" {
    pub fn futimes(arg1: ::libc::c_int, arg2: *const timeval) -> ::libc::c_int;
}
extern "C" {
    pub fn lutimes(arg1: *const ::libc::c_char, arg2: *const timeval) -> ::libc::c_int;
}
extern "C" {
    pub fn settimeofday(arg1: *const timeval, arg2: *const timezone) -> ::libc::c_int;
}
extern "C" {
    pub fn getitimer(__which: ::libc::c_int, __value: *mut itimerval) -> ::libc::c_int;
}
extern "C" {
    pub fn setitimer(
        __which: ::libc::c_int,
        __value: *const itimerval,
        __ovalue: *mut itimerval,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gettimeofday(__p: *mut timeval, __tz: *mut ::libc::c_void) -> ::libc::c_int;
}
pub type socklen_t = u32;
pub type sa_family_t = u16;
#[repr(C)]
#[derive(Debug, Default)]
pub struct sockaddr {
    pub sa_family: sa_family_t,
    pub sa_data: __IncompleteArrayField<::libc::c_char>,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sockaddr_storage {
    pub ss_family: sa_family_t,
    pub __ss_padding: [::libc::c_char; 26usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct linger {
    pub l_onoff: ::libc::c_int,
    pub l_linger: ::libc::c_int,
}
extern "C" {
    pub fn accept(
        sockfd: ::libc::c_int,
        addr: *mut sockaddr,
        addrlen: *mut socklen_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn bind(sockfd: ::libc::c_int, addr: *const sockaddr, addrlen: socklen_t) -> ::libc::c_int;
}
extern "C" {
    pub fn closesocket(sockfd: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn connect(
        sockfd: ::libc::c_int,
        addr: *const sockaddr,
        addrlen: socklen_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn getpeername(
        sockfd: ::libc::c_int,
        addr: *mut sockaddr,
        addrlen: *mut socklen_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn getsockname(
        sockfd: ::libc::c_int,
        addr: *mut sockaddr,
        addrlen: *mut socklen_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn getsockopt(
        sockfd: ::libc::c_int,
        level: ::libc::c_int,
        optname: ::libc::c_int,
        optval: *mut ::libc::c_void,
        optlen: *mut socklen_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn listen(sockfd: ::libc::c_int, backlog: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn recv(
        sockfd: ::libc::c_int,
        buf: *mut ::libc::c_void,
        len: usize,
        flags: ::libc::c_int,
    ) -> isize;
}
extern "C" {
    pub fn recvfrom(
        sockfd: ::libc::c_int,
        buf: *mut ::libc::c_void,
        len: usize,
        flags: ::libc::c_int,
        src_addr: *mut sockaddr,
        addrlen: *mut socklen_t,
    ) -> isize;
}
extern "C" {
    pub fn send(
        sockfd: ::libc::c_int,
        buf: *const ::libc::c_void,
        len: usize,
        flags: ::libc::c_int,
    ) -> isize;
}
extern "C" {
    pub fn sendto(
        sockfd: ::libc::c_int,
        buf: *const ::libc::c_void,
        len: usize,
        flags: ::libc::c_int,
        dest_addr: *const sockaddr,
        addrlen: socklen_t,
    ) -> isize;
}
extern "C" {
    pub fn setsockopt(
        sockfd: ::libc::c_int,
        level: ::libc::c_int,
        optname: ::libc::c_int,
        optval: *const ::libc::c_void,
        optlen: socklen_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn shutdown(sockfd: ::libc::c_int, how: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn socket(
        domain: ::libc::c_int,
        type_: ::libc::c_int,
        protocol: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn sockatmark(sockfd: ::libc::c_int) -> ::libc::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sockaddr_in {
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: in_addr,
    pub sin_zero: [::libc::c_uchar; 8usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ip_mreq {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
}
#[doc = "The mac address of the interface (u32 mac[6])"]
#[doc = ""]

pub const NETOPT_MAC_ADDRESS: NetworkOpt = 4100;
#[doc = "The ARP table [`SOCU_ARPTableEntry`]"]
#[doc = ""]

pub const NETOPT_ARP_TABLE: NetworkOpt = 12290;
#[doc = "The current IP setup [`SOCU_IPInfo`]"]
#[doc = ""]

pub const NETOPT_IP_INFO: NetworkOpt = 16387;
#[doc = "The value of the IP MTU (u32)"]
#[doc = ""]

pub const NETOPT_IP_MTU: NetworkOpt = 16388;
#[doc = "The routing table [`SOCU_RoutingTableEntry`]"]
#[doc = ""]

pub const NETOPT_ROUTING_TABLE: NetworkOpt = 16390;
#[doc = "The number of sockets in the UDP table (u32)"]
#[doc = ""]

pub const NETOPT_UDP_NUMBER: NetworkOpt = 32770;
#[doc = "The table of opened UDP sockets [`SOCU_UDPTableEntry`]"]
#[doc = ""]

pub const NETOPT_UDP_TABLE: NetworkOpt = 32771;
#[doc = "The number of sockets in the TCP table (u32)"]
#[doc = ""]

pub const NETOPT_TCP_NUMBER: NetworkOpt = 36866;
#[doc = "The table of opened TCP sockets [`SOCU_TCPTableEntry`]"]
#[doc = ""]

pub const NETOPT_TCP_TABLE: NetworkOpt = 36867;
#[doc = "The table of the DNS servers [`SOCU_DNSTableEntry`] -- Returns a buffer of size 336 but only 2 entries are set ?"]
#[doc = ""]

pub const NETOPT_DNS_TABLE: NetworkOpt = 45059;
#[doc = "The DHCP lease time remaining, in seconds"]
#[doc = ""]

pub const NETOPT_DHCP_LEASE_TIME: NetworkOpt = 49153;
#[doc = "Options to be used with [`SOCU_GetNetworkOpt`]"]
#[doc = ""]

pub type NetworkOpt = ::libc::c_uint;
#[doc = "One entry of the ARP table retrieved by using [`SOCU_GetNetworkOpt`] and [`NETOPT_ARP_TABLE`]"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SOCU_ARPTableEntry {
    pub unk0: u32_,
    #[doc = "The IPv4 address associated to the entry"]
    #[doc = ""]
    pub ip: in_addr,
    #[doc = "The MAC address of associated to the entry"]
    #[doc = ""]
    pub mac: [u8_; 6usize],
    pub padding: [u8_; 2usize],
}
#[doc = "Structure returned by [`SOCU_GetNetworkOpt`] when using [`NETOPT_IP_INFO`]"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SOCU_IPInfo {
    #[doc = "Current IPv4 address"]
    #[doc = ""]
    pub ip: in_addr,
    #[doc = "Current network mask"]
    #[doc = ""]
    pub netmask: in_addr,
    #[doc = "Current network broadcast address"]
    #[doc = ""]
    pub broadcast: in_addr,
}
#[doc = "One entry of the routing table retrieved by using [`SOCU_GetNetworkOpt`] and [`NETOPT_ROUTING_TABLE`]"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SOCU_RoutingTableEntry {
    #[doc = "Destination IP address of the route"]
    #[doc = ""]
    pub dest_ip: in_addr,
    #[doc = "Mask used for this route"]
    #[doc = ""]
    pub netmask: in_addr,
    #[doc = "Gateway address to reach the network"]
    #[doc = ""]
    pub gateway: in_addr,
    #[doc = "Linux netstat flags [`ROUTING_FLAG_G`]"]
    #[doc = ""]
    pub flags: u32_,
    #[doc = "number of milliseconds since 1st Jan 1900 00:00."]
    #[doc = ""]
    pub time: u64_,
}
#[doc = "One entry of the UDP sockets table retrieved by using [`SOCU_GetNetworkOpt`] and [`NETOPT_UDP_TABLE`]"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SOCU_UDPTableEntry {
    #[doc = "Local address information"]
    #[doc = ""]
    pub local: sockaddr_storage,
    #[doc = "Remote address information"]
    #[doc = ""]
    pub remote: sockaddr_storage,
}
#[doc = "One entry of the TCP sockets table retrieved by using [`SOCU_GetNetworkOpt`] and [`NETOPT_TCP_TABLE`]"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SOCU_TCPTableEntry {
    #[doc = "[`TCP`] states defines"]
    #[doc = ""]
    pub state: u32_,
    #[doc = "Local address information"]
    #[doc = ""]
    pub local: sockaddr_storage,
    #[doc = "Remote address information"]
    #[doc = ""]
    pub remote: sockaddr_storage,
}
#[doc = "One entry of the DNS servers table retrieved by using [`SOCU_GetNetworkOpt`] and [`NETOPT_DNS_TABLE`]"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SOCU_DNSTableEntry {
    pub family: u32_,
    #[doc = "Family of the address of the DNS server"]
    #[doc = ""]
    pub ip: in_addr,
    #[doc = "IP of the DNS server"]
    #[doc = ""]
    pub padding: [u8_; 12usize],
}
extern "C" {
    #[must_use]
    #[doc = "Initializes the SOC service.\n @param context_addr Address of a page-aligned (0x1000) buffer to be used.\n @param context_size Size of the buffer, a multiple of 0x1000.\n @note The specified context buffer can no longer be accessed by the process which called this function, since the userland permissions for this block are set to no-access."]
    #[doc = ""]
    pub fn socInit(context_addr: *mut u32_, context_size: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Closes the soc service.\n @note You need to call this in order to be able to use the buffer again."]
    #[doc = ""]
    pub fn socExit() -> Result;
}
extern "C" {
    #[doc = "Gets the system's host ID.\n @return The system's host ID."]
    #[doc = ""]
    pub fn gethostid() -> ::libc::c_long;
}
extern "C" {
    pub fn gethostname(name: *mut ::libc::c_char, namelen: usize) -> ::libc::c_int;
}
extern "C" {
    pub fn SOCU_ShutdownSockets() -> ::libc::c_int;
}
extern "C" {
    pub fn SOCU_CloseSockets() -> ::libc::c_int;
}
extern "C" {
    #[doc = "Retrieves information from the network configuration. Similar to getsockopt().\n @param level Only value allowed seems to be [`SOL_CONFIG\n`] @param optname The option to be retrieved\n @param optval Will contain the output of the command\n @param optlen Size of the optval buffer, will be updated to hold the size of the output\n @return 0 if successful. -1 if failed, and errno will be set accordingly. Can also return a system error code."]
    #[doc = ""]
    pub fn SOCU_GetNetworkOpt(
        level: ::libc::c_int,
        optname: NetworkOpt,
        optval: *mut ::libc::c_void,
        optlen: *mut socklen_t,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Gets the system's IP address, netmask, and subnet broadcast\n @return error"]
    #[doc = ""]
    pub fn SOCU_GetIPInfo(
        ip: *mut in_addr,
        netmask: *mut in_addr,
        broadcast: *mut in_addr,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Adds a global socket.\n @param sockfd The socket fd.\n @return error"]
    #[doc = ""]
    pub fn SOCU_AddGlobalSocket(sockfd: ::libc::c_int) -> ::libc::c_int;
}
#[doc = "Unsigned 8-bit PCM."]
#[doc = ""]

pub const MICU_ENCODING_PCM8: MICU_Encoding = 0;
#[doc = "Unsigned 16-bit PCM."]
#[doc = ""]

pub const MICU_ENCODING_PCM16: MICU_Encoding = 1;
#[doc = "Signed 8-bit PCM."]
#[doc = ""]

pub const MICU_ENCODING_PCM8_SIGNED: MICU_Encoding = 2;
#[doc = "Signed 16-bit PCM."]
#[doc = ""]

pub const MICU_ENCODING_PCM16_SIGNED: MICU_Encoding = 3;
#[doc = "Microphone audio encodings."]
#[doc = ""]

pub type MICU_Encoding = ::libc::c_uint;
#[doc = "32728.498 Hz"]
#[doc = ""]

pub const MICU_SAMPLE_RATE_32730: MICU_SampleRate = 0;
#[doc = "16364.479 Hz"]
#[doc = ""]

pub const MICU_SAMPLE_RATE_16360: MICU_SampleRate = 1;
#[doc = "10909.499 Hz"]
#[doc = ""]

pub const MICU_SAMPLE_RATE_10910: MICU_SampleRate = 2;
#[doc = "8182.1245 Hz"]
#[doc = ""]

pub const MICU_SAMPLE_RATE_8180: MICU_SampleRate = 3;
#[doc = "Microphone audio sampling rates."]
#[doc = ""]

pub type MICU_SampleRate = ::libc::c_uint;
extern "C" {
    #[must_use]
    #[doc = "Initializes MIC.\n @param size Shared memory buffer to write audio data to. Must be aligned to 0x1000 bytes.\n @param handle Size of the shared memory buffer."]
    #[doc = ""]
    pub fn micInit(buffer: *mut u8_, bufferSize: u32_) -> Result;
}
extern "C" {
    #[doc = "Exits MIC."]
    #[doc = ""]
    pub fn micExit();
}
extern "C" {
    #[doc = "Gets the size of the sample data area within the shared memory buffer.\n @return The sample data's size."]
    #[doc = ""]
    pub fn micGetSampleDataSize() -> u32_;
}
extern "C" {
    #[doc = "Gets the offset within the shared memory buffer of the last sample written.\n @return The last sample's offset."]
    #[doc = ""]
    pub fn micGetLastSampleOffset() -> u32_;
}
extern "C" {
    #[must_use]
    #[doc = "Maps MIC shared memory.\n @param size Size of the shared memory.\n @param handle Handle of the shared memory."]
    #[doc = ""]
    pub fn MICU_MapSharedMem(size: u32_, handle: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Unmaps MIC shared memory."]
    #[doc = ""]
    pub fn MICU_UnmapSharedMem() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Begins sampling microphone input.\n @param encoding Encoding of outputted audio.\n @param sampleRate Sample rate of outputted audio.\n @param sharedMemAudioOffset Offset to write audio data to in the shared memory buffer.\n @param sharedMemAudioSize Size of audio data to write to the shared memory buffer. This should be at most \"bufferSize - 4\".\n @param loop Whether to loop back to the beginning of the buffer when the end is reached."]
    #[doc = ""]
    pub fn MICU_StartSampling(
        encoding: MICU_Encoding,
        sampleRate: MICU_SampleRate,
        offset: u32_,
        size: u32_,
        loop_: bool,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Adjusts the configuration of the current sampling session.\n @param sampleRate Sample rate of outputted audio."]
    #[doc = ""]
    pub fn MICU_AdjustSampling(sampleRate: MICU_SampleRate) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Stops sampling microphone input."]
    #[doc = ""]
    pub fn MICU_StopSampling() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets whether microphone input is currently being sampled.\n @param sampling Pointer to output the sampling state to."]
    #[doc = ""]
    pub fn MICU_IsSampling(sampling: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets an event handle triggered when the shared memory buffer is full.\n @param handle Pointer to output the event handle to."]
    #[doc = ""]
    pub fn MICU_GetEventHandle(handle: *mut Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the microphone's gain.\n @param gain Gain to set."]
    #[doc = ""]
    pub fn MICU_SetGain(gain: u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the microphone's gain.\n @param gain Pointer to output the current gain to."]
    #[doc = ""]
    pub fn MICU_GetGain(gain: *mut u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets whether the microphone is powered on.\n @param power Whether the microphone is powered on."]
    #[doc = ""]
    pub fn MICU_SetPower(power: bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets whether the microphone is powered on.\n @param power Pointer to output the power state to."]
    #[doc = ""]
    pub fn MICU_GetPower(power: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets whether to clamp microphone input.\n @param clamp Whether to clamp microphone input."]
    #[doc = ""]
    pub fn MICU_SetClamp(clamp: bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets whether to clamp microphone input.\n @param clamp Pointer to output the clamp state to."]
    #[doc = ""]
    pub fn MICU_GetClamp(clamp: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets whether to allow sampling when the shell is closed.\n @param allowShellClosed Whether to allow sampling when the shell is closed."]
    #[doc = ""]
    pub fn MICU_SetAllowShellClosed(allowShellClosed: bool) -> Result;
}
#[doc = "Converting color formats."]
#[doc = ""]

pub const MVDMODE_COLORFORMATCONV: MVDSTD_Mode = 0;
#[doc = "Processing video."]
#[doc = ""]

pub const MVDMODE_VIDEOPROCESSING: MVDSTD_Mode = 1;
#[doc = "Processing mode."]
#[doc = ""]

pub type MVDSTD_Mode = ::libc::c_uint;
#[doc = "YUYV422"]
#[doc = ""]

pub const MVD_INPUT_YUYV422: MVDSTD_InputFormat = 65537;
#[doc = "H264"]
#[doc = ""]

pub const MVD_INPUT_H264: MVDSTD_InputFormat = 131073;
#[doc = "Input format."]
#[doc = ""]

pub type MVDSTD_InputFormat = ::libc::c_uint;
#[doc = "YUYV422"]
#[doc = ""]

pub const MVD_OUTPUT_YUYV422: MVDSTD_OutputFormat = 65537;
#[doc = "BGR565"]
#[doc = ""]

pub const MVD_OUTPUT_BGR565: MVDSTD_OutputFormat = 262146;
#[doc = "RGB565"]
#[doc = ""]

pub const MVD_OUTPUT_RGB565: MVDSTD_OutputFormat = 262148;
#[doc = "Output format."]
#[doc = ""]

pub type MVDSTD_OutputFormat = ::libc::c_uint;
#[doc = "Processing configuration."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MVDSTD_Config {
    #[doc = "Input type."]
    #[doc = ""]
    pub input_type: MVDSTD_InputFormat,
    #[doc = "Unknown."]
    #[doc = ""]
    pub unk_x04: u32_,
    #[doc = "Unknown. Referred to as \"H264 range\" in SKATER."]
    #[doc = ""]
    pub unk_x08: u32_,
    #[doc = "Input width."]
    #[doc = ""]
    pub inwidth: u32_,
    #[doc = "Input height."]
    #[doc = ""]
    pub inheight: u32_,
    #[doc = "Physical address of color conversion input data."]
    #[doc = ""]
    pub physaddr_colorconv_indata: u32_,
    #[doc = "Physical address used with color conversion."]
    #[doc = ""]
    pub physaddr_colorconv_unk0: u32_,
    #[doc = "Physical address used with color conversion."]
    #[doc = ""]
    pub physaddr_colorconv_unk1: u32_,
    #[doc = "Physical address used with color conversion."]
    #[doc = ""]
    pub physaddr_colorconv_unk2: u32_,
    #[doc = "Physical address used with color conversion."]
    #[doc = ""]
    pub physaddr_colorconv_unk3: u32_,
    #[doc = "Unknown."]
    #[doc = ""]
    pub unk_x28: [u32_; 6usize],
    #[doc = "Enables cropping with the input image when non-zero via the following 4 words."]
    #[doc = ""]
    pub enable_cropping: u32_,
    pub input_crop_x_pos: u32_,
    pub input_crop_y_pos: u32_,
    pub input_crop_height: u32_,
    pub input_crop_width: u32_,
    #[doc = "Unknown."]
    #[doc = ""]
    pub unk_x54: u32_,
    #[doc = "Output type."]
    #[doc = ""]
    pub output_type: MVDSTD_OutputFormat,
    #[doc = "Output width."]
    #[doc = ""]
    pub outwidth: u32_,
    #[doc = "Output height."]
    #[doc = ""]
    pub outheight: u32_,
    #[doc = "Physical address of output data."]
    #[doc = ""]
    pub physaddr_outdata0: u32_,
    #[doc = "Additional physical address for output data, only used when the output format type is value 0x00020001."]
    #[doc = ""]
    pub physaddr_outdata1: u32_,
    #[doc = "Unknown."]
    #[doc = ""]
    pub unk_x6c: [u32_; 38usize],
    #[doc = "This enables using the following 4 words when non-zero."]
    #[doc = ""]
    pub flag_x104: u32_,
    #[doc = "Output X position in the output buffer."]
    #[doc = ""]
    pub output_x_pos: u32_,
    #[doc = "Same as above except for the Y pos."]
    #[doc = ""]
    pub output_y_pos: u32_,
    #[doc = "Used for aligning the output width when larger than the output width. Overrides the output width when smaller than the output width."]
    #[doc = ""]
    pub output_width_override: u32_,
    #[doc = "Same as output_width_override except for the output height."]
    #[doc = ""]
    pub output_height_override: u32_,
    pub unk_x118: u32_,
}
impl Default for MVDSTD_Config {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MVDSTD_ProcessNALUnitOut {
    pub end_vaddr: u32_,
    pub end_physaddr: u32_,
    pub remaining_size: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MVDSTD_OutputBuffersEntry {
    pub outdata0: *mut ::libc::c_void,
    pub outdata1: *mut ::libc::c_void,
}
impl Default for MVDSTD_OutputBuffersEntry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MVDSTD_OutputBuffersEntryList {
    pub total_entries: u32_,
    pub entries: [MVDSTD_OutputBuffersEntry; 17usize],
}
impl Default for MVDSTD_OutputBuffersEntryList {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "This can be used to override the default input values for MVDSTD commands during initialization with video-processing. The default for these fields are all-zero, except for cmd1b_inval which is 1. See also here: <https://www.3dbrew.org/wiki/MVD_Services>"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MVDSTD_InitStruct {
    pub cmd5_inval0: s8,
    pub cmd5_inval1: s8,
    pub cmd5_inval2: s8,
    pub cmd5_inval3: u32_,
    pub cmd1b_inval: u8_,
}
extern "C" {
    #[must_use]
    #[doc = "Initializes MVDSTD.\n @param mode Mode to initialize MVDSTD to.\n @param input_type Type of input to process.\n @param output_type Type of output to produce.\n @param size Size of the work buffer, MVD_DEFAULT_WORKBUF_SIZE can be used for this. Only used when type == MVDMODE_VIDEOPROCESSING.\n @param initstruct Optional MVDSTD_InitStruct, this should be NULL normally."]
    #[doc = ""]
    pub fn mvdstdInit(
        mode: MVDSTD_Mode,
        input_type: MVDSTD_InputFormat,
        output_type: MVDSTD_OutputFormat,
        size: u32_,
        initstruct: *mut MVDSTD_InitStruct,
    ) -> Result;
}
extern "C" {
    #[doc = "Shuts down MVDSTD."]
    #[doc = ""]
    pub fn mvdstdExit();
}
extern "C" {
    #[doc = "Generates a default MVDSTD configuration.\n @param config Pointer to output the generated config to.\n @param input_width Input width.\n @param input_height Input height.\n @param output_width Output width.\n @param output_height Output height.\n @param vaddr_colorconv_indata Virtual address of the color conversion input data.\n @param vaddr_outdata0 Virtual address of the output data.\n @param vaddr_outdata1 Additional virtual address for output data, only used when the output format type is value 0x00020001."]
    #[doc = ""]
    pub fn mvdstdGenerateDefaultConfig(
        config: *mut MVDSTD_Config,
        input_width: u32_,
        input_height: u32_,
        output_width: u32_,
        output_height: u32_,
        vaddr_colorconv_indata: *mut u32_,
        vaddr_outdata0: *mut u32_,
        vaddr_outdata1: *mut u32_,
    );
}
extern "C" {
    #[must_use]
    #[doc = "Run color-format-conversion.\n @param config Pointer to the configuration to use."]
    #[doc = ""]
    pub fn mvdstdConvertImage(config: *mut MVDSTD_Config) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Processes a video frame(specifically a NAL-unit).\n @param inbuf_vaddr Input NAL-unit starting with the 3-byte \"00 00 01\" prefix. Must be located in linearmem.\n @param size Size of the input buffer.\n @param flag See here regarding this input flag: <https://www.3dbrew.org/wiki/MVDSTD:ProcessNALUnit\n> @param out Optional output MVDSTD_ProcessNALUnitOut structure."]
    #[doc = ""]
    pub fn mvdstdProcessVideoFrame(
        inbuf_vaddr: *mut ::libc::c_void,
        size: usize,
        flag: u32_,
        out: *mut MVDSTD_ProcessNALUnitOut,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Renders the video frame.\n @param config Optional pointer to the configuration to use. When NULL, MVDSTD_SetConfig() should have been used previously for this video.\n @param wait When true, wait for rendering to finish. When false, you can manually call this function repeatedly until it stops returning MVD_STATUS_BUSY."]
    #[doc = ""]
    pub fn mvdstdRenderVideoFrame(config: *mut MVDSTD_Config, wait: bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the current configuration of MVDSTD.\n @param config Pointer to the configuration to set."]
    #[doc = ""]
    pub fn MVDSTD_SetConfig(config: *mut MVDSTD_Config) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "New3DS Internet Browser doesn't use this. Once done, rendered frames will be written to the output buffers specified by the entrylist instead of the output specified by configuration. See here: <https://www.3dbrew.org/wiki/MVDSTD:SetupOutputBuffers\n> @param entrylist Input entrylist.\n @param bufsize Size of each buffer from the entrylist."]
    #[doc = ""]
    pub fn mvdstdSetupOutputBuffers(
        entrylist: *mut MVDSTD_OutputBuffersEntryList,
        bufsize: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "New3DS Internet Browser doesn't use this. This overrides the entry0 output buffers originally setup by mvdstdSetupOutputBuffers(). See also here: <https://www.3dbrew.org/wiki/MVDSTD:OverrideOutputBuffers\n> @param cur_outdata0 Linearmem vaddr. The current outdata0 for this entry must match this value.\n @param cur_outdata1 Linearmem vaddr. The current outdata1 for this entry must match this value.\n @param new_outdata0 Linearmem vaddr. This is the new address to use for outaddr0.\n @param new_outdata1 Linearmem vaddr. This is the new address to use for outaddr1."]
    #[doc = ""]
    pub fn mvdstdOverrideOutputBuffers(
        cur_outdata0: *mut ::libc::c_void,
        cur_outdata1: *mut ::libc::c_void,
        new_outdata0: *mut ::libc::c_void,
        new_outdata1: *mut ::libc::c_void,
    ) -> Result;
}
pub const NFC_OpType_1: NFC_OpType = 1;
#[doc = "Unknown."]
#[doc = ""]

pub const NFC_OpType_NFCTag: NFC_OpType = 2;
#[doc = "This is the default."]
#[doc = ""]

pub const NFC_OpType_RawNFC: NFC_OpType = 3;
#[doc = "NFC operation type."]
#[doc = ""]

pub type NFC_OpType = ::libc::c_uint;
pub const NFC_TagState_Uninitialized: NFC_TagState = 0;
#[doc = "nfcInit() was not used yet."]
#[doc = ""]

pub const NFC_TagState_ScanningStopped: NFC_TagState = 1;
#[doc = "Not currently scanning for NFC tags. Set by nfcStopScanning() and nfcInit(), when successful."]
#[doc = ""]

pub const NFC_TagState_Scanning: NFC_TagState = 2;
#[doc = "Currently scanning for NFC tags. Set by nfcStartScanning() when successful."]
#[doc = ""]

pub const NFC_TagState_InRange: NFC_TagState = 3;
#[doc = "NFC tag is in range. The state automatically changes to this when the state was previously value 2, without using any NFC service commands."]
#[doc = ""]

pub const NFC_TagState_OutOfRange: NFC_TagState = 4;
#[doc = "NFC tag is now out of range, where the NFC tag was previously in range. This occurs automatically without using any NFC service commands. Once this state is entered, it won't automatically change to anything else when the tag is moved in range again. Hence, if you want to keep doing tag scanning after this, you must stop+start scanning."]
#[doc = ""]

pub const NFC_TagState_DataReady: NFC_TagState = 5;
pub type NFC_TagState = ::libc::c_uint;
pub const NFC_amiiboFlag_Setup: _bindgen_ty_28 = 16;
#[doc = "This indicates that the amiibo was setup with amiibo Settings. nfcGetAmiiboSettings() will return an all-zero struct when this is not set."]
#[doc = ""]

pub const NFC_amiiboFlag_AppDataSetup: _bindgen_ty_28 = 32;
#[doc = "Bit4-7 are always clear with nfcGetAmiiboSettings() due to \"& 0xF\"."]
#[doc = ""]

pub type _bindgen_ty_28 = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NFC_TagInfo {
    pub id_offset_size: u16_,

    pub unk_x2: u8_,
    pub unk_x3: u8_,
    pub id: [u8_; 40usize],
}
impl Default for NFC_TagInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "AmiiboSettings structure, see also here: <https://3dbrew.org/wiki/NFC:GetAmiiboSettings>"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NFC_AmiiboSettings {
    pub mii: [u8_; 96usize],

    pub nickname: [u16_; 11usize],

    pub flags: u8_,

    pub countrycodeid: u8_,

    pub setupdate_year: u16_,
    pub setupdate_month: u8_,
    pub setupdate_day: u8_,
    pub unk_x7c: [u8_; 44usize],
}
impl Default for NFC_AmiiboSettings {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "AmiiboConfig structure, see also here: <https://3dbrew.org/wiki/NFC:GetAmiiboConfig>"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NFC_AmiiboConfig {
    pub lastwritedate_year: u16_,
    pub lastwritedate_month: u8_,
    pub lastwritedate_day: u8_,
    pub write_counter: u16_,
    pub characterID: [u8_; 3usize],
    #[doc = "the first element is the collection ID, the second the character in this collection, the third the variant"]
    #[doc = ""]
    pub series: u8_,
    #[doc = "ID of the series"]
    #[doc = ""]
    pub amiiboID: u16_,
    #[doc = "ID shared by all exact same amiibo. Some amiibo are only distinguished by this one like regular SMB Series Mario and the gold one"]
    #[doc = ""]
    pub type_: u8_,
    #[doc = "Type of amiibo 0 = figure, 1 = card, 2 = plush"]
    #[doc = ""]
    pub pagex4_byte3: u8_,
    pub appdata_size: u16_,

    pub zeros: [u8_; 48usize],
}
impl Default for NFC_AmiiboConfig {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Used by nfcInitializeWriteAppData() internally, see also here: <https://3dbrew.org/wiki/NFC:GetAppDataInitStruct>"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NFC_AppDataInitStruct {
    pub data_x0: [u8_; 12usize],
    pub data_xc: [u8_; 48usize],
}
impl Default for NFC_AppDataInitStruct {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Used by nfcWriteAppData() internally, see also: <https://3dbrew.org/wiki/NFC:WriteAppData>"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NFC_AppDataWriteStruct {
    pub id: [u8_; 10usize],
    pub id_size: u8_,
    pub unused_xb: [u8_; 21usize],
}
extern "C" {
    #[must_use]
    #[doc = "Initializes NFC.\n @param type See the NFC_OpType enum."]
    #[doc = ""]
    pub fn nfcInit(type_: NFC_OpType) -> Result;
}
extern "C" {
    #[doc = "Shuts down NFC."]
    #[doc = ""]
    pub fn nfcExit();
}
extern "C" {
    #[doc = "Gets the NFC service handle.\n @return The NFC service handle."]
    #[doc = ""]
    pub fn nfcGetSessionHandle() -> Handle;
}
extern "C" {
    #[must_use]
    #[doc = "Starts scanning for NFC tags.\n @param inval Unknown. See NFC_STARTSCAN_DEFAULTINPUT."]
    #[doc = ""]
    pub fn nfcStartScanning(inval: u16_) -> Result;
}
extern "C" {
    #[doc = "Stops scanning for NFC tags."]
    #[doc = ""]
    pub fn nfcStopScanning();
}
extern "C" {
    #[must_use]
    #[doc = "Read amiibo NFC data and load in memory."]
    #[doc = ""]
    pub fn nfcLoadAmiiboData() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "If the tagstate is valid(NFC_TagState_DataReady or 6), it then sets the current tagstate to NFC_TagState_InRange."]
    #[doc = ""]
    pub fn nfcResetTagScanState() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "This writes the amiibo data stored in memory to the actual amiibo data storage(which is normally the NFC data pages). This can only be used if NFC_LoadAmiiboData() was used previously."]
    #[doc = ""]
    pub fn nfcUpdateStoredAmiiboData() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Returns the current NFC tag state.\n @param state Pointer to write NFC tag state."]
    #[doc = ""]
    pub fn nfcGetTagState(state: *mut NFC_TagState) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Returns the current TagInfo.\n @param out Pointer to write the output TagInfo."]
    #[doc = ""]
    pub fn nfcGetTagInfo(out: *mut NFC_TagInfo) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Opens the appdata, when the amiibo appdata was previously initialized. This must be used before reading/writing the appdata. See also: <https://3dbrew.org/wiki/NFC:OpenAppData\n> @param amiibo_appid Amiibo AppID. See here: <https://www.3dbrew.org/wiki/Amiibo>"]
    #[doc = ""]
    pub fn nfcOpenAppData(amiibo_appid: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "This initializes the appdata using the specified input, when the appdata previously wasn't initialized. If the appdata is already initialized, you must first use the amiibo Settings applet menu option labeled \"Delete amiibo Game Data\". This automatically writes the amiibo data into the actual data storage(normally NFC data pages). See also nfcWriteAppData().\n @param amiibo_appid amiibo AppID. See also nfcOpenAppData().\n @param buf Input buffer.\n @param size Buffer size."]
    #[doc = ""]
    pub fn nfcInitializeWriteAppData(
        amiibo_appid: u32_,
        buf: *const ::libc::c_void,
        size: usize,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Reads the appdata. The size must be >=0xD8-bytes, but the actual used size is hard-coded to 0xD8. Note that areas of appdata which were never written to by applications are uninitialized in this output buffer.\n @param buf Output buffer.\n @param size Buffer size."]
    #[doc = ""]
    pub fn nfcReadAppData(buf: *mut ::libc::c_void, size: usize) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Writes the appdata, after nfcOpenAppData() was used successfully. The size should be <=0xD8-bytes. See also: <https://3dbrew.org/wiki/NFC:WriteAppData\n> @param buf Input buffer.\n @param size Buffer size.\n @param taginfo TagInfo from nfcGetTagInfo()."]
    #[doc = ""]
    pub fn nfcWriteAppData(
        buf: *const ::libc::c_void,
        size: usize,
        taginfo: *mut NFC_TagInfo,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Returns the current AmiiboSettings.\n @param out Pointer to write the output AmiiboSettings."]
    #[doc = ""]
    pub fn nfcGetAmiiboSettings(out: *mut NFC_AmiiboSettings) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Returns the current AmiiboConfig.\n @param out Pointer to write the output AmiiboConfig."]
    #[doc = ""]
    pub fn nfcGetAmiiboConfig(out: *mut NFC_AmiiboConfig) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Starts scanning for NFC tags when initialized with NFC_OpType_RawNFC. See also: <https://www.3dbrew.org/wiki/NFC:StartOtherTagScanning\n> @param unk0 Same as nfcStartScanning() input.\n @param unk1 Unknown."]
    #[doc = ""]
    pub fn nfcStartOtherTagScanning(unk0: u16_, unk1: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "This sends a raw NFC command to the tag. This can only be used when initialized with NFC_OpType_RawNFC, and when the TagState is NFC_TagState_InRange. See also: <https://www.3dbrew.org/wiki/NFC:SendTagCommand\n> @param inbuf Input buffer.\n @param insize Size of the input buffer.\n @param outbuf Output buffer.\n @param outsize Size of the output buffer.\n @param actual_transfer_size Optional output ptr to write the actual output-size to, can be NULL.\n @param microseconds Timing-related field in microseconds."]
    #[doc = ""]
    pub fn nfcSendTagCommand(
        inbuf: *const ::libc::c_void,
        insize: usize,
        outbuf: *mut ::libc::c_void,
        outsize: usize,
        actual_transfer_size: *mut usize,
        microseconds: u64_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Unknown. This can only be used when initialized with NFC_OpType_RawNFC, and when the TagState is NFC_TagState_InRange."]
    #[doc = ""]
    pub fn nfcCmd21() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Unknown. This can only be used when initialized with NFC_OpType_RawNFC, and when the TagState is NFC_TagState_InRange."]
    #[doc = ""]
    pub fn nfcCmd22() -> Result;
}
#[doc = "Notification header data."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NotificationHeader {
    pub dataSet: bool,
    pub unread: bool,
    pub enableJPEG: bool,
    pub isSpotPass: bool,
    pub isOptedOut: bool,
    pub unkData: [u8_; 3usize],
    pub processID: u64_,
    pub unkData2: [u8_; 8usize],
    pub jumpParam: u64_,
    pub unkData3: [u8_; 8usize],
    pub time: u64_,
    pub title: [u16_; 32usize],
}
extern "C" {
    #[must_use]
    #[doc = "Initializes NEWS."]
    #[doc = ""]
    pub fn newsInit() -> Result;
}
extern "C" {
    #[doc = "Exits NEWS."]
    #[doc = ""]
    pub fn newsExit();
}
extern "C" {
    #[must_use]
    #[doc = "Adds a notification to the home menu Notifications applet.\n @param title UTF-16 title of the notification.\n @param titleLength Number of characters in the title, not including the null-terminator.\n @param message UTF-16 message of the notification, or NULL for no message.\n @param messageLength Number of characters in the message, not including the null-terminator.\n @param image Data of the image to show in the notification, or NULL for no image.\n @param imageSize Size of the image data in bytes.\n @param jpeg Whether the image is a JPEG or not."]
    #[doc = ""]
    pub fn NEWS_AddNotification(
        title: *const u16_,
        titleLength: u32_,
        message: *const u16_,
        messageLength: u32_,
        imageData: *const ::libc::c_void,
        imageSize: u32_,
        jpeg: bool,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets current total notifications number.\n @param num Pointer where total number will be saved."]
    #[doc = ""]
    pub fn NEWS_GetTotalNotifications(num: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets a custom header for a specific notification.\n @param news_id Identification number of the notification.\n @param header Pointer to notification header to set."]
    #[doc = ""]
    pub fn NEWS_SetNotificationHeader(news_id: u32_, header: *const NotificationHeader) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the header of a specific notification.\n @param news_id Identification number of the notification.\n @param header Pointer where header of the notification will be saved."]
    #[doc = ""]
    pub fn NEWS_GetNotificationHeader(news_id: u32_, header: *mut NotificationHeader) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets a custom message for a specific notification.\n @param news_id Identification number of the notification.\n @param message Pointer to UTF-16 message to set.\n @param size Size of message to set."]
    #[doc = ""]
    pub fn NEWS_SetNotificationMessage(news_id: u32_, message: *const u16_, size: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the message of a specific notification.\n @param news_id Identification number of the notification.\n @param message Pointer where UTF-16 message of the notification will be saved.\n @param size Pointer where size of the message data will be saved in bytes."]
    #[doc = ""]
    pub fn NEWS_GetNotificationMessage(
        news_id: u32_,
        message: *mut u16_,
        size: *mut u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets a custom image for a specific notification.\n @param news_id Identification number of the notification.\n @param buffer Pointer to MPO image to set.\n @param size Size of the MPO image to set."]
    #[doc = ""]
    pub fn NEWS_SetNotificationImage(
        news_id: u32_,
        buffer: *const ::libc::c_void,
        size: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the image of a specific notification.\n @param news_id Identification number of the notification.\n @param buffer Pointer where MPO image of the notification will be saved.\n @param size Pointer where size of the image data will be saved in bytes."]
    #[doc = ""]
    pub fn NEWS_GetNotificationImage(
        news_id: u32_,
        buffer: *mut ::libc::c_void,
        size: *mut u32_,
    ) -> Result;
}
#[doc = "Head tracking coordinate pair."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct QTM_HeadTrackingInfoCoord {
    #[doc = "X coordinate."]
    #[doc = ""]
    pub x: f32,
    #[doc = "Y coordinate."]
    #[doc = ""]
    pub y: f32,
}
#[doc = "Head tracking info."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct QTM_HeadTrackingInfo {
    #[doc = "Flags."]
    #[doc = ""]
    pub flags: [u8_; 5usize],
    #[doc = "Padding."]
    #[doc = ""]
    pub padding: [u8_; 3usize],
    #[doc = "Unknown. Not used by System_Settings."]
    #[doc = ""]
    pub floatdata_x08: f32,
    #[doc = "Head coordinates."]
    #[doc = ""]
    pub coords0: [QTM_HeadTrackingInfoCoord; 4usize],
    #[doc = "Unknown. Not used by System_Settings."]
    #[doc = ""]
    pub unk_x2c: [u32_; 5usize],
}
extern "C" {
    #[must_use]
    #[doc = "Initializes QTM."]
    #[doc = ""]
    pub fn qtmInit() -> Result;
}
extern "C" {
    #[doc = "Exits QTM."]
    #[doc = ""]
    pub fn qtmExit();
}
extern "C" {
    #[doc = "Checks whether QTM is initialized.\n @return Whether QTM is initialized."]
    #[doc = ""]
    pub fn qtmCheckInitialized() -> bool;
}
extern "C" {
    #[doc = "Checks whether a head is fully detected.\n @param info Tracking info to check."]
    #[doc = ""]
    pub fn qtmCheckHeadFullyDetected(info: *mut QTM_HeadTrackingInfo) -> bool;
}
extern "C" {
    #[must_use]
    #[doc = "Converts QTM coordinates to screen coordinates.\n @param coord Coordinates to convert.\n @param screen_width Width of the screen. Can be NULL to use the default value for the top screen.\n @param screen_height Height of the screen. Can be NULL to use the default value for the top screen.\n @param x Pointer to output the screen X coordinate to.\n @param y Pointer to output the screen Y coordinate to."]
    #[doc = ""]
    pub fn qtmConvertCoordToScreen(
        coord: *mut QTM_HeadTrackingInfoCoord,
        screen_width: *mut f32,
        screen_height: *mut f32,
        x: *mut u32_,
        y: *mut u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the current head tracking info.\n @param val Normally 0.\n @param out Pointer to write head tracking info to."]
    #[doc = ""]
    pub fn QTM_GetHeadTrackingInfo(val: u64_, out: *mut QTM_HeadTrackingInfo) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initializes srv:pm and the service API."]
    #[doc = ""]
    pub fn srvPmInit() -> Result;
}
extern "C" {
    #[doc = "Exits srv:pm and the service API."]
    #[doc = ""]
    pub fn srvPmExit();
}
extern "C" {
    #[doc = "Gets the current srv:pm session handle.\n @return The current srv:pm session handle."]
    #[doc = ""]
    pub fn srvPmGetSessionHandle() -> *mut Handle;
}
extern "C" {
    #[must_use]
    #[doc = "Publishes a notification to a process.\n @param notificationId ID of the notification.\n @param process Process to publish to."]
    #[doc = ""]
    pub fn SRVPM_PublishToProcess(notificationId: u32_, process: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Publishes a notification to all processes.\n @param notificationId ID of the notification."]
    #[doc = ""]
    pub fn SRVPM_PublishToAll(notificationId: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Registers a process with SRV.\n @param pid ID of the process.\n @param count Number of services within the service access control data.\n @param serviceAccessControlList Service Access Control list."]
    #[doc = ""]
    pub fn SRVPM_RegisterProcess(
        pid: u32_,
        count: u32_,
        serviceAccessControlList: *const [::libc::c_char; 8usize],
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Unregisters a process with SRV.\n @param pid ID of the process."]
    #[doc = ""]
    pub fn SRVPM_UnregisterProcess(pid: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initializes LOADER."]
    #[doc = ""]
    pub fn loaderInit() -> Result;
}
extern "C" {
    #[doc = "Exits LOADER."]
    #[doc = ""]
    pub fn loaderExit();
}
extern "C" {
    #[must_use]
    #[doc = "Loads a program and returns a process handle to the newly created process.\n @param[out] process Pointer to output the process handle to.\n @param programHandle The handle of the program to load."]
    #[doc = ""]
    pub fn LOADER_LoadProcess(process: *mut Handle, programHandle: u64_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Registers a program (along with its update).\n @param[out] programHandle Pointer to output the program handle to.\n @param programInfo The program info.\n @param programInfo The program update info."]
    #[doc = ""]
    pub fn LOADER_RegisterProgram(
        programHandle: *mut u64_,
        programInfo: *const FS_ProgramInfo,
        programInfoUpdate: *const FS_ProgramInfo,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Unregisters a program (along with its update).\n @param programHandle The handle of the program to unregister."]
    #[doc = ""]
    pub fn LOADER_UnregisterProgram(programHandle: u64_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Retrives a program's main NCCH extended header info (SCI + ACI, see [`ExHeader_Info).\n`] @param[out] exheaderInfo Pointer to output the main NCCH extended header info.\n @param programHandle The handle of the program to unregister"]
    #[doc = ""]
    pub fn LOADER_GetProgramInfo(exheaderInfo: *mut ExHeader_Info, programHandle: u64_) -> Result;
}
#[doc = "The normal mode of the led"]
#[doc = ""]

pub const LED_NORMAL: powerLedState = 1;
#[doc = "The led pulses slowly as it does in the sleep mode"]
#[doc = ""]

pub const LED_SLEEP_MODE: powerLedState = 2;
#[doc = "Switch off power led"]
#[doc = ""]

pub const LED_OFF: powerLedState = 3;
#[doc = "Red state of the led"]
#[doc = ""]

pub const LED_RED: powerLedState = 4;
#[doc = "Blue state of the led"]
#[doc = ""]

pub const LED_BLUE: powerLedState = 5;
#[doc = "Blinking red state of power led and notification led"]
#[doc = ""]

pub const LED_BLINK_RED: powerLedState = 6;
pub type powerLedState = ::libc::c_uint;
extern "C" {
    #[must_use]
    #[doc = "Initializes mcuHwc."]
    #[doc = ""]
    pub fn mcuHwcInit() -> Result;
}
extern "C" {
    #[doc = "Exits mcuHwc."]
    #[doc = ""]
    pub fn mcuHwcExit();
}
extern "C" {
    #[doc = "Gets the current mcuHwc session handle.\n @return A pointer to the current mcuHwc session handle."]
    #[doc = ""]
    pub fn mcuHwcGetSessionHandle() -> *mut Handle;
}
extern "C" {
    #[must_use]
    #[doc = "Reads data from an i2c device3 register\n @param reg Register number. See <https://www.3dbrew.org/wiki/I2C_Registers#Device_3> for more info\n @param data Pointer to write the data to.\n @param size Size of data to be read"]
    #[doc = ""]
    pub fn MCUHWC_ReadRegister(reg: u8_, data: *mut ::libc::c_void, size: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Writes data to a i2c device3 register\n @param reg Register number. See <https://www.3dbrew.org/wiki/I2C_Registers#Device_3> for more info\n @param data Pointer to write the data to.\n @param size Size of data to be written"]
    #[doc = ""]
    pub fn MCUHWC_WriteRegister(reg: u8_, data: *const ::libc::c_void, size: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the battery voltage\n @param voltage Pointer to write the battery voltage to."]
    #[doc = ""]
    pub fn MCUHWC_GetBatteryVoltage(voltage: *mut u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the battery level\n @param level Pointer to write the current battery level to."]
    #[doc = ""]
    pub fn MCUHWC_GetBatteryLevel(level: *mut u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the sound slider level\n @param level Pointer to write the slider level to."]
    #[doc = ""]
    pub fn MCUHWC_GetSoundSliderLevel(level: *mut u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets Wifi LED state\n @param state State of Wifi LED. (True/False)"]
    #[doc = ""]
    pub fn MCUHWC_SetWifiLedState(state: bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets Power LED state\n @param state powerLedState State of power LED."]
    #[doc = ""]
    pub fn MCUHWC_SetPowerLedState(state: powerLedState) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets 3d slider level\n @param level Pointer to write 3D slider level to."]
    #[doc = ""]
    pub fn MCUHWC_Get3dSliderLevel(level: *mut u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the major MCU firmware version\n @param out Pointer to write the major firmware version to."]
    #[doc = ""]
    pub fn MCUHWC_GetFwVerHigh(out: *mut u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the minor MCU firmware version\n @param out Pointer to write the minor firmware version to."]
    #[doc = ""]
    pub fn MCUHWC_GetFwVerLow(out: *mut u8_) -> Result;
}
#[doc = "Primary I2S line, used by DSP/Mic (configurable)/GBA sound controller."]
#[doc = ""]

pub const CODEC_I2S_LINE_1: CodecI2sLine = 0;
#[doc = "Secondary I2S line, used by CSND hardware."]
#[doc = ""]

pub const CODEC_I2S_LINE_2: CodecI2sLine = 1;
#[doc = "I2S line enumeration"]
#[doc = ""]

pub type CodecI2sLine = ::libc::c_uint;
extern "C" {
    #[must_use]
    #[doc = "Initializes CDCCHK."]
    #[doc = ""]
    pub fn cdcChkInit() -> Result;
}
extern "C" {
    #[doc = "Exits CDCCHK."]
    #[doc = ""]
    pub fn cdcChkExit();
}
extern "C" {
    #[doc = "Gets a pointer to the current cdc:CHK session handle.\n @return A pointer to the current cdc:CHK session handle."]
    #[doc = ""]
    pub fn cdcChkGetSessionHandle() -> *mut Handle;
}
extern "C" {
    #[must_use]
    #[doc = "Reads multiple registers from the CODEC, using the old\n SPI hardware interface and a 4MHz baudrate.\n @param pageId CODEC Page ID.\n @param initialRegAddr Address of the CODEC register to start with.\n @param[out] outData Where to write the read data to.\n @param size Number of registers to read (bytes to read, max. 64)."]
    #[doc = ""]
    pub fn CDCCHK_ReadRegisters1(
        pageId: u8_,
        initialRegAddr: u8_,
        outData: *mut ::libc::c_void,
        size: usize,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Reads multiple registers from the CODEC, using the new\n SPI hardware interface and a 16MHz baudrate.\n @param pageId CODEC Page ID.\n @param initialRegAddr Address of the CODEC register to start with.\n @param[out] outData Where to read the data to.\n @param size Number of registers to read (bytes to read, max. 64)."]
    #[doc = ""]
    pub fn CDCCHK_ReadRegisters2(
        pageId: u8_,
        initialRegAddr: u8_,
        outData: *mut ::libc::c_void,
        size: usize,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Writes multiple registers to the CODEC, using the old\n SPI hardware interface and a 4MHz baudrate.\n @param pageId CODEC Page ID.\n @param initialRegAddr Address of the CODEC register to start with.\n @param data Where to read the data to write from.\n @param size Number of registers to write (bytes to read, max. 64)."]
    #[doc = ""]
    pub fn CDCCHK_WriteRegisters1(
        pageId: u8_,
        initialRegAddr: u8_,
        data: *const ::libc::c_void,
        size: usize,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Writes multiple registers to the CODEC, using the new\n SPI hardware interface and a 16MHz baudrate.\n @param pageId CODEC Page ID.\n @param initialRegAddr Address of the CODEC register to start with.\n @param data Where to read the data to write from.\n @param size Number of registers to write (bytes to read, max. 64)."]
    #[doc = ""]
    pub fn CDCCHK_WriteRegisters2(
        pageId: u8_,
        initialRegAddr: u8_,
        data: *const ::libc::c_void,
        size: usize,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Reads a single register from the NTR PMIC.\n @param[out] outData Where to read the data to (1 byte).\n @param regAddr Register address.\n @note The NTR PMIC is emulated by the CODEC hardware and sends\n IRQs to the MCU when relevant."]
    #[doc = ""]
    pub fn CDCCHK_ReadNtrPmicRegister(outData: *mut u8_, regAddr: u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Writes a single register from the NTR PMIC.\n @param regAddr Register address.\n @param data Data to write (1 byte).\n @note The NTR PMIC is emulated by the CODEC hardware and sends\n IRQs to the MCU when relevant."]
    #[doc = ""]
    pub fn CDCCHK_WriteNtrPmicRegister(regAddr: u8_, data: u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the DAC volume level for the specified I2S line.\n @param i2sLine I2S line to set the volume for.\n @param volume Volume level (-128 to 0)."]
    #[doc = ""]
    pub fn CDCCHK_SetI2sVolume(i2sLine: CodecI2sLine, volume: s8) -> Result;
}
#[doc = "8-bit Red + 8-bit Green + 8-bit Blue + 8-bit Alpha"]
#[doc = ""]

pub const GX_TRANSFER_FMT_RGBA8: GX_TRANSFER_FORMAT = 0;
#[doc = "8-bit Red + 8-bit Green + 8-bit Blue"]
#[doc = ""]

pub const GX_TRANSFER_FMT_RGB8: GX_TRANSFER_FORMAT = 1;
#[doc = "5-bit Red + 6-bit Green + 5-bit Blue"]
#[doc = ""]

pub const GX_TRANSFER_FMT_RGB565: GX_TRANSFER_FORMAT = 2;
#[doc = "5-bit Red + 5-bit Green + 5-bit Blue + 1-bit Alpha"]
#[doc = ""]

pub const GX_TRANSFER_FMT_RGB5A1: GX_TRANSFER_FORMAT = 3;
#[doc = "4-bit Red + 4-bit Green + 4-bit Blue + 4-bit Alpha"]
#[doc = ""]

pub const GX_TRANSFER_FMT_RGBA4: GX_TRANSFER_FORMAT = 4;
#[doc = "Supported transfer pixel formats.\n [`GSPGPU_FramebufferFormat`]"]
#[doc = ""]

pub type GX_TRANSFER_FORMAT = ::libc::c_uint;
#[doc = "No anti-aliasing"]
#[doc = ""]

pub const GX_TRANSFER_SCALE_NO: GX_TRANSFER_SCALE = 0;
#[doc = "2x1 anti-aliasing"]
#[doc = ""]

pub const GX_TRANSFER_SCALE_X: GX_TRANSFER_SCALE = 1;
#[doc = "2x2 anti-aliasing"]
#[doc = ""]

pub const GX_TRANSFER_SCALE_XY: GX_TRANSFER_SCALE = 2;
#[doc = "Anti-aliasing modes\n\n Please remember that the framebuffer is sideways.\n Hence if you activate 2x1 anti-aliasing the destination dimensions are w = 240*2 and h = 400"]
#[doc = ""]

pub type GX_TRANSFER_SCALE = ::libc::c_uint;
#[doc = "Trigger the PPF event"]
#[doc = ""]

pub const GX_FILL_TRIGGER: GX_FILL_CONTROL = 1;
#[doc = "Indicates if the memory fill is complete. You should not use it when requesting a transfer."]
#[doc = ""]

pub const GX_FILL_FINISHED: GX_FILL_CONTROL = 2;
#[doc = "The buffer has a 16 bit per pixel depth"]
#[doc = ""]

pub const GX_FILL_16BIT_DEPTH: GX_FILL_CONTROL = 0;
#[doc = "The buffer has a 24 bit per pixel depth"]
#[doc = ""]

pub const GX_FILL_24BIT_DEPTH: GX_FILL_CONTROL = 256;
#[doc = "The buffer has a 32 bit per pixel depth"]
#[doc = ""]

pub const GX_FILL_32BIT_DEPTH: GX_FILL_CONTROL = 512;
#[doc = "GX transfer control flags"]
#[doc = ""]

pub type GX_FILL_CONTROL = ::libc::c_uint;
#[doc = "GX command entry"]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub union gxCmdEntry_s {
    #[doc = "Raw command data"]
    #[doc = ""]
    pub data: [u32_; 8usize],
    pub __bindgen_anon_1: gxCmdEntry_s__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct gxCmdEntry_s__bindgen_ty_1 {
    #[doc = "Command type"]
    #[doc = ""]
    pub type_: u8_,
    pub unk1: u8_,
    pub unk2: u8_,
    pub unk3: u8_,
    #[doc = "Command arguments"]
    #[doc = ""]
    pub args: [u32_; 7usize],
}
impl Default for gxCmdEntry_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "GX command queue structure"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tag_gxCmdQueue_s {
    #[doc = "Pointer to array of GX command entries"]
    #[doc = ""]
    pub entries: *mut gxCmdEntry_s,
    #[doc = "Capacity of the command array"]
    #[doc = ""]
    pub maxEntries: u16_,
    #[doc = "Number of commands in the queue"]
    #[doc = ""]
    pub numEntries: u16_,
    #[doc = "Index of the first pending command to be submitted to GX"]
    #[doc = ""]
    pub curEntry: u16_,
    #[doc = "Number of commands completed by GX"]
    #[doc = ""]
    pub lastEntry: u16_,
    #[doc = "User callback"]
    #[doc = ""]
    pub callback: ::core::option::Option<unsafe extern "C" fn(arg1: *mut tag_gxCmdQueue_s)>,
    #[doc = "Data for user callback"]
    #[doc = ""]
    pub user: *mut ::libc::c_void,
}
impl Default for tag_gxCmdQueue_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "GX command queue structure"]
#[doc = ""]

pub type gxCmdQueue_s = tag_gxCmdQueue_s;
extern "C" {
    #[doc = "Clears a GX command queue.\n @param queue The GX command queue."]
    #[doc = ""]
    pub fn gxCmdQueueClear(queue: *mut gxCmdQueue_s);
}
extern "C" {
    #[doc = "Adds a command to a GX command queue.\n @param queue The GX command queue.\n @param entry The GX command to add."]
    #[doc = ""]
    pub fn gxCmdQueueAdd(queue: *mut gxCmdQueue_s, entry: *const gxCmdEntry_s);
}
extern "C" {
    #[doc = "Runs a GX command queue, causing it to begin processing incoming commands as they arrive.\n @param queue The GX command queue."]
    #[doc = ""]
    pub fn gxCmdQueueRun(queue: *mut gxCmdQueue_s);
}
extern "C" {
    #[doc = "Stops a GX command queue from processing incoming commands.\n @param queue The GX command queue."]
    #[doc = ""]
    pub fn gxCmdQueueStop(queue: *mut gxCmdQueue_s);
}
extern "C" {
    #[doc = "Waits for a GX command queue to finish executing pending commands.\n @param queue The GX command queue.\n @param timeout Optional timeout (in nanoseconds) to wait (specify -1 for no timeout).\n @return false if timeout expired, true otherwise."]
    #[doc = ""]
    pub fn gxCmdQueueWait(queue: *mut gxCmdQueue_s, timeout: s64) -> bool;
}
extern "C" {
    #[doc = "Selects a command queue to which GX_* functions will add commands instead of immediately submitting them to GX.\n @param queue The GX command queue. (Pass NULL to remove the bound command queue)"]
    #[doc = ""]
    pub fn GX_BindQueue(queue: *mut gxCmdQueue_s);
}
extern "C" {
    #[must_use]
    #[doc = "Requests a DMA.\n @param src Source to DMA from.\n @param dst Destination to DMA to.\n @param length Length of data to transfer."]
    #[doc = ""]
    pub fn GX_RequestDma(src: *mut u32_, dst: *mut u32_, length: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Processes a GPU command list.\n @param buf0a Command list address.\n @param buf0s Command list size.\n @param flags Flags to process with."]
    #[doc = ""]
    pub fn GX_ProcessCommandList(buf0a: *mut u32_, buf0s: u32_, flags: u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Fills the memory of two buffers with the given values.\n @param buf0a Start address of the first buffer.\n @param buf0v Dimensions of the first buffer.\n @param buf0e End address of the first buffer.\n @param control0 Value to fill the first buffer with.\n @param buf1a Start address of the second buffer.\n @param buf1v Dimensions of the second buffer.\n @param buf1e End address of the second buffer.\n @param control1 Value to fill the second buffer with."]
    #[doc = ""]
    pub fn GX_MemoryFill(
        buf0a: *mut u32_,
        buf0v: u32_,
        buf0e: *mut u32_,
        control0: u16_,
        buf1a: *mut u32_,
        buf1v: u32_,
        buf1e: *mut u32_,
        control1: u16_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initiates a display transfer.\n @note The PPF event will be signaled on completion.\n @param inadr Address of the input.\n @param indim Dimensions of the input.\n @param outadr Address of the output.\n @param outdim Dimensions of the output.\n @param flags Flags to transfer with."]
    #[doc = ""]
    pub fn GX_DisplayTransfer(
        inadr: *mut u32_,
        indim: u32_,
        outadr: *mut u32_,
        outdim: u32_,
        flags: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initiates a texture copy.\n @note The PPF event will be signaled on completion.\n @param inadr Address of the input.\n @param indim Dimensions of the input.\n @param outadr Address of the output.\n @param outdim Dimensions of the output.\n @param size Size of the data to transfer.\n @param flags Flags to transfer with."]
    #[doc = ""]
    pub fn GX_TextureCopy(
        inadr: *mut u32_,
        indim: u32_,
        outadr: *mut u32_,
        outdim: u32_,
        size: u32_,
        flags: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Flushes the cache regions of three buffers. (This command cannot be queued in a GX command queue)\n @param buf0a Address of the first buffer.\n @param buf0s Size of the first buffer.\n @param buf1a Address of the second buffer.\n @param buf1s Size of the second buffer.\n @param buf2a Address of the third buffer.\n @param buf2s Size of the third buffer."]
    #[doc = ""]
    pub fn GX_FlushCacheRegions(
        buf0a: *mut u32_,
        buf0s: u32_,
        buf1a: *mut u32_,
        buf1s: u32_,
        buf2a: *mut u32_,
        buf2s: u32_,
    ) -> Result;
}
#[doc = "Nearest-neighbor interpolation."]
#[doc = ""]

pub const GPU_NEAREST: GPU_TEXTURE_FILTER_PARAM = 0;
#[doc = "Linear interpolation."]
#[doc = ""]

pub const GPU_LINEAR: GPU_TEXTURE_FILTER_PARAM = 1;
#[doc = "Texture filters."]
#[doc = ""]

pub type GPU_TEXTURE_FILTER_PARAM = ::libc::c_uint;
#[doc = "Clamps to edge."]
#[doc = ""]

pub const GPU_CLAMP_TO_EDGE: GPU_TEXTURE_WRAP_PARAM = 0;
#[doc = "Clamps to border."]
#[doc = ""]

pub const GPU_CLAMP_TO_BORDER: GPU_TEXTURE_WRAP_PARAM = 1;
#[doc = "Repeats texture."]
#[doc = ""]

pub const GPU_REPEAT: GPU_TEXTURE_WRAP_PARAM = 2;
#[doc = "Repeats with mirrored texture."]
#[doc = ""]

pub const GPU_MIRRORED_REPEAT: GPU_TEXTURE_WRAP_PARAM = 3;
#[doc = "Texture wrap modes."]
#[doc = ""]

pub type GPU_TEXTURE_WRAP_PARAM = ::libc::c_uint;
#[doc = "2D texture"]
#[doc = ""]

pub const GPU_TEX_2D: GPU_TEXTURE_MODE_PARAM = 0;
#[doc = "Cube map"]
#[doc = ""]

pub const GPU_TEX_CUBE_MAP: GPU_TEXTURE_MODE_PARAM = 1;
#[doc = "2D Shadow texture"]
#[doc = ""]

pub const GPU_TEX_SHADOW_2D: GPU_TEXTURE_MODE_PARAM = 2;
#[doc = "Projection texture"]
#[doc = ""]

pub const GPU_TEX_PROJECTION: GPU_TEXTURE_MODE_PARAM = 3;
#[doc = "Shadow cube map"]
#[doc = ""]

pub const GPU_TEX_SHADOW_CUBE: GPU_TEXTURE_MODE_PARAM = 4;
#[doc = "Disabled"]
#[doc = ""]

pub const GPU_TEX_DISABLED: GPU_TEXTURE_MODE_PARAM = 5;
#[doc = "Texture modes."]
#[doc = ""]

pub type GPU_TEXTURE_MODE_PARAM = ::libc::c_uint;
#[doc = "Texture unit 0."]
#[doc = ""]

pub const GPU_TEXUNIT0: GPU_TEXUNIT = 1;
#[doc = "Texture unit 1."]
#[doc = ""]

pub const GPU_TEXUNIT1: GPU_TEXUNIT = 2;
#[doc = "Texture unit 2."]
#[doc = ""]

pub const GPU_TEXUNIT2: GPU_TEXUNIT = 4;
#[doc = "Supported texture units."]
#[doc = ""]

pub type GPU_TEXUNIT = ::libc::c_uint;
#[doc = "8-bit Red + 8-bit Green + 8-bit Blue + 8-bit Alpha"]
#[doc = ""]

pub const GPU_RGBA8: GPU_TEXCOLOR = 0;
#[doc = "8-bit Red + 8-bit Green + 8-bit Blue"]
#[doc = ""]

pub const GPU_RGB8: GPU_TEXCOLOR = 1;
#[doc = "5-bit Red + 5-bit Green + 5-bit Blue + 1-bit Alpha"]
#[doc = ""]

pub const GPU_RGBA5551: GPU_TEXCOLOR = 2;
#[doc = "5-bit Red + 6-bit Green + 5-bit Blue"]
#[doc = ""]

pub const GPU_RGB565: GPU_TEXCOLOR = 3;
#[doc = "4-bit Red + 4-bit Green + 4-bit Blue + 4-bit Alpha"]
#[doc = ""]

pub const GPU_RGBA4: GPU_TEXCOLOR = 4;
#[doc = "8-bit Luminance + 8-bit Alpha"]
#[doc = ""]

pub const GPU_LA8: GPU_TEXCOLOR = 5;
#[doc = "8-bit Hi + 8-bit Lo"]
#[doc = ""]

pub const GPU_HILO8: GPU_TEXCOLOR = 6;
#[doc = "8-bit Luminance"]
#[doc = ""]

pub const GPU_L8: GPU_TEXCOLOR = 7;
#[doc = "8-bit Alpha"]
#[doc = ""]

pub const GPU_A8: GPU_TEXCOLOR = 8;
#[doc = "4-bit Luminance + 4-bit Alpha"]
#[doc = ""]

pub const GPU_LA4: GPU_TEXCOLOR = 9;
#[doc = "4-bit Luminance"]
#[doc = ""]

pub const GPU_L4: GPU_TEXCOLOR = 10;
#[doc = "4-bit Alpha"]
#[doc = ""]

pub const GPU_A4: GPU_TEXCOLOR = 11;
#[doc = "ETC1 texture compression"]
#[doc = ""]

pub const GPU_ETC1: GPU_TEXCOLOR = 12;
#[doc = "ETC1 texture compression + 4-bit Alpha"]
#[doc = ""]

pub const GPU_ETC1A4: GPU_TEXCOLOR = 13;
#[doc = "Supported texture formats."]
#[doc = ""]

pub type GPU_TEXCOLOR = ::libc::c_uint;
#[doc = "2D face"]
#[doc = ""]

pub const GPU_TEXFACE_2D: GPU_TEXFACE = 0;
#[doc = "+X face"]
#[doc = ""]

pub const GPU_POSITIVE_X: GPU_TEXFACE = 0;
#[doc = "-X face"]
#[doc = ""]

pub const GPU_NEGATIVE_X: GPU_TEXFACE = 1;
#[doc = "+Y face"]
#[doc = ""]

pub const GPU_POSITIVE_Y: GPU_TEXFACE = 2;
#[doc = "-Y face"]
#[doc = ""]

pub const GPU_NEGATIVE_Y: GPU_TEXFACE = 3;
#[doc = "+Z face"]
#[doc = ""]

pub const GPU_POSITIVE_Z: GPU_TEXFACE = 4;
#[doc = "-Z face"]
#[doc = ""]

pub const GPU_NEGATIVE_Z: GPU_TEXFACE = 5;
#[doc = "Texture faces."]
#[doc = ""]

pub type GPU_TEXFACE = ::libc::c_uint;
#[doc = "Clamp to zero."]
#[doc = ""]

pub const GPU_PT_CLAMP_TO_ZERO: GPU_PROCTEX_CLAMP = 0;
#[doc = "Clamp to edge."]
#[doc = ""]

pub const GPU_PT_CLAMP_TO_EDGE: GPU_PROCTEX_CLAMP = 1;
#[doc = "Symmetrical repeat."]
#[doc = ""]

pub const GPU_PT_REPEAT: GPU_PROCTEX_CLAMP = 2;
#[doc = "Mirrored repeat."]
#[doc = ""]

pub const GPU_PT_MIRRORED_REPEAT: GPU_PROCTEX_CLAMP = 3;
#[doc = "Pulse."]
#[doc = ""]

pub const GPU_PT_PULSE: GPU_PROCTEX_CLAMP = 4;
#[doc = "Procedural texture clamp modes."]
#[doc = ""]

pub type GPU_PROCTEX_CLAMP = ::libc::c_uint;
#[doc = "U"]
#[doc = ""]

pub const GPU_PT_U: GPU_PROCTEX_MAPFUNC = 0;
#[doc = "U2"]
#[doc = ""]

pub const GPU_PT_U2: GPU_PROCTEX_MAPFUNC = 1;
#[doc = "V"]
#[doc = ""]

pub const GPU_PT_V: GPU_PROCTEX_MAPFUNC = 2;
#[doc = "V2"]
#[doc = ""]

pub const GPU_PT_V2: GPU_PROCTEX_MAPFUNC = 3;
#[doc = "U+V"]
#[doc = ""]

pub const GPU_PT_ADD: GPU_PROCTEX_MAPFUNC = 4;
#[doc = "U2+V2"]
#[doc = ""]

pub const GPU_PT_ADD2: GPU_PROCTEX_MAPFUNC = 5;
#[doc = "sqrt(U2+V2)"]
#[doc = ""]

pub const GPU_PT_SQRT2: GPU_PROCTEX_MAPFUNC = 6;
#[doc = "min"]
#[doc = ""]

pub const GPU_PT_MIN: GPU_PROCTEX_MAPFUNC = 7;
#[doc = "max"]
#[doc = ""]

pub const GPU_PT_MAX: GPU_PROCTEX_MAPFUNC = 8;
#[doc = "rmax"]
#[doc = ""]

pub const GPU_PT_RMAX: GPU_PROCTEX_MAPFUNC = 9;
#[doc = "Procedural texture mapping functions."]
#[doc = ""]

pub type GPU_PROCTEX_MAPFUNC = ::libc::c_uint;
#[doc = "No shift."]
#[doc = ""]

pub const GPU_PT_NONE: GPU_PROCTEX_SHIFT = 0;
#[doc = "Odd shift."]
#[doc = ""]

pub const GPU_PT_ODD: GPU_PROCTEX_SHIFT = 1;
#[doc = "Even shift."]
#[doc = ""]

pub const GPU_PT_EVEN: GPU_PROCTEX_SHIFT = 2;
#[doc = "Procedural texture shift values."]
#[doc = ""]

pub type GPU_PROCTEX_SHIFT = ::libc::c_uint;
#[doc = "Nearest-neighbor"]
#[doc = ""]

pub const GPU_PT_NEAREST: GPU_PROCTEX_FILTER = 0;
#[doc = "Linear interpolation"]
#[doc = ""]

pub const GPU_PT_LINEAR: GPU_PROCTEX_FILTER = 1;
#[doc = "Nearest-neighbor with mipmap using nearest-neighbor"]
#[doc = ""]

pub const GPU_PT_NEAREST_MIP_NEAREST: GPU_PROCTEX_FILTER = 2;
#[doc = "Linear interpolation with mipmap using nearest-neighbor"]
#[doc = ""]

pub const GPU_PT_LINEAR_MIP_NEAREST: GPU_PROCTEX_FILTER = 3;
#[doc = "Nearest-neighbor with mipmap using linear interpolation"]
#[doc = ""]

pub const GPU_PT_NEAREST_MIP_LINEAR: GPU_PROCTEX_FILTER = 4;
#[doc = "Linear interpolation with mipmap using linear interpolation"]
#[doc = ""]

pub const GPU_PT_LINEAR_MIP_LINEAR: GPU_PROCTEX_FILTER = 5;
#[doc = "Procedural texture filter values."]
#[doc = ""]

pub type GPU_PROCTEX_FILTER = ::libc::c_uint;
#[doc = "Noise table"]
#[doc = ""]

pub const GPU_LUT_NOISE: GPU_PROCTEX_LUTID = 0;
#[doc = "RGB mapping function table"]
#[doc = ""]

pub const GPU_LUT_RGBMAP: GPU_PROCTEX_LUTID = 2;
#[doc = "Alpha mapping function table"]
#[doc = ""]

pub const GPU_LUT_ALPHAMAP: GPU_PROCTEX_LUTID = 3;
#[doc = "Color table"]
#[doc = ""]

pub const GPU_LUT_COLOR: GPU_PROCTEX_LUTID = 4;
#[doc = "Color difference table"]
#[doc = ""]

pub const GPU_LUT_COLORDIF: GPU_PROCTEX_LUTID = 5;
#[doc = "Procedural texture LUT IDs."]
#[doc = ""]

pub type GPU_PROCTEX_LUTID = ::libc::c_uint;
#[doc = "8-bit Red + 8-bit Green + 8-bit Blue + 8-bit Alpha"]
#[doc = ""]

pub const GPU_RB_RGBA8: GPU_COLORBUF = 0;
#[doc = "8-bit Red + 8-bit Green + 8-bit Blue"]
#[doc = ""]

pub const GPU_RB_RGB8: GPU_COLORBUF = 1;
#[doc = "5-bit Red + 5-bit Green + 5-bit Blue + 1-bit Alpha"]
#[doc = ""]

pub const GPU_RB_RGBA5551: GPU_COLORBUF = 2;
#[doc = "5-bit Red + 6-bit Green + 5-bit Blue"]
#[doc = ""]

pub const GPU_RB_RGB565: GPU_COLORBUF = 3;
#[doc = "4-bit Red + 4-bit Green + 4-bit Blue + 4-bit Alpha"]
#[doc = ""]

pub const GPU_RB_RGBA4: GPU_COLORBUF = 4;
#[doc = "Supported color buffer formats."]
#[doc = ""]

pub type GPU_COLORBUF = ::libc::c_uint;
#[doc = "16-bit Depth"]
#[doc = ""]

pub const GPU_RB_DEPTH16: GPU_DEPTHBUF = 0;
#[doc = "24-bit Depth"]
#[doc = ""]

pub const GPU_RB_DEPTH24: GPU_DEPTHBUF = 2;
#[doc = "24-bit Depth + 8-bit Stencil"]
#[doc = ""]

pub const GPU_RB_DEPTH24_STENCIL8: GPU_DEPTHBUF = 3;
#[doc = "Supported depth buffer formats."]
#[doc = ""]

pub type GPU_DEPTHBUF = ::libc::c_uint;
#[doc = "Never pass."]
#[doc = ""]

pub const GPU_NEVER: GPU_TESTFUNC = 0;
#[doc = "Always pass."]
#[doc = ""]

pub const GPU_ALWAYS: GPU_TESTFUNC = 1;
#[doc = "Pass if equal."]
#[doc = ""]

pub const GPU_EQUAL: GPU_TESTFUNC = 2;
#[doc = "Pass if not equal."]
#[doc = ""]

pub const GPU_NOTEQUAL: GPU_TESTFUNC = 3;
#[doc = "Pass if less than."]
#[doc = ""]

pub const GPU_LESS: GPU_TESTFUNC = 4;
#[doc = "Pass if less than or equal."]
#[doc = ""]

pub const GPU_LEQUAL: GPU_TESTFUNC = 5;
#[doc = "Pass if greater than."]
#[doc = ""]

pub const GPU_GREATER: GPU_TESTFUNC = 6;
#[doc = "Pass if greater than or equal."]
#[doc = ""]

pub const GPU_GEQUAL: GPU_TESTFUNC = 7;
#[doc = "Test functions."]
#[doc = ""]

pub type GPU_TESTFUNC = ::libc::c_uint;
#[doc = "Pass if greater than or equal."]
#[doc = ""]

pub const GPU_EARLYDEPTH_GEQUAL: GPU_EARLYDEPTHFUNC = 0;
#[doc = "Pass if greater than."]
#[doc = ""]

pub const GPU_EARLYDEPTH_GREATER: GPU_EARLYDEPTHFUNC = 1;
#[doc = "Pass if less than or equal."]
#[doc = ""]

pub const GPU_EARLYDEPTH_LEQUAL: GPU_EARLYDEPTHFUNC = 2;
#[doc = "Pass if less than."]
#[doc = ""]

pub const GPU_EARLYDEPTH_LESS: GPU_EARLYDEPTHFUNC = 3;
#[doc = "Early depth test functions."]
#[doc = ""]

pub type GPU_EARLYDEPTHFUNC = ::libc::c_uint;
#[doc = "Never pass (0)."]
#[doc = ""]

pub const GPU_GAS_NEVER: GPU_GASDEPTHFUNC = 0;
#[doc = "Always pass (1)."]
#[doc = ""]

pub const GPU_GAS_ALWAYS: GPU_GASDEPTHFUNC = 1;
#[doc = "Pass if greater than (1-X)."]
#[doc = ""]

pub const GPU_GAS_GREATER: GPU_GASDEPTHFUNC = 2;
#[doc = "Pass if less than (X)."]
#[doc = ""]

pub const GPU_GAS_LESS: GPU_GASDEPTHFUNC = 3;
#[doc = "Gas depth functions."]
#[doc = ""]

pub type GPU_GASDEPTHFUNC = ::libc::c_uint;
#[doc = "Disable."]
#[doc = ""]

pub const GPU_SCISSOR_DISABLE: GPU_SCISSORMODE = 0;
#[doc = "Exclude pixels inside the scissor box."]
#[doc = ""]

pub const GPU_SCISSOR_INVERT: GPU_SCISSORMODE = 1;
#[doc = "Exclude pixels outside of the scissor box."]
#[doc = ""]

pub const GPU_SCISSOR_NORMAL: GPU_SCISSORMODE = 3;
#[doc = "Scissor test modes."]
#[doc = ""]

pub type GPU_SCISSORMODE = ::libc::c_uint;
#[doc = "Keep old value. (old_stencil)"]
#[doc = ""]

pub const GPU_STENCIL_KEEP: GPU_STENCILOP = 0;
#[doc = "Zero. (0)"]
#[doc = ""]

pub const GPU_STENCIL_ZERO: GPU_STENCILOP = 1;
#[doc = "Replace value. (ref)"]
#[doc = ""]

pub const GPU_STENCIL_REPLACE: GPU_STENCILOP = 2;
#[doc = "Increment value. (old_stencil + 1 saturated to [0, 255])"]
#[doc = ""]

pub const GPU_STENCIL_INCR: GPU_STENCILOP = 3;
#[doc = "Decrement value. (old_stencil - 1 saturated to [0, 255])"]
#[doc = ""]

pub const GPU_STENCIL_DECR: GPU_STENCILOP = 4;
#[doc = "Invert value. (~old_stencil)"]
#[doc = ""]

pub const GPU_STENCIL_INVERT: GPU_STENCILOP = 5;
#[doc = "Increment value. (old_stencil + 1)"]
#[doc = ""]

pub const GPU_STENCIL_INCR_WRAP: GPU_STENCILOP = 6;
#[doc = "Decrement value. (old_stencil - 1)"]
#[doc = ""]

pub const GPU_STENCIL_DECR_WRAP: GPU_STENCILOP = 7;
#[doc = "Stencil operations."]
#[doc = ""]

pub type GPU_STENCILOP = ::libc::c_uint;
#[doc = "Write red."]
#[doc = ""]

pub const GPU_WRITE_RED: GPU_WRITEMASK = 1;
#[doc = "Write green."]
#[doc = ""]

pub const GPU_WRITE_GREEN: GPU_WRITEMASK = 2;
#[doc = "Write blue."]
#[doc = ""]

pub const GPU_WRITE_BLUE: GPU_WRITEMASK = 4;
#[doc = "Write alpha."]
#[doc = ""]

pub const GPU_WRITE_ALPHA: GPU_WRITEMASK = 8;
#[doc = "Write depth."]
#[doc = ""]

pub const GPU_WRITE_DEPTH: GPU_WRITEMASK = 16;
#[doc = "Write all color components."]
#[doc = ""]

pub const GPU_WRITE_COLOR: GPU_WRITEMASK = 15;
#[doc = "Write all components."]
#[doc = ""]

pub const GPU_WRITE_ALL: GPU_WRITEMASK = 31;
#[doc = "Pixel write mask."]
#[doc = ""]

pub type GPU_WRITEMASK = ::libc::c_uint;
#[doc = "Add colors."]
#[doc = ""]

pub const GPU_BLEND_ADD: GPU_BLENDEQUATION = 0;
#[doc = "Subtract colors."]
#[doc = ""]

pub const GPU_BLEND_SUBTRACT: GPU_BLENDEQUATION = 1;
#[doc = "Reverse-subtract colors."]
#[doc = ""]

pub const GPU_BLEND_REVERSE_SUBTRACT: GPU_BLENDEQUATION = 2;
#[doc = "Use the minimum color."]
#[doc = ""]

pub const GPU_BLEND_MIN: GPU_BLENDEQUATION = 3;
#[doc = "Use the maximum color."]
#[doc = ""]

pub const GPU_BLEND_MAX: GPU_BLENDEQUATION = 4;
#[doc = "Blend modes."]
#[doc = ""]

pub type GPU_BLENDEQUATION = ::libc::c_uint;
#[doc = "Zero."]
#[doc = ""]

pub const GPU_ZERO: GPU_BLENDFACTOR = 0;
#[doc = "One."]
#[doc = ""]

pub const GPU_ONE: GPU_BLENDFACTOR = 1;
#[doc = "Source color."]
#[doc = ""]

pub const GPU_SRC_COLOR: GPU_BLENDFACTOR = 2;
#[doc = "Source color - 1."]
#[doc = ""]

pub const GPU_ONE_MINUS_SRC_COLOR: GPU_BLENDFACTOR = 3;
#[doc = "Destination color."]
#[doc = ""]

pub const GPU_DST_COLOR: GPU_BLENDFACTOR = 4;
#[doc = "Destination color - 1."]
#[doc = ""]

pub const GPU_ONE_MINUS_DST_COLOR: GPU_BLENDFACTOR = 5;
#[doc = "Source alpha."]
#[doc = ""]

pub const GPU_SRC_ALPHA: GPU_BLENDFACTOR = 6;
#[doc = "Source alpha - 1."]
#[doc = ""]

pub const GPU_ONE_MINUS_SRC_ALPHA: GPU_BLENDFACTOR = 7;
#[doc = "Destination alpha."]
#[doc = ""]

pub const GPU_DST_ALPHA: GPU_BLENDFACTOR = 8;
#[doc = "Destination alpha - 1."]
#[doc = ""]

pub const GPU_ONE_MINUS_DST_ALPHA: GPU_BLENDFACTOR = 9;
#[doc = "Constant color."]
#[doc = ""]

pub const GPU_CONSTANT_COLOR: GPU_BLENDFACTOR = 10;
#[doc = "Constant color - 1."]
#[doc = ""]

pub const GPU_ONE_MINUS_CONSTANT_COLOR: GPU_BLENDFACTOR = 11;
#[doc = "Constant alpha."]
#[doc = ""]

pub const GPU_CONSTANT_ALPHA: GPU_BLENDFACTOR = 12;
#[doc = "Constant alpha - 1."]
#[doc = ""]

pub const GPU_ONE_MINUS_CONSTANT_ALPHA: GPU_BLENDFACTOR = 13;
#[doc = "Saturated alpha."]
#[doc = ""]

pub const GPU_SRC_ALPHA_SATURATE: GPU_BLENDFACTOR = 14;
#[doc = "Blend factors."]
#[doc = ""]

pub type GPU_BLENDFACTOR = ::libc::c_uint;
#[doc = "Clear."]
#[doc = ""]

pub const GPU_LOGICOP_CLEAR: GPU_LOGICOP = 0;
#[doc = "Bitwise AND."]
#[doc = ""]

pub const GPU_LOGICOP_AND: GPU_LOGICOP = 1;
#[doc = "Reverse bitwise AND."]
#[doc = ""]

pub const GPU_LOGICOP_AND_REVERSE: GPU_LOGICOP = 2;
#[doc = "Copy."]
#[doc = ""]

pub const GPU_LOGICOP_COPY: GPU_LOGICOP = 3;
#[doc = "Set."]
#[doc = ""]

pub const GPU_LOGICOP_SET: GPU_LOGICOP = 4;
#[doc = "Inverted copy."]
#[doc = ""]

pub const GPU_LOGICOP_COPY_INVERTED: GPU_LOGICOP = 5;
#[doc = "No operation."]
#[doc = ""]

pub const GPU_LOGICOP_NOOP: GPU_LOGICOP = 6;
#[doc = "Invert."]
#[doc = ""]

pub const GPU_LOGICOP_INVERT: GPU_LOGICOP = 7;
#[doc = "Bitwise NAND."]
#[doc = ""]

pub const GPU_LOGICOP_NAND: GPU_LOGICOP = 8;
#[doc = "Bitwise OR."]
#[doc = ""]

pub const GPU_LOGICOP_OR: GPU_LOGICOP = 9;
#[doc = "Bitwise NOR."]
#[doc = ""]

pub const GPU_LOGICOP_NOR: GPU_LOGICOP = 10;
#[doc = "Bitwise XOR."]
#[doc = ""]

pub const GPU_LOGICOP_XOR: GPU_LOGICOP = 11;
#[doc = "Equivalent."]
#[doc = ""]

pub const GPU_LOGICOP_EQUIV: GPU_LOGICOP = 12;
#[doc = "Inverted bitwise AND."]
#[doc = ""]

pub const GPU_LOGICOP_AND_INVERTED: GPU_LOGICOP = 13;
#[doc = "Reverse bitwise OR."]
#[doc = ""]

pub const GPU_LOGICOP_OR_REVERSE: GPU_LOGICOP = 14;
#[doc = "Inverted bitwize OR."]
#[doc = ""]

pub const GPU_LOGICOP_OR_INVERTED: GPU_LOGICOP = 15;
#[doc = "Logical operations."]
#[doc = ""]

pub type GPU_LOGICOP = ::libc::c_uint;
#[doc = "OpenGL mode."]
#[doc = ""]

pub const GPU_FRAGOPMODE_GL: GPU_FRAGOPMODE = 0;
#[doc = "Gas mode (?)."]
#[doc = ""]

pub const GPU_FRAGOPMODE_GAS_ACC: GPU_FRAGOPMODE = 1;
#[doc = "Shadow mode (?)."]
#[doc = ""]

pub const GPU_FRAGOPMODE_SHADOW: GPU_FRAGOPMODE = 3;
#[doc = "Fragment operation modes."]
#[doc = ""]

pub type GPU_FRAGOPMODE = ::libc::c_uint;
#[doc = "8-bit byte."]
#[doc = ""]

pub const GPU_BYTE: GPU_FORMATS = 0;
#[doc = "8-bit unsigned byte."]
#[doc = ""]

pub const GPU_UNSIGNED_BYTE: GPU_FORMATS = 1;
#[doc = "16-bit short."]
#[doc = ""]

pub const GPU_SHORT: GPU_FORMATS = 2;
#[doc = "32-bit float."]
#[doc = ""]

pub const GPU_FLOAT: GPU_FORMATS = 3;
#[doc = "Supported component formats."]
#[doc = ""]

pub type GPU_FORMATS = ::libc::c_uint;
#[doc = "Disabled."]
#[doc = ""]

pub const GPU_CULL_NONE: GPU_CULLMODE = 0;
#[doc = "Front, counter-clockwise."]
#[doc = ""]

pub const GPU_CULL_FRONT_CCW: GPU_CULLMODE = 1;
#[doc = "Back, counter-clockwise."]
#[doc = ""]

pub const GPU_CULL_BACK_CCW: GPU_CULLMODE = 2;
#[doc = "Cull modes."]
#[doc = ""]

pub type GPU_CULLMODE = ::libc::c_uint;
#[doc = "Primary color."]
#[doc = ""]

pub const GPU_PRIMARY_COLOR: GPU_TEVSRC = 0;
#[doc = "Primary fragment color."]
#[doc = ""]

pub const GPU_FRAGMENT_PRIMARY_COLOR: GPU_TEVSRC = 1;
#[doc = "Secondary fragment color."]
#[doc = ""]

pub const GPU_FRAGMENT_SECONDARY_COLOR: GPU_TEVSRC = 2;
#[doc = "Texture unit 0."]
#[doc = ""]

pub const GPU_TEXTURE0: GPU_TEVSRC = 3;
#[doc = "Texture unit 1."]
#[doc = ""]

pub const GPU_TEXTURE1: GPU_TEVSRC = 4;
#[doc = "Texture unit 2."]
#[doc = ""]

pub const GPU_TEXTURE2: GPU_TEVSRC = 5;
#[doc = "Texture unit 3."]
#[doc = ""]

pub const GPU_TEXTURE3: GPU_TEVSRC = 6;
#[doc = "Previous buffer."]
#[doc = ""]

pub const GPU_PREVIOUS_BUFFER: GPU_TEVSRC = 13;
#[doc = "Constant value."]
#[doc = ""]

pub const GPU_CONSTANT: GPU_TEVSRC = 14;
#[doc = "Previous value."]
#[doc = ""]

pub const GPU_PREVIOUS: GPU_TEVSRC = 15;
#[doc = "Texture combiner sources."]
#[doc = ""]

pub type GPU_TEVSRC = ::libc::c_uint;
#[doc = "Source color."]
#[doc = ""]

pub const GPU_TEVOP_RGB_SRC_COLOR: GPU_TEVOP_RGB = 0;
#[doc = "Source color - 1."]
#[doc = ""]

pub const GPU_TEVOP_RGB_ONE_MINUS_SRC_COLOR: GPU_TEVOP_RGB = 1;
#[doc = "Source alpha."]
#[doc = ""]

pub const GPU_TEVOP_RGB_SRC_ALPHA: GPU_TEVOP_RGB = 2;
#[doc = "Source alpha - 1."]
#[doc = ""]

pub const GPU_TEVOP_RGB_ONE_MINUS_SRC_ALPHA: GPU_TEVOP_RGB = 3;
#[doc = "Source red."]
#[doc = ""]

pub const GPU_TEVOP_RGB_SRC_R: GPU_TEVOP_RGB = 4;
#[doc = "Source red - 1."]
#[doc = ""]

pub const GPU_TEVOP_RGB_ONE_MINUS_SRC_R: GPU_TEVOP_RGB = 5;
#[doc = "Unknown."]
#[doc = ""]

pub const GPU_TEVOP_RGB_0x06: GPU_TEVOP_RGB = 6;
#[doc = "Unknown."]
#[doc = ""]

pub const GPU_TEVOP_RGB_0x07: GPU_TEVOP_RGB = 7;
#[doc = "Source green."]
#[doc = ""]

pub const GPU_TEVOP_RGB_SRC_G: GPU_TEVOP_RGB = 8;
#[doc = "Source green - 1."]
#[doc = ""]

pub const GPU_TEVOP_RGB_ONE_MINUS_SRC_G: GPU_TEVOP_RGB = 9;
#[doc = "Unknown."]
#[doc = ""]

pub const GPU_TEVOP_RGB_0x0A: GPU_TEVOP_RGB = 10;
#[doc = "Unknown."]
#[doc = ""]

pub const GPU_TEVOP_RGB_0x0B: GPU_TEVOP_RGB = 11;
#[doc = "Source blue."]
#[doc = ""]

pub const GPU_TEVOP_RGB_SRC_B: GPU_TEVOP_RGB = 12;
#[doc = "Source blue - 1."]
#[doc = ""]

pub const GPU_TEVOP_RGB_ONE_MINUS_SRC_B: GPU_TEVOP_RGB = 13;
#[doc = "Unknown."]
#[doc = ""]

pub const GPU_TEVOP_RGB_0x0E: GPU_TEVOP_RGB = 14;
#[doc = "Unknown."]
#[doc = ""]

pub const GPU_TEVOP_RGB_0x0F: GPU_TEVOP_RGB = 15;
#[doc = "Texture RGB combiner operands."]
#[doc = ""]

pub type GPU_TEVOP_RGB = ::libc::c_uint;
#[doc = "Source alpha."]
#[doc = ""]

pub const GPU_TEVOP_A_SRC_ALPHA: GPU_TEVOP_A = 0;
#[doc = "Source alpha - 1."]
#[doc = ""]

pub const GPU_TEVOP_A_ONE_MINUS_SRC_ALPHA: GPU_TEVOP_A = 1;
#[doc = "Source red."]
#[doc = ""]

pub const GPU_TEVOP_A_SRC_R: GPU_TEVOP_A = 2;
#[doc = "Source red - 1."]
#[doc = ""]

pub const GPU_TEVOP_A_ONE_MINUS_SRC_R: GPU_TEVOP_A = 3;
#[doc = "Source green."]
#[doc = ""]

pub const GPU_TEVOP_A_SRC_G: GPU_TEVOP_A = 4;
#[doc = "Source green - 1."]
#[doc = ""]

pub const GPU_TEVOP_A_ONE_MINUS_SRC_G: GPU_TEVOP_A = 5;
#[doc = "Source blue."]
#[doc = ""]

pub const GPU_TEVOP_A_SRC_B: GPU_TEVOP_A = 6;
#[doc = "Source blue - 1."]
#[doc = ""]

pub const GPU_TEVOP_A_ONE_MINUS_SRC_B: GPU_TEVOP_A = 7;
#[doc = "Texture Alpha combiner operands."]
#[doc = ""]

pub type GPU_TEVOP_A = ::libc::c_uint;
#[doc = "Replace."]
#[doc = ""]

pub const GPU_REPLACE: GPU_COMBINEFUNC = 0;
#[doc = "Modulate."]
#[doc = ""]

pub const GPU_MODULATE: GPU_COMBINEFUNC = 1;
#[doc = "Add."]
#[doc = ""]

pub const GPU_ADD: GPU_COMBINEFUNC = 2;
#[doc = "Signed add."]
#[doc = ""]

pub const GPU_ADD_SIGNED: GPU_COMBINEFUNC = 3;
#[doc = "Interpolate."]
#[doc = ""]

pub const GPU_INTERPOLATE: GPU_COMBINEFUNC = 4;
#[doc = "Subtract."]
#[doc = ""]

pub const GPU_SUBTRACT: GPU_COMBINEFUNC = 5;
#[doc = "Dot3. RGB only."]
#[doc = ""]

pub const GPU_DOT3_RGB: GPU_COMBINEFUNC = 6;
#[doc = "Multiply then add."]
#[doc = ""]

pub const GPU_MULTIPLY_ADD: GPU_COMBINEFUNC = 8;
#[doc = "Add then multiply."]
#[doc = ""]

pub const GPU_ADD_MULTIPLY: GPU_COMBINEFUNC = 9;
#[doc = "Texture combiner functions."]
#[doc = ""]

pub type GPU_COMBINEFUNC = ::libc::c_uint;
#[doc = "1x"]
#[doc = ""]

pub const GPU_TEVSCALE_1: GPU_TEVSCALE = 0;
#[doc = "2x"]
#[doc = ""]

pub const GPU_TEVSCALE_2: GPU_TEVSCALE = 1;
#[doc = "4x"]
#[doc = ""]

pub const GPU_TEVSCALE_4: GPU_TEVSCALE = 2;
#[doc = "Texture scale factors."]
#[doc = ""]

pub type GPU_TEVSCALE = ::libc::c_uint;
#[doc = "None."]
#[doc = ""]

pub const GPU_NO_FRESNEL: GPU_FRESNELSEL = 0;
#[doc = "Primary alpha."]
#[doc = ""]

pub const GPU_PRI_ALPHA_FRESNEL: GPU_FRESNELSEL = 1;
#[doc = "Secondary alpha."]
#[doc = ""]

pub const GPU_SEC_ALPHA_FRESNEL: GPU_FRESNELSEL = 2;
#[doc = "Primary and secondary alpha."]
#[doc = ""]

pub const GPU_PRI_SEC_ALPHA_FRESNEL: GPU_FRESNELSEL = 3;
#[doc = "Fresnel options."]
#[doc = ""]

pub type GPU_FRESNELSEL = ::libc::c_uint;
#[doc = "Disabled."]
#[doc = ""]

pub const GPU_BUMP_NOT_USED: GPU_BUMPMODE = 0;
#[doc = "Bump as bump mapping."]
#[doc = ""]

pub const GPU_BUMP_AS_BUMP: GPU_BUMPMODE = 1;
#[doc = "Bump as tangent/normal mapping."]
#[doc = ""]

pub const GPU_BUMP_AS_TANG: GPU_BUMPMODE = 2;
#[doc = "Bump map modes."]
#[doc = ""]

pub type GPU_BUMPMODE = ::libc::c_uint;
#[doc = "D0 LUT."]
#[doc = ""]

pub const GPU_LUT_D0: GPU_LIGHTLUTID = 0;
#[doc = "D1 LUT."]
#[doc = ""]

pub const GPU_LUT_D1: GPU_LIGHTLUTID = 1;
#[doc = "Spotlight LUT."]
#[doc = ""]

pub const GPU_LUT_SP: GPU_LIGHTLUTID = 2;
#[doc = "Fresnel LUT."]
#[doc = ""]

pub const GPU_LUT_FR: GPU_LIGHTLUTID = 3;
#[doc = "Reflection-Blue LUT."]
#[doc = ""]

pub const GPU_LUT_RB: GPU_LIGHTLUTID = 4;
#[doc = "Reflection-Green LUT."]
#[doc = ""]

pub const GPU_LUT_RG: GPU_LIGHTLUTID = 5;
#[doc = "Reflection-Red LUT."]
#[doc = ""]

pub const GPU_LUT_RR: GPU_LIGHTLUTID = 6;
#[doc = "Distance attenuation LUT."]
#[doc = ""]

pub const GPU_LUT_DA: GPU_LIGHTLUTID = 7;
#[doc = "LUT IDs."]
#[doc = ""]

pub type GPU_LIGHTLUTID = ::libc::c_uint;
#[doc = "Normal*HalfVector"]
#[doc = ""]

pub const GPU_LUTINPUT_NH: GPU_LIGHTLUTINPUT = 0;
#[doc = "View*HalfVector"]
#[doc = ""]

pub const GPU_LUTINPUT_VH: GPU_LIGHTLUTINPUT = 1;
#[doc = "Normal*View"]
#[doc = ""]

pub const GPU_LUTINPUT_NV: GPU_LIGHTLUTINPUT = 2;
#[doc = "LightVector*Normal"]
#[doc = ""]

pub const GPU_LUTINPUT_LN: GPU_LIGHTLUTINPUT = 3;
#[doc = "-LightVector*SpotlightVector"]
#[doc = ""]

pub const GPU_LUTINPUT_SP: GPU_LIGHTLUTINPUT = 4;
#[doc = "cosine of phi"]
#[doc = ""]

pub const GPU_LUTINPUT_CP: GPU_LIGHTLUTINPUT = 5;
#[doc = "LUT inputs."]
#[doc = ""]

pub type GPU_LIGHTLUTINPUT = ::libc::c_uint;
#[doc = "1x scale."]
#[doc = ""]

pub const GPU_LUTSCALER_1x: GPU_LIGHTLUTSCALER = 0;
#[doc = "2x scale."]
#[doc = ""]

pub const GPU_LUTSCALER_2x: GPU_LIGHTLUTSCALER = 1;
#[doc = "4x scale."]
#[doc = ""]

pub const GPU_LUTSCALER_4x: GPU_LIGHTLUTSCALER = 2;
#[doc = "8x scale."]
#[doc = ""]

pub const GPU_LUTSCALER_8x: GPU_LIGHTLUTSCALER = 3;
#[doc = "0.25x scale."]
#[doc = ""]

pub const GPU_LUTSCALER_0_25x: GPU_LIGHTLUTSCALER = 6;
#[doc = "0.5x scale."]
#[doc = ""]

pub const GPU_LUTSCALER_0_5x: GPU_LIGHTLUTSCALER = 7;
#[doc = "LUT scalers."]
#[doc = ""]

pub type GPU_LIGHTLUTSCALER = ::libc::c_uint;
#[doc = "LUTs that are common to all lights."]
#[doc = ""]

pub const GPU_LUTSELECT_COMMON: GPU_LIGHTLUTSELECT = 0;
#[doc = "Spotlight LUT."]
#[doc = ""]

pub const GPU_LUTSELECT_SP: GPU_LIGHTLUTSELECT = 1;
#[doc = "Distance attenuation LUT."]
#[doc = ""]

pub const GPU_LUTSELECT_DA: GPU_LIGHTLUTSELECT = 2;
#[doc = "LUT selection."]
#[doc = ""]

pub type GPU_LIGHTLUTSELECT = ::libc::c_uint;
#[doc = "Fog/Gas unit disabled."]
#[doc = ""]

pub const GPU_NO_FOG: GPU_FOGMODE = 0;
#[doc = "Fog/Gas unit configured in Fog mode."]
#[doc = ""]

pub const GPU_FOG: GPU_FOGMODE = 5;
#[doc = "Fog/Gas unit configured in Gas mode."]
#[doc = ""]

pub const GPU_GAS: GPU_FOGMODE = 7;
#[doc = "Fog modes."]
#[doc = ""]

pub type GPU_FOGMODE = ::libc::c_uint;
#[doc = "Plain density."]
#[doc = ""]

pub const GPU_PLAIN_DENSITY: GPU_GASMODE = 0;
#[doc = "Depth density."]
#[doc = ""]

pub const GPU_DEPTH_DENSITY: GPU_GASMODE = 1;
#[doc = "Gas shading density source values."]
#[doc = ""]

pub type GPU_GASMODE = ::libc::c_uint;
#[doc = "Gas density used as input."]
#[doc = ""]

pub const GPU_GAS_DENSITY: GPU_GASLUTINPUT = 0;
#[doc = "Light factor used as input."]
#[doc = ""]

pub const GPU_GAS_LIGHT_FACTOR: GPU_GASLUTINPUT = 1;
#[doc = "Gas color LUT inputs."]
#[doc = ""]

pub type GPU_GASLUTINPUT = ::libc::c_uint;
#[doc = "Triangles."]
#[doc = ""]

pub const GPU_TRIANGLES: GPU_Primitive_t = 0;
#[doc = "Triangle strip."]
#[doc = ""]

pub const GPU_TRIANGLE_STRIP: GPU_Primitive_t = 256;
#[doc = "Triangle fan."]
#[doc = ""]

pub const GPU_TRIANGLE_FAN: GPU_Primitive_t = 512;
#[doc = "Geometry shader primitive."]
#[doc = ""]

pub const GPU_GEOMETRY_PRIM: GPU_Primitive_t = 768;
#[doc = "Supported primitives."]
#[doc = ""]

pub type GPU_Primitive_t = ::libc::c_uint;
#[doc = "Vertex shader."]
#[doc = ""]

pub const GPU_VERTEX_SHADER: GPU_SHADER_TYPE = 0;
#[doc = "Geometry shader."]
#[doc = ""]

pub const GPU_GEOMETRY_SHADER: GPU_SHADER_TYPE = 1;
#[doc = "Shader types."]
#[doc = ""]

pub type GPU_SHADER_TYPE = ::libc::c_uint;
extern "C" {
    #[doc = "GPU command buffer."]
    #[doc = ""]
    pub static mut gpuCmdBuf: *mut u32_;
}
extern "C" {
    #[doc = "GPU command buffer size."]
    #[doc = ""]
    pub static mut gpuCmdBufSize: u32_;
}
extern "C" {
    #[doc = "GPU command buffer offset."]
    #[doc = ""]
    pub static mut gpuCmdBufOffset: u32_;
}
extern "C" {
    #[doc = "Adds raw GPU commands to the current command buffer.\n @param cmd Buffer containing commands to add.\n @param size Size of the buffer."]
    #[doc = ""]
    pub fn GPUCMD_AddRawCommands(cmd: *const u32_, size: u32_);
}
extern "C" {
    #[doc = "Adds a GPU command to the current command buffer.\n @param header Header of the command.\n @param param Parameters of the command.\n @param paramlength Size of the parameter buffer."]
    #[doc = ""]
    pub fn GPUCMD_Add(header: u32_, param: *const u32_, paramlength: u32_);
}
extern "C" {
    #[doc = "Splits the current GPU command buffer.\n @param addr Pointer to output the command buffer to.\n @param size Pointer to output the size (in words) of the command buffer to."]
    #[doc = ""]
    pub fn GPUCMD_Split(addr: *mut *mut u32_, size: *mut u32_);
}
extern "C" {
    #[doc = "Converts a 32-bit float to a 16-bit float.\n @param f Float to convert.\n @return The converted float."]
    #[doc = ""]
    pub fn f32tof16(f: f32) -> u32_;
}
extern "C" {
    #[doc = "Converts a 32-bit float to a 20-bit float.\n @param f Float to convert.\n @return The converted float."]
    #[doc = ""]
    pub fn f32tof20(f: f32) -> u32_;
}
extern "C" {
    #[doc = "Converts a 32-bit float to a 24-bit float.\n @param f Float to convert.\n @return The converted float."]
    #[doc = ""]
    pub fn f32tof24(f: f32) -> u32_;
}
extern "C" {
    #[doc = "Converts a 32-bit float to a 31-bit float.\n @param f Float to convert.\n @return The converted float."]
    #[doc = ""]
    pub fn f32tof31(f: f32) -> u32_;
}
#[doc = "Vertex shader."]
#[doc = ""]

pub const VERTEX_SHDR: DVLE_type = 0;
#[doc = "Geometry shader."]
#[doc = ""]

pub const GEOMETRY_SHDR: DVLE_type = 1;
#[doc = "DVLE type."]
#[doc = ""]

pub type DVLE_type = ::libc::c_uint;
#[doc = "Bool."]
#[doc = ""]

pub const DVLE_CONST_BOOL: DVLE_constantType = 0;
#[doc = "Unsigned 8-bit integer."]
#[doc = ""]

pub const DVLE_CONST_u8: DVLE_constantType = 1;
#[doc = "24-bit float."]
#[doc = ""]

pub const DVLE_CONST_FLOAT24: DVLE_constantType = 2;
#[doc = "Constant type."]
#[doc = ""]

pub type DVLE_constantType = ::libc::c_uint;
#[doc = "Position."]
#[doc = ""]

pub const RESULT_POSITION: DVLE_outputAttribute_t = 0;
#[doc = "Normal Quaternion."]
#[doc = ""]

pub const RESULT_NORMALQUAT: DVLE_outputAttribute_t = 1;
#[doc = "Color."]
#[doc = ""]

pub const RESULT_COLOR: DVLE_outputAttribute_t = 2;
#[doc = "Texture coordinate 0."]
#[doc = ""]

pub const RESULT_TEXCOORD0: DVLE_outputAttribute_t = 3;
#[doc = "Texture coordinate 0 W."]
#[doc = ""]

pub const RESULT_TEXCOORD0W: DVLE_outputAttribute_t = 4;
#[doc = "Texture coordinate 1."]
#[doc = ""]

pub const RESULT_TEXCOORD1: DVLE_outputAttribute_t = 5;
#[doc = "Texture coordinate 2."]
#[doc = ""]

pub const RESULT_TEXCOORD2: DVLE_outputAttribute_t = 6;
#[doc = "View."]
#[doc = ""]

pub const RESULT_VIEW: DVLE_outputAttribute_t = 8;
#[doc = "Dummy attribute (used as passthrough for geometry shader input)."]
#[doc = ""]

pub const RESULT_DUMMY: DVLE_outputAttribute_t = 9;
#[doc = "Output attribute."]
#[doc = ""]

pub type DVLE_outputAttribute_t = ::libc::c_uint;
#[doc = "Point processing mode."]
#[doc = ""]

pub const GSH_POINT: DVLE_geoShaderMode = 0;
#[doc = "Variable-size primitive processing mode."]
#[doc = ""]

pub const GSH_VARIABLE_PRIM: DVLE_geoShaderMode = 1;
#[doc = "Fixed-size primitive processing mode."]
#[doc = ""]

pub const GSH_FIXED_PRIM: DVLE_geoShaderMode = 2;
#[doc = "Geometry shader operation modes."]
#[doc = ""]

pub type DVLE_geoShaderMode = ::libc::c_uint;
#[doc = "DVLP data."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DVLP_s {
    #[doc = "Code size."]
    #[doc = ""]
    pub codeSize: u32_,
    #[doc = "Code data."]
    #[doc = ""]
    pub codeData: *mut u32_,
    #[doc = "Operand description size."]
    #[doc = ""]
    pub opdescSize: u32_,
    #[doc = "Operand description data."]
    #[doc = ""]
    pub opcdescData: *mut u32_,
}
impl Default for DVLP_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "DVLE constant entry data."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct DVLE_constEntry_s {
    #[doc = "Constant type. See [`DVLE_constantType`]"]
    #[doc = ""]
    pub type_: u16_,
    #[doc = "Constant ID."]
    #[doc = ""]
    pub id: u16_,
    #[doc = "Constant data."]
    #[doc = ""]
    pub data: [u32_; 4usize],
}
#[doc = "DVLE output entry data."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct DVLE_outEntry_s {
    #[doc = "Output type. See [`DVLE_outputAttribute_t`]"]
    #[doc = ""]
    pub type_: u16_,
    #[doc = "Output register ID."]
    #[doc = ""]
    pub regID: u16_,
    #[doc = "Output mask."]
    #[doc = ""]
    pub mask: u8_,
    #[doc = "Unknown."]
    #[doc = ""]
    pub unk: [u8_; 3usize],
}
#[doc = "DVLE uniform entry data."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct DVLE_uniformEntry_s {
    #[doc = "Symbol offset."]
    #[doc = ""]
    pub symbolOffset: u32_,
    #[doc = "Start register."]
    #[doc = ""]
    pub startReg: u16_,
    #[doc = "End register."]
    #[doc = ""]
    pub endReg: u16_,
}
#[doc = "DVLE data."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DVLE_s {
    #[doc = "DVLE type."]
    #[doc = ""]
    pub type_: DVLE_type,
    #[doc = "true = merge vertex/geometry shader outmaps ('dummy' output attribute is present)."]
    #[doc = ""]
    pub mergeOutmaps: bool,
    #[doc = "Geometry shader operation mode."]
    #[doc = ""]
    pub gshMode: DVLE_geoShaderMode,
    #[doc = "Starting float uniform register number for storing the fixed-size primitive vertex array."]
    #[doc = ""]
    pub gshFixedVtxStart: u8_,
    #[doc = "Number of fully-defined vertices in the variable-size primitive vertex array."]
    #[doc = ""]
    pub gshVariableVtxNum: u8_,
    #[doc = "Number of vertices in the fixed-size primitive vertex array."]
    #[doc = ""]
    pub gshFixedVtxNum: u8_,
    #[doc = "Contained DVLPs."]
    #[doc = ""]
    pub dvlp: *mut DVLP_s,
    #[doc = "Offset of the start of the main function."]
    #[doc = ""]
    pub mainOffset: u32_,
    #[doc = "Offset of the end of the main function."]
    #[doc = ""]
    pub endmainOffset: u32_,
    #[doc = "Constant table size."]
    #[doc = ""]
    pub constTableSize: u32_,
    #[doc = "Constant table data."]
    #[doc = ""]
    pub constTableData: *mut DVLE_constEntry_s,
    #[doc = "Output table size."]
    #[doc = ""]
    pub outTableSize: u32_,
    #[doc = "Output table data."]
    #[doc = ""]
    pub outTableData: *mut DVLE_outEntry_s,
    #[doc = "Uniform table size."]
    #[doc = ""]
    pub uniformTableSize: u32_,
    #[doc = "Uniform table data."]
    #[doc = ""]
    pub uniformTableData: *mut DVLE_uniformEntry_s,
    #[doc = "Symbol table data."]
    #[doc = ""]
    pub symbolTableData: *mut ::libc::c_char,
    #[doc = "Output map mask."]
    #[doc = ""]
    pub outmapMask: u8_,
    #[doc = "Output map data."]
    #[doc = ""]
    pub outmapData: [u32_; 8usize],
    #[doc = "Output map mode."]
    #[doc = ""]
    pub outmapMode: u32_,
    #[doc = "Output map attribute clock."]
    #[doc = ""]
    pub outmapClock: u32_,
}
impl Default for DVLE_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "DVLB data."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DVLB_s {
    #[doc = "DVLE count."]
    #[doc = ""]
    pub numDVLE: u32_,
    #[doc = "Primary DVLP."]
    #[doc = ""]
    pub DVLP: DVLP_s,
    #[doc = "Contained DVLE."]
    #[doc = ""]
    pub DVLE: *mut DVLE_s,
}
impl Default for DVLB_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = "Parses a shader binary.\n @param shbinData Shader binary data.\n @param shbinSize Shader binary size.\n @return The parsed shader binary."]
    #[doc = ""]
    pub fn DVLB_ParseFile(shbinData: *mut u32_, shbinSize: u32_) -> *mut DVLB_s;
}
extern "C" {
    #[doc = "Frees shader binary data.\n @param dvlb DVLB to free."]
    #[doc = ""]
    pub fn DVLB_Free(dvlb: *mut DVLB_s);
}
extern "C" {
    #[doc = "Gets a uniform register index from a shader.\n @param dvle Shader to get the register from.\n @param name Name of the register.\n @return The uniform register index."]
    #[doc = ""]
    pub fn DVLE_GetUniformRegister(dvle: *mut DVLE_s, name: *const ::libc::c_char) -> s8;
}
extern "C" {
    #[doc = "Generates a shader output map.\n @param dvle Shader to generate an output map for."]
    #[doc = ""]
    pub fn DVLE_GenerateOutmap(dvle: *mut DVLE_s);
}
#[doc = "24-bit float uniforms."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct float24Uniform_s {
    #[doc = "Uniform ID."]
    #[doc = ""]
    pub id: u32_,
    #[doc = "Uniform data."]
    #[doc = ""]
    pub data: [u32_; 3usize],
}
#[doc = "Describes an instance of either a vertex or geometry shader."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct shaderInstance_s {
    #[doc = "Shader DVLE."]
    #[doc = ""]
    pub dvle: *mut DVLE_s,
    #[doc = "Boolean uniforms."]
    #[doc = ""]
    pub boolUniforms: u16_,
    #[doc = "Used boolean uniform mask."]
    #[doc = ""]
    pub boolUniformMask: u16_,
    #[doc = "Integer uniforms."]
    #[doc = ""]
    pub intUniforms: [u32_; 4usize],
    #[doc = "24-bit float uniforms."]
    #[doc = ""]
    pub float24Uniforms: *mut float24Uniform_s,
    #[doc = "Used integer uniform mask."]
    #[doc = ""]
    pub intUniformMask: u8_,
    #[doc = "Float uniform count."]
    #[doc = ""]
    pub numFloat24Uniforms: u8_,
}
impl Default for shaderInstance_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Describes an instance of a full shader program."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct shaderProgram_s {
    #[doc = "Vertex shader."]
    #[doc = ""]
    pub vertexShader: *mut shaderInstance_s,
    #[doc = "Geometry shader."]
    #[doc = ""]
    pub geometryShader: *mut shaderInstance_s,
    #[doc = "Geometry shader input permutation."]
    #[doc = ""]
    pub geoShaderInputPermutation: [u32_; 2usize],
    #[doc = "Geometry shader input stride."]
    #[doc = ""]
    pub geoShaderInputStride: u8_,
}
impl Default for shaderProgram_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[must_use]
    #[doc = "Initializes a shader instance.\n @param si Shader instance to initialize.\n @param dvle DVLE to initialize the shader instance with."]
    #[doc = ""]
    pub fn shaderInstanceInit(si: *mut shaderInstance_s, dvle: *mut DVLE_s) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Frees a shader instance.\n @param si Shader instance to free."]
    #[doc = ""]
    pub fn shaderInstanceFree(si: *mut shaderInstance_s) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets a bool uniform of a shader.\n @param si Shader instance to use.\n @param id ID of the bool uniform.\n @param value Value to set."]
    #[doc = ""]
    pub fn shaderInstanceSetBool(
        si: *mut shaderInstance_s,
        id: ::libc::c_int,
        value: bool,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets a bool uniform of a shader.\n @param si Shader instance to use.\n @param id ID of the bool uniform.\n @param value Pointer to output the value to."]
    #[doc = ""]
    pub fn shaderInstanceGetBool(
        si: *mut shaderInstance_s,
        id: ::libc::c_int,
        value: *mut bool,
    ) -> Result;
}
extern "C" {
    #[doc = "Gets the location of a shader's uniform.\n @param si Shader instance to use.\n @param name Name of the uniform."]
    #[doc = ""]
    pub fn shaderInstanceGetUniformLocation(
        si: *mut shaderInstance_s,
        name: *const ::libc::c_char,
    ) -> s8;
}
extern "C" {
    #[must_use]
    #[doc = "Initializes a shader program.\n @param sp Shader program to initialize."]
    #[doc = ""]
    pub fn shaderProgramInit(sp: *mut shaderProgram_s) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Frees a shader program.\n @param sp Shader program to free."]
    #[doc = ""]
    pub fn shaderProgramFree(sp: *mut shaderProgram_s) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the vertex shader of a shader program.\n @param sp Shader program to use.\n @param dvle Vertex shader to set."]
    #[doc = ""]
    pub fn shaderProgramSetVsh(sp: *mut shaderProgram_s, dvle: *mut DVLE_s) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the geometry shader of a shader program.\n @param sp Shader program to use.\n @param dvle Geometry shader to set.\n @param stride Input stride of the shader (pass 0 to match the number of outputs of the vertex shader)."]
    #[doc = ""]
    pub fn shaderProgramSetGsh(sp: *mut shaderProgram_s, dvle: *mut DVLE_s, stride: u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Configures the permutation of the input attributes of the geometry shader of a shader program.\n @param sp Shader program to use.\n @param permutation Attribute permutation to use."]
    #[doc = ""]
    pub fn shaderProgramSetGshInputPermutation(
        sp: *mut shaderProgram_s,
        permutation: u64_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Configures the shader units to use the specified shader program.\n @param sp Shader program to use.\n @param sendVshCode When true, the vertex shader's code and operand descriptors are uploaded.\n @param sendGshCode When true, the geometry shader's code and operand descriptors are uploaded."]
    #[doc = ""]
    pub fn shaderProgramConfigure(
        sp: *mut shaderProgram_s,
        sendVshCode: bool,
        sendGshCode: bool,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Same as shaderProgramConfigure, but always loading code/operand descriptors and uploading DVLE constants afterwards.\n @param sp Shader program to use."]
    #[doc = ""]
    pub fn shaderProgramUse(sp: *mut shaderProgram_s) -> Result;
}
#[doc = "Mono sound"]
#[doc = ""]

pub const NDSP_OUTPUT_MONO: ndspOutputMode = 0;
#[doc = "Stereo sound"]
#[doc = ""]

pub const NDSP_OUTPUT_STEREO: ndspOutputMode = 1;
#[doc = "3D Surround sound"]
#[doc = ""]

pub const NDSP_OUTPUT_SURROUND: ndspOutputMode = 2;
#[doc = "# Data types\n@{\n Sound output modes."]
#[doc = ""]

pub type ndspOutputMode = ::libc::c_uint;
#[doc = "\"Normal\" clipping mode (?)"]
#[doc = ""]

pub const NDSP_CLIP_NORMAL: ndspClippingMode = 0;
#[doc = "\"Soft\" clipping mode (?)"]
#[doc = ""]

pub const NDSP_CLIP_SOFT: ndspClippingMode = 1;
pub type ndspClippingMode = ::libc::c_uint;
#[doc = "<?"]
#[doc = ""]

pub const NDSP_SPKPOS_SQUARE: ndspSpeakerPos = 0;
#[doc = "<?"]
#[doc = ""]

pub const NDSP_SPKPOS_WIDE: ndspSpeakerPos = 1;
#[doc = "<?"]
#[doc = ""]

pub const NDSP_SPKPOS_NUM: ndspSpeakerPos = 2;
pub type ndspSpeakerPos = ::libc::c_uint;
#[doc = "ADPCM data."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ndspAdpcmData {
    #[doc = "Current predictor index"]
    #[doc = ""]
    pub index: u16_,
    #[doc = "Last outputted PCM16 sample."]
    #[doc = ""]
    pub history0: s16,
    #[doc = "Second to last outputted PCM16 sample."]
    #[doc = ""]
    pub history1: s16,
}
#[doc = "Wave buffer struct."]
#[doc = ""]

pub type ndspWaveBuf = tag_ndspWaveBuf;
#[doc = "The wave buffer is not queued."]
#[doc = ""]

pub const NDSP_WBUF_FREE: _bindgen_ty_29 = 0;
#[doc = "The wave buffer is queued and has not been played yet."]
#[doc = ""]

pub const NDSP_WBUF_QUEUED: _bindgen_ty_29 = 1;
#[doc = "The wave buffer is playing right now."]
#[doc = ""]

pub const NDSP_WBUF_PLAYING: _bindgen_ty_29 = 2;
#[doc = "The wave buffer has finished being played."]
#[doc = ""]

pub const NDSP_WBUF_DONE: _bindgen_ty_29 = 3;
#[doc = "Wave buffer status."]
#[doc = ""]

pub type _bindgen_ty_29 = ::libc::c_uint;
#[doc = "Wave buffer struct."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tag_ndspWaveBuf {
    pub __bindgen_anon_1: tag_ndspWaveBuf__bindgen_ty_1,
    #[doc = "Total number of samples (PCM8=bytes, PCM16=halfwords, DSPADPCM=nibbles without frame headers)"]
    #[doc = ""]
    pub nsamples: u32_,
    #[doc = "ADPCM data."]
    #[doc = ""]
    pub adpcm_data: *mut ndspAdpcmData,
    #[doc = "Buffer offset. Only used for capture."]
    #[doc = ""]
    pub offset: u32_,
    #[doc = "Whether to loop the buffer."]
    #[doc = ""]
    pub looping: bool,
    #[doc = "Queuing/playback status."]
    #[doc = ""]
    pub status: u8_,
    #[doc = "Sequence ID. Assigned automatically by ndspChnWaveBufAdd."]
    #[doc = ""]
    pub sequence_id: u16_,
    #[doc = "Next buffer to play. Used internally, do not modify."]
    #[doc = ""]
    pub next: *mut ndspWaveBuf,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tag_ndspWaveBuf__bindgen_ty_1 {
    #[doc = "Pointer to PCM8 sample data."]
    #[doc = ""]
    pub data_pcm8: *mut s8,
    #[doc = "Pointer to PCM16 sample data."]
    #[doc = ""]
    pub data_pcm16: *mut s16,
    #[doc = "Pointer to DSPADPCM sample data."]
    #[doc = ""]
    pub data_adpcm: *mut u8_,
    #[doc = "Data virtual address."]
    #[doc = ""]
    pub data_vaddr: *const ::libc::c_void,
}
impl Default for tag_ndspWaveBuf__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for tag_ndspWaveBuf {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Sound frame callback function. (data = User provided data)"]
#[doc = ""]

pub type ndspCallback = ::core::option::Option<unsafe extern "C" fn(data: *mut ::libc::c_void)>;
#[doc = "Auxiliary output callback function. (data = User provided data, nsamples = Number of samples, samples = Sample data)"]
#[doc = ""]

pub type ndspAuxCallback = ::core::option::Option<
    unsafe extern "C" fn(
        data: *mut ::libc::c_void,
        nsamples: ::libc::c_int,
        samples: *mut *mut ::libc::c_void,
    ),
>;
extern "C" {
    #[doc = "# Initialization and basic operations\n@{\n**\n* @brief Sets up the DSP component.\n* @param binary DSP binary to load.\n* @param size Size of the DSP binary.\n* @param progMask Program RAM block mask to load the binary to.\n* @param dataMask Data RAM block mask to load the binary to.\n*/"]
    #[doc = ""]
    pub fn ndspUseComponent(
        binary: *const ::libc::c_void,
        size: u32_,
        progMask: u16_,
        dataMask: u16_,
    );
}
extern "C" {
    #[must_use]
    #[doc = "Initializes NDSP."]
    #[doc = ""]
    pub fn ndspInit() -> Result;
}
extern "C" {
    #[doc = "Exits NDSP."]
    #[doc = ""]
    pub fn ndspExit();
}
extern "C" {
    #[doc = "Gets the number of dropped sound frames.\n @return The number of dropped sound frames."]
    #[doc = ""]
    pub fn ndspGetDroppedFrames() -> u32_;
}
extern "C" {
    #[doc = "Gets the total sound frame count.\n @return The total sound frame count."]
    #[doc = ""]
    pub fn ndspGetFrameCount() -> u32_;
}
extern "C" {
    #[doc = "# General parameters\n@{\n**\n* @brief Sets the master volume.\n* @param volume Volume to set. Defaults to 1.0f.\n*/"]
    #[doc = ""]
    pub fn ndspSetMasterVol(volume: f32);
}
extern "C" {
    #[doc = "Gets the master volume.\n @return The master volume."]
    #[doc = ""]
    pub fn ndspGetMasterVol() -> f32;
}
extern "C" {
    #[doc = "Sets the output mode.\n @param mode Output mode to set. Defaults to NDSP_OUTPUT_STEREO."]
    #[doc = ""]
    pub fn ndspSetOutputMode(mode: ndspOutputMode);
}
extern "C" {
    #[doc = "Gets the output mode.\n @return The output mode."]
    #[doc = ""]
    pub fn ndspGetOutputMode() -> ndspOutputMode;
}
extern "C" {
    #[doc = "Sets the clipping mode.\n @param mode Clipping mode to set. Defaults to NDSP_CLIP_SOFT."]
    #[doc = ""]
    pub fn ndspSetClippingMode(mode: ndspClippingMode);
}
extern "C" {
    #[doc = "Gets the clipping mode.\n @return The clipping mode."]
    #[doc = ""]
    pub fn ndspGetClippingMode() -> ndspClippingMode;
}
extern "C" {
    #[doc = "Sets the output count.\n @param count Output count to set. Defaults to 2."]
    #[doc = ""]
    pub fn ndspSetOutputCount(count: ::libc::c_int);
}
extern "C" {
    #[doc = "Gets the output count.\n @return The output count."]
    #[doc = ""]
    pub fn ndspGetOutputCount() -> ::libc::c_int;
}
extern "C" {
    #[doc = "Sets the wave buffer to capture audio to.\n @param capture Wave buffer to capture to."]
    #[doc = ""]
    pub fn ndspSetCapture(capture: *mut ndspWaveBuf);
}
extern "C" {
    #[doc = "Sets the sound frame callback.\n @param callback Callback to set.\n @param data User-defined data to pass to the callback."]
    #[doc = ""]
    pub fn ndspSetCallback(callback: ndspCallback, data: *mut ::libc::c_void);
}
extern "C" {
    #[doc = "# Surround\n@{\n**\n* @brief Sets the surround sound depth.\n* @param depth Depth to set. Defaults to 0x7FFF.\n*/"]
    #[doc = ""]
    pub fn ndspSurroundSetDepth(depth: u16_);
}
extern "C" {
    #[doc = "Gets the surround sound depth.\n @return The surround sound depth."]
    #[doc = ""]
    pub fn ndspSurroundGetDepth() -> u16_;
}
extern "C" {
    #[doc = "Sets the surround sound position.\n @param pos Position to set. Defaults to NDSP_SPKPOS_SQUARE."]
    #[doc = ""]
    pub fn ndspSurroundSetPos(pos: ndspSpeakerPos);
}
extern "C" {
    #[doc = "Gets the surround sound position.\n @return The surround sound speaker position."]
    #[doc = ""]
    pub fn ndspSurroundGetPos() -> ndspSpeakerPos;
}
extern "C" {
    #[doc = "Sets the surround sound rear ratio.\n @param ratio Rear ratio to set. Defaults to 0x8000."]
    #[doc = ""]
    pub fn ndspSurroundSetRearRatio(ratio: u16_);
}
extern "C" {
    #[doc = "Gets the surround sound rear ratio.\n @return The rear ratio."]
    #[doc = ""]
    pub fn ndspSurroundGetRearRatio() -> u16_;
}
extern "C" {
    #[doc = "# Auxiliary output\n@{\n**\n* @brief Configures whether an auxiliary output is enabled.\n* @param id ID of the auxiliary output.\n* @param enable Whether to enable the auxiliary output.\n*/"]
    #[doc = ""]
    pub fn ndspAuxSetEnable(id: ::libc::c_int, enable: bool);
}
extern "C" {
    #[doc = "Gets whether auxiliary output is enabled.\n @param id ID of the auxiliary output.\n @return Whether auxiliary output is enabled."]
    #[doc = ""]
    pub fn ndspAuxIsEnabled(id: ::libc::c_int) -> bool;
}
extern "C" {
    #[doc = "Configures whether an auxiliary output should use front bypass.\n @param id ID of the auxiliary output.\n @param bypass Whether to use front bypass."]
    #[doc = ""]
    pub fn ndspAuxSetFrontBypass(id: ::libc::c_int, bypass: bool);
}
extern "C" {
    #[doc = "Gets whether auxiliary output front bypass is enabled.\n @param id ID of the auxiliary output.\n @return Whether auxiliary output front bypass is enabled."]
    #[doc = ""]
    pub fn ndspAuxGetFrontBypass(id: ::libc::c_int) -> bool;
}
extern "C" {
    #[doc = "Sets the volume of an auxiliary output.\n @param id ID of the auxiliary output.\n @param volume Volume to set."]
    #[doc = ""]
    pub fn ndspAuxSetVolume(id: ::libc::c_int, volume: f32);
}
extern "C" {
    #[doc = "Gets the volume of an auxiliary output.\n @param id ID of the auxiliary output.\n @return Volume of the auxiliary output."]
    #[doc = ""]
    pub fn ndspAuxGetVolume(id: ::libc::c_int) -> f32;
}
extern "C" {
    #[doc = "Sets the callback of an auxiliary output.\n @param id ID of the auxiliary output.\n @param callback Callback to set.\n @param data User-defined data to pass to the callback."]
    #[doc = ""]
    pub fn ndspAuxSetCallback(
        id: ::libc::c_int,
        callback: ndspAuxCallback,
        data: *mut ::libc::c_void,
    );
}
#[doc = "PCM8"]
#[doc = ""]

pub const NDSP_ENCODING_PCM8: _bindgen_ty_30 = 0;
#[doc = "PCM16"]
#[doc = ""]

pub const NDSP_ENCODING_PCM16: _bindgen_ty_30 = 1;
#[doc = "DSPADPCM (GameCube format)"]
#[doc = ""]

pub const NDSP_ENCODING_ADPCM: _bindgen_ty_30 = 2;
#[doc = "# Data types\n@{\n Supported sample encodings."]
#[doc = ""]

pub type _bindgen_ty_30 = ::libc::c_uint;
#[doc = "Buffer contains Mono PCM8."]
#[doc = ""]

pub const NDSP_FORMAT_MONO_PCM8: _bindgen_ty_31 = 1;
#[doc = "Buffer contains Mono PCM16."]
#[doc = ""]

pub const NDSP_FORMAT_MONO_PCM16: _bindgen_ty_31 = 5;
#[doc = "Buffer contains Mono ADPCM."]
#[doc = ""]

pub const NDSP_FORMAT_MONO_ADPCM: _bindgen_ty_31 = 9;
#[doc = "Buffer contains Stereo PCM8."]
#[doc = ""]

pub const NDSP_FORMAT_STEREO_PCM8: _bindgen_ty_31 = 2;
#[doc = "Buffer contains Stereo PCM16."]
#[doc = ""]

pub const NDSP_FORMAT_STEREO_PCM16: _bindgen_ty_31 = 6;
#[doc = "(Alias) Buffer contains Mono PCM8."]
#[doc = ""]

pub const NDSP_FORMAT_PCM8: _bindgen_ty_31 = 1;
#[doc = "(Alias) Buffer contains Mono PCM16."]
#[doc = ""]

pub const NDSP_FORMAT_PCM16: _bindgen_ty_31 = 5;
#[doc = "(Alias) Buffer contains Mono ADPCM."]
#[doc = ""]

pub const NDSP_FORMAT_ADPCM: _bindgen_ty_31 = 9;
#[doc = "Front bypass."]
#[doc = ""]

pub const NDSP_FRONT_BYPASS: _bindgen_ty_31 = 16;
#[doc = "(?) Unknown, under research"]
#[doc = ""]

pub const NDSP_3D_SURROUND_PREPROCESSED: _bindgen_ty_31 = 64;
#[doc = "Channel format flags for use with ndspChnSetFormat."]
#[doc = ""]

pub type _bindgen_ty_31 = ::libc::c_uint;
#[doc = "Polyphase interpolation"]
#[doc = ""]

pub const NDSP_INTERP_POLYPHASE: ndspInterpType = 0;
#[doc = "Linear interpolation"]
#[doc = ""]

pub const NDSP_INTERP_LINEAR: ndspInterpType = 1;
#[doc = "No interpolation"]
#[doc = ""]

pub const NDSP_INTERP_NONE: ndspInterpType = 2;
#[doc = "Interpolation types."]
#[doc = ""]

pub type ndspInterpType = ::libc::c_uint;
extern "C" {
    #[doc = "# Basic channel operation\n@{\n**\n* @brief Resets a channel.\n* @param id ID of the channel (0..23).\n*/"]
    #[doc = ""]
    pub fn ndspChnReset(id: ::libc::c_int);
}
extern "C" {
    #[doc = "Initializes the parameters of a channel.\n @param id ID of the channel (0..23)."]
    #[doc = ""]
    pub fn ndspChnInitParams(id: ::libc::c_int);
}
extern "C" {
    #[doc = "Checks whether a channel is currently playing.\n @param id ID of the channel (0..23).\n @return Whether the channel is currently playing."]
    #[doc = ""]
    pub fn ndspChnIsPlaying(id: ::libc::c_int) -> bool;
}
extern "C" {
    #[doc = "Gets the current sample position of a channel.\n @param id ID of the channel (0..23).\n @return The channel's sample position."]
    #[doc = ""]
    pub fn ndspChnGetSamplePos(id: ::libc::c_int) -> u32_;
}
extern "C" {
    #[doc = "Gets the sequence ID of the wave buffer that is currently playing in a channel.\n @param id ID of the channel (0..23).\n @return The sequence ID of the wave buffer."]
    #[doc = ""]
    pub fn ndspChnGetWaveBufSeq(id: ::libc::c_int) -> u16_;
}
extern "C" {
    #[doc = "Checks whether a channel is currently paused.\n @param id ID of the channel (0..23).\n @return Whether the channel is currently paused."]
    #[doc = ""]
    pub fn ndspChnIsPaused(id: ::libc::c_int) -> bool;
}
extern "C" {
    #[doc = "Sets the pause status of a channel.\n @param id ID of the channel (0..23).\n @param paused Whether the channel is to be paused (true) or unpaused (false)."]
    #[doc = ""]
    pub fn ndspChnSetPaused(id: ::libc::c_int, paused: bool);
}
extern "C" {
    #[doc = "# Configuration\n@{\n**\n* @brief Sets the format of a channel.\n* @param id ID of the channel (0..23).\n* @param format Format to use.\n*/"]
    #[doc = ""]
    pub fn ndspChnSetFormat(id: ::libc::c_int, format: u16_);
}
extern "C" {
    #[doc = "Gets the format of a channel.\n @param id ID of the channel (0..23).\n @return The format of the channel."]
    #[doc = ""]
    pub fn ndspChnGetFormat(id: ::libc::c_int) -> u16_;
}
extern "C" {
    #[doc = "Sets the interpolation type of a channel.\n @param id ID of the channel (0..23).\n @param type Interpolation type to use."]
    #[doc = ""]
    pub fn ndspChnSetInterp(id: ::libc::c_int, type_: ndspInterpType);
}
extern "C" {
    #[doc = "Gets the interpolation type of a channel.\n @param id ID of the channel (0..23).\n @return The interpolation type of the channel."]
    #[doc = ""]
    pub fn ndspChnGetInterp(id: ::libc::c_int) -> ndspInterpType;
}
extern "C" {
    #[doc = "Sets the sample rate of a channel.\n @param id ID of the channel (0..23).\n @param rate Sample rate to use."]
    #[doc = ""]
    pub fn ndspChnSetRate(id: ::libc::c_int, rate: f32);
}
extern "C" {
    #[doc = "Gets the sample rate of a channel.\n @param id ID of the channel (0..23).\n @return The sample rate of the channel."]
    #[doc = ""]
    pub fn ndspChnGetRate(id: ::libc::c_int) -> f32;
}
extern "C" {
    #[doc = "Sets the mix parameters (volumes) of a channel.\n @param id ID of the channel (0..23).\n @param mix Mix parameters to use. Working hypothesis:\n - 0: Front left volume.\n - 1: Front right volume.\n - 2: Back left volume:\n - 3: Back right volume:\n - 4..7: Same as 0..3, but for auxiliary output 0.\n - 8..11: Same as 0..3, but for auxiliary output 1."]
    #[doc = ""]
    pub fn ndspChnSetMix(id: ::libc::c_int, mix: *mut f32);
}
extern "C" {
    #[doc = "Gets the mix parameters (volumes) of a channel.\n @param id ID of the channel (0..23)\n @param mix Mix parameters to write out to. See [`ndspChnSetMix`]"]
    #[doc = ""]
    pub fn ndspChnGetMix(id: ::libc::c_int, mix: *mut f32);
}
extern "C" {
    #[doc = "Sets the DSPADPCM coefficients of a channel.\n @param id ID of the channel (0..23).\n @param coefs DSPADPCM coefficients to use."]
    #[doc = ""]
    pub fn ndspChnSetAdpcmCoefs(id: ::libc::c_int, coefs: *mut u16_);
}
extern "C" {
    #[doc = "# Wave buffers\n@{\n**\n* @brief Clears the wave buffer queue of a channel and stops playback.\n* @param id ID of the channel (0..23).\n*/"]
    #[doc = ""]
    pub fn ndspChnWaveBufClear(id: ::libc::c_int);
}
extern "C" {
    #[doc = "Adds a wave buffer to the wave buffer queue of a channel.\n @remark If the channel's wave buffer queue was empty before the use of this function, playback is started.\n @param id ID of the channel (0..23).\n @param buf Wave buffer to add."]
    #[doc = ""]
    pub fn ndspChnWaveBufAdd(id: ::libc::c_int, buf: *mut ndspWaveBuf);
}
extern "C" {
    #[doc = "# IIR filters\n@{\n**\n* @brief Configures whether the IIR monopole filter of a channel is enabled.\n* @param id ID of the channel (0..23).\n* @param enable Whether to enable the IIR monopole filter.\n*/"]
    #[doc = ""]
    pub fn ndspChnIirMonoSetEnable(id: ::libc::c_int, enable: bool);
}
extern "C" {
    #[doc = "Manually sets up the parameters on monopole filter\n @param id ID of the channel (0..23).\n @param enable Whether to enable the IIR monopole filter."]
    #[doc = ""]
    pub fn ndspChnIirMonoSetParamsCustomFilter(
        id: ::libc::c_int,
        a0: f32,
        a1: f32,
        b0: f32,
    ) -> bool;
}
extern "C" {
    #[doc = "Sets the monopole to be a low pass filter. (Note: This is a lower-quality filter than the biquad one.)\n @param id ID of the channel (0..23).\n @param f0 Low pass cut-off frequency."]
    #[doc = ""]
    pub fn ndspChnIirMonoSetParamsLowPassFilter(id: ::libc::c_int, f0: f32) -> bool;
}
extern "C" {
    #[doc = "Sets the monopole to be a high pass filter. (Note: This is a lower-quality filter than the biquad one.)\n @param id ID of the channel (0..23).\n @param f0 High pass cut-off frequency."]
    #[doc = ""]
    pub fn ndspChnIirMonoSetParamsHighPassFilter(id: ::libc::c_int, f0: f32) -> bool;
}
extern "C" {
    #[doc = "Configures whether the IIR biquad filter of a channel is enabled.\n @param id ID of the channel (0..23).\n @param enable Whether to enable the IIR biquad filter."]
    #[doc = ""]
    pub fn ndspChnIirBiquadSetEnable(id: ::libc::c_int, enable: bool);
}
extern "C" {
    #[doc = "Manually sets up the parameters of the biquad filter\n @param id ID of the channel (0..23)."]
    #[doc = ""]
    pub fn ndspChnIirBiquadSetParamsCustomFilter(
        id: ::libc::c_int,
        a0: f32,
        a1: f32,
        a2: f32,
        b0: f32,
        b1: f32,
        b2: f32,
    ) -> bool;
}
extern "C" {
    #[doc = "Sets the biquad to be a low pass filter.\n @param id ID of the channel (0..23).\n @param f0 Low pass cut-off frequency.\n @param Q \"Quality factor\", typically should be sqrt(2)/2 (i.e. 0.7071)."]
    #[doc = ""]
    pub fn ndspChnIirBiquadSetParamsLowPassFilter(id: ::libc::c_int, f0: f32, Q: f32) -> bool;
}
extern "C" {
    #[doc = "Sets the biquad to be a high pass filter.\n @param id ID of the channel (0..23).\n @param f0 High pass cut-off frequency.\n @param Q \"Quality factor\", typically should be sqrt(2)/2 (i.e. 0.7071)."]
    #[doc = ""]
    pub fn ndspChnIirBiquadSetParamsHighPassFilter(id: ::libc::c_int, f0: f32, Q: f32) -> bool;
}
extern "C" {
    #[doc = "Sets the biquad to be a band pass filter.\n @param id ID of the channel (0..23).\n @param f0 Mid-frequency.\n @param Q \"Quality factor\", typically should be sqrt(2)/2 (i.e. 0.7071)."]
    #[doc = ""]
    pub fn ndspChnIirBiquadSetParamsBandPassFilter(id: ::libc::c_int, f0: f32, Q: f32) -> bool;
}
extern "C" {
    #[doc = "Sets the biquad to be a notch filter.\n @param id ID of the channel (0..23).\n @param f0 Notch frequency.\n @param Q \"Quality factor\", typically should be sqrt(2)/2 (i.e. 0.7071)."]
    #[doc = ""]
    pub fn ndspChnIirBiquadSetParamsNotchFilter(id: ::libc::c_int, f0: f32, Q: f32) -> bool;
}
extern "C" {
    #[doc = "Sets the biquad to be a peaking equalizer.\n @param id ID of the channel (0..23).\n @param f0 Central frequency.\n @param Q \"Quality factor\", typically should be sqrt(2)/2 (i.e. 0.7071).\n @param gain Amount of gain (raw value = 10 ^ dB/40)"]
    #[doc = ""]
    pub fn ndspChnIirBiquadSetParamsPeakingEqualizer(
        id: ::libc::c_int,
        f0: f32,
        Q: f32,
        gain: f32,
    ) -> bool;
}
#[doc = "Normal keyboard with several pages (QWERTY/accents/symbol/mobile)"]
#[doc = ""]

pub const SWKBD_TYPE_NORMAL: SwkbdType = 0;
#[doc = "QWERTY keyboard only."]
#[doc = ""]

pub const SWKBD_TYPE_QWERTY: SwkbdType = 1;
#[doc = "Number pad."]
#[doc = ""]

pub const SWKBD_TYPE_NUMPAD: SwkbdType = 2;
#[doc = "On JPN systems, a text keyboard without Japanese input capabilities, otherwise same as SWKBD_TYPE_NORMAL."]
#[doc = ""]

pub const SWKBD_TYPE_WESTERN: SwkbdType = 3;
#[doc = "Keyboard types."]
#[doc = ""]

pub type SwkbdType = ::libc::c_uint;
#[doc = "All inputs are accepted."]
#[doc = ""]

pub const SWKBD_ANYTHING: SwkbdValidInput = 0;
#[doc = "Empty inputs are not accepted."]
#[doc = ""]

pub const SWKBD_NOTEMPTY: SwkbdValidInput = 1;
#[doc = "Empty or blank inputs (consisting solely of whitespace) are not accepted."]
#[doc = ""]

pub const SWKBD_NOTEMPTY_NOTBLANK: SwkbdValidInput = 2;
pub const SWKBD_NOTBLANK_NOTEMPTY: SwkbdValidInput = 2;
#[doc = "Blank inputs (consisting solely of whitespace) are not accepted, but empty inputs are."]
#[doc = ""]

pub const SWKBD_NOTBLANK: SwkbdValidInput = 3;
#[doc = "The input must have a fixed length (specified by maxTextLength in swkbdInit)."]
#[doc = ""]

pub const SWKBD_FIXEDLEN: SwkbdValidInput = 4;
#[doc = "Accepted input types."]
#[doc = ""]

pub type SwkbdValidInput = ::libc::c_uint;
#[doc = "Left button (usually Cancel)"]
#[doc = ""]

pub const SWKBD_BUTTON_LEFT: SwkbdButton = 0;
#[doc = "Middle button (usually I Forgot)"]
#[doc = ""]

pub const SWKBD_BUTTON_MIDDLE: SwkbdButton = 1;
#[doc = "Right button (usually OK)"]
#[doc = ""]

pub const SWKBD_BUTTON_RIGHT: SwkbdButton = 2;
pub const SWKBD_BUTTON_CONFIRM: SwkbdButton = 2;
#[doc = "No button (returned by swkbdInputText in special cases)"]
#[doc = ""]

pub const SWKBD_BUTTON_NONE: SwkbdButton = 3;
#[doc = "Keyboard dialog buttons."]
#[doc = ""]

pub type SwkbdButton = ::libc::c_uint;
#[doc = "Characters are not concealed."]
#[doc = ""]

pub const SWKBD_PASSWORD_NONE: SwkbdPasswordMode = 0;
#[doc = "Characters are concealed immediately."]
#[doc = ""]

pub const SWKBD_PASSWORD_HIDE: SwkbdPasswordMode = 1;
#[doc = "Characters are concealed a second after they've been typed."]
#[doc = ""]

pub const SWKBD_PASSWORD_HIDE_DELAY: SwkbdPasswordMode = 2;
#[doc = "Keyboard password modes."]
#[doc = ""]

pub type SwkbdPasswordMode = ::libc::c_uint;
#[doc = "Disallow the use of more than a certain number of digits (0 or more)"]
#[doc = ""]

pub const SWKBD_FILTER_DIGITS: _bindgen_ty_32 = 1;
#[doc = "Disallow the use of the @ sign."]
#[doc = ""]

pub const SWKBD_FILTER_AT: _bindgen_ty_32 = 2;
#[doc = "Disallow the use of the % sign."]
#[doc = ""]

pub const SWKBD_FILTER_PERCENT: _bindgen_ty_32 = 4;
#[doc = "Disallow the use of the \\ sign."]
#[doc = ""]

pub const SWKBD_FILTER_BACKSLASH: _bindgen_ty_32 = 8;
#[doc = "Disallow profanity using Nintendo's profanity filter."]
#[doc = ""]

pub const SWKBD_FILTER_PROFANITY: _bindgen_ty_32 = 16;
#[doc = "Use a callback in order to check the input."]
#[doc = ""]

pub const SWKBD_FILTER_CALLBACK: _bindgen_ty_32 = 32;
#[doc = "Keyboard input filtering flags."]
#[doc = ""]

pub type _bindgen_ty_32 = ::libc::c_uint;
#[doc = "Parental PIN mode."]
#[doc = ""]

pub const SWKBD_PARENTAL: _bindgen_ty_33 = 1;
#[doc = "Darken the top screen when the keyboard is shown."]
#[doc = ""]

pub const SWKBD_DARKEN_TOP_SCREEN: _bindgen_ty_33 = 2;
#[doc = "Enable predictive input (necessary for Kanji input in JPN systems)."]
#[doc = ""]

pub const SWKBD_PREDICTIVE_INPUT: _bindgen_ty_33 = 4;
#[doc = "Enable multiline input."]
#[doc = ""]

pub const SWKBD_MULTILINE: _bindgen_ty_33 = 8;
#[doc = "Enable fixed-width mode."]
#[doc = ""]

pub const SWKBD_FIXED_WIDTH: _bindgen_ty_33 = 16;
#[doc = "Allow the usage of the HOME button."]
#[doc = ""]

pub const SWKBD_ALLOW_HOME: _bindgen_ty_33 = 32;
#[doc = "Allow the usage of a software-reset combination."]
#[doc = ""]

pub const SWKBD_ALLOW_RESET: _bindgen_ty_33 = 64;
#[doc = "Allow the usage of the POWER button."]
#[doc = ""]

pub const SWKBD_ALLOW_POWER: _bindgen_ty_33 = 128;
#[doc = "Default to the QWERTY page when the keyboard is shown."]
#[doc = ""]

pub const SWKBD_DEFAULT_QWERTY: _bindgen_ty_33 = 512;
#[doc = "Keyboard features."]
#[doc = ""]

pub type _bindgen_ty_33 = ::libc::c_uint;
#[doc = "Specifies that the input is valid."]
#[doc = ""]

pub const SWKBD_CALLBACK_OK: SwkbdCallbackResult = 0;
#[doc = "Displays an error message, then closes the keyboard."]
#[doc = ""]

pub const SWKBD_CALLBACK_CLOSE: SwkbdCallbackResult = 1;
#[doc = "Displays an error message and continues displaying the keyboard."]
#[doc = ""]

pub const SWKBD_CALLBACK_CONTINUE: SwkbdCallbackResult = 2;
#[doc = "Keyboard filter callback return values."]
#[doc = ""]

pub type SwkbdCallbackResult = ::libc::c_uint;
#[doc = "Dummy/unused."]
#[doc = ""]

pub const SWKBD_NONE: SwkbdResult = -1;
#[doc = "Invalid parameters to swkbd."]
#[doc = ""]

pub const SWKBD_INVALID_INPUT: SwkbdResult = -2;
#[doc = "Out of memory."]
#[doc = ""]

pub const SWKBD_OUTOFMEM: SwkbdResult = -3;
#[doc = "The button was clicked in 1-button dialogs."]
#[doc = ""]

pub const SWKBD_D0_CLICK: SwkbdResult = 0;
#[doc = "The left button was clicked in 2-button dialogs."]
#[doc = ""]

pub const SWKBD_D1_CLICK0: SwkbdResult = 1;
#[doc = "The right button was clicked in 2-button dialogs."]
#[doc = ""]

pub const SWKBD_D1_CLICK1: SwkbdResult = 2;
#[doc = "The left button was clicked in 3-button dialogs."]
#[doc = ""]

pub const SWKBD_D2_CLICK0: SwkbdResult = 3;
#[doc = "The middle button was clicked in 3-button dialogs."]
#[doc = ""]

pub const SWKBD_D2_CLICK1: SwkbdResult = 4;
#[doc = "The right button was clicked in 3-button dialogs."]
#[doc = ""]

pub const SWKBD_D2_CLICK2: SwkbdResult = 5;
#[doc = "The HOME button was pressed."]
#[doc = ""]

pub const SWKBD_HOMEPRESSED: SwkbdResult = 10;
#[doc = "The soft-reset key combination was pressed."]
#[doc = ""]

pub const SWKBD_RESETPRESSED: SwkbdResult = 11;
#[doc = "The POWER button was pressed."]
#[doc = ""]

pub const SWKBD_POWERPRESSED: SwkbdResult = 12;
#[doc = "The parental PIN was verified successfully."]
#[doc = ""]

pub const SWKBD_PARENTAL_OK: SwkbdResult = 20;
#[doc = "The parental PIN was incorrect."]
#[doc = ""]

pub const SWKBD_PARENTAL_FAIL: SwkbdResult = 21;
#[doc = "The filter callback returned SWKBD_CALLBACK_CLOSE."]
#[doc = ""]

pub const SWKBD_BANNED_INPUT: SwkbdResult = 30;
#[doc = "Keyboard return values."]
#[doc = ""]

pub type SwkbdResult = ::libc::c_int;
#[doc = "Keyboard dictionary word for predictive input."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SwkbdDictWord {
    #[doc = "Reading of the word (that is, the string that needs to be typed)."]
    #[doc = ""]
    pub reading: [u16_; 41usize],
    #[doc = "Spelling of the word."]
    #[doc = ""]
    pub word: [u16_; 41usize],
    #[doc = "Language the word applies to."]
    #[doc = ""]
    pub language: u8_,
    #[doc = "Specifies if the word applies to all languages."]
    #[doc = ""]
    pub all_languages: bool,
}
impl Default for SwkbdDictWord {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Keyboard filter callback function."]
#[doc = ""]

pub type SwkbdCallbackFn = ::core::option::Option<
    unsafe extern "C" fn(
        user: *mut ::libc::c_void,
        ppMessage: *mut *const ::libc::c_char,
        text: *const ::libc::c_char,
        textlen: usize,
    ) -> SwkbdCallbackResult,
>;
#[doc = "Keyboard status data."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SwkbdStatusData {
    pub data: [u32_; 17usize],
}
#[doc = "Keyboard predictive input learning data."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SwkbdLearningData {
    pub data: [u32_; 10523usize],
}
impl Default for SwkbdLearningData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Internal libctru book-keeping structure for software keyboards."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SwkbdExtra {
    pub initial_text: *const ::libc::c_char,
    pub dict: *const SwkbdDictWord,
    pub status_data: *mut SwkbdStatusData,
    pub learning_data: *mut SwkbdLearningData,
    pub callback: SwkbdCallbackFn,
    pub callback_user: *mut ::libc::c_void,
}
impl Default for SwkbdExtra {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Software keyboard parameter structure, it shouldn't be modified directly."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SwkbdState {
    pub type_: ::libc::c_int,
    pub num_buttons_m1: ::libc::c_int,
    pub valid_input: ::libc::c_int,
    pub password_mode: ::libc::c_int,
    pub is_parental_screen: ::libc::c_int,
    pub darken_top_screen: ::libc::c_int,
    pub filter_flags: u32_,
    pub save_state_flags: u32_,
    pub max_text_len: u16_,
    pub dict_word_count: u16_,
    pub max_digits: u16_,
    pub button_text: [[u16_; 17usize]; 3usize],
    pub numpad_keys: [u16_; 2usize],
    pub hint_text: [u16_; 65usize],
    pub predictive_input: bool,
    pub multiline: bool,
    pub fixed_width: bool,
    pub allow_home: bool,
    pub allow_reset: bool,
    pub allow_power: bool,
    pub unknown: bool,
    pub default_qwerty: bool,
    pub button_submits_text: [bool; 4usize],
    pub language: u16_,
    pub initial_text_offset: ::libc::c_int,
    pub dict_offset: ::libc::c_int,
    pub initial_status_offset: ::libc::c_int,
    pub initial_learning_offset: ::libc::c_int,
    pub shared_memory_size: usize,
    pub version: u32_,
    pub result: SwkbdResult,
    pub status_offset: ::libc::c_int,
    pub learning_offset: ::libc::c_int,
    pub text_offset: ::libc::c_int,
    pub text_length: u16_,
    pub callback_result: ::libc::c_int,
    pub callback_msg: [u16_; 257usize],
    pub skip_at_check: bool,
    pub __bindgen_anon_1: SwkbdState__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SwkbdState__bindgen_ty_1 {
    pub reserved: [u8_; 171usize],
    pub extra: SwkbdExtra,
}
impl Default for SwkbdState__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for SwkbdState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = "Initializes software keyboard status.\n @param swkbd Pointer to swkbd state.\n @param type Keyboard type.\n @param numButtons Number of dialog buttons to display (1, 2 or 3).\n @param maxTextLength Maximum number of UTF-16 code units that input text can have (or -1 to let libctru use a big default)."]
    #[doc = ""]
    pub fn swkbdInit(
        swkbd: *mut SwkbdState,
        type_: SwkbdType,
        numButtons: ::libc::c_int,
        maxTextLength: ::libc::c_int,
    );
}
extern "C" {
    #[doc = "Specifies which special features are enabled in a software keyboard.\n @param swkbd Pointer to swkbd state.\n @param features Feature bitmask."]
    #[doc = ""]
    pub fn swkbdSetFeatures(swkbd: *mut SwkbdState, features: u32_);
}
extern "C" {
    #[doc = "Sets the hint text of a software keyboard (that is, the help text that is displayed when the textbox is empty).\n @param swkbd Pointer to swkbd state.\n @param text Hint text."]
    #[doc = ""]
    pub fn swkbdSetHintText(swkbd: *mut SwkbdState, text: *const ::libc::c_char);
}
extern "C" {
    #[doc = "Configures a dialog button in a software keyboard.\n @param swkbd Pointer to swkbd state.\n @param button Specifies which button to configure.\n @param text Button text.\n @param submit Specifies whether pushing the button will submit the text or discard it."]
    #[doc = ""]
    pub fn swkbdSetButton(
        swkbd: *mut SwkbdState,
        button: SwkbdButton,
        text: *const ::libc::c_char,
        submit: bool,
    );
}
extern "C" {
    #[doc = "Sets the initial text that a software keyboard will display on launch.\n @param swkbd Pointer to swkbd state.\n @param text Initial text."]
    #[doc = ""]
    pub fn swkbdSetInitialText(swkbd: *mut SwkbdState, text: *const ::libc::c_char);
}
extern "C" {
    #[doc = "Configures a word in a predictive dictionary for use with a software keyboard.\n @param word Pointer to dictionary word structure.\n @param reading Reading of the word, that is, the sequence of characters that need to be typed to trigger the word in the predictive input system.\n @param text Spelling of the word, that is, the actual characters that will be produced when the user decides to select the word."]
    #[doc = ""]
    pub fn swkbdSetDictWord(
        word: *mut SwkbdDictWord,
        reading: *const ::libc::c_char,
        text: *const ::libc::c_char,
    );
}
extern "C" {
    #[doc = "Sets the custom word dictionary to be used with the predictive input system of a software keyboard.\n @param swkbd Pointer to swkbd state.\n @param dict Pointer to dictionary words.\n @param wordCount Number of words in the dictionary."]
    #[doc = ""]
    pub fn swkbdSetDictionary(
        swkbd: *mut SwkbdState,
        dict: *const SwkbdDictWord,
        wordCount: ::libc::c_int,
    );
}
extern "C" {
    #[doc = "Configures software keyboard internal status management.\n @param swkbd Pointer to swkbd state.\n @param data Pointer to internal status structure (can be in, out or both depending on the other parameters).\n @param in Specifies whether the data should be read from the structure when the keyboard is launched.\n @param out Specifies whether the data should be written to the structure when the keyboard is closed."]
    #[doc = ""]
    pub fn swkbdSetStatusData(
        swkbd: *mut SwkbdState,
        data: *mut SwkbdStatusData,
        in_: bool,
        out: bool,
    );
}
extern "C" {
    #[doc = "Configures software keyboard predictive input learning data management.\n @param swkbd Pointer to swkbd state.\n @param data Pointer to learning data structure (can be in, out or both depending on the other parameters).\n @param in Specifies whether the data should be read from the structure when the keyboard is launched.\n @param out Specifies whether the data should be written to the structure when the keyboard is closed."]
    #[doc = ""]
    pub fn swkbdSetLearningData(
        swkbd: *mut SwkbdState,
        data: *mut SwkbdLearningData,
        in_: bool,
        out: bool,
    );
}
extern "C" {
    #[doc = "Configures a custom function to be used to check the validity of input when it is submitted in a software keyboard.\n @param swkbd Pointer to swkbd state.\n @param callback Filter callback function.\n @param user Custom data to be passed to the callback function."]
    #[doc = ""]
    pub fn swkbdSetFilterCallback(
        swkbd: *mut SwkbdState,
        callback: SwkbdCallbackFn,
        user: *mut ::libc::c_void,
    );
}
extern "C" {
    #[doc = "Launches a software keyboard in order to input text.\n @param swkbd Pointer to swkbd state.\n @param buf Pointer to output buffer which will hold the inputted text.\n @param bufsize Maximum number of UTF-8 code units that the buffer can hold (including null terminator).\n @return The identifier of the dialog button that was pressed, or SWKBD_BUTTON_NONE if a different condition was triggered - in that case use swkbdGetResult to check the condition."]
    #[doc = ""]
    pub fn swkbdInputText(
        swkbd: *mut SwkbdState,
        buf: *mut ::libc::c_char,
        bufsize: usize,
    ) -> SwkbdButton;
}
#[doc = "<??-Unknown flag"]
#[doc = ""]

pub const ERROR_LANGUAGE_FLAG: _bindgen_ty_34 = 256;
#[doc = "<??-Unknown flag"]
#[doc = ""]

pub const ERROR_WORD_WRAP_FLAG: _bindgen_ty_34 = 512;
pub type _bindgen_ty_34 = ::libc::c_uint;
#[doc = "Displays the infrastructure communications-related error message corresponding to the error code."]
#[doc = ""]

pub const ERROR_CODE: errorType = 0;
#[doc = "Displays text passed to this applet."]
#[doc = ""]

pub const ERROR_TEXT: errorType = 1;
#[doc = "Displays the EULA"]
#[doc = ""]

pub const ERROR_EULA: errorType = 2;
#[doc = "Use prohibited."]
#[doc = ""]

pub const ERROR_TYPE_EULA_FIRST_BOOT: errorType = 3;
#[doc = "Use prohibited."]
#[doc = ""]

pub const ERROR_TYPE_EULA_DRAW_ONLY: errorType = 4;
#[doc = "Use prohibited."]
#[doc = ""]

pub const ERROR_TYPE_AGREE: errorType = 5;
#[doc = "Displays a network error message in a specified language."]
#[doc = ""]

pub const ERROR_CODE_LANGUAGE: errorType = 256;
#[doc = "Displays text passed to this applet in a specified language."]
#[doc = ""]

pub const ERROR_TEXT_LANGUAGE: errorType = 257;
#[doc = "Displays EULA in a specified language."]
#[doc = ""]

pub const ERROR_EULA_LANGUAGE: errorType = 258;
#[doc = "Displays the custom error message passed to this applet with automatic line wrapping"]
#[doc = ""]

pub const ERROR_TEXT_WORD_WRAP: errorType = 513;
#[doc = "Displays the custom error message with automatic line wrapping and in the specified language."]
#[doc = ""]

pub const ERROR_TEXT_LANGUAGE_WORD_WRAP: errorType = 769;
pub type errorType = ::libc::c_uint;
pub const ERROR_NORMAL: errorScreenFlag = 0;
pub const ERROR_STEREO: errorScreenFlag = 1;
pub type errorScreenFlag = ::libc::c_uint;
pub const ERROR_UNKNOWN: errorReturnCode = -1;
pub const ERROR_NONE: errorReturnCode = 0;
pub const ERROR_SUCCESS: errorReturnCode = 1;
pub const ERROR_NOT_SUPPORTED: errorReturnCode = 2;
pub const ERROR_HOME_BUTTON: errorReturnCode = 10;
pub const ERROR_SOFTWARE_RESET: errorReturnCode = 11;
pub const ERROR_POWER_BUTTON: errorReturnCode = 12;
pub type errorReturnCode = ::libc::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct errorConf {
    pub type_: errorType,
    pub errorCode: ::libc::c_int,
    pub upperScreenFlag: errorScreenFlag,
    pub useLanguage: u16_,
    pub Text: [u16_; 1900usize],
    pub homeButton: bool,
    pub softwareReset: bool,
    pub appJump: bool,
    pub returnCode: errorReturnCode,
    pub eulaVersion: u16_,
}
impl Default for errorConf {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = "Init the error applet.\n @param err Pointer to errorConf.\n @param type errorType Type of error.\n @param lang CFG_Language Lang of error."]
    #[doc = ""]
    pub fn errorInit(err: *mut errorConf, type_: errorType, lang: CFG_Language);
}
extern "C" {
    #[doc = "Sets error code to display.\n @param err Pointer to errorConf.\n @param error Error-code to display."]
    #[doc = ""]
    pub fn errorCode(err: *mut errorConf, error: ::libc::c_int);
}
extern "C" {
    #[doc = "Sets error text to display.\n @param err Pointer to errorConf.\n @param text Error-text to display."]
    #[doc = ""]
    pub fn errorText(err: *mut errorConf, text: *const ::libc::c_char);
}
extern "C" {
    #[doc = "Displays the error applet.\n @param err Pointer to errorConf."]
    #[doc = ""]
    pub fn errorDisp(err: *mut errorConf);
}
#[doc = "Parameter structure passed to AppletEd"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MiiSelectorConf {
    #[doc = "Enables canceling of selection if nonzero."]
    #[doc = ""]
    pub enable_cancel_button: u8_,
    #[doc = "Makes Guets Miis selectable if nonzero."]
    #[doc = ""]
    pub enable_selecting_guests: u8_,
    #[doc = "Shows applet on top screen if nonzero,\notherwise show it on the bottom screen."]
    #[doc = ""]
    pub show_on_top_screen: u8_,
    #[doc = "@private"]
    #[doc = ""]
    pub _unk0x3: [u8_; 5usize],
    #[doc = "UTF16-LE string displayed at the top of the applet. If\nset to the empty string, a default title is displayed."]
    #[doc = ""]
    pub title: [u16_; 64usize],
    #[doc = "@private"]
    #[doc = ""]
    pub _unk0x88: [u8_; 4usize],
    #[doc = "If nonzero, the applet shows a page with Guest\nMiis on launch."]
    #[doc = ""]
    pub show_guest_page: u8_,
    #[doc = "@private"]
    #[doc = ""]
    pub _unk0x8D: [u8_; 3usize],
    #[doc = "Index of the initially selected Mii. If\n[`MiiSelectorConf.show_guest_page`] is\nset, this is the index of a Guest Mii,\notherwise that of a user Mii."]
    #[doc = ""]
    pub initial_index: u32_,
    #[doc = "Each byte set to a nonzero value\nenables its corresponding Guest\nMii to be enabled for selection."]
    #[doc = ""]
    pub mii_guest_whitelist: [u8_; 6usize],
    #[doc = "Each byte set to a nonzero value enables\nits corresponding user Mii to be enabled\nfor selection."]
    #[doc = ""]
    pub mii_whitelist: [u8_; 100usize],
    #[doc = "@private"]
    #[doc = ""]
    pub _unk0xFE: u16_,
    #[doc = "Will be set to [`MIISELECTOR_MAGIC`] before launching the\napplet."]
    #[doc = ""]
    pub magic: u32_,
}
impl Default for MiiSelectorConf {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Structure written by AppletEd"]
#[doc = ""]
#[repr(C)]
pub struct MiiSelectorReturn {
    #[doc = "0 if a Mii was selected, 1 if the selection was\ncanceled."]
    #[doc = ""]
    pub no_mii_selected: u32_,
    #[doc = "1 if a Guest Mii was selected, 0 otherwise."]
    #[doc = ""]
    pub guest_mii_was_selected: u32_,
    #[doc = "Index of the selected Guest Mii,\n0xFFFFFFFF if no guest was selected."]
    #[doc = ""]
    pub guest_mii_index: u32_,
    #[doc = "Data of selected Mii."]
    #[doc = ""]
    pub mii: MiiData,
    #[doc = "@private"]
    #[doc = ""]
    pub _pad0x68: u16_,
    #[doc = "Checksum of the returned Mii data.\nStored as a big-endian value; use\n[`miiSelectorChecksumIsValid`] to\nverify."]
    #[doc = ""]
    pub checksum: u16_,
    #[doc = "Localized name of a Guest Mii,\nif one was selected (UTF16-LE\nstring). Zeroed otherwise."]
    #[doc = ""]
    pub guest_mii_name: [u16_; 12usize],
}
impl Default for MiiSelectorReturn {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Show the cancel button"]
#[doc = ""]

pub const MIISELECTOR_CANCEL: _bindgen_ty_35 = 1;
#[doc = "Make Guets Miis selectable"]
#[doc = ""]

pub const MIISELECTOR_GUESTS: _bindgen_ty_35 = 2;
#[doc = "Show AppletEd on top screen"]
#[doc = ""]

pub const MIISELECTOR_TOP: _bindgen_ty_35 = 4;
#[doc = "Start on guest page"]
#[doc = ""]

pub const MIISELECTOR_GUESTSTART: _bindgen_ty_35 = 8;
#[doc = "AppletEd options"]
#[doc = ""]

pub type _bindgen_ty_35 = ::libc::c_uint;
extern "C" {
    #[doc = "Initialize Mii selector config\n @param conf Pointer to Miiselector config."]
    #[doc = ""]
    pub fn miiSelectorInit(conf: *mut MiiSelectorConf);
}
extern "C" {
    #[doc = "Launch the Mii selector library applet\n\n @param conf Configuration determining how the applet should behave"]
    #[doc = ""]
    pub fn miiSelectorLaunch(conf: *const MiiSelectorConf, returnbuf: *mut MiiSelectorReturn);
}
extern "C" {
    #[doc = "Sets title of the Mii selector library applet\n\n @param conf Pointer to miiSelector configuration\n @param text Title text of Mii selector"]
    #[doc = ""]
    pub fn miiSelectorSetTitle(conf: *mut MiiSelectorConf, text: *const ::libc::c_char);
}
extern "C" {
    #[doc = "Specifies which special options are enabled in the Mii selector\n\n @param conf Pointer to miiSelector configuration\n @param options Options bitmask"]
    #[doc = ""]
    pub fn miiSelectorSetOptions(conf: *mut MiiSelectorConf, options: u32_);
}
extern "C" {
    #[doc = "Specifies which guest Miis will be selectable\n\n @param conf Pointer to miiSelector configuration\n @param index Index of the guest Miis that will be whitelisted.\n [`MIISELECTOR_GUESTMII_SLOTS`] can be used to whitelist all the guest Miis."]
    #[doc = ""]
    pub fn miiSelectorWhitelistGuestMii(conf: *mut MiiSelectorConf, index: u32_);
}
extern "C" {
    #[doc = "Specifies which guest Miis will be unselectable\n\n @param conf Pointer to miiSelector configuration\n @param index Index of the guest Miis that will be blacklisted.\n [`MIISELECTOR_GUESTMII_SLOTS`] can be used to blacklist all the guest Miis."]
    #[doc = ""]
    pub fn miiSelectorBlacklistGuestMii(conf: *mut MiiSelectorConf, index: u32_);
}
extern "C" {
    #[doc = "Specifies which user Miis will be selectable\n\n @param conf Pointer to miiSelector configuration\n @param index Index of the user Miis that will be whitelisted.\n [`MIISELECTOR_USERMII_SLOTS`] can be used to whitlist all the user Miis"]
    #[doc = ""]
    pub fn miiSelectorWhitelistUserMii(conf: *mut MiiSelectorConf, index: u32_);
}
extern "C" {
    #[doc = "Specifies which user Miis will be selectable\n\n @param conf Pointer to miiSelector configuration\n @param index Index of the user Miis that will be blacklisted.\n [`MIISELECTOR_USERMII_SLOTS`] can be used to blacklist all the user Miis"]
    #[doc = ""]
    pub fn miiSelectorBlacklistUserMii(conf: *mut MiiSelectorConf, index: u32_);
}
extern "C" {
    #[doc = "Get Mii name\n\n @param returnbuf Pointer to miiSelector return\n @param out String containing a Mii's name\n @param max_size Size of string. Since UTF8 characters range in size from 1-3 bytes\n (assuming that no non-BMP characters are used), this value should be 36 (or 30 if you are not\n dealing with guest miis)."]
    #[doc = ""]
    pub fn miiSelectorReturnGetName(
        returnbuf: *const MiiSelectorReturn,
        out: *mut ::libc::c_char,
        max_size: usize,
    );
}
extern "C" {
    #[doc = "Get Mii Author\n\n @param returnbuf Pointer to miiSelector return\n @param out String containing a Mii's author\n @param max_size Size of string. Since UTF8 characters range in size from 1-3 bytes\n (assuming that no non-BMP characters are used), this value should be 30."]
    #[doc = ""]
    pub fn miiSelectorReturnGetAuthor(
        returnbuf: *const MiiSelectorReturn,
        out: *mut ::libc::c_char,
        max_size: usize,
    );
}
extern "C" {
    #[doc = "Verifies that the Mii data returned from the applet matches its\n checksum\n\n @param returnbuf Buffer filled by Mii selector applet\n @return `true` if `returnbuf->checksum` is the same as the one computed from `returnbuf`"]
    #[doc = ""]
    pub fn miiSelectorChecksumIsValid(returnbuf: *const MiiSelectorReturn) -> bool;
}
#[doc = "Open directory struct"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct archive_dir_t {
    pub magic: u32_,

    pub fd: Handle,
    #[doc = "CTRU handle"]
    #[doc = ""]
    pub index: isize,
    #[doc = "Current entry index"]
    #[doc = ""]
    pub size: usize,
    #[doc = "Current batch size"]
    #[doc = ""]
    pub entry_data: [FS_DirectoryEntry; 32usize],
}
impl Default for archive_dir_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[must_use]
    #[doc = "Mounts the SD"]
    #[doc = ""]
    pub fn archiveMountSdmc() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Mounts and opens an archive as deviceName\n Returns either an archive open error code, or -1 for generic failure"]
    #[doc = ""]
    pub fn archiveMount(
        archiveID: FS_ArchiveID,
        archivePath: FS_Path,
        deviceName: *const ::libc::c_char,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Uses FSUSER_ControlArchive with control action ARCHIVE_ACTION_COMMIT_SAVE_DATA on the opened archive. Not done automatically at unmount.\n Returns -1 if the specified device is not found"]
    #[doc = ""]
    pub fn archiveCommitSaveData(deviceName: *const ::libc::c_char) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Unmounts the specified device, closing its archive in the process\n Returns -1 if the specified device was not found"]
    #[doc = ""]
    pub fn archiveUnmount(deviceName: *const ::libc::c_char) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Unmounts all devices and cleans up any resources used by the driver"]
    #[doc = ""]
    pub fn archiveUnmountAll() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Get a file's mtime"]
    #[doc = ""]
    pub fn archive_getmtime(name: *const ::libc::c_char, mtime: *mut u64_) -> Result;
}
#[doc = "RomFS header."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct romfs_header {
    #[doc = "Size of the header."]
    #[doc = ""]
    pub headerSize: u32_,
    #[doc = "Offset of the directory hash table."]
    #[doc = ""]
    pub dirHashTableOff: u32_,
    #[doc = "Size of the directory hash table."]
    #[doc = ""]
    pub dirHashTableSize: u32_,
    #[doc = "Offset of the directory table."]
    #[doc = ""]
    pub dirTableOff: u32_,
    #[doc = "Size of the directory table."]
    #[doc = ""]
    pub dirTableSize: u32_,
    #[doc = "Offset of the file hash table."]
    #[doc = ""]
    pub fileHashTableOff: u32_,
    #[doc = "Size of the file hash table."]
    #[doc = ""]
    pub fileHashTableSize: u32_,
    #[doc = "Offset of the file table."]
    #[doc = ""]
    pub fileTableOff: u32_,
    #[doc = "Size of the file table."]
    #[doc = ""]
    pub fileTableSize: u32_,
    #[doc = "Offset of the file data."]
    #[doc = ""]
    pub fileDataOff: u32_,
}
#[doc = "RomFS directory."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default)]
pub struct romfs_dir {
    #[doc = "Offset of the parent directory."]
    #[doc = ""]
    pub parent: u32_,
    #[doc = "Offset of the next sibling directory."]
    #[doc = ""]
    pub sibling: u32_,
    #[doc = "Offset of the first child directory."]
    #[doc = ""]
    pub childDir: u32_,
    #[doc = "Offset of the first file."]
    #[doc = ""]
    pub childFile: u32_,
    #[doc = "Directory hash table pointer."]
    #[doc = ""]
    pub nextHash: u32_,
    #[doc = "Name length."]
    #[doc = ""]
    pub nameLen: u32_,
    #[doc = "Name. (UTF-16)"]
    #[doc = ""]
    pub name: __IncompleteArrayField<u16_>,
}
#[doc = "RomFS file."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default)]
pub struct romfs_file {
    #[doc = "Offset of the parent directory."]
    #[doc = ""]
    pub parent: u32_,
    #[doc = "Offset of the next sibling file."]
    #[doc = ""]
    pub sibling: u32_,
    #[doc = "Offset of the file's data."]
    #[doc = ""]
    pub dataOff: u64_,
    #[doc = "Length of the file's data."]
    #[doc = ""]
    pub dataSize: u64_,
    #[doc = "File hash table pointer."]
    #[doc = ""]
    pub nextHash: u32_,
    #[doc = "Name length."]
    #[doc = ""]
    pub nameLen: u32_,
    #[doc = "Name. (UTF-16)"]
    #[doc = ""]
    pub name: __IncompleteArrayField<u16_>,
}
extern "C" {
    #[must_use]
    #[doc = "Mounts the Application's RomFS.\n @param name Device mount name.\n @remark This function is intended to be used to access one's own RomFS.\n If the application is running as 3DSX, it mounts the embedded RomFS section inside the 3DSX.\n If on the other hand it's an NCCH, it behaves identically to [`romfsMountFromCurrentProcess`]"]
    #[doc = ""]
    pub fn romfsMountSelf(name: *const ::libc::c_char) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Mounts RomFS from an open file.\n @param fd FSFILE handle of the RomFS image.\n @param offset Offset of the RomFS within the file.\n @param name Device mount name."]
    #[doc = ""]
    pub fn romfsMountFromFile(fd: Handle, offset: u32_, name: *const ::libc::c_char) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Mounts RomFS using the current process host program RomFS.\n @param name Device mount name."]
    #[doc = ""]
    pub fn romfsMountFromCurrentProcess(name: *const ::libc::c_char) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Mounts RomFS from the specified title.\n @param tid Title ID\n @param mediatype Mediatype\n @param name Device mount name."]
    #[doc = ""]
    pub fn romfsMountFromTitle(
        tid: u64_,
        mediatype: FS_MediaType,
        name: *const ::libc::c_char,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Unmounts the RomFS device."]
    #[doc = ""]
    pub fn romfsUnmount(name: *const ::libc::c_char) -> Result;
}
#[doc = "Character width information structure."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct charWidthInfo_s {
    #[doc = "Horizontal offset to draw the glyph with."]
    #[doc = ""]
    pub left: s8,
    #[doc = "Width of the glyph."]
    #[doc = ""]
    pub glyphWidth: u8_,
    #[doc = "Width of the character, that is, horizontal distance to advance."]
    #[doc = ""]
    pub charWidth: u8_,
}
#[doc = "Font texture sheet information."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TGLP_s {
    #[doc = "Width of a glyph cell."]
    #[doc = ""]
    pub cellWidth: u8_,
    #[doc = "Height of a glyph cell."]
    #[doc = ""]
    pub cellHeight: u8_,
    #[doc = "Vertical position of the baseline."]
    #[doc = ""]
    pub baselinePos: u8_,
    #[doc = "Maximum character width."]
    #[doc = ""]
    pub maxCharWidth: u8_,
    #[doc = "Size in bytes of a texture sheet."]
    #[doc = ""]
    pub sheetSize: u32_,
    #[doc = "Number of texture sheets."]
    #[doc = ""]
    pub nSheets: u16_,
    #[doc = "GPU texture format (GPU_TEXCOLOR)."]
    #[doc = ""]
    pub sheetFmt: u16_,
    #[doc = "Number of glyphs per row per sheet."]
    #[doc = ""]
    pub nRows: u16_,
    #[doc = "Number of glyph rows per sheet."]
    #[doc = ""]
    pub nLines: u16_,
    #[doc = "Texture sheet width."]
    #[doc = ""]
    pub sheetWidth: u16_,
    #[doc = "Texture sheet height."]
    #[doc = ""]
    pub sheetHeight: u16_,
    #[doc = "Pointer to texture sheet data."]
    #[doc = ""]
    pub sheetData: *mut u8_,
}
impl Default for TGLP_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Font character width information block structure."]
#[doc = ""]

pub type CWDH_s = tag_CWDH_s;
#[doc = "Font character width information block structure."]
#[doc = ""]
#[repr(C)]
#[derive(Debug)]
pub struct tag_CWDH_s {
    #[doc = "First Unicode codepoint the block applies to."]
    #[doc = ""]
    pub startIndex: u16_,
    #[doc = "Last Unicode codepoint the block applies to."]
    #[doc = ""]
    pub endIndex: u16_,
    #[doc = "Pointer to the next block."]
    #[doc = ""]
    pub next: *mut CWDH_s,
    #[doc = "Table of character width information structures."]
    #[doc = ""]
    pub widths: __IncompleteArrayField<charWidthInfo_s>,
}
impl Default for tag_CWDH_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Identity mapping."]
#[doc = ""]

pub const CMAP_TYPE_DIRECT: _bindgen_ty_36 = 0;
#[doc = "Mapping using a table."]
#[doc = ""]

pub const CMAP_TYPE_TABLE: _bindgen_ty_36 = 1;
#[doc = "Mapping using a list of mapped characters."]
#[doc = ""]

pub const CMAP_TYPE_SCAN: _bindgen_ty_36 = 2;
#[doc = "Font character map methods."]
#[doc = ""]

pub type _bindgen_ty_36 = ::libc::c_uint;
#[doc = "Font character map structure."]
#[doc = ""]

pub type CMAP_s = tag_CMAP_s;
#[doc = "Font character map structure."]
#[doc = ""]
#[repr(C)]
pub struct tag_CMAP_s {
    #[doc = "First Unicode codepoint the block applies to."]
    #[doc = ""]
    pub codeBegin: u16_,
    #[doc = "Last Unicode codepoint the block applies to."]
    #[doc = ""]
    pub codeEnd: u16_,
    #[doc = "Mapping method."]
    #[doc = ""]
    pub mappingMethod: u16_,
    pub reserved: u16_,
    #[doc = "Pointer to the next map."]
    #[doc = ""]
    pub next: *mut CMAP_s,
    pub __bindgen_anon_1: tag_CMAP_s__bindgen_ty_1,
}
#[repr(C)]
pub struct tag_CMAP_s__bindgen_ty_1 {
    #[doc = "For CMAP_TYPE_DIRECT: index of the first glyph."]
    #[doc = ""]
    pub indexOffset: __BindgenUnionField<u16_>,
    #[doc = "For CMAP_TYPE_TABLE: table of glyph indices."]
    #[doc = ""]
    pub indexTable: __BindgenUnionField<[u16_; 0usize]>,
    pub __bindgen_anon_1: __BindgenUnionField<tag_CMAP_s__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: u16,
}
#[doc = "For CMAP_TYPE_SCAN: Mapping data."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default)]
pub struct tag_CMAP_s__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "Number of pairs."]
    #[doc = ""]
    pub nScanEntries: u16_,
    pub scanEntries: __IncompleteArrayField<tag_CMAP_s__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>,
}
#[doc = "Mapping pairs."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tag_CMAP_s__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "Unicode codepoint."]
    #[doc = ""]
    pub code: u16_,
    #[doc = "Mapped glyph index."]
    #[doc = ""]
    pub glyphIndex: u16_,
}
impl Default for tag_CMAP_s__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for tag_CMAP_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Font information structure."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FINF_s {
    #[doc = "Signature (FINF)."]
    #[doc = ""]
    pub signature: u32_,
    #[doc = "Section size."]
    #[doc = ""]
    pub sectionSize: u32_,
    #[doc = "Font type"]
    #[doc = ""]
    pub fontType: u8_,
    #[doc = "Line feed vertical distance."]
    #[doc = ""]
    pub lineFeed: u8_,
    #[doc = "Glyph index of the replacement character."]
    #[doc = ""]
    pub alterCharIndex: u16_,
    #[doc = "Default character width information."]
    #[doc = ""]
    pub defaultWidth: charWidthInfo_s,
    #[doc = "Font encoding (?)"]
    #[doc = ""]
    pub encoding: u8_,
    #[doc = "Pointer to texture sheet information."]
    #[doc = ""]
    pub tglp: *mut TGLP_s,
    #[doc = "Pointer to the first character width information block."]
    #[doc = ""]
    pub cwdh: *mut CWDH_s,
    #[doc = "Pointer to the first character map."]
    #[doc = ""]
    pub cmap: *mut CMAP_s,
    #[doc = "Font height."]
    #[doc = ""]
    pub height: u8_,
    #[doc = "Font width."]
    #[doc = ""]
    pub width: u8_,
    #[doc = "Font ascent."]
    #[doc = ""]
    pub ascent: u8_,
    pub padding: u8_,
}
impl Default for FINF_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Font structure."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFNT_s {
    #[doc = "Signature (CFNU)."]
    #[doc = ""]
    pub signature: u32_,
    #[doc = "Endianness constant (0xFEFF)."]
    #[doc = ""]
    pub endianness: u16_,
    #[doc = "Header size."]
    #[doc = ""]
    pub headerSize: u16_,
    #[doc = "Format version."]
    #[doc = ""]
    pub version: u32_,
    #[doc = "File size."]
    #[doc = ""]
    pub fileSize: u32_,
    #[doc = "Number of blocks."]
    #[doc = ""]
    pub nBlocks: u32_,
    #[doc = "Font information."]
    #[doc = ""]
    pub finf: FINF_s,
}
impl Default for CFNT_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Font glyph position structure."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fontGlyphPos_s {
    #[doc = "Texture sheet index to use to render the glyph."]
    #[doc = ""]
    pub sheetIndex: ::libc::c_int,
    #[doc = "Horizontal offset to draw the glyph width."]
    #[doc = ""]
    pub xOffset: f32,
    #[doc = "Horizontal distance to advance after drawing the glyph."]
    #[doc = ""]
    pub xAdvance: f32,
    #[doc = "Glyph width."]
    #[doc = ""]
    pub width: f32,
    pub texcoord: fontGlyphPos_s__bindgen_ty_1,
    pub vtxcoord: fontGlyphPos_s__bindgen_ty_2,
}
#[doc = "Texture coordinates to use to render the glyph."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fontGlyphPos_s__bindgen_ty_1 {
    pub left: f32,
    pub top: f32,
    pub right: f32,
    pub bottom: f32,
}
#[doc = "Vertex coordinates to use to render the glyph."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fontGlyphPos_s__bindgen_ty_2 {
    pub left: f32,
    pub top: f32,
    pub right: f32,
    pub bottom: f32,
}
#[doc = "Calculates vertex coordinates in addition to texture coordinates."]
#[doc = ""]

pub const GLYPH_POS_CALC_VTXCOORD: _bindgen_ty_37 = 1;
#[doc = "Position the glyph at the baseline instead of at the top-left corner."]
#[doc = ""]

pub const GLYPH_POS_AT_BASELINE: _bindgen_ty_37 = 2;
#[doc = "Indicates that the Y axis points up instead of down."]
#[doc = ""]

pub const GLYPH_POS_Y_POINTS_UP: _bindgen_ty_37 = 4;
#[doc = "Flags for use with fontCalcGlyphPos."]
#[doc = ""]

pub type _bindgen_ty_37 = ::libc::c_uint;
extern "C" {
    #[must_use]
    #[doc = "Ensures the shared system font is mapped."]
    #[doc = ""]
    pub fn fontEnsureMapped() -> Result;
}
extern "C" {
    #[doc = "Fixes the pointers internal to a just-loaded font\n @param font Font to fix\n @remark Should never be run on the system font, and only once on any other font."]
    #[doc = ""]
    pub fn fontFixPointers(font: *mut CFNT_s);
}
extern "C" {
    #[doc = "Retrieves the glyph index of the specified Unicode codepoint.\n @param font Pointer to font structure. If NULL, the shared system font is used.\n @param codePoint Unicode codepoint."]
    #[doc = ""]
    pub fn fontGlyphIndexFromCodePoint(font: *mut CFNT_s, codePoint: u32_) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Retrieves character width information of the specified glyph.\n @param font Pointer to font structure. If NULL, the shared system font is used.\n @param glyphIndex Index of the glyph."]
    #[doc = ""]
    pub fn fontGetCharWidthInfo(
        font: *mut CFNT_s,
        glyphIndex: ::libc::c_int,
    ) -> *mut charWidthInfo_s;
}
extern "C" {
    #[doc = "Calculates position information for the specified glyph.\n @param out Output structure in which to write the information.\n @param font Pointer to font structure. If NULL, the shared system font is used.\n @param glyphIndex Index of the glyph.\n @param flags Calculation flags (see GLYPH_POS_* flags).\n @param scaleX Scale factor to apply horizontally.\n @param scaleY Scale factor to apply vertically."]
    #[doc = ""]
    pub fn fontCalcGlyphPos(
        out: *mut fontGlyphPos_s,
        font: *mut CFNT_s,
        glyphIndex: ::libc::c_int,
        flags: u32_,
        scaleX: f32,
        scaleY: f32,
    );
}
extern "C" {
    pub fn gdbHioDevInit() -> ::libc::c_int;
}
extern "C" {
    pub fn gdbHioDevExit();
}
extern "C" {
    pub fn gdbHioDevGetStdin() -> ::libc::c_int;
}
extern "C" {
    pub fn gdbHioDevGetStdout() -> ::libc::c_int;
}
extern "C" {
    pub fn gdbHioDevGetStderr() -> ::libc::c_int;
}
extern "C" {
    pub fn gdbHioDevRedirectStdStreams(in_: bool, out: bool, err: bool) -> ::libc::c_int;
}
extern "C" {
    pub fn gdbHioDevGettimeofday(tv: *mut timeval, tz: *mut ::libc::c_void) -> ::libc::c_int;
}
extern "C" {
    pub fn gdbHioDevIsatty(fd: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn gdbHioDevSystem(command: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Address of the host connected through 3dslink"]
    #[doc = ""]
    pub static mut __3dslink_host: in_addr;
}
extern "C" {
    #[doc = "Connects to the 3dslink host, setting up an output stream.\n @param[in] redirStdout Whether to redirect stdout to nxlink output.\n @param[in] redirStderr Whether to redirect stderr to nxlink output.\n @return Socket fd on success, negative number on failure.\n @note The socket should be closed with close() during application cleanup."]
    #[doc = ""]
    pub fn link3dsConnectToHost(redirStdout: bool, redirStderr: bool) -> ::libc::c_int;
}
