/* automatically generated by rust-bindgen 0.65.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::core::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::core::mem::transmute(self)
    }
}
impl<T> ::core::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::core::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::core::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::core::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::core::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::core::cmp::Eq for __BindgenUnionField<T> {}
pub const _NEWLIB_VERSION_H__: u32 = 1;
pub const _NEWLIB_VERSION: &[u8; 6usize] = b"4.3.0\0";
pub const __NEWLIB__: u32 = 4;
pub const __NEWLIB_MINOR__: u32 = 3;
pub const __NEWLIB_PATCHLEVEL__: u32 = 0;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __ATFILE_VISIBLE: u32 = 1;
pub const __BSD_VISIBLE: u32 = 1;
pub const __GNU_VISIBLE: u32 = 0;
pub const __ISO_C_VISIBLE: u32 = 2011;
pub const __LARGEFILE_VISIBLE: u32 = 0;
pub const __MISC_VISIBLE: u32 = 1;
pub const __POSIX_VISIBLE: u32 = 200809;
pub const __SVID_VISIBLE: u32 = 1;
pub const __XSI_VISIBLE: u32 = 0;
pub const __SSP_FORTIFY_LEVEL: u32 = 0;
pub const _POSIX_MONOTONIC_CLOCK: u32 = 200112;
pub const _POSIX_TIMERS: u32 = 1;
pub const _POSIX_THREADS: u32 = 1;
pub const _POSIX_SEMAPHORES: u32 = 1;
pub const _POSIX_BARRIERS: u32 = 200112;
pub const _POSIX_READER_WRITER_LOCKS: u32 = 200112;
pub const _UNIX98_THREAD_MUTEX_ATTRIBUTES: u32 = 1;
pub const __have_longlong64: u32 = 1;
pub const __have_long32: u32 = 1;
pub const ___int8_t_defined: u32 = 1;
pub const ___int16_t_defined: u32 = 1;
pub const ___int32_t_defined: u32 = 1;
pub const ___int64_t_defined: u32 = 1;
pub const ___int_least8_t_defined: u32 = 1;
pub const ___int_least16_t_defined: u32 = 1;
pub const ___int_least32_t_defined: u32 = 1;
pub const ___int_least64_t_defined: u32 = 1;
pub const __int20: u32 = 2;
pub const __int20__: u32 = 2;
pub const __INT8: &[u8; 3usize] = b"hh\0";
pub const __INT16: &[u8; 2usize] = b"h\0";
pub const __INT64: &[u8; 3usize] = b"ll\0";
pub const __FAST8: &[u8; 3usize] = b"hh\0";
pub const __FAST16: &[u8; 2usize] = b"h\0";
pub const __FAST64: &[u8; 3usize] = b"ll\0";
pub const __LEAST8: &[u8; 3usize] = b"hh\0";
pub const __LEAST16: &[u8; 2usize] = b"h\0";
pub const __LEAST64: &[u8; 3usize] = b"ll\0";
pub const __int8_t_defined: u32 = 1;
pub const __int16_t_defined: u32 = 1;
pub const __int32_t_defined: u32 = 1;
pub const __int64_t_defined: u32 = 1;
pub const __int_least8_t_defined: u32 = 1;
pub const __int_least16_t_defined: u32 = 1;
pub const __int_least32_t_defined: u32 = 1;
pub const __int_least64_t_defined: u32 = 1;
pub const __int_fast8_t_defined: u32 = 1;
pub const __int_fast16_t_defined: u32 = 1;
pub const __int_fast32_t_defined: u32 = 1;
pub const __int_fast64_t_defined: u32 = 1;
pub const WINT_MIN: u32 = 0;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const CUR_PROCESS_HANDLE: u32 = 4294934529;
pub const ARBITRATION_SIGNAL_ALL: i32 = -1;
pub const CUR_THREAD_HANDLE: u32 = 4294934528;
pub const SYSCLOCK_SOC: u32 = 16756991;
pub const SYSCLOCK_SYS: u32 = 33513982;
pub const SYSCLOCK_SDMMC: u32 = 67027964;
pub const SYSCLOCK_ARM9: u32 = 134055928;
pub const SYSCLOCK_ARM11: u32 = 268111856;
pub const SYSCLOCK_ARM11_LGR1: u32 = 536223712;
pub const SYSCLOCK_ARM11_LGR2: u32 = 804335568;
pub const SYSCLOCK_ARM11_NEW: u32 = 804335568;
pub const CPU_TICKS_PER_MSEC: f64 = 268111.856;
pub const CPU_TICKS_PER_USEC: f64 = 268.111856;
pub const OS_HEAP_AREA_BEGIN: u32 = 134217728;
pub const OS_HEAP_AREA_END: u32 = 234881024;
pub const OS_MAP_AREA_BEGIN: u32 = 268435456;
pub const OS_MAP_AREA_END: u32 = 335544320;
pub const OS_OLD_FCRAM_VADDR: u32 = 335544320;
pub const OS_OLD_FCRAM_PADDR: u32 = 536870912;
pub const OS_OLD_FCRAM_SIZE: u32 = 134217728;
pub const OS_QTMRAM_VADDR: u32 = 511705088;
pub const OS_QTMRAM_PADDR: u32 = 520093696;
pub const OS_QTMRAM_SIZE: u32 = 4194304;
pub const OS_MMIO_VADDR: u32 = 515899392;
pub const OS_MMIO_PADDR: u32 = 269484032;
pub const OS_MMIO_SIZE: u32 = 4194304;
pub const OS_VRAM_VADDR: u32 = 520093696;
pub const OS_VRAM_PADDR: u32 = 402653184;
pub const OS_VRAM_SIZE: u32 = 6291456;
pub const OS_DSPRAM_VADDR: u32 = 535822336;
pub const OS_DSPRAM_PADDR: u32 = 535822336;
pub const OS_DSPRAM_SIZE: u32 = 524288;
pub const OS_KERNELCFG_VADDR: u32 = 536346624;
pub const OS_SHAREDCFG_VADDR: u32 = 536350720;
pub const OS_FCRAM_VADDR: u32 = 805306368;
pub const OS_FCRAM_PADDR: u32 = 536870912;
pub const OS_FCRAM_SIZE: u32 = 268435456;
pub const __NEWLIB_H__: u32 = 1;
pub const _ATEXIT_DYNAMIC_ALLOC: u32 = 1;
pub const _FSEEK_OPTIMIZATION: u32 = 1;
pub const _FVWRITE_IN_STREAMIO: u32 = 1;
pub const _HAVE_CC_INHIBIT_LOOP_TO_LIBCALL: u32 = 1;
pub const _HAVE_INITFINI_ARRAY: u32 = 1;
pub const _HAVE_LONG_DOUBLE: u32 = 1;
pub const _LDBL_EQ_DBL: u32 = 1;
pub const _MB_CAPABLE: u32 = 1;
pub const _MB_LEN_MAX: u32 = 8;
pub const _REENT_CHECK_VERIFY: u32 = 1;
pub const _UNBUF_STREAM_OPT: u32 = 1;
pub const _WANT_IO_C99_FORMATS: u32 = 1;
pub const _WANT_IO_LONG_LONG: u32 = 1;
pub const _WANT_IO_POS_ARGS: u32 = 1;
pub const _WANT_USE_GDTOA: u32 = 1;
pub const __OBSOLETE_MATH_DEFAULT: u32 = 0;
pub const __OBSOLETE_MATH: u32 = 0;
pub const __RAND_MAX: u32 = 2147483647;
pub const GSP_SCREEN_TOP: u32 = 0;
pub const GSP_SCREEN_BOTTOM: u32 = 1;
pub const GSP_SCREEN_WIDTH: u32 = 240;
pub const GSP_SCREEN_HEIGHT_TOP: u32 = 400;
pub const GSP_SCREEN_HEIGHT_TOP_2X: u32 = 800;
pub const GSP_SCREEN_HEIGHT_BOTTOM: u32 = 320;
pub const CONSOLE_COLOR_BOLD: u32 = 1;
pub const CONSOLE_COLOR_FAINT: u32 = 2;
pub const CONSOLE_ITALIC: u32 = 4;
pub const CONSOLE_UNDERLINE: u32 = 8;
pub const CONSOLE_BLINK_SLOW: u32 = 16;
pub const CONSOLE_BLINK_FAST: u32 = 32;
pub const CONSOLE_COLOR_REVERSE: u32 = 64;
pub const CONSOLE_CONCEAL: u32 = 128;
pub const CONSOLE_CROSSED_OUT: u32 = 256;
pub const CONSOLE_FG_CUSTOM: u32 = 512;
pub const CONSOLE_BG_CUSTOM: u32 = 1024;
pub const __GNUCLIKE_ASM: u32 = 3;
pub const __GNUCLIKE___TYPEOF: u32 = 1;
pub const __GNUCLIKE___SECTION: u32 = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: u32 = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: u32 = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: u32 = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: u32 = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: u32 = 1;
pub const __CC_SUPPORTS_INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE__: u32 = 1;
pub const __CC_SUPPORTS___FUNC__: u32 = 1;
pub const __CC_SUPPORTS_WARNING: u32 = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: u32 = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _LITTLE_ENDIAN: u32 = 1234;
pub const _BIG_ENDIAN: u32 = 4321;
pub const _PDP_ENDIAN: u32 = 3412;
pub const _BYTE_ORDER: u32 = 1234;
pub const _QUAD_HIGHWORD: u32 = 1;
pub const _QUAD_LOWWORD: u32 = 0;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const FD_SETSIZE: u32 = 64;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const PTHREAD_SCOPE_PROCESS: u32 = 0;
pub const PTHREAD_SCOPE_SYSTEM: u32 = 1;
pub const PTHREAD_INHERIT_SCHED: u32 = 1;
pub const PTHREAD_EXPLICIT_SCHED: u32 = 2;
pub const PTHREAD_CREATE_DETACHED: u32 = 0;
pub const PTHREAD_CREATE_JOINABLE: u32 = 1;
pub const PTHREAD_MUTEX_NORMAL: u32 = 0;
pub const PTHREAD_MUTEX_RECURSIVE: u32 = 1;
pub const PTHREAD_MUTEX_ERRORCHECK: u32 = 2;
pub const PTHREAD_MUTEX_DEFAULT: u32 = 3;
pub const CSND_NUM_CHANNELS: u32 = 32;
pub const FRIEND_SCREEN_NAME_SIZE: u32 = 11;
pub const FRIEND_COMMENT_SIZE: u32 = 33;
pub const FRIEND_LIST_SIZE: u32 = 100;
pub const HTTPC_RESULTCODE_DOWNLOADPENDING: u32 = 3628113963;
pub const HTTPC_RESULTCODE_NOTFOUND: u32 = 3628113960;
pub const HTTPC_RESULTCODE_TIMEDOUT: u32 = 3626016873;
pub const UDS_MAXNODES: u32 = 16;
pub const UDS_BROADCAST_NETWORKNODEID: u32 = 65535;
pub const UDS_HOST_NETWORKNODEID: u32 = 1;
pub const UDS_DEFAULT_RECVBUFSIZE: u32 = 11824;
pub const UDS_DATAFRAME_MAXSIZE: u32 = 1478;
pub const DST_NONE: u32 = 0;
pub const DST_USA: u32 = 1;
pub const DST_AUST: u32 = 2;
pub const DST_WET: u32 = 3;
pub const DST_MET: u32 = 4;
pub const DST_EET: u32 = 5;
pub const DST_CAN: u32 = 6;
pub const SBT_MAX: u64 = 9223372036854775807;
pub const ITIMER_REAL: u32 = 0;
pub const ITIMER_VIRTUAL: u32 = 1;
pub const ITIMER_PROF: u32 = 2;
pub const _NULL: u32 = 0;
pub const _ATEXIT_SIZE: u32 = 32;
pub const _RAND48_SEED_0: u32 = 13070;
pub const _RAND48_SEED_1: u32 = 43981;
pub const _RAND48_SEED_2: u32 = 4660;
pub const _RAND48_MULT_0: u32 = 58989;
pub const _RAND48_MULT_1: u32 = 57068;
pub const _RAND48_MULT_2: u32 = 5;
pub const _RAND48_ADD: u32 = 11;
pub const _REENT_EMERGENCY_SIZE: u32 = 25;
pub const _REENT_ASCTIME_SIZE: u32 = 26;
pub const _REENT_SIGNAL_SIZE: u32 = 24;
pub const _CLOCKS_PER_SEC_: u32 = 100;
pub const CLOCKS_PER_SEC: u32 = 100;
pub const CLK_TCK: u32 = 100;
pub const SIGEV_NONE: u32 = 1;
pub const SIGEV_SIGNAL: u32 = 2;
pub const SIGEV_THREAD: u32 = 3;
pub const SI_USER: u32 = 1;
pub const SI_QUEUE: u32 = 2;
pub const SI_TIMER: u32 = 3;
pub const SI_ASYNCIO: u32 = 4;
pub const SI_MESGQ: u32 = 5;
pub const SA_NOCLDSTOP: u32 = 1;
pub const MINSIGSTKSZ: u32 = 2048;
pub const SIGSTKSZ: u32 = 8192;
pub const SS_ONSTACK: u32 = 1;
pub const SS_DISABLE: u32 = 2;
pub const SIG_SETMASK: u32 = 0;
pub const SIG_BLOCK: u32 = 1;
pub const SIG_UNBLOCK: u32 = 2;
pub const SIGHUP: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGQUIT: u32 = 3;
pub const SIGILL: u32 = 4;
pub const SIGTRAP: u32 = 5;
pub const SIGIOT: u32 = 6;
pub const SIGABRT: u32 = 6;
pub const SIGEMT: u32 = 7;
pub const SIGFPE: u32 = 8;
pub const SIGKILL: u32 = 9;
pub const SIGBUS: u32 = 10;
pub const SIGSEGV: u32 = 11;
pub const SIGSYS: u32 = 12;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGTERM: u32 = 15;
pub const SIGURG: u32 = 16;
pub const SIGSTOP: u32 = 17;
pub const SIGTSTP: u32 = 18;
pub const SIGCONT: u32 = 19;
pub const SIGCHLD: u32 = 20;
pub const SIGCLD: u32 = 20;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGIO: u32 = 23;
pub const SIGPOLL: u32 = 23;
pub const SIGXCPU: u32 = 24;
pub const SIGXFSZ: u32 = 25;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGWINCH: u32 = 28;
pub const SIGLOST: u32 = 29;
pub const SIGUSR1: u32 = 30;
pub const SIGUSR2: u32 = 31;
pub const NSIG: u32 = 32;
pub const CLOCK_ENABLED: u32 = 1;
pub const CLOCK_DISABLED: u32 = 0;
pub const CLOCK_ALLOWED: u32 = 1;
pub const CLOCK_DISALLOWED: u32 = 0;
pub const TIMER_ABSTIME: u32 = 4;
pub const SOL_SOCKET: u32 = 65535;
pub const PF_UNSPEC: u32 = 0;
pub const PF_INET: u32 = 2;
pub const PF_INET6: u32 = 23;
pub const AF_UNSPEC: u32 = 0;
pub const AF_INET: u32 = 2;
pub const AF_INET6: u32 = 23;
pub const SOCK_STREAM: u32 = 1;
pub const SOCK_DGRAM: u32 = 2;
pub const MSG_OOB: u32 = 1;
pub const MSG_PEEK: u32 = 2;
pub const MSG_DONTWAIT: u32 = 4;
pub const MSG_DONTROUTE: u32 = 0;
pub const MSG_WAITALL: u32 = 0;
pub const MSG_MORE: u32 = 0;
pub const MSG_NOSIGNAL: u32 = 0;
pub const SHUT_RD: u32 = 0;
pub const SHUT_WR: u32 = 1;
pub const SHUT_RDWR: u32 = 2;
pub const SO_REUSEADDR: u32 = 4;
pub const SO_LINGER: u32 = 128;
pub const SO_OOBINLINE: u32 = 256;
pub const SO_SNDBUF: u32 = 4097;
pub const SO_RCVBUF: u32 = 4098;
pub const SO_SNDLOWAT: u32 = 4099;
pub const SO_RCVLOWAT: u32 = 4100;
pub const SO_TYPE: u32 = 4104;
pub const SO_ERROR: u32 = 4105;
pub const SO_BROADCAST: u32 = 0;
pub const INADDR_LOOPBACK: u32 = 2130706433;
pub const INADDR_ANY: u32 = 0;
pub const INADDR_BROADCAST: u32 = 4294967295;
pub const INADDR_NONE: u32 = 4294967295;
pub const INET_ADDRSTRLEN: u32 = 16;
pub const IPPROTO_IP: u32 = 0;
pub const IPPROTO_UDP: u32 = 17;
pub const IPPROTO_TCP: u32 = 6;
pub const IP_TOS: u32 = 7;
pub const IP_TTL: u32 = 8;
pub const IP_MULTICAST_LOOP: u32 = 9;
pub const IP_MULTICAST_TTL: u32 = 10;
pub const IP_ADD_MEMBERSHIP: u32 = 11;
pub const IP_DROP_MEMBERSHIP: u32 = 12;
pub const SOL_CONFIG: u32 = 65534;
pub const ROUTING_FLAG_G: u32 = 1;
pub const TCP_STATE_CLOSED: u32 = 1;
pub const TCP_STATE_LISTEN: u32 = 2;
pub const TCP_STATE_ESTABLISHED: u32 = 5;
pub const TCP_STATE_FINWAIT1: u32 = 6;
pub const TCP_STATE_FINWAIT2: u32 = 7;
pub const TCP_STATE_CLOSE_WAIT: u32 = 8;
pub const TCP_STATE_LAST_ACK: u32 = 9;
pub const TCP_STATE_TIME_WAIT: u32 = 11;
pub const MVD_STATUS_OK: u32 = 94208;
pub const MVD_STATUS_PARAMSET: u32 = 94209;
pub const MVD_STATUS_BUSY: u32 = 94210;
pub const MVD_STATUS_FRAMEREADY: u32 = 94211;
pub const MVD_STATUS_INCOMPLETEPROCESSING: u32 = 94212;
pub const MVD_STATUS_NALUPROCFLAG: u32 = 94215;
pub const MVD_DEFAULT_WORKBUF_SIZE: u32 = 9438920;
pub const NFC_ERR_INVALID_STATE: u32 = 3366024704;
pub const NFC_ERR_APPDATA_UNINITIALIZED: u32 = 3366024736;
pub const NFC_ERR_AMIIBO_NOTSETUP: u32 = 3366024744;
pub const NFC_ERR_APPID_MISMATCH: u32 = 3366024760;
pub const NFC_ERR_DATACORRUPTION0: u32 = 3368121868;
pub const NFC_ERR_DATACORRUPTION1: u32 = 3366024728;
pub const NFC_STARTSCAN_DEFAULTINPUT: u32 = 0;
pub const GPUREG_0000: u32 = 0;
pub const GPUREG_0001: u32 = 1;
pub const GPUREG_0002: u32 = 2;
pub const GPUREG_0003: u32 = 3;
pub const GPUREG_0004: u32 = 4;
pub const GPUREG_0005: u32 = 5;
pub const GPUREG_0006: u32 = 6;
pub const GPUREG_0007: u32 = 7;
pub const GPUREG_0008: u32 = 8;
pub const GPUREG_0009: u32 = 9;
pub const GPUREG_000A: u32 = 10;
pub const GPUREG_000B: u32 = 11;
pub const GPUREG_000C: u32 = 12;
pub const GPUREG_000D: u32 = 13;
pub const GPUREG_000E: u32 = 14;
pub const GPUREG_000F: u32 = 15;
pub const GPUREG_FINALIZE: u32 = 16;
pub const GPUREG_0011: u32 = 17;
pub const GPUREG_0012: u32 = 18;
pub const GPUREG_0013: u32 = 19;
pub const GPUREG_0014: u32 = 20;
pub const GPUREG_0015: u32 = 21;
pub const GPUREG_0016: u32 = 22;
pub const GPUREG_0017: u32 = 23;
pub const GPUREG_0018: u32 = 24;
pub const GPUREG_0019: u32 = 25;
pub const GPUREG_001A: u32 = 26;
pub const GPUREG_001B: u32 = 27;
pub const GPUREG_001C: u32 = 28;
pub const GPUREG_001D: u32 = 29;
pub const GPUREG_001E: u32 = 30;
pub const GPUREG_001F: u32 = 31;
pub const GPUREG_0020: u32 = 32;
pub const GPUREG_0021: u32 = 33;
pub const GPUREG_0022: u32 = 34;
pub const GPUREG_0023: u32 = 35;
pub const GPUREG_0024: u32 = 36;
pub const GPUREG_0025: u32 = 37;
pub const GPUREG_0026: u32 = 38;
pub const GPUREG_0027: u32 = 39;
pub const GPUREG_0028: u32 = 40;
pub const GPUREG_0029: u32 = 41;
pub const GPUREG_002A: u32 = 42;
pub const GPUREG_002B: u32 = 43;
pub const GPUREG_002C: u32 = 44;
pub const GPUREG_002D: u32 = 45;
pub const GPUREG_002E: u32 = 46;
pub const GPUREG_002F: u32 = 47;
pub const GPUREG_0030: u32 = 48;
pub const GPUREG_0031: u32 = 49;
pub const GPUREG_0032: u32 = 50;
pub const GPUREG_0033: u32 = 51;
pub const GPUREG_0034: u32 = 52;
pub const GPUREG_0035: u32 = 53;
pub const GPUREG_0036: u32 = 54;
pub const GPUREG_0037: u32 = 55;
pub const GPUREG_0038: u32 = 56;
pub const GPUREG_0039: u32 = 57;
pub const GPUREG_003A: u32 = 58;
pub const GPUREG_003B: u32 = 59;
pub const GPUREG_003C: u32 = 60;
pub const GPUREG_003D: u32 = 61;
pub const GPUREG_003E: u32 = 62;
pub const GPUREG_003F: u32 = 63;
pub const GPUREG_FACECULLING_CONFIG: u32 = 64;
pub const GPUREG_VIEWPORT_WIDTH: u32 = 65;
pub const GPUREG_VIEWPORT_INVW: u32 = 66;
pub const GPUREG_VIEWPORT_HEIGHT: u32 = 67;
pub const GPUREG_VIEWPORT_INVH: u32 = 68;
pub const GPUREG_0045: u32 = 69;
pub const GPUREG_0046: u32 = 70;
pub const GPUREG_FRAGOP_CLIP: u32 = 71;
pub const GPUREG_FRAGOP_CLIP_DATA0: u32 = 72;
pub const GPUREG_FRAGOP_CLIP_DATA1: u32 = 73;
pub const GPUREG_FRAGOP_CLIP_DATA2: u32 = 74;
pub const GPUREG_FRAGOP_CLIP_DATA3: u32 = 75;
pub const GPUREG_004C: u32 = 76;
pub const GPUREG_DEPTHMAP_SCALE: u32 = 77;
pub const GPUREG_DEPTHMAP_OFFSET: u32 = 78;
pub const GPUREG_SH_OUTMAP_TOTAL: u32 = 79;
pub const GPUREG_SH_OUTMAP_O0: u32 = 80;
pub const GPUREG_SH_OUTMAP_O1: u32 = 81;
pub const GPUREG_SH_OUTMAP_O2: u32 = 82;
pub const GPUREG_SH_OUTMAP_O3: u32 = 83;
pub const GPUREG_SH_OUTMAP_O4: u32 = 84;
pub const GPUREG_SH_OUTMAP_O5: u32 = 85;
pub const GPUREG_SH_OUTMAP_O6: u32 = 86;
pub const GPUREG_0057: u32 = 87;
pub const GPUREG_0058: u32 = 88;
pub const GPUREG_0059: u32 = 89;
pub const GPUREG_005A: u32 = 90;
pub const GPUREG_005B: u32 = 91;
pub const GPUREG_005C: u32 = 92;
pub const GPUREG_005D: u32 = 93;
pub const GPUREG_005E: u32 = 94;
pub const GPUREG_005F: u32 = 95;
pub const GPUREG_0060: u32 = 96;
pub const GPUREG_EARLYDEPTH_FUNC: u32 = 97;
pub const GPUREG_EARLYDEPTH_TEST1: u32 = 98;
pub const GPUREG_EARLYDEPTH_CLEAR: u32 = 99;
pub const GPUREG_SH_OUTATTR_MODE: u32 = 100;
pub const GPUREG_SCISSORTEST_MODE: u32 = 101;
pub const GPUREG_SCISSORTEST_POS: u32 = 102;
pub const GPUREG_SCISSORTEST_DIM: u32 = 103;
pub const GPUREG_VIEWPORT_XY: u32 = 104;
pub const GPUREG_0069: u32 = 105;
pub const GPUREG_EARLYDEPTH_DATA: u32 = 106;
pub const GPUREG_006B: u32 = 107;
pub const GPUREG_006C: u32 = 108;
pub const GPUREG_DEPTHMAP_ENABLE: u32 = 109;
pub const GPUREG_RENDERBUF_DIM: u32 = 110;
pub const GPUREG_SH_OUTATTR_CLOCK: u32 = 111;
pub const GPUREG_0070: u32 = 112;
pub const GPUREG_0071: u32 = 113;
pub const GPUREG_0072: u32 = 114;
pub const GPUREG_0073: u32 = 115;
pub const GPUREG_0074: u32 = 116;
pub const GPUREG_0075: u32 = 117;
pub const GPUREG_0076: u32 = 118;
pub const GPUREG_0077: u32 = 119;
pub const GPUREG_0078: u32 = 120;
pub const GPUREG_0079: u32 = 121;
pub const GPUREG_007A: u32 = 122;
pub const GPUREG_007B: u32 = 123;
pub const GPUREG_007C: u32 = 124;
pub const GPUREG_007D: u32 = 125;
pub const GPUREG_007E: u32 = 126;
pub const GPUREG_007F: u32 = 127;
pub const GPUREG_TEXUNIT_CONFIG: u32 = 128;
pub const GPUREG_TEXUNIT0_BORDER_COLOR: u32 = 129;
pub const GPUREG_TEXUNIT0_DIM: u32 = 130;
pub const GPUREG_TEXUNIT0_PARAM: u32 = 131;
pub const GPUREG_TEXUNIT0_LOD: u32 = 132;
pub const GPUREG_TEXUNIT0_ADDR1: u32 = 133;
pub const GPUREG_TEXUNIT0_ADDR2: u32 = 134;
pub const GPUREG_TEXUNIT0_ADDR3: u32 = 135;
pub const GPUREG_TEXUNIT0_ADDR4: u32 = 136;
pub const GPUREG_TEXUNIT0_ADDR5: u32 = 137;
pub const GPUREG_TEXUNIT0_ADDR6: u32 = 138;
pub const GPUREG_TEXUNIT0_SHADOW: u32 = 139;
pub const GPUREG_008C: u32 = 140;
pub const GPUREG_008D: u32 = 141;
pub const GPUREG_TEXUNIT0_TYPE: u32 = 142;
pub const GPUREG_LIGHTING_ENABLE0: u32 = 143;
pub const GPUREG_0090: u32 = 144;
pub const GPUREG_TEXUNIT1_BORDER_COLOR: u32 = 145;
pub const GPUREG_TEXUNIT1_DIM: u32 = 146;
pub const GPUREG_TEXUNIT1_PARAM: u32 = 147;
pub const GPUREG_TEXUNIT1_LOD: u32 = 148;
pub const GPUREG_TEXUNIT1_ADDR: u32 = 149;
pub const GPUREG_TEXUNIT1_TYPE: u32 = 150;
pub const GPUREG_0097: u32 = 151;
pub const GPUREG_0098: u32 = 152;
pub const GPUREG_TEXUNIT2_BORDER_COLOR: u32 = 153;
pub const GPUREG_TEXUNIT2_DIM: u32 = 154;
pub const GPUREG_TEXUNIT2_PARAM: u32 = 155;
pub const GPUREG_TEXUNIT2_LOD: u32 = 156;
pub const GPUREG_TEXUNIT2_ADDR: u32 = 157;
pub const GPUREG_TEXUNIT2_TYPE: u32 = 158;
pub const GPUREG_009F: u32 = 159;
pub const GPUREG_00A0: u32 = 160;
pub const GPUREG_00A1: u32 = 161;
pub const GPUREG_00A2: u32 = 162;
pub const GPUREG_00A3: u32 = 163;
pub const GPUREG_00A4: u32 = 164;
pub const GPUREG_00A5: u32 = 165;
pub const GPUREG_00A6: u32 = 166;
pub const GPUREG_00A7: u32 = 167;
pub const GPUREG_TEXUNIT3_PROCTEX0: u32 = 168;
pub const GPUREG_TEXUNIT3_PROCTEX1: u32 = 169;
pub const GPUREG_TEXUNIT3_PROCTEX2: u32 = 170;
pub const GPUREG_TEXUNIT3_PROCTEX3: u32 = 171;
pub const GPUREG_TEXUNIT3_PROCTEX4: u32 = 10;
pub const GPUREG_TEXUNIT3_PROCTEX5: u32 = 13;
pub const GPUREG_00AE: u32 = 174;
pub const GPUREG_PROCTEX_LUT: u32 = 175;
pub const GPUREG_PROCTEX_LUT_DATA0: u32 = 176;
pub const GPUREG_PROCTEX_LUT_DATA1: u32 = 177;
pub const GPUREG_PROCTEX_LUT_DATA2: u32 = 178;
pub const GPUREG_PROCTEX_LUT_DATA3: u32 = 179;
pub const GPUREG_PROCTEX_LUT_DATA4: u32 = 180;
pub const GPUREG_PROCTEX_LUT_DATA5: u32 = 181;
pub const GPUREG_PROCTEX_LUT_DATA6: u32 = 182;
pub const GPUREG_PROCTEX_LUT_DATA7: u32 = 183;
pub const GPUREG_00B8: u32 = 184;
pub const GPUREG_00B9: u32 = 185;
pub const GPUREG_00BA: u32 = 186;
pub const GPUREG_00BB: u32 = 187;
pub const GPUREG_00BC: u32 = 188;
pub const GPUREG_00BD: u32 = 189;
pub const GPUREG_00BE: u32 = 190;
pub const GPUREG_00BF: u32 = 191;
pub const GPUREG_TEXENV0_SOURCE: u32 = 192;
pub const GPUREG_TEXENV0_OPERAND: u32 = 193;
pub const GPUREG_TEXENV0_COMBINER: u32 = 194;
pub const GPUREG_TEXENV0_COLOR: u32 = 195;
pub const GPUREG_TEXENV0_SCALE: u32 = 196;
pub const GPUREG_00C5: u32 = 197;
pub const GPUREG_00C6: u32 = 198;
pub const GPUREG_00C7: u32 = 199;
pub const GPUREG_TEXENV1_SOURCE: u32 = 200;
pub const GPUREG_TEXENV1_OPERAND: u32 = 201;
pub const GPUREG_TEXENV1_COMBINER: u32 = 202;
pub const GPUREG_TEXENV1_COLOR: u32 = 203;
pub const GPUREG_TEXENV1_SCALE: u32 = 204;
pub const GPUREG_00CD: u32 = 205;
pub const GPUREG_00CE: u32 = 206;
pub const GPUREG_00CF: u32 = 207;
pub const GPUREG_TEXENV2_SOURCE: u32 = 208;
pub const GPUREG_TEXENV2_OPERAND: u32 = 209;
pub const GPUREG_TEXENV2_COMBINER: u32 = 210;
pub const GPUREG_TEXENV2_COLOR: u32 = 211;
pub const GPUREG_TEXENV2_SCALE: u32 = 212;
pub const GPUREG_00D5: u32 = 213;
pub const GPUREG_00D6: u32 = 214;
pub const GPUREG_00D7: u32 = 215;
pub const GPUREG_TEXENV3_SOURCE: u32 = 216;
pub const GPUREG_TEXENV3_OPERAND: u32 = 217;
pub const GPUREG_TEXENV3_COMBINER: u32 = 218;
pub const GPUREG_TEXENV3_COLOR: u32 = 219;
pub const GPUREG_TEXENV3_SCALE: u32 = 220;
pub const GPUREG_00DD: u32 = 221;
pub const GPUREG_00DE: u32 = 222;
pub const GPUREG_00DF: u32 = 223;
pub const GPUREG_TEXENV_UPDATE_BUFFER: u32 = 224;
pub const GPUREG_FOG_COLOR: u32 = 225;
pub const GPUREG_00E2: u32 = 226;
pub const GPUREG_00E3: u32 = 227;
pub const GPUREG_GAS_ATTENUATION: u32 = 228;
pub const GPUREG_GAS_ACCMAX: u32 = 229;
pub const GPUREG_FOG_LUT_INDEX: u32 = 230;
pub const GPUREG_00E7: u32 = 231;
pub const GPUREG_FOG_LUT_DATA0: u32 = 232;
pub const GPUREG_FOG_LUT_DATA1: u32 = 233;
pub const GPUREG_FOG_LUT_DATA2: u32 = 234;
pub const GPUREG_FOG_LUT_DATA3: u32 = 235;
pub const GPUREG_FOG_LUT_DATA4: u32 = 236;
pub const GPUREG_FOG_LUT_DATA5: u32 = 237;
pub const GPUREG_FOG_LUT_DATA6: u32 = 238;
pub const GPUREG_FOG_LUT_DATA7: u32 = 239;
pub const GPUREG_TEXENV4_SOURCE: u32 = 240;
pub const GPUREG_TEXENV4_OPERAND: u32 = 241;
pub const GPUREG_TEXENV4_COMBINER: u32 = 242;
pub const GPUREG_TEXENV4_COLOR: u32 = 243;
pub const GPUREG_TEXENV4_SCALE: u32 = 244;
pub const GPUREG_00F5: u32 = 245;
pub const GPUREG_00F6: u32 = 246;
pub const GPUREG_00F7: u32 = 247;
pub const GPUREG_TEXENV5_SOURCE: u32 = 248;
pub const GPUREG_TEXENV5_OPERAND: u32 = 249;
pub const GPUREG_TEXENV5_COMBINER: u32 = 250;
pub const GPUREG_TEXENV5_COLOR: u32 = 251;
pub const GPUREG_TEXENV5_SCALE: u32 = 252;
pub const GPUREG_TEXENV_BUFFER_COLOR: u32 = 253;
pub const GPUREG_00FE: u32 = 254;
pub const GPUREG_00FF: u32 = 255;
pub const GPUREG_COLOR_OPERATION: u32 = 256;
pub const GPUREG_BLEND_FUNC: u32 = 257;
pub const GPUREG_LOGIC_OP: u32 = 258;
pub const GPUREG_BLEND_COLOR: u32 = 259;
pub const GPUREG_FRAGOP_ALPHA_TEST: u32 = 260;
pub const GPUREG_STENCIL_TEST: u32 = 261;
pub const GPUREG_STENCIL_OP: u32 = 262;
pub const GPUREG_DEPTH_COLOR_MASK: u32 = 263;
pub const GPUREG_0108: u32 = 264;
pub const GPUREG_0109: u32 = 265;
pub const GPUREG_010A: u32 = 266;
pub const GPUREG_010B: u32 = 267;
pub const GPUREG_010C: u32 = 268;
pub const GPUREG_010D: u32 = 269;
pub const GPUREG_010E: u32 = 270;
pub const GPUREG_010F: u32 = 271;
pub const GPUREG_FRAMEBUFFER_INVALIDATE: u32 = 272;
pub const GPUREG_FRAMEBUFFER_FLUSH: u32 = 273;
pub const GPUREG_COLORBUFFER_READ: u32 = 274;
pub const GPUREG_COLORBUFFER_WRITE: u32 = 275;
pub const GPUREG_DEPTHBUFFER_READ: u32 = 276;
pub const GPUREG_DEPTHBUFFER_WRITE: u32 = 277;
pub const GPUREG_DEPTHBUFFER_FORMAT: u32 = 278;
pub const GPUREG_COLORBUFFER_FORMAT: u32 = 279;
pub const GPUREG_EARLYDEPTH_TEST2: u32 = 280;
pub const GPUREG_0119: u32 = 281;
pub const GPUREG_011A: u32 = 282;
pub const GPUREG_FRAMEBUFFER_BLOCK32: u32 = 283;
pub const GPUREG_DEPTHBUFFER_LOC: u32 = 284;
pub const GPUREG_COLORBUFFER_LOC: u32 = 285;
pub const GPUREG_FRAMEBUFFER_DIM: u32 = 286;
pub const GPUREG_011F: u32 = 287;
pub const GPUREG_GAS_LIGHT_XY: u32 = 288;
pub const GPUREG_GAS_LIGHT_Z: u32 = 289;
pub const GPUREG_GAS_LIGHT_Z_COLOR: u32 = 290;
pub const GPUREG_GAS_LUT_INDEX: u32 = 291;
pub const GPUREG_GAS_LUT_DATA: u32 = 292;
pub const GPUREG_GAS_ACCMAX_FEEDBACK: u32 = 293;
pub const GPUREG_GAS_DELTAZ_DEPTH: u32 = 294;
pub const GPUREG_0127: u32 = 295;
pub const GPUREG_0128: u32 = 296;
pub const GPUREG_0129: u32 = 297;
pub const GPUREG_012A: u32 = 298;
pub const GPUREG_012B: u32 = 299;
pub const GPUREG_012C: u32 = 300;
pub const GPUREG_012D: u32 = 301;
pub const GPUREG_012E: u32 = 302;
pub const GPUREG_012F: u32 = 303;
pub const GPUREG_FRAGOP_SHADOW: u32 = 304;
pub const GPUREG_0131: u32 = 305;
pub const GPUREG_0132: u32 = 306;
pub const GPUREG_0133: u32 = 307;
pub const GPUREG_0134: u32 = 308;
pub const GPUREG_0135: u32 = 309;
pub const GPUREG_0136: u32 = 310;
pub const GPUREG_0137: u32 = 311;
pub const GPUREG_0138: u32 = 312;
pub const GPUREG_0139: u32 = 313;
pub const GPUREG_013A: u32 = 314;
pub const GPUREG_013B: u32 = 315;
pub const GPUREG_013C: u32 = 316;
pub const GPUREG_013D: u32 = 317;
pub const GPUREG_013E: u32 = 318;
pub const GPUREG_013F: u32 = 319;
pub const GPUREG_LIGHT0_SPECULAR0: u32 = 320;
pub const GPUREG_LIGHT0_SPECULAR1: u32 = 321;
pub const GPUREG_LIGHT0_DIFFUSE: u32 = 322;
pub const GPUREG_LIGHT0_AMBIENT: u32 = 323;
pub const GPUREG_LIGHT0_XY: u32 = 324;
pub const GPUREG_LIGHT0_Z: u32 = 325;
pub const GPUREG_LIGHT0_SPOTDIR_XY: u32 = 326;
pub const GPUREG_LIGHT0_SPOTDIR_Z: u32 = 327;
pub const GPUREG_0148: u32 = 328;
pub const GPUREG_LIGHT0_CONFIG: u32 = 329;
pub const GPUREG_LIGHT0_ATTENUATION_BIAS: u32 = 330;
pub const GPUREG_LIGHT0_ATTENUATION_SCALE: u32 = 331;
pub const GPUREG_014C: u32 = 332;
pub const GPUREG_014D: u32 = 333;
pub const GPUREG_014E: u32 = 334;
pub const GPUREG_014F: u32 = 335;
pub const GPUREG_LIGHT1_SPECULAR0: u32 = 336;
pub const GPUREG_LIGHT1_SPECULAR1: u32 = 337;
pub const GPUREG_LIGHT1_DIFFUSE: u32 = 338;
pub const GPUREG_LIGHT1_AMBIENT: u32 = 339;
pub const GPUREG_LIGHT1_XY: u32 = 340;
pub const GPUREG_LIGHT1_Z: u32 = 341;
pub const GPUREG_LIGHT1_SPOTDIR_XY: u32 = 342;
pub const GPUREG_LIGHT1_SPOTDIR_Z: u32 = 343;
pub const GPUREG_0158: u32 = 344;
pub const GPUREG_LIGHT1_CONFIG: u32 = 345;
pub const GPUREG_LIGHT1_ATTENUATION_BIAS: u32 = 346;
pub const GPUREG_LIGHT1_ATTENUATION_SCALE: u32 = 347;
pub const GPUREG_015C: u32 = 348;
pub const GPUREG_015D: u32 = 349;
pub const GPUREG_015E: u32 = 350;
pub const GPUREG_015F: u32 = 351;
pub const GPUREG_LIGHT2_SPECULAR0: u32 = 352;
pub const GPUREG_LIGHT2_SPECULAR1: u32 = 353;
pub const GPUREG_LIGHT2_DIFFUSE: u32 = 354;
pub const GPUREG_LIGHT2_AMBIENT: u32 = 355;
pub const GPUREG_LIGHT2_XY: u32 = 356;
pub const GPUREG_LIGHT2_Z: u32 = 357;
pub const GPUREG_LIGHT2_SPOTDIR_XY: u32 = 358;
pub const GPUREG_LIGHT2_SPOTDIR_Z: u32 = 359;
pub const GPUREG_0168: u32 = 360;
pub const GPUREG_LIGHT2_CONFIG: u32 = 361;
pub const GPUREG_LIGHT2_ATTENUATION_BIAS: u32 = 362;
pub const GPUREG_LIGHT2_ATTENUATION_SCALE: u32 = 363;
pub const GPUREG_016C: u32 = 364;
pub const GPUREG_016D: u32 = 365;
pub const GPUREG_016E: u32 = 366;
pub const GPUREG_016F: u32 = 367;
pub const GPUREG_LIGHT3_SPECULAR0: u32 = 368;
pub const GPUREG_LIGHT3_SPECULAR1: u32 = 369;
pub const GPUREG_LIGHT3_DIFFUSE: u32 = 370;
pub const GPUREG_LIGHT3_AMBIENT: u32 = 371;
pub const GPUREG_LIGHT3_XY: u32 = 372;
pub const GPUREG_LIGHT3_Z: u32 = 373;
pub const GPUREG_LIGHT3_SPOTDIR_XY: u32 = 374;
pub const GPUREG_LIGHT3_SPOTDIR_Z: u32 = 375;
pub const GPUREG_0178: u32 = 376;
pub const GPUREG_LIGHT3_CONFIG: u32 = 377;
pub const GPUREG_LIGHT3_ATTENUATION_BIAS: u32 = 378;
pub const GPUREG_LIGHT3_ATTENUATION_SCALE: u32 = 379;
pub const GPUREG_017C: u32 = 380;
pub const GPUREG_017D: u32 = 381;
pub const GPUREG_017E: u32 = 382;
pub const GPUREG_017F: u32 = 383;
pub const GPUREG_LIGHT4_SPECULAR0: u32 = 384;
pub const GPUREG_LIGHT4_SPECULAR1: u32 = 385;
pub const GPUREG_LIGHT4_DIFFUSE: u32 = 386;
pub const GPUREG_LIGHT4_AMBIENT: u32 = 387;
pub const GPUREG_LIGHT4_XY: u32 = 388;
pub const GPUREG_LIGHT4_Z: u32 = 389;
pub const GPUREG_LIGHT4_SPOTDIR_XY: u32 = 390;
pub const GPUREG_LIGHT4_SPOTDIR_Z: u32 = 391;
pub const GPUREG_0188: u32 = 392;
pub const GPUREG_LIGHT4_CONFIG: u32 = 393;
pub const GPUREG_LIGHT4_ATTENUATION_BIAS: u32 = 394;
pub const GPUREG_LIGHT4_ATTENUATION_SCALE: u32 = 395;
pub const GPUREG_018C: u32 = 396;
pub const GPUREG_018D: u32 = 397;
pub const GPUREG_018E: u32 = 398;
pub const GPUREG_018F: u32 = 399;
pub const GPUREG_LIGHT5_SPECULAR0: u32 = 400;
pub const GPUREG_LIGHT5_SPECULAR1: u32 = 401;
pub const GPUREG_LIGHT5_DIFFUSE: u32 = 402;
pub const GPUREG_LIGHT5_AMBIENT: u32 = 403;
pub const GPUREG_LIGHT5_XY: u32 = 404;
pub const GPUREG_LIGHT5_Z: u32 = 405;
pub const GPUREG_LIGHT5_SPOTDIR_XY: u32 = 406;
pub const GPUREG_LIGHT5_SPOTDIR_Z: u32 = 407;
pub const GPUREG_0198: u32 = 408;
pub const GPUREG_LIGHT5_CONFIG: u32 = 409;
pub const GPUREG_LIGHT5_ATTENUATION_BIAS: u32 = 410;
pub const GPUREG_LIGHT5_ATTENUATION_SCALE: u32 = 411;
pub const GPUREG_019C: u32 = 412;
pub const GPUREG_019D: u32 = 413;
pub const GPUREG_019E: u32 = 414;
pub const GPUREG_019F: u32 = 415;
pub const GPUREG_LIGHT6_SPECULAR0: u32 = 416;
pub const GPUREG_LIGHT6_SPECULAR1: u32 = 417;
pub const GPUREG_LIGHT6_DIFFUSE: u32 = 418;
pub const GPUREG_LIGHT6_AMBIENT: u32 = 419;
pub const GPUREG_LIGHT6_XY: u32 = 420;
pub const GPUREG_LIGHT6_Z: u32 = 421;
pub const GPUREG_LIGHT6_SPOTDIR_XY: u32 = 422;
pub const GPUREG_LIGHT6_SPOTDIR_Z: u32 = 423;
pub const GPUREG_01A8: u32 = 424;
pub const GPUREG_LIGHT6_CONFIG: u32 = 425;
pub const GPUREG_LIGHT6_ATTENUATION_BIAS: u32 = 426;
pub const GPUREG_LIGHT6_ATTENUATION_SCALE: u32 = 427;
pub const GPUREG_01AC: u32 = 428;
pub const GPUREG_01AD: u32 = 429;
pub const GPUREG_01AE: u32 = 430;
pub const GPUREG_01AF: u32 = 431;
pub const GPUREG_LIGHT7_SPECULAR0: u32 = 432;
pub const GPUREG_LIGHT7_SPECULAR1: u32 = 433;
pub const GPUREG_LIGHT7_DIFFUSE: u32 = 434;
pub const GPUREG_LIGHT7_AMBIENT: u32 = 435;
pub const GPUREG_LIGHT7_XY: u32 = 436;
pub const GPUREG_LIGHT7_Z: u32 = 437;
pub const GPUREG_LIGHT7_SPOTDIR_XY: u32 = 438;
pub const GPUREG_LIGHT7_SPOTDIR_Z: u32 = 439;
pub const GPUREG_01B8: u32 = 440;
pub const GPUREG_LIGHT7_CONFIG: u32 = 441;
pub const GPUREG_LIGHT7_ATTENUATION_BIAS: u32 = 442;
pub const GPUREG_LIGHT7_ATTENUATION_SCALE: u32 = 443;
pub const GPUREG_01BC: u32 = 444;
pub const GPUREG_01BD: u32 = 445;
pub const GPUREG_01BE: u32 = 446;
pub const GPUREG_01BF: u32 = 447;
pub const GPUREG_LIGHTING_AMBIENT: u32 = 448;
pub const GPUREG_01C1: u32 = 449;
pub const GPUREG_LIGHTING_NUM_LIGHTS: u32 = 450;
pub const GPUREG_LIGHTING_CONFIG0: u32 = 451;
pub const GPUREG_LIGHTING_CONFIG1: u32 = 452;
pub const GPUREG_LIGHTING_LUT_INDEX: u32 = 453;
pub const GPUREG_LIGHTING_ENABLE1: u32 = 454;
pub const GPUREG_01C7: u32 = 455;
pub const GPUREG_LIGHTING_LUT_DATA0: u32 = 456;
pub const GPUREG_LIGHTING_LUT_DATA1: u32 = 457;
pub const GPUREG_LIGHTING_LUT_DATA2: u32 = 458;
pub const GPUREG_LIGHTING_LUT_DATA3: u32 = 459;
pub const GPUREG_LIGHTING_LUT_DATA4: u32 = 460;
pub const GPUREG_LIGHTING_LUT_DATA5: u32 = 461;
pub const GPUREG_LIGHTING_LUT_DATA6: u32 = 462;
pub const GPUREG_LIGHTING_LUT_DATA7: u32 = 463;
pub const GPUREG_LIGHTING_LUTINPUT_ABS: u32 = 464;
pub const GPUREG_LIGHTING_LUTINPUT_SELECT: u32 = 465;
pub const GPUREG_LIGHTING_LUTINPUT_SCALE: u32 = 466;
pub const GPUREG_01D3: u32 = 467;
pub const GPUREG_01D4: u32 = 468;
pub const GPUREG_01D5: u32 = 469;
pub const GPUREG_01D6: u32 = 470;
pub const GPUREG_01D7: u32 = 471;
pub const GPUREG_01D8: u32 = 472;
pub const GPUREG_LIGHTING_LIGHT_PERMUTATION: u32 = 473;
pub const GPUREG_01DA: u32 = 474;
pub const GPUREG_01DB: u32 = 475;
pub const GPUREG_01DC: u32 = 476;
pub const GPUREG_01DD: u32 = 477;
pub const GPUREG_01DE: u32 = 478;
pub const GPUREG_01DF: u32 = 479;
pub const GPUREG_01E0: u32 = 480;
pub const GPUREG_01E1: u32 = 481;
pub const GPUREG_01E2: u32 = 482;
pub const GPUREG_01E3: u32 = 483;
pub const GPUREG_01E4: u32 = 484;
pub const GPUREG_01E5: u32 = 485;
pub const GPUREG_01E6: u32 = 486;
pub const GPUREG_01E7: u32 = 487;
pub const GPUREG_01E8: u32 = 488;
pub const GPUREG_01E9: u32 = 489;
pub const GPUREG_01EA: u32 = 490;
pub const GPUREG_01EB: u32 = 491;
pub const GPUREG_01EC: u32 = 492;
pub const GPUREG_01ED: u32 = 493;
pub const GPUREG_01EE: u32 = 494;
pub const GPUREG_01EF: u32 = 495;
pub const GPUREG_01F0: u32 = 496;
pub const GPUREG_01F1: u32 = 497;
pub const GPUREG_01F2: u32 = 498;
pub const GPUREG_01F3: u32 = 499;
pub const GPUREG_01F4: u32 = 500;
pub const GPUREG_01F5: u32 = 501;
pub const GPUREG_01F6: u32 = 502;
pub const GPUREG_01F7: u32 = 503;
pub const GPUREG_01F8: u32 = 504;
pub const GPUREG_01F9: u32 = 505;
pub const GPUREG_01FA: u32 = 506;
pub const GPUREG_01FB: u32 = 507;
pub const GPUREG_01FC: u32 = 508;
pub const GPUREG_01FD: u32 = 509;
pub const GPUREG_01FE: u32 = 510;
pub const GPUREG_01FF: u32 = 511;
pub const GPUREG_ATTRIBBUFFERS_LOC: u32 = 512;
pub const GPUREG_ATTRIBBUFFERS_FORMAT_LOW: u32 = 513;
pub const GPUREG_ATTRIBBUFFERS_FORMAT_HIGH: u32 = 514;
pub const GPUREG_ATTRIBBUFFER0_OFFSET: u32 = 515;
pub const GPUREG_ATTRIBBUFFER0_CONFIG1: u32 = 516;
pub const GPUREG_ATTRIBBUFFER0_CONFIG2: u32 = 517;
pub const GPUREG_ATTRIBBUFFER1_OFFSET: u32 = 518;
pub const GPUREG_ATTRIBBUFFER1_CONFIG1: u32 = 519;
pub const GPUREG_ATTRIBBUFFER1_CONFIG2: u32 = 520;
pub const GPUREG_ATTRIBBUFFER2_OFFSET: u32 = 521;
pub const GPUREG_ATTRIBBUFFER2_CONFIG1: u32 = 522;
pub const GPUREG_ATTRIBBUFFER2_CONFIG2: u32 = 523;
pub const GPUREG_ATTRIBBUFFER3_OFFSET: u32 = 524;
pub const GPUREG_ATTRIBBUFFER3_CONFIG1: u32 = 525;
pub const GPUREG_ATTRIBBUFFER3_CONFIG2: u32 = 526;
pub const GPUREG_ATTRIBBUFFER4_OFFSET: u32 = 527;
pub const GPUREG_ATTRIBBUFFER4_CONFIG1: u32 = 528;
pub const GPUREG_ATTRIBBUFFER4_CONFIG2: u32 = 529;
pub const GPUREG_ATTRIBBUFFER5_OFFSET: u32 = 530;
pub const GPUREG_ATTRIBBUFFER5_CONFIG1: u32 = 531;
pub const GPUREG_ATTRIBBUFFER5_CONFIG2: u32 = 532;
pub const GPUREG_ATTRIBBUFFER6_OFFSET: u32 = 533;
pub const GPUREG_ATTRIBBUFFER6_CONFIG1: u32 = 534;
pub const GPUREG_ATTRIBBUFFER6_CONFIG2: u32 = 535;
pub const GPUREG_ATTRIBBUFFER7_OFFSET: u32 = 536;
pub const GPUREG_ATTRIBBUFFER7_CONFIG1: u32 = 537;
pub const GPUREG_ATTRIBBUFFER7_CONFIG2: u32 = 538;
pub const GPUREG_ATTRIBBUFFER8_OFFSET: u32 = 539;
pub const GPUREG_ATTRIBBUFFER8_CONFIG1: u32 = 540;
pub const GPUREG_ATTRIBBUFFER8_CONFIG2: u32 = 541;
pub const GPUREG_ATTRIBBUFFER9_OFFSET: u32 = 542;
pub const GPUREG_ATTRIBBUFFER9_CONFIG1: u32 = 543;
pub const GPUREG_ATTRIBBUFFER9_CONFIG2: u32 = 544;
pub const GPUREG_ATTRIBBUFFERA_OFFSET: u32 = 545;
pub const GPUREG_ATTRIBBUFFERA_CONFIG1: u32 = 546;
pub const GPUREG_ATTRIBBUFFERA_CONFIG2: u32 = 547;
pub const GPUREG_ATTRIBBUFFERB_OFFSET: u32 = 548;
pub const GPUREG_ATTRIBBUFFERB_CONFIG1: u32 = 549;
pub const GPUREG_ATTRIBBUFFERB_CONFIG2: u32 = 550;
pub const GPUREG_INDEXBUFFER_CONFIG: u32 = 551;
pub const GPUREG_NUMVERTICES: u32 = 552;
pub const GPUREG_GEOSTAGE_CONFIG: u32 = 553;
pub const GPUREG_VERTEX_OFFSET: u32 = 554;
pub const GPUREG_022B: u32 = 555;
pub const GPUREG_022C: u32 = 556;
pub const GPUREG_POST_VERTEX_CACHE_NUM: u32 = 557;
pub const GPUREG_DRAWARRAYS: u32 = 558;
pub const GPUREG_DRAWELEMENTS: u32 = 559;
pub const GPUREG_0230: u32 = 560;
pub const GPUREG_VTX_FUNC: u32 = 561;
pub const GPUREG_FIXEDATTRIB_INDEX: u32 = 562;
pub const GPUREG_FIXEDATTRIB_DATA0: u32 = 563;
pub const GPUREG_FIXEDATTRIB_DATA1: u32 = 564;
pub const GPUREG_FIXEDATTRIB_DATA2: u32 = 565;
pub const GPUREG_0236: u32 = 566;
pub const GPUREG_0237: u32 = 567;
pub const GPUREG_CMDBUF_SIZE0: u32 = 568;
pub const GPUREG_CMDBUF_SIZE1: u32 = 569;
pub const GPUREG_CMDBUF_ADDR0: u32 = 570;
pub const GPUREG_CMDBUF_ADDR1: u32 = 571;
pub const GPUREG_CMDBUF_JUMP0: u32 = 572;
pub const GPUREG_CMDBUF_JUMP1: u32 = 573;
pub const GPUREG_023E: u32 = 574;
pub const GPUREG_023F: u32 = 575;
pub const GPUREG_0240: u32 = 576;
pub const GPUREG_0241: u32 = 577;
pub const GPUREG_VSH_NUM_ATTR: u32 = 578;
pub const GPUREG_0243: u32 = 579;
pub const GPUREG_VSH_COM_MODE: u32 = 580;
pub const GPUREG_START_DRAW_FUNC0: u32 = 581;
pub const GPUREG_0246: u32 = 582;
pub const GPUREG_0247: u32 = 583;
pub const GPUREG_0248: u32 = 584;
pub const GPUREG_0249: u32 = 585;
pub const GPUREG_VSH_OUTMAP_TOTAL1: u32 = 586;
pub const GPUREG_024B: u32 = 587;
pub const GPUREG_024C: u32 = 588;
pub const GPUREG_024D: u32 = 589;
pub const GPUREG_024E: u32 = 590;
pub const GPUREG_024F: u32 = 591;
pub const GPUREG_0250: u32 = 592;
pub const GPUREG_VSH_OUTMAP_TOTAL2: u32 = 593;
pub const GPUREG_GSH_MISC0: u32 = 594;
pub const GPUREG_GEOSTAGE_CONFIG2: u32 = 595;
pub const GPUREG_GSH_MISC1: u32 = 596;
pub const GPUREG_0255: u32 = 597;
pub const GPUREG_0256: u32 = 598;
pub const GPUREG_0257: u32 = 599;
pub const GPUREG_0258: u32 = 600;
pub const GPUREG_0259: u32 = 601;
pub const GPUREG_025A: u32 = 602;
pub const GPUREG_025B: u32 = 603;
pub const GPUREG_025C: u32 = 604;
pub const GPUREG_025D: u32 = 605;
pub const GPUREG_PRIMITIVE_CONFIG: u32 = 606;
pub const GPUREG_RESTART_PRIMITIVE: u32 = 607;
pub const GPUREG_0260: u32 = 608;
pub const GPUREG_0261: u32 = 609;
pub const GPUREG_0262: u32 = 610;
pub const GPUREG_0263: u32 = 611;
pub const GPUREG_0264: u32 = 612;
pub const GPUREG_0265: u32 = 613;
pub const GPUREG_0266: u32 = 614;
pub const GPUREG_0267: u32 = 615;
pub const GPUREG_0268: u32 = 616;
pub const GPUREG_0269: u32 = 617;
pub const GPUREG_026A: u32 = 618;
pub const GPUREG_026B: u32 = 619;
pub const GPUREG_026C: u32 = 620;
pub const GPUREG_026D: u32 = 621;
pub const GPUREG_026E: u32 = 622;
pub const GPUREG_026F: u32 = 623;
pub const GPUREG_0270: u32 = 624;
pub const GPUREG_0271: u32 = 625;
pub const GPUREG_0272: u32 = 626;
pub const GPUREG_0273: u32 = 627;
pub const GPUREG_0274: u32 = 628;
pub const GPUREG_0275: u32 = 629;
pub const GPUREG_0276: u32 = 630;
pub const GPUREG_0277: u32 = 631;
pub const GPUREG_0278: u32 = 632;
pub const GPUREG_0279: u32 = 633;
pub const GPUREG_027A: u32 = 634;
pub const GPUREG_027B: u32 = 635;
pub const GPUREG_027C: u32 = 636;
pub const GPUREG_027D: u32 = 637;
pub const GPUREG_027E: u32 = 638;
pub const GPUREG_027F: u32 = 639;
pub const GPUREG_GSH_BOOLUNIFORM: u32 = 640;
pub const GPUREG_GSH_INTUNIFORM_I0: u32 = 641;
pub const GPUREG_GSH_INTUNIFORM_I1: u32 = 642;
pub const GPUREG_GSH_INTUNIFORM_I2: u32 = 643;
pub const GPUREG_GSH_INTUNIFORM_I3: u32 = 644;
pub const GPUREG_0285: u32 = 645;
pub const GPUREG_0286: u32 = 646;
pub const GPUREG_0287: u32 = 647;
pub const GPUREG_0288: u32 = 648;
pub const GPUREG_GSH_INPUTBUFFER_CONFIG: u32 = 649;
pub const GPUREG_GSH_ENTRYPOINT: u32 = 650;
pub const GPUREG_GSH_ATTRIBUTES_PERMUTATION_LOW: u32 = 651;
pub const GPUREG_GSH_ATTRIBUTES_PERMUTATION_HIGH: u32 = 652;
pub const GPUREG_GSH_OUTMAP_MASK: u32 = 653;
pub const GPUREG_028E: u32 = 654;
pub const GPUREG_GSH_CODETRANSFER_END: u32 = 655;
pub const GPUREG_GSH_FLOATUNIFORM_CONFIG: u32 = 656;
pub const GPUREG_GSH_FLOATUNIFORM_DATA: u32 = 657;
pub const GPUREG_0299: u32 = 665;
pub const GPUREG_029A: u32 = 666;
pub const GPUREG_GSH_CODETRANSFER_CONFIG: u32 = 667;
pub const GPUREG_GSH_CODETRANSFER_DATA: u32 = 668;
pub const GPUREG_02A4: u32 = 676;
pub const GPUREG_GSH_OPDESCS_CONFIG: u32 = 677;
pub const GPUREG_GSH_OPDESCS_DATA: u32 = 678;
pub const GPUREG_02AE: u32 = 686;
pub const GPUREG_02AF: u32 = 687;
pub const GPUREG_VSH_BOOLUNIFORM: u32 = 688;
pub const GPUREG_VSH_INTUNIFORM_I0: u32 = 689;
pub const GPUREG_VSH_INTUNIFORM_I1: u32 = 690;
pub const GPUREG_VSH_INTUNIFORM_I2: u32 = 691;
pub const GPUREG_VSH_INTUNIFORM_I3: u32 = 692;
pub const GPUREG_02B5: u32 = 693;
pub const GPUREG_02B6: u32 = 694;
pub const GPUREG_02B7: u32 = 695;
pub const GPUREG_02B8: u32 = 696;
pub const GPUREG_VSH_INPUTBUFFER_CONFIG: u32 = 697;
pub const GPUREG_VSH_ENTRYPOINT: u32 = 698;
pub const GPUREG_VSH_ATTRIBUTES_PERMUTATION_LOW: u32 = 699;
pub const GPUREG_VSH_ATTRIBUTES_PERMUTATION_HIGH: u32 = 700;
pub const GPUREG_VSH_OUTMAP_MASK: u32 = 701;
pub const GPUREG_02BE: u32 = 702;
pub const GPUREG_VSH_CODETRANSFER_END: u32 = 703;
pub const GPUREG_VSH_FLOATUNIFORM_CONFIG: u32 = 704;
pub const GPUREG_VSH_FLOATUNIFORM_DATA: u32 = 705;
pub const GPUREG_02C9: u32 = 713;
pub const GPUREG_02CA: u32 = 714;
pub const GPUREG_VSH_CODETRANSFER_CONFIG: u32 = 715;
pub const GPUREG_VSH_CODETRANSFER_DATA: u32 = 716;
pub const GPUREG_02D4: u32 = 724;
pub const GPUREG_VSH_OPDESCS_CONFIG: u32 = 725;
pub const GPUREG_VSH_OPDESCS_DATA: u32 = 726;
pub const GPUREG_02DE: u32 = 734;
pub const GPUREG_02DF: u32 = 735;
pub const GPUREG_02E0: u32 = 736;
pub const GPUREG_02E1: u32 = 737;
pub const GPUREG_02E2: u32 = 738;
pub const GPUREG_02E3: u32 = 739;
pub const GPUREG_02E4: u32 = 740;
pub const GPUREG_02E5: u32 = 741;
pub const GPUREG_02E6: u32 = 742;
pub const GPUREG_02E7: u32 = 743;
pub const GPUREG_02E8: u32 = 744;
pub const GPUREG_02E9: u32 = 745;
pub const GPUREG_02EA: u32 = 746;
pub const GPUREG_02EB: u32 = 747;
pub const GPUREG_02EC: u32 = 748;
pub const GPUREG_02ED: u32 = 749;
pub const GPUREG_02EE: u32 = 750;
pub const GPUREG_02EF: u32 = 751;
pub const GPUREG_02F0: u32 = 752;
pub const GPUREG_02F1: u32 = 753;
pub const GPUREG_02F2: u32 = 754;
pub const GPUREG_02F3: u32 = 755;
pub const GPUREG_02F4: u32 = 756;
pub const GPUREG_02F5: u32 = 757;
pub const GPUREG_02F6: u32 = 758;
pub const GPUREG_02F7: u32 = 759;
pub const GPUREG_02F8: u32 = 760;
pub const GPUREG_02F9: u32 = 761;
pub const GPUREG_02FA: u32 = 762;
pub const GPUREG_02FB: u32 = 763;
pub const GPUREG_02FC: u32 = 764;
pub const GPUREG_02FD: u32 = 765;
pub const GPUREG_02FE: u32 = 766;
pub const GPUREG_02FF: u32 = 767;
pub const NDSP_SAMPLE_RATE: f64 = 32728.498046875;
pub const SWKBD_MAX_WORD_LEN: u32 = 40;
pub const SWKBD_MAX_BUTTON_TEXT_LEN: u32 = 16;
pub const SWKBD_MAX_HINT_TEXT_LEN: u32 = 64;
pub const SWKBD_MAX_CALLBACK_MSG_LEN: u32 = 256;
pub const MIISELECTOR_MAGIC: u32 = 333326543;
pub const MIISELECTOR_TITLE_LEN: u32 = 64;
pub const MIISELECTOR_GUESTMII_SLOTS: u32 = 6;
pub const MIISELECTOR_USERMII_SLOTS: u32 = 100;
pub const MIISELECTOR_GUESTMII_NAME_LEN: u32 = 12;
pub const ARCHIVE_DIRITER_MAGIC: u32 = 1751347809;
pub const LINK3DS_COMM_PORT: u32 = 17491;
pub const __error_t_defined: u32 = 1;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const ENOMSG: u32 = 35;
pub const EIDRM: u32 = 36;
pub const EDEADLK: u32 = 45;
pub const ENOLCK: u32 = 46;
pub const ENOSTR: u32 = 60;
pub const ENODATA: u32 = 61;
pub const ETIME: u32 = 62;
pub const ENOSR: u32 = 63;
pub const ENOLINK: u32 = 67;
pub const EPROTO: u32 = 71;
pub const EMULTIHOP: u32 = 74;
pub const EBADMSG: u32 = 77;
pub const EFTYPE: u32 = 79;
pub const ENOSYS: u32 = 88;
pub const ENOTEMPTY: u32 = 90;
pub const ENAMETOOLONG: u32 = 91;
pub const ELOOP: u32 = 92;
pub const EOPNOTSUPP: u32 = 95;
pub const EPFNOSUPPORT: u32 = 96;
pub const ECONNRESET: u32 = 104;
pub const ENOBUFS: u32 = 105;
pub const EAFNOSUPPORT: u32 = 106;
pub const EPROTOTYPE: u32 = 107;
pub const ENOTSOCK: u32 = 108;
pub const ENOPROTOOPT: u32 = 109;
pub const ECONNREFUSED: u32 = 111;
pub const EADDRINUSE: u32 = 112;
pub const ECONNABORTED: u32 = 113;
pub const ENETUNREACH: u32 = 114;
pub const ENETDOWN: u32 = 115;
pub const ETIMEDOUT: u32 = 116;
pub const EHOSTDOWN: u32 = 117;
pub const EHOSTUNREACH: u32 = 118;
pub const EINPROGRESS: u32 = 119;
pub const EALREADY: u32 = 120;
pub const EDESTADDRREQ: u32 = 121;
pub const EMSGSIZE: u32 = 122;
pub const EPROTONOSUPPORT: u32 = 123;
pub const EADDRNOTAVAIL: u32 = 125;
pub const ENETRESET: u32 = 126;
pub const EISCONN: u32 = 127;
pub const ENOTCONN: u32 = 128;
pub const ETOOMANYREFS: u32 = 129;
pub const EDQUOT: u32 = 132;
pub const ESTALE: u32 = 133;
pub const ENOTSUP: u32 = 134;
pub const EILSEQ: u32 = 138;
pub const EOVERFLOW: u32 = 139;
pub const ECANCELED: u32 = 140;
pub const ENOTRECOVERABLE: u32 = 141;
pub const EOWNERDEAD: u32 = 142;
pub const EWOULDBLOCK: u32 = 11;
pub const __ELASTERROR: u32 = 2000;
pub type __int8_t = ::libc::c_schar;
pub type __uint8_t = ::libc::c_uchar;
pub type __int16_t = ::libc::c_short;
pub type __uint16_t = ::libc::c_ushort;
pub type __int32_t = ::libc::c_int;
pub type __uint32_t = ::libc::c_uint;
pub type __int64_t = ::libc::c_longlong;
pub type __uint64_t = ::libc::c_ulonglong;
pub type __int_least8_t = ::libc::c_schar;
pub type __uint_least8_t = ::libc::c_uchar;
pub type __int_least16_t = ::libc::c_short;
pub type __uint_least16_t = ::libc::c_ushort;
pub type __int_least32_t = ::libc::c_int;
pub type __uint_least32_t = ::libc::c_uint;
pub type __int_least64_t = ::libc::c_longlong;
pub type __uint_least64_t = ::libc::c_ulonglong;
pub type __intmax_t = ::libc::c_longlong;
pub type __uintmax_t = ::libc::c_ulonglong;
pub type __intptr_t = ::libc::c_int;
pub type __uintptr_t = ::libc::c_uint;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type int_least8_t = __int_least8_t;
pub type uint_least8_t = __uint_least8_t;
pub type int_least16_t = __int_least16_t;
pub type uint_least16_t = __uint_least16_t;
pub type int_least32_t = __int_least32_t;
pub type uint_least32_t = __uint_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::libc::c_schar;
pub type uint_fast8_t = ::libc::c_uchar;
pub type int_fast16_t = ::libc::c_short;
pub type uint_fast16_t = ::libc::c_ushort;
pub type int_fast32_t = ::libc::c_int;
pub type uint_fast32_t = ::libc::c_uint;
pub type int_fast64_t = ::libc::c_longlong;
pub type uint_fast64_t = ::libc::c_ulonglong;
pub type wchar_t = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::libc::c_longlong,
    pub __clang_max_align_nonce2: f64,
}
pub type u8_ = u8;
pub type u16_ = u16;
pub type u32_ = u32;
pub type u64_ = u64;
pub type s8 = i8;
pub type s16 = i16;
pub type s32 = i32;
pub type s64 = i64;
pub type vu8 = u8_;
pub type vu16 = u16_;
pub type vu32 = u32_;
pub type vu64 = u64_;
pub type vs8 = s8;
pub type vs16 = s16;
pub type vs32 = s32;
pub type vs64 = s64;
pub type Handle = u32_;
pub type Result = s32;
pub type ThreadFunc = ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::libc::c_void)>;
pub type voidfn = ::core::option::Option<unsafe extern "C" fn()>;
#[doc = "Structure representing CPU registers"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CpuRegisters {
    #[doc = "< r0-r12."]
    pub r: [u32_; 13usize],
    #[doc = "< sp."]
    pub sp: u32_,
    #[doc = "< lr."]
    pub lr: u32_,
    #[doc = "< pc. May need to be adjusted."]
    pub pc: u32_,
    #[doc = "< cpsr."]
    pub cpsr: u32_,
}
#[doc = "Structure representing FPU registers"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FpuRegisters {
    pub __bindgen_anon_1: FpuRegisters__bindgen_ty_1,
    #[doc = "< fpscr."]
    pub fpscr: u32_,
    #[doc = "< fpexc."]
    pub fpexc: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union FpuRegisters__bindgen_ty_1 {
    pub __bindgen_anon_1: FpuRegisters__bindgen_ty_1__bindgen_ty_1,
    #[doc = "< s0-s31."]
    pub s: [f32; 32usize],
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FpuRegisters__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< d0-d15."]
    pub d: [f64; 16usize],
}
impl Default for FpuRegisters__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for FpuRegisters {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const RL_SUCCESS: _bindgen_ty_1 = 0;
pub const RL_INFO: _bindgen_ty_1 = 1;
pub const RL_FATAL: _bindgen_ty_1 = 31;
pub const RL_RESET: _bindgen_ty_1 = 30;
pub const RL_REINITIALIZE: _bindgen_ty_1 = 29;
pub const RL_USAGE: _bindgen_ty_1 = 28;
pub const RL_PERMANENT: _bindgen_ty_1 = 27;
pub const RL_TEMPORARY: _bindgen_ty_1 = 26;
pub const RL_STATUS: _bindgen_ty_1 = 25;
#[doc = "Result code level values."]
pub type _bindgen_ty_1 = ::libc::c_uint;
pub const RS_SUCCESS: _bindgen_ty_2 = 0;
pub const RS_NOP: _bindgen_ty_2 = 1;
pub const RS_WOULDBLOCK: _bindgen_ty_2 = 2;
pub const RS_OUTOFRESOURCE: _bindgen_ty_2 = 3;
pub const RS_NOTFOUND: _bindgen_ty_2 = 4;
pub const RS_INVALIDSTATE: _bindgen_ty_2 = 5;
pub const RS_NOTSUPPORTED: _bindgen_ty_2 = 6;
pub const RS_INVALIDARG: _bindgen_ty_2 = 7;
pub const RS_WRONGARG: _bindgen_ty_2 = 8;
pub const RS_CANCELED: _bindgen_ty_2 = 9;
pub const RS_STATUSCHANGED: _bindgen_ty_2 = 10;
pub const RS_INTERNAL: _bindgen_ty_2 = 11;
pub const RS_INVALIDRESVAL: _bindgen_ty_2 = 63;
#[doc = "Result code summary values."]
pub type _bindgen_ty_2 = ::libc::c_uint;
pub const RM_COMMON: _bindgen_ty_3 = 0;
pub const RM_KERNEL: _bindgen_ty_3 = 1;
pub const RM_UTIL: _bindgen_ty_3 = 2;
pub const RM_FILE_SERVER: _bindgen_ty_3 = 3;
pub const RM_LOADER_SERVER: _bindgen_ty_3 = 4;
pub const RM_TCB: _bindgen_ty_3 = 5;
pub const RM_OS: _bindgen_ty_3 = 6;
pub const RM_DBG: _bindgen_ty_3 = 7;
pub const RM_DMNT: _bindgen_ty_3 = 8;
pub const RM_PDN: _bindgen_ty_3 = 9;
pub const RM_GSP: _bindgen_ty_3 = 10;
pub const RM_I2C: _bindgen_ty_3 = 11;
pub const RM_GPIO: _bindgen_ty_3 = 12;
pub const RM_DD: _bindgen_ty_3 = 13;
pub const RM_CODEC: _bindgen_ty_3 = 14;
pub const RM_SPI: _bindgen_ty_3 = 15;
pub const RM_PXI: _bindgen_ty_3 = 16;
pub const RM_FS: _bindgen_ty_3 = 17;
pub const RM_DI: _bindgen_ty_3 = 18;
pub const RM_HID: _bindgen_ty_3 = 19;
pub const RM_CAM: _bindgen_ty_3 = 20;
pub const RM_PI: _bindgen_ty_3 = 21;
pub const RM_PM: _bindgen_ty_3 = 22;
pub const RM_PM_LOW: _bindgen_ty_3 = 23;
pub const RM_FSI: _bindgen_ty_3 = 24;
pub const RM_SRV: _bindgen_ty_3 = 25;
pub const RM_NDM: _bindgen_ty_3 = 26;
pub const RM_NWM: _bindgen_ty_3 = 27;
pub const RM_SOC: _bindgen_ty_3 = 28;
pub const RM_LDR: _bindgen_ty_3 = 29;
pub const RM_ACC: _bindgen_ty_3 = 30;
pub const RM_ROMFS: _bindgen_ty_3 = 31;
pub const RM_AM: _bindgen_ty_3 = 32;
pub const RM_HIO: _bindgen_ty_3 = 33;
pub const RM_UPDATER: _bindgen_ty_3 = 34;
pub const RM_MIC: _bindgen_ty_3 = 35;
pub const RM_FND: _bindgen_ty_3 = 36;
pub const RM_MP: _bindgen_ty_3 = 37;
pub const RM_MPWL: _bindgen_ty_3 = 38;
pub const RM_AC: _bindgen_ty_3 = 39;
pub const RM_HTTP: _bindgen_ty_3 = 40;
pub const RM_DSP: _bindgen_ty_3 = 41;
pub const RM_SND: _bindgen_ty_3 = 42;
pub const RM_DLP: _bindgen_ty_3 = 43;
pub const RM_HIO_LOW: _bindgen_ty_3 = 44;
pub const RM_CSND: _bindgen_ty_3 = 45;
pub const RM_SSL: _bindgen_ty_3 = 46;
pub const RM_AM_LOW: _bindgen_ty_3 = 47;
pub const RM_NEX: _bindgen_ty_3 = 48;
pub const RM_FRIENDS: _bindgen_ty_3 = 49;
pub const RM_RDT: _bindgen_ty_3 = 50;
pub const RM_APPLET: _bindgen_ty_3 = 51;
pub const RM_NIM: _bindgen_ty_3 = 52;
pub const RM_PTM: _bindgen_ty_3 = 53;
pub const RM_MIDI: _bindgen_ty_3 = 54;
pub const RM_MC: _bindgen_ty_3 = 55;
pub const RM_SWC: _bindgen_ty_3 = 56;
pub const RM_FATFS: _bindgen_ty_3 = 57;
pub const RM_NGC: _bindgen_ty_3 = 58;
pub const RM_CARD: _bindgen_ty_3 = 59;
pub const RM_CARDNOR: _bindgen_ty_3 = 60;
pub const RM_SDMC: _bindgen_ty_3 = 61;
pub const RM_BOSS: _bindgen_ty_3 = 62;
pub const RM_DBM: _bindgen_ty_3 = 63;
pub const RM_CONFIG: _bindgen_ty_3 = 64;
pub const RM_PS: _bindgen_ty_3 = 65;
pub const RM_CEC: _bindgen_ty_3 = 66;
pub const RM_IR: _bindgen_ty_3 = 67;
pub const RM_UDS: _bindgen_ty_3 = 68;
pub const RM_PL: _bindgen_ty_3 = 69;
pub const RM_CUP: _bindgen_ty_3 = 70;
pub const RM_GYROSCOPE: _bindgen_ty_3 = 71;
pub const RM_MCU: _bindgen_ty_3 = 72;
pub const RM_NS: _bindgen_ty_3 = 73;
pub const RM_NEWS: _bindgen_ty_3 = 74;
pub const RM_RO: _bindgen_ty_3 = 75;
pub const RM_GD: _bindgen_ty_3 = 76;
pub const RM_CARD_SPI: _bindgen_ty_3 = 77;
pub const RM_EC: _bindgen_ty_3 = 78;
pub const RM_WEB_BROWSER: _bindgen_ty_3 = 79;
pub const RM_TEST: _bindgen_ty_3 = 80;
pub const RM_ENC: _bindgen_ty_3 = 81;
pub const RM_PIA: _bindgen_ty_3 = 82;
pub const RM_ACT: _bindgen_ty_3 = 83;
pub const RM_VCTL: _bindgen_ty_3 = 84;
pub const RM_OLV: _bindgen_ty_3 = 85;
pub const RM_NEIA: _bindgen_ty_3 = 86;
pub const RM_NPNS: _bindgen_ty_3 = 87;
pub const RM_AVD: _bindgen_ty_3 = 90;
pub const RM_L2B: _bindgen_ty_3 = 91;
pub const RM_MVD: _bindgen_ty_3 = 92;
pub const RM_NFC: _bindgen_ty_3 = 93;
pub const RM_UART: _bindgen_ty_3 = 94;
pub const RM_SPM: _bindgen_ty_3 = 95;
pub const RM_QTM: _bindgen_ty_3 = 96;
pub const RM_NFP: _bindgen_ty_3 = 97;
pub const RM_APPLICATION: _bindgen_ty_3 = 254;
pub const RM_INVALIDRESVAL: _bindgen_ty_3 = 255;
#[doc = "Result code module values."]
pub type _bindgen_ty_3 = ::libc::c_uint;
pub const RD_SUCCESS: _bindgen_ty_4 = 0;
pub const RD_INVALID_RESULT_VALUE: _bindgen_ty_4 = 1023;
pub const RD_TIMEOUT: _bindgen_ty_4 = 1022;
pub const RD_OUT_OF_RANGE: _bindgen_ty_4 = 1021;
pub const RD_ALREADY_EXISTS: _bindgen_ty_4 = 1020;
pub const RD_CANCEL_REQUESTED: _bindgen_ty_4 = 1019;
pub const RD_NOT_FOUND: _bindgen_ty_4 = 1018;
pub const RD_ALREADY_INITIALIZED: _bindgen_ty_4 = 1017;
pub const RD_NOT_INITIALIZED: _bindgen_ty_4 = 1016;
pub const RD_INVALID_HANDLE: _bindgen_ty_4 = 1015;
pub const RD_INVALID_POINTER: _bindgen_ty_4 = 1014;
pub const RD_INVALID_ADDRESS: _bindgen_ty_4 = 1013;
pub const RD_NOT_IMPLEMENTED: _bindgen_ty_4 = 1012;
pub const RD_OUT_OF_MEMORY: _bindgen_ty_4 = 1011;
pub const RD_MISALIGNED_SIZE: _bindgen_ty_4 = 1010;
pub const RD_MISALIGNED_ADDRESS: _bindgen_ty_4 = 1009;
pub const RD_BUSY: _bindgen_ty_4 = 1008;
pub const RD_NO_DATA: _bindgen_ty_4 = 1007;
pub const RD_INVALID_COMBINATION: _bindgen_ty_4 = 1006;
pub const RD_INVALID_ENUM_VALUE: _bindgen_ty_4 = 1005;
pub const RD_INVALID_SIZE: _bindgen_ty_4 = 1004;
pub const RD_ALREADY_DONE: _bindgen_ty_4 = 1003;
pub const RD_NOT_AUTHORIZED: _bindgen_ty_4 = 1002;
pub const RD_TOO_LARGE: _bindgen_ty_4 = 1001;
pub const RD_INVALID_SELECTION: _bindgen_ty_4 = 1000;
#[doc = "Result code generic description values."]
pub type _bindgen_ty_4 = ::libc::c_uint;
#[doc = "< Readable"]
pub const IPC_BUFFER_R: IPC_BufferRights = 2;
#[doc = "< Writable"]
pub const IPC_BUFFER_W: IPC_BufferRights = 4;
#[doc = "< Readable and Writable"]
pub const IPC_BUFFER_RW: IPC_BufferRights = 6;
#[doc = "IPC buffer access rights."]
pub type IPC_BufferRights = ::libc::c_uint;
extern "C" {
    #[doc = "Creates a command header to be used for IPC\n # Arguments\n\n* `command_id` - ID of the command to create a header for.\n * `normal_params` - Size of the normal parameters in words. Up to 63.\n * `translate_params` - Size of the translate parameters in words. Up to 63.\n # Returns\n\nThe created IPC header.\n\n Normal parameters are sent directly to the process while the translate parameters might go through modifications and checks by the kernel.\n The translate parameters are described by headers generated with the IPC_Desc_* functions.\n\n > **Note:** While #normal_params is equivalent to the number of normal parameters, #translate_params includes the size occupied by the translate parameters headers."]
    #[link_name = "IPC_MakeHeader__extern"]
    pub fn IPC_MakeHeader(
        command_id: u16_,
        normal_params: ::libc::c_uint,
        translate_params: ::libc::c_uint,
    ) -> u32_;
}
extern "C" {
    #[doc = "Creates a header to share handles\n # Arguments\n\n* `number` - The number of handles following this header. Max 64.\n # Returns\n\nThe created shared handles header.\n\n The #number next values are handles that will be shared between the two processes.\n\n > **Note:** Zero values will have no effect."]
    #[link_name = "IPC_Desc_SharedHandles__extern"]
    pub fn IPC_Desc_SharedHandles(number: ::libc::c_uint) -> u32_;
}
extern "C" {
    #[doc = "Creates the header to transfer handle ownership\n # Arguments\n\n* `number` - The number of handles following this header. Max 64.\n # Returns\n\nThe created handle transfer header.\n\n The #number next values are handles that will be duplicated and closed by the other process.\n\n > **Note:** Zero values will have no effect."]
    #[link_name = "IPC_Desc_MoveHandles__extern"]
    pub fn IPC_Desc_MoveHandles(number: ::libc::c_uint) -> u32_;
}
extern "C" {
    #[doc = "Returns the code to ask the kernel to fill the handle with the current process ID.\n # Returns\n\nThe code to request the current process ID.\n\n The next value is a placeholder that will be replaced by the current process ID by the kernel."]
    #[link_name = "IPC_Desc_CurProcessId__extern"]
    pub fn IPC_Desc_CurProcessId() -> u32_;
}
extern "C" {
    #[link_name = "IPC_Desc_CurProcessHandle__extern"]
    pub fn IPC_Desc_CurProcessHandle() -> u32_;
}
extern "C" {
    #[doc = "Creates a header describing a static buffer.\n # Arguments\n\n* `size` - Size of the buffer. Max ?0x03FFFF?.\n * `buffer_id` - The Id of the buffer. Max 0xF.\n # Returns\n\nThe created static buffer header.\n\n The next value is a pointer to the buffer. It will be copied to TLS offset 0x180 + static_buffer_id*8."]
    #[link_name = "IPC_Desc_StaticBuffer__extern"]
    pub fn IPC_Desc_StaticBuffer(size: usize, buffer_id: ::libc::c_uint) -> u32_;
}
extern "C" {
    #[doc = "Creates a header describing a buffer to be sent over PXI.\n # Arguments\n\n* `size` - Size of the buffer. Max 0x00FFFFFF.\n * `buffer_id` - The Id of the buffer. Max 0xF.\n * `is_read_only` - true if the buffer is read-only. If false, the buffer is considered to have read-write access.\n # Returns\n\nThe created PXI buffer header.\n\n The next value is a phys-address of a table located in the BASE memregion."]
    #[link_name = "IPC_Desc_PXIBuffer__extern"]
    pub fn IPC_Desc_PXIBuffer(size: usize, buffer_id: ::libc::c_uint, is_read_only: bool) -> u32_;
}
extern "C" {
    #[doc = "Creates a header describing a buffer from the main memory.\n # Arguments\n\n* `size` - Size of the buffer. Max 0x0FFFFFFF.\n * `rights` - The rights of the buffer for the destination process.\n # Returns\n\nThe created buffer header.\n\n The next value is a pointer to the buffer."]
    #[link_name = "IPC_Desc_Buffer__extern"]
    pub fn IPC_Desc_Buffer(size: usize, rights: IPC_BufferRights) -> u32_;
}
#[doc = "< Memory un-mapping"]
pub const MEMOP_FREE: MemOp = 1;
#[doc = "< Reserve memory"]
pub const MEMOP_RESERVE: MemOp = 2;
#[doc = "< Memory mapping"]
pub const MEMOP_ALLOC: MemOp = 3;
#[doc = "< Mirror mapping"]
pub const MEMOP_MAP: MemOp = 4;
#[doc = "< Mirror unmapping"]
pub const MEMOP_UNMAP: MemOp = 5;
#[doc = "< Change protection"]
pub const MEMOP_PROT: MemOp = 6;
#[doc = "< APPLICATION memory region."]
pub const MEMOP_REGION_APP: MemOp = 256;
#[doc = "< SYSTEM memory region."]
pub const MEMOP_REGION_SYSTEM: MemOp = 512;
#[doc = "< BASE memory region."]
pub const MEMOP_REGION_BASE: MemOp = 768;
#[doc = "< Operation bitmask."]
pub const MEMOP_OP_MASK: MemOp = 255;
#[doc = "< Region bitmask."]
pub const MEMOP_REGION_MASK: MemOp = 3840;
#[doc = "< Flag for linear memory operations"]
pub const MEMOP_LINEAR_FLAG: MemOp = 65536;
#[doc = "< Allocates linear memory."]
pub const MEMOP_ALLOC_LINEAR: MemOp = 65539;
#[doc = "svcControlMemory operation flags\n\n The lowest 8 bits are the operation"]
pub type MemOp = ::libc::c_uint;
#[doc = "< Free memory"]
pub const MEMSTATE_FREE: MemState = 0;
#[doc = "< Reserved memory"]
pub const MEMSTATE_RESERVED: MemState = 1;
#[doc = "< I/O memory"]
pub const MEMSTATE_IO: MemState = 2;
#[doc = "< Static memory"]
pub const MEMSTATE_STATIC: MemState = 3;
#[doc = "< Code memory"]
pub const MEMSTATE_CODE: MemState = 4;
#[doc = "< Private memory"]
pub const MEMSTATE_PRIVATE: MemState = 5;
#[doc = "< Shared memory"]
pub const MEMSTATE_SHARED: MemState = 6;
#[doc = "< Continuous memory"]
pub const MEMSTATE_CONTINUOUS: MemState = 7;
#[doc = "< Aliased memory"]
pub const MEMSTATE_ALIASED: MemState = 8;
#[doc = "< Alias memory"]
pub const MEMSTATE_ALIAS: MemState = 9;
#[doc = "< Aliased code memory"]
pub const MEMSTATE_ALIASCODE: MemState = 10;
#[doc = "< Locked memory"]
pub const MEMSTATE_LOCKED: MemState = 11;
#[doc = "The state of a memory block."]
pub type MemState = ::libc::c_uint;
#[doc = "< Readable"]
pub const MEMPERM_READ: MemPerm = 1;
#[doc = "< Writable"]
pub const MEMPERM_WRITE: MemPerm = 2;
#[doc = "< Executable"]
pub const MEMPERM_EXECUTE: MemPerm = 4;
#[doc = "< Readable and writable"]
pub const MEMPERM_READWRITE: MemPerm = 3;
#[doc = "< Readable and executable"]
pub const MEMPERM_READEXECUTE: MemPerm = 5;
#[doc = "< Don't care"]
pub const MEMPERM_DONTCARE: MemPerm = 268435456;
#[doc = "Memory permission flags"]
pub type MemPerm = ::libc::c_uint;
#[doc = "< All regions."]
pub const MEMREGION_ALL: MemRegion = 0;
#[doc = "< APPLICATION memory."]
pub const MEMREGION_APPLICATION: MemRegion = 1;
#[doc = "< SYSTEM memory."]
pub const MEMREGION_SYSTEM: MemRegion = 2;
#[doc = "< BASE memory."]
pub const MEMREGION_BASE: MemRegion = 3;
#[doc = "Memory regions."]
pub type MemRegion = ::libc::c_uint;
#[doc = "Memory information."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MemInfo {
    #[doc = "< Base address."]
    pub base_addr: u32_,
    #[doc = "< Size."]
    pub size: u32_,
    #[doc = "< Memory permissions. See MemPerm"]
    pub perm: u32_,
    #[doc = "< Memory state. See MemState"]
    pub state: u32_,
}
#[doc = "Memory page information."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PageInfo {
    #[doc = "< Page flags."]
    pub flags: u32_,
}
#[doc = "< Signal #value threads for wake-up."]
pub const ARBITRATION_SIGNAL: ArbitrationType = 0;
#[doc = "< If the memory at the address is strictly lower than #value, then wait for signal."]
pub const ARBITRATION_WAIT_IF_LESS_THAN: ArbitrationType = 1;
#[doc = "< If the memory at the address is strictly lower than #value, then decrement it and wait for signal."]
pub const ARBITRATION_DECREMENT_AND_WAIT_IF_LESS_THAN: ArbitrationType = 2;
#[doc = "< If the memory at the address is strictly lower than #value, then wait for signal or timeout."]
pub const ARBITRATION_WAIT_IF_LESS_THAN_TIMEOUT: ArbitrationType = 3;
#[doc = "< If the memory at the address is strictly lower than #value, then decrement it and wait for signal or timeout."]
pub const ARBITRATION_DECREMENT_AND_WAIT_IF_LESS_THAN_TIMEOUT: ArbitrationType = 4;
#[doc = "Arbitration modes."]
pub type ArbitrationType = ::libc::c_uint;
#[doc = "< When the primitive is signaled, it will wake up exactly one thread and will clear itself automatically."]
pub const RESET_ONESHOT: ResetType = 0;
#[doc = "< When the primitive is signaled, it will wake up all threads and it won't clear itself automatically."]
pub const RESET_STICKY: ResetType = 1;
#[doc = "< Only meaningful for timers: same as ONESHOT but it will periodically signal the timer instead of just once."]
pub const RESET_PULSE: ResetType = 2;
#[doc = "Reset types (for use with events and timers)"]
pub type ResetType = ::libc::c_uint;
#[doc = "< Unknown."]
pub const THREADINFO_TYPE_UNKNOWN: ThreadInfoType = 0;
#[doc = "Types of thread info."]
pub type ThreadInfoType = ::libc::c_uint;
#[doc = "< Thread priority"]
pub const RESLIMIT_PRIORITY: ResourceLimitType = 0;
#[doc = "< Quantity of allocatable memory"]
pub const RESLIMIT_COMMIT: ResourceLimitType = 1;
#[doc = "< Number of threads"]
pub const RESLIMIT_THREAD: ResourceLimitType = 2;
#[doc = "< Number of events"]
pub const RESLIMIT_EVENT: ResourceLimitType = 3;
#[doc = "< Number of mutexes"]
pub const RESLIMIT_MUTEX: ResourceLimitType = 4;
#[doc = "< Number of semaphores"]
pub const RESLIMIT_SEMAPHORE: ResourceLimitType = 5;
#[doc = "< Number of timers"]
pub const RESLIMIT_TIMER: ResourceLimitType = 6;
#[doc = "< Number of shared memory objects, see svcCreateMemoryBlock"]
pub const RESLIMIT_SHAREDMEMORY: ResourceLimitType = 7;
#[doc = "< Number of address arbiters"]
pub const RESLIMIT_ADDRESSARBITER: ResourceLimitType = 8;
#[doc = "< CPU time. Value expressed in percentage regular until it reaches 90."]
pub const RESLIMIT_CPUTIME: ResourceLimitType = 9;
#[doc = "< Forces enum size to be 32 bits"]
pub const RESLIMIT_BIT: ResourceLimitType = 2147483648;
#[doc = "Types of resource limit"]
pub type ResourceLimitType = ::libc::c_uint;
#[doc = "< DMA transfer involving at least one device is starting and has not reached DMAWFP yet."]
pub const DMASTATE_STARTING: DmaState = 0;
#[doc = "< DMA channel is in WFP state for the destination device (2nd loop iteration onwards)."]
pub const DMASTATE_WFP_DST: DmaState = 1;
#[doc = "< DMA channel is in WFP state for the source device (2nd loop iteration onwards)."]
pub const DMASTATE_WFP_SRC: DmaState = 2;
#[doc = "< DMA transfer is running."]
pub const DMASTATE_RUNNING: DmaState = 3;
#[doc = "< DMA transfer is done."]
pub const DMASTATE_DONE: DmaState = 4;
#[doc = "DMA transfer state."]
pub type DmaState = ::libc::c_uint;
#[doc = "< DMA source is a device/peripheral. Address will not auto-increment."]
pub const DMACFG_SRC_IS_DEVICE: _bindgen_ty_5 = 1;
#[doc = "< DMA destination is a device/peripheral. Address will not auto-increment."]
pub const DMACFG_DST_IS_DEVICE: _bindgen_ty_5 = 2;
#[doc = "< Make svcStartInterProcessDma wait for the channel to be unlocked."]
pub const DMACFG_WAIT_AVAILABLE: _bindgen_ty_5 = 4;
#[doc = "< Keep the channel locked after the transfer. Required for svcRestartDma."]
pub const DMACFG_KEEP_LOCKED: _bindgen_ty_5 = 8;
#[doc = "< Use the provided source device configuration even if the DMA source is not a device."]
pub const DMACFG_USE_SRC_CONFIG: _bindgen_ty_5 = 64;
#[doc = "< Use the provided destination device configuration even if the DMA destination is not a device."]
pub const DMACFG_USE_DST_CONFIG: _bindgen_ty_5 = 128;
#[doc = "Configuration flags for DmaConfig."]
pub type _bindgen_ty_5 = ::libc::c_uint;
#[doc = "< Unlock the channel after transfer."]
pub const DMARST_UNLOCK: _bindgen_ty_6 = 1;
#[doc = "< Replace DMAFLUSHP instructions by NOP (they may not be regenerated even if this flag is not set)."]
pub const DMARST_RESUME_DEVICE: _bindgen_ty_6 = 2;
#[doc = "Configuration flags for svcRestartDma."]
pub type _bindgen_ty_6 = ::libc::c_uint;
#[doc = "Device configuration structure, part of DmaConfig.\n > **Note:** - if (and only if) src/dst is a device, then src/dst won't be auto-incremented.\n - the kernel uses DMAMOV instead of DMAADNH, when having to decrement (possibly working around an erratum);\n this forces all loops to be unrolled -- you need to keep that in mind when using negative increments, as the kernel\n uses a limit of 100 DMA instruction bytes per channel."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct DmaDeviceConfig {
    #[doc = "< DMA device ID."]
    pub deviceId: s8,
    #[doc = "< Mask of allowed access alignments (8, 4, 2, 1)."]
    pub allowedAlignments: s8,
    #[doc = "< Number of bytes transferred in a burst loop. Can be 0 (in which case the max allowed alignment is used as unit)."]
    pub burstSize: s16,
    #[doc = "< Number of bytes transferred in a \"transfer\" loop (made of burst loops)."]
    pub transferSize: s16,
    #[doc = "< Burst loop stride, can be <= 0."]
    pub burstStride: s16,
    #[doc = "< \"Transfer\" loop stride, can be <= 0."]
    pub transferStride: s16,
}
#[doc = "Configuration stucture for svcStartInterProcessDma."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct DmaConfig {
    #[doc = "< Channel ID (Arm11: 0-7, Arm9: 0-1). Use -1 to auto-assign to a free channel (Arm11: 3-7, Arm9: 0-1)."]
    pub channelId: s8,
    #[doc = "< Endian swap size (can be 0)."]
    pub endianSwapSize: s8,
    #[doc = "< DMACFG_* flags."]
    pub flags: u8_,
    pub _padding: u8_,
    #[doc = "< Source device configuration, read if DMACFG_SRC_IS_DEVICE and/or DMACFG_USE_SRC_CONFIG are set."]
    pub srcCfg: DmaDeviceConfig,
    #[doc = "< Destination device configuration, read if DMACFG_SRC_IS_DEVICE and/or DMACFG_USE_SRC_CONFIG are set."]
    pub dstCfg: DmaDeviceConfig,
}
#[doc = "< Enable and lock perfmon. functionality."]
pub const PERFCOUNTEROP_ENABLE: PerfCounterOperation = 0;
#[doc = "< Disable and forcibly unlock perfmon. functionality."]
pub const PERFCOUNTEROP_DISABLE: PerfCounterOperation = 1;
#[doc = "< Get the value of a counter register."]
pub const PERFCOUNTEROP_GET_VALUE: PerfCounterOperation = 2;
#[doc = "< Set the value of a counter register."]
pub const PERFCOUNTEROP_SET_VALUE: PerfCounterOperation = 3;
#[doc = "< Get the overflow flags for all CP15 and SCU counters."]
pub const PERFCOUNTEROP_GET_OVERFLOW_FLAGS: PerfCounterOperation = 4;
#[doc = "< Reset the value and/or overflow flags of selected counters."]
pub const PERFCOUNTEROP_RESET: PerfCounterOperation = 5;
#[doc = "< Get the event ID associated to a particular counter."]
pub const PERFCOUNTEROP_GET_EVENT: PerfCounterOperation = 6;
#[doc = "< Set the event ID associated to a paritcular counter."]
pub const PERFCOUNTEROP_SET_EVENT: PerfCounterOperation = 7;
#[doc = "< (Dis)allow the kernel to track counter overflows and to use 64-bit counter values."]
pub const PERFCOUNTEROP_SET_VIRTUAL_COUNTER_ENABLED: PerfCounterOperation = 8;
#[doc = "Operations for svcControlPerformanceCounter"]
pub type PerfCounterOperation = ::libc::c_uint;
pub const PERFCOUNTERREG_CORE_BASE: PerfCounterRegister = 0;
#[doc = "< CP15 PMN0."]
pub const PERFCOUNTERREG_CORE_COUNT_REG_0: PerfCounterRegister = 0;
#[doc = "< CP15 PMN1."]
pub const PERFCOUNTERREG_CORE_COUNT_REG_1: PerfCounterRegister = 1;
#[doc = "< CP15 CCNT."]
pub const PERFCOUNTERREG_CORE_CYCLE_COUNTER: PerfCounterRegister = 2;
pub const PERFCOUNTERREG_SCU_BASE: PerfCounterRegister = 16;
#[doc = "< SCU MN0."]
pub const PERFCOUNTERREG_SCU_0: PerfCounterRegister = 16;
#[doc = "< SCU MN1."]
pub const PERFCOUNTERREG_SCU_1: PerfCounterRegister = 17;
#[doc = "< SCU MN2."]
pub const PERFCOUNTERREG_SCU_2: PerfCounterRegister = 18;
#[doc = "< SCU MN3."]
pub const PERFCOUNTERREG_SCU_3: PerfCounterRegister = 19;
#[doc = "< SCU MN4. Prod-N3DS only. IRQ line missing."]
pub const PERFCOUNTERREG_SCU_4: PerfCounterRegister = 20;
#[doc = "< SCU MN5. Prod-N3DS only. IRQ line missing."]
pub const PERFCOUNTERREG_SCU_5: PerfCounterRegister = 21;
#[doc = "< SCU MN6. Prod-N3DS only. IRQ line missing."]
pub const PERFCOUNTERREG_SCU_6: PerfCounterRegister = 22;
#[doc = "< SCU MN7. Prod-N3DS only. IRQ line missing."]
pub const PERFCOUNTERREG_SCU_7: PerfCounterRegister = 23;
#[doc = "Performance counter register IDs (CP15 and SCU)."]
pub type PerfCounterRegister = ::libc::c_uint;
pub const PERFCOUNTEREVT_CORE_BASE: PerfCounterEvent = 0;
pub const PERFCOUNTEREVT_CORE_INST_CACHE_MISS: PerfCounterEvent = 0;
pub const PERFCOUNTEREVT_CORE_STALL_BY_LACK_OF_INST: PerfCounterEvent = 1;
pub const PERFCOUNTEREVT_CORE_STALL_BY_DATA_HAZARD: PerfCounterEvent = 2;
pub const PERFCOUNTEREVT_CORE_INST_MICRO_TLB_MISS: PerfCounterEvent = 3;
pub const PERFCOUNTEREVT_CORE_DATA_MICRO_TLB_MISS: PerfCounterEvent = 4;
pub const PERFCOUNTEREVT_CORE_BRANCH_INST: PerfCounterEvent = 5;
pub const PERFCOUNTEREVT_CORE_BRANCH_NOT_PREDICTED: PerfCounterEvent = 6;
pub const PERFCOUNTEREVT_CORE_BRANCH_MISS_PREDICTED: PerfCounterEvent = 7;
pub const PERFCOUNTEREVT_CORE_INST_EXECUTED: PerfCounterEvent = 8;
pub const PERFCOUNTEREVT_CORE_FOLDED_INST_EXECUTED: PerfCounterEvent = 9;
pub const PERFCOUNTEREVT_CORE_DATA_CACHE_READ: PerfCounterEvent = 10;
pub const PERFCOUNTEREVT_CORE_DATA_CACHE_READ_MISS: PerfCounterEvent = 11;
pub const PERFCOUNTEREVT_CORE_DATA_CACHE_WRITE: PerfCounterEvent = 12;
pub const PERFCOUNTEREVT_CORE_DATA_CACHE_WRITE_MISS: PerfCounterEvent = 13;
pub const PERFCOUNTEREVT_CORE_DATA_CACHE_LINE_EVICTION: PerfCounterEvent = 14;
pub const PERFCOUNTEREVT_CORE_PC_CHANGED: PerfCounterEvent = 15;
pub const PERFCOUNTEREVT_CORE_MAIN_TLB_MISS: PerfCounterEvent = 16;
pub const PERFCOUNTEREVT_CORE_EXTERNAL_REQUEST: PerfCounterEvent = 17;
pub const PERFCOUNTEREVT_CORE_STALL_BY_LSU_FULL: PerfCounterEvent = 18;
pub const PERFCOUNTEREVT_CORE_STORE_BUFFER_DRAIN: PerfCounterEvent = 19;
pub const PERFCOUNTEREVT_CORE_MERGE_IN_STORE_BUFFER: PerfCounterEvent = 20;
#[doc = "< One cycle elapsed."]
pub const PERFCOUNTEREVT_CORE_CYCLE_COUNT: PerfCounterEvent = 255;
#[doc = "< 64 cycles elapsed."]
pub const PERFCOUNTEREVT_CORE_CYCLE_COUNT_64: PerfCounterEvent = 4095;
pub const PERFCOUNTEREVT_SCU_BASE: PerfCounterEvent = 4096;
pub const PERFCOUNTEREVT_SCU_DISABLED: PerfCounterEvent = 4096;
pub const PERFCOUNTEREVT_SCU_LINEFILL_MISS_FROM_CORE0: PerfCounterEvent = 4097;
pub const PERFCOUNTEREVT_SCU_LINEFILL_MISS_FROM_CORE1: PerfCounterEvent = 4098;
pub const PERFCOUNTEREVT_SCU_LINEFILL_MISS_FROM_CORE2: PerfCounterEvent = 4099;
pub const PERFCOUNTEREVT_SCU_LINEFILL_MISS_FROM_CORE3: PerfCounterEvent = 4100;
pub const PERFCOUNTEREVT_SCU_LINEFILL_HIT_FROM_CORE0: PerfCounterEvent = 4101;
pub const PERFCOUNTEREVT_SCU_LINEFILL_HIT_FROM_CORE1: PerfCounterEvent = 4102;
pub const PERFCOUNTEREVT_SCU_LINEFILL_HIT_FROM_CORE2: PerfCounterEvent = 4103;
pub const PERFCOUNTEREVT_SCU_LINEFILL_HIT_FROM_CORE3: PerfCounterEvent = 4104;
pub const PERFCOUNTEREVT_SCU_LINE_MISSING_FROM_CORE0: PerfCounterEvent = 4105;
pub const PERFCOUNTEREVT_SCU_LINE_MISSING_FROM_CORE1: PerfCounterEvent = 4106;
pub const PERFCOUNTEREVT_SCU_LINE_MISSING_FROM_CORE2: PerfCounterEvent = 4107;
pub const PERFCOUNTEREVT_SCU_LINE_MISSING_FROM_CORE3: PerfCounterEvent = 4108;
pub const PERFCOUNTEREVT_SCU_LINE_MIGRATION: PerfCounterEvent = 4109;
pub const PERFCOUNTEREVT_SCU_READ_BUSY_PORT0: PerfCounterEvent = 4110;
pub const PERFCOUNTEREVT_SCU_READ_BUSY_PORT1: PerfCounterEvent = 4111;
pub const PERFCOUNTEREVT_SCU_WRITE_BUSY_PORT0: PerfCounterEvent = 4112;
pub const PERFCOUNTEREVT_SCU_WRITE_BUSY_PORT1: PerfCounterEvent = 4113;
pub const PERFCOUNTEREVT_SCU_EXTERNAL_READ: PerfCounterEvent = 4114;
pub const PERFCOUNTEREVT_SCU_EXTERNAL_WRITE: PerfCounterEvent = 4115;
pub const PERFCOUNTEREVT_SCU_CYCLE_COUNT: PerfCounterEvent = 4127;
#[doc = "Performance counter event IDs (CP15 or SCU).\n\n > **Note:** Refer to:\n - CP15: https://developer.arm.com/documentation/ddi0360/e/control-coprocessor-cp15/register-descriptions/c15--performance-monitor-control-register--pmnc-\n - SCU: https://developer.arm.com/documentation/ddi0360/e/mpcore-private-memory-region/about-the-mpcore-private-memory-region/performance-monitor-event-registers"]
pub type PerfCounterEvent = ::libc::c_uint;
#[doc = "Event relating to the attachment of a process."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AttachProcessEvent {
    #[doc = "< ID of the program."]
    pub program_id: u64_,
    #[doc = "< Name of the process."]
    pub process_name: [::libc::c_char; 8usize],
    #[doc = "< ID of the process."]
    pub process_id: u32_,
    #[doc = "< Always 0"]
    pub other_flags: u32_,
}
#[doc = "< Process exited either normally or due to an uncaught exception."]
pub const EXITPROCESS_EVENT_EXIT: ExitProcessEventReason = 0;
#[doc = "< Process has been terminated by svcTerminateProcess."]
pub const EXITPROCESS_EVENT_TERMINATE: ExitProcessEventReason = 1;
#[doc = "< Process has been terminated by svcTerminateDebugProcess."]
pub const EXITPROCESS_EVENT_DEBUG_TERMINATE: ExitProcessEventReason = 2;
#[doc = "Reasons for an exit process event."]
pub type ExitProcessEventReason = ::libc::c_uint;
#[doc = "Event relating to the exiting of a process."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExitProcessEvent {
    #[doc = "< Reason for exiting. See ExitProcessEventReason"]
    pub reason: ExitProcessEventReason,
}
impl Default for ExitProcessEvent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Event relating to the attachment of a thread."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AttachThreadEvent {
    #[doc = "< ID of the creating thread."]
    pub creator_thread_id: u32_,
    #[doc = "< Thread local storage."]
    pub thread_local_storage: u32_,
    #[doc = "< Entry point of the thread."]
    pub entry_point: u32_,
}
#[doc = "< Thread exited."]
pub const EXITTHREAD_EVENT_EXIT: ExitThreadEventReason = 0;
#[doc = "< Thread terminated."]
pub const EXITTHREAD_EVENT_TERMINATE: ExitThreadEventReason = 1;
#[doc = "< Process exited either normally or due to an uncaught exception."]
pub const EXITTHREAD_EVENT_EXIT_PROCESS: ExitThreadEventReason = 2;
#[doc = "< Process has been terminated by svcTerminateProcess."]
pub const EXITTHREAD_EVENT_TERMINATE_PROCESS: ExitThreadEventReason = 3;
#[doc = "Reasons for an exit thread event."]
pub type ExitThreadEventReason = ::libc::c_uint;
#[doc = "Event relating to the exiting of a thread."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExitThreadEvent {
    #[doc = "< Reason for exiting. See ExitThreadEventReason"]
    pub reason: ExitThreadEventReason,
}
impl Default for ExitThreadEvent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "< Panic."]
pub const USERBREAK_PANIC: UserBreakType = 0;
#[doc = "< Assertion failed."]
pub const USERBREAK_ASSERT: UserBreakType = 1;
#[doc = "< User related."]
pub const USERBREAK_USER: UserBreakType = 2;
#[doc = "< Load RO."]
pub const USERBREAK_LOAD_RO: UserBreakType = 3;
#[doc = "< Unload RO."]
pub const USERBREAK_UNLOAD_RO: UserBreakType = 4;
#[doc = "Reasons for a user break."]
pub type UserBreakType = ::libc::c_uint;
#[doc = "< Undefined instruction."]
pub const EXCEVENT_UNDEFINED_INSTRUCTION: ExceptionEventType = 0;
#[doc = "< Prefetch abort."]
pub const EXCEVENT_PREFETCH_ABORT: ExceptionEventType = 1;
#[doc = "< Data abort (other than the below kind)."]
pub const EXCEVENT_DATA_ABORT: ExceptionEventType = 2;
#[doc = "< Unaligned data access."]
pub const EXCEVENT_UNALIGNED_DATA_ACCESS: ExceptionEventType = 3;
#[doc = "< Attached break."]
pub const EXCEVENT_ATTACH_BREAK: ExceptionEventType = 4;
#[doc = "< Stop point reached."]
pub const EXCEVENT_STOP_POINT: ExceptionEventType = 5;
#[doc = "< User break occurred."]
pub const EXCEVENT_USER_BREAK: ExceptionEventType = 6;
#[doc = "< Debugger break occurred."]
pub const EXCEVENT_DEBUGGER_BREAK: ExceptionEventType = 7;
#[doc = "< Undefined syscall."]
pub const EXCEVENT_UNDEFINED_SYSCALL: ExceptionEventType = 8;
#[doc = "Reasons for an exception event."]
pub type ExceptionEventType = ::libc::c_uint;
#[doc = "Event relating to fault exceptions (CPU exceptions other than stop points and undefined syscalls)."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FaultExceptionEvent {
    #[doc = "< FAR (for DATA ABORT / UNALIGNED DATA ACCESS), attempted syscall or 0"]
    pub fault_information: u32_,
}
#[doc = "< See SVC_STOP_POINT."]
pub const STOPPOINT_SVC_FF: StopPointType = 0;
#[doc = "< Breakpoint."]
pub const STOPPOINT_BREAKPOINT: StopPointType = 1;
#[doc = "< Watchpoint."]
pub const STOPPOINT_WATCHPOINT: StopPointType = 2;
#[doc = "Stop point types"]
pub type StopPointType = ::libc::c_uint;
#[doc = "Event relating to stop points"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct StopPointExceptionEvent {
    #[doc = "< Stop point type, see StopPointType."]
    pub type_: StopPointType,
    #[doc = "< FAR for Watchpoints, otherwise 0."]
    pub fault_information: u32_,
}
impl Default for StopPointExceptionEvent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Event relating to svcBreak"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UserBreakExceptionEvent {
    #[doc = "< User break type, see UserBreakType."]
    pub type_: UserBreakType,
    #[doc = "< For LOAD_RO and UNLOAD_RO."]
    pub croInfo: u32_,
    #[doc = "< For LOAD_RO and UNLOAD_RO."]
    pub croInfoSize: u32_,
}
impl Default for UserBreakExceptionEvent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Event relating to svcBreakDebugProcess"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct DebuggerBreakExceptionEvent {
    #[doc = "< IDs of the attached process's threads that were running on each core at the time of the svcBreakDebugProcess call, or -1 (only the first 2 values are meaningful on O3DS)."]
    pub thread_ids: [s32; 4usize],
}
#[doc = "Event relating to exceptions."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ExceptionEvent {
    #[doc = "< Type of event. See ExceptionEventType."]
    pub type_: ExceptionEventType,
    #[doc = "< Address of the exception."]
    pub address: u32_,
    pub __bindgen_anon_1: ExceptionEvent__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ExceptionEvent__bindgen_ty_1 {
    #[doc = "< Fault exception event data."]
    pub fault: FaultExceptionEvent,
    #[doc = "< Stop point exception event data."]
    pub stop_point: StopPointExceptionEvent,
    #[doc = "< User break exception event data."]
    pub user_break: UserBreakExceptionEvent,
    #[doc = "< Debugger break exception event data"]
    pub debugger_break: DebuggerBreakExceptionEvent,
}
impl Default for ExceptionEvent__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ExceptionEvent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Event relating to the scheduler."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ScheduleInOutEvent {
    #[doc = "< Clock tick that the event occurred."]
    pub clock_tick: u64_,
}
#[doc = "Event relating to syscalls."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SyscallInOutEvent {
    #[doc = "< Clock tick that the event occurred."]
    pub clock_tick: u64_,
    #[doc = "< Syscall sent/received."]
    pub syscall: u32_,
}
#[doc = "Event relating to debug output."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct OutputStringEvent {
    #[doc = "< Address of the outputted string."]
    pub string_addr: u32_,
    #[doc = "< Size of the outputted string."]
    pub string_size: u32_,
}
#[doc = "Event relating to the mapping of memory."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MapEvent {
    #[doc = "< Mapped address."]
    pub mapped_addr: u32_,
    #[doc = "< Mapped size."]
    pub mapped_size: u32_,
    #[doc = "< Memory permissions. See MemPerm."]
    pub memperm: MemPerm,
    #[doc = "< Memory state. See MemState."]
    pub memstate: MemState,
}
impl Default for MapEvent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "< Process attached event."]
pub const DBGEVENT_ATTACH_PROCESS: DebugEventType = 0;
#[doc = "< Thread attached event."]
pub const DBGEVENT_ATTACH_THREAD: DebugEventType = 1;
#[doc = "< Thread exit event."]
pub const DBGEVENT_EXIT_THREAD: DebugEventType = 2;
#[doc = "< Process exit event."]
pub const DBGEVENT_EXIT_PROCESS: DebugEventType = 3;
#[doc = "< Exception event."]
pub const DBGEVENT_EXCEPTION: DebugEventType = 4;
#[doc = "< DLL load event."]
pub const DBGEVENT_DLL_LOAD: DebugEventType = 5;
#[doc = "< DLL unload event."]
pub const DBGEVENT_DLL_UNLOAD: DebugEventType = 6;
#[doc = "< Schedule in event."]
pub const DBGEVENT_SCHEDULE_IN: DebugEventType = 7;
#[doc = "< Schedule out event."]
pub const DBGEVENT_SCHEDULE_OUT: DebugEventType = 8;
#[doc = "< Syscall in event."]
pub const DBGEVENT_SYSCALL_IN: DebugEventType = 9;
#[doc = "< Syscall out event."]
pub const DBGEVENT_SYSCALL_OUT: DebugEventType = 10;
#[doc = "< Output string event."]
pub const DBGEVENT_OUTPUT_STRING: DebugEventType = 11;
#[doc = "< Map event."]
pub const DBGEVENT_MAP: DebugEventType = 12;
#[doc = "Debug event type."]
pub type DebugEventType = ::libc::c_uint;
#[doc = "Information about a debug event."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DebugEventInfo {
    #[doc = "< Type of event. See DebugEventType"]
    pub type_: DebugEventType,
    #[doc = "< ID of the thread."]
    pub thread_id: u32_,
    #[doc = "< Flags. Bit0 means that svcContinueDebugEvent needs to be called for this event (except for EXIT PROCESS events, where this flag is disregarded)."]
    pub flags: u32_,
    #[doc = "< Always 0."]
    pub remnants: [u8_; 4usize],
    pub __bindgen_anon_1: DebugEventInfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DebugEventInfo__bindgen_ty_1 {
    #[doc = "< Process attachment event data."]
    pub attach_process: AttachProcessEvent,
    #[doc = "< Thread attachment event data."]
    pub attach_thread: AttachThreadEvent,
    #[doc = "< Thread exit event data."]
    pub exit_thread: ExitThreadEvent,
    #[doc = "< Process exit event data."]
    pub exit_process: ExitProcessEvent,
    #[doc = "< Exception event data."]
    pub exception: ExceptionEvent,
    #[doc = "< Schedule in/out event data."]
    pub scheduler: ScheduleInOutEvent,
    #[doc = "< Syscall in/out event data."]
    pub syscall: SyscallInOutEvent,
    #[doc = "< Output string event data."]
    pub output_string: OutputStringEvent,
    #[doc = "< Map event data."]
    pub map: MapEvent,
}
impl Default for DebugEventInfo__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for DebugEventInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "< Inhibit user-defined CPU exception handlers (including watchpoints and breakpoints, regardless of any svcKernelSetState call)."]
pub const DBG_INHIBIT_USER_CPU_EXCEPTION_HANDLERS: DebugFlags = 1;
#[doc = "< Signal fault exception events. See FaultExceptionEvent."]
pub const DBG_SIGNAL_FAULT_EXCEPTION_EVENTS: DebugFlags = 2;
#[doc = "< Signal schedule in/out events. See ScheduleInOutEvent."]
pub const DBG_SIGNAL_SCHEDULE_EVENTS: DebugFlags = 4;
#[doc = "< Signal syscall in/out events. See SyscallInOutEvent."]
pub const DBG_SIGNAL_SYSCALL_EVENTS: DebugFlags = 8;
#[doc = "< Signal map events. See MapEvent."]
pub const DBG_SIGNAL_MAP_EVENTS: DebugFlags = 16;
#[doc = "Debug flags for an attached process, set by svcContinueDebugEvent"]
pub type DebugFlags = ::libc::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ThreadContext {
    #[doc = "< CPU registers."]
    pub cpu_registers: CpuRegisters,
    #[doc = "< FPU registers."]
    pub fpu_registers: FpuRegisters,
}
impl Default for ThreadContext {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "< Control r0-r12."]
pub const THREADCONTEXT_CONTROL_CPU_GPRS: ThreadContextControlFlags = 1;
#[doc = "< Control sp, lr, pc, cpsr."]
pub const THREADCONTEXT_CONTROL_CPU_SPRS: ThreadContextControlFlags = 2;
#[doc = "< Control d0-d15 (or s0-s31)."]
pub const THREADCONTEXT_CONTROL_FPU_GPRS: ThreadContextControlFlags = 4;
#[doc = "< Control fpscr, fpexc."]
pub const THREADCONTEXT_CONTROL_FPU_SPRS: ThreadContextControlFlags = 8;
#[doc = "< Control r0-r12, sp, lr, pc, cpsr."]
pub const THREADCONTEXT_CONTROL_CPU_REGS: ThreadContextControlFlags = 3;
#[doc = "< Control d0-d15, fpscr, fpexc."]
pub const THREADCONTEXT_CONTROL_FPU_REGS: ThreadContextControlFlags = 12;
#[doc = "< Control all of the above."]
pub const THREADCONTEXT_CONTROL_ALL: ThreadContextControlFlags = 15;
#[doc = "Control flags for svcGetDebugThreadContext and svcSetDebugThreadContext"]
pub type ThreadContextControlFlags = ::libc::c_uint;
#[doc = "< Thread priority."]
pub const DBGTHREAD_PARAMETER_PRIORITY: DebugThreadParameter = 0;
#[doc = "< Low scheduling mask."]
pub const DBGTHREAD_PARAMETER_SCHEDULING_MASK_LOW: DebugThreadParameter = 1;
#[doc = "< Ideal processor."]
pub const DBGTHREAD_PARAMETER_CPU_IDEAL: DebugThreadParameter = 2;
#[doc = "< Processor that created the threod."]
pub const DBGTHREAD_PARAMETER_CPU_CREATOR: DebugThreadParameter = 3;
#[doc = "Thread parameter field for svcGetDebugThreadParameter"]
pub type DebugThreadParameter = ::libc::c_uint;
#[doc = "Information on address space for process. All sizes are in pages (0x1000 bytes)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CodeSetHeader {
    #[doc = "< ASCII name of codeset"]
    pub name: [u8_; 8usize],
    #[doc = "< Version field of codeset (unused)"]
    pub version: u16_,
    #[doc = "< Padding"]
    pub padding: [u16_; 3usize],
    #[doc = "< .text start address"]
    pub text_addr: u32_,
    #[doc = "< .text number of pages"]
    pub text_size: u32_,
    #[doc = "< .rodata start address"]
    pub ro_addr: u32_,
    #[doc = "< .rodata number of pages"]
    pub ro_size: u32_,
    #[doc = "< .data, .bss start address"]
    pub rw_addr: u32_,
    #[doc = "< .data number of pages"]
    pub rw_size: u32_,
    #[doc = "< total pages for .text (aligned)"]
    pub text_size_total: u32_,
    #[doc = "< total pages for .rodata (aligned)"]
    pub ro_size_total: u32_,
    #[doc = "< total pages for .data, .bss (aligned)"]
    pub rw_size_total: u32_,
    #[doc = "< Padding"]
    pub padding2: u32_,
    #[doc = "< Program ID"]
    pub program_id: u64_,
}
#[doc = "Information for the main thread of a process."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct StartupInfo {
    #[doc = "< Priority of the main thread."]
    pub priority: ::libc::c_int,
    #[doc = "< Size of the stack of the main thread."]
    pub stack_size: u32_,
    #[doc = "< Unused on retail kernel."]
    pub argc: ::libc::c_int,
    #[doc = "< Unused on retail kernel."]
    pub argv: *mut u16_,
    #[doc = "< Unused on retail kernel."]
    pub envp: *mut u16_,
}
impl Default for StartupInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = "Gets the thread local storage buffer.\n # Returns\n\nThe thread local storage bufger."]
    #[link_name = "getThreadLocalStorage__extern"]
    pub fn getThreadLocalStorage() -> *mut ::libc::c_void;
}
extern "C" {
    #[doc = "Gets the thread command buffer.\n # Returns\n\nThe thread command bufger."]
    #[link_name = "getThreadCommandBuffer__extern"]
    pub fn getThreadCommandBuffer() -> *mut u32_;
}
extern "C" {
    #[doc = "Gets the thread static buffer.\n # Returns\n\nThe thread static bufger."]
    #[link_name = "getThreadStaticBuffers__extern"]
    pub fn getThreadStaticBuffers() -> *mut u32_;
}
extern "C" {
    #[doc = "Writes the default DMA device config that the kernel uses when DMACFG_*_IS_DEVICE and DMACFG_*_USE_CFG are not set"]
    #[link_name = "dmaDeviceConfigInitDefault__extern"]
    pub fn dmaDeviceConfigInitDefault(cfg: *mut DmaDeviceConfig);
}
extern "C" {
    #[doc = "Initializes a DmaConfig instance with sane defaults for RAM<>RAM tranfers"]
    #[link_name = "dmaConfigInitDefault__extern"]
    pub fn dmaConfigInitDefault(cfg: *mut DmaConfig);
}
extern "C" {
    #[must_use]
    #[doc = "Memory management\n# *\n* Controls memory mapping\n # Arguments\n\n* `addr_out` (direction out) - The virtual address resulting from the operation. Usually the same as addr0.\n * `addr0` - The virtual address to be used for the operation.\n * `addr1` - The virtual address to be (un)mirrored by `addr0` when using MEMOP_MAP or MEMOP_UNMAP.\n It has to be pointing to a RW memory.\n* Use NULL if the operation is MEMOP_FREE or MEMOP_ALLOC.\n * `size` - The requested size for MEMOP_ALLOC and MEMOP_ALLOC_LINEAR.\n * `op` - Operation flags. See MemOp.\n * `perm` - A combination of MEMPERM_READ and MEMPERM_WRITE. Using MEMPERM_EXECUTE will return an error.\n Value 0 is used when unmapping memory.\n*\n* If a memory is mapped for two or more addresses, you have to use MEMOP_UNMAP before being able to MEMOP_FREE it.\n* MEMOP_MAP will fail if `addr1` was already mapped to another address.\n\n* More information is available at http://3dbrew.org/wiki/SVC#Memory_Mapping.\n*\n* [`svcControlProcessMemory`]\n/"]
    pub fn svcControlMemory(
        addr_out: *mut u32_,
        addr0: u32_,
        addr1: u32_,
        size: u32_,
        op: MemOp,
        perm: MemPerm,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Controls the memory mapping of a process\n # Arguments\n\n* `addr0` - The virtual address to map\n * `addr1` - The virtual address to be mapped by `addr0`\n * `type` - Only operations MEMOP_MAP, MEMOP_UNMAP and MEMOP_PROT are allowed.\n\n This is the only SVC which allows mapping executable memory.\n Using MEMOP_PROT will change the memory permissions of an already mapped memory.\n\n > **Note:** The pseudo handle for the current process is not supported by this service call.\n [`svcControlProcess`]"]
    pub fn svcControlProcessMemory(
        process: Handle,
        addr0: u32_,
        addr1: u32_,
        size: u32_,
        type_: u32_,
        perm: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Creates a block of shared memory\n # Arguments\n\n* `memblock` (direction out) - Pointer to store the handle of the block\n * `addr` - Address of the memory to map, page-aligned. So its alignment must be 0x1000.\n * `size` - Size of the memory to map, a multiple of 0x1000.\n * `my_perm` - Memory permissions for the current process\n * `other_perm` - Memory permissions for the other processes\n\n > **Note:** The shared memory block, and its rights, are destroyed when the handle is closed."]
    pub fn svcCreateMemoryBlock(
        memblock: *mut Handle,
        addr: u32_,
        size: u32_,
        my_perm: MemPerm,
        other_perm: MemPerm,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Maps a block of shared memory\n # Arguments\n\n* `memblock` - Handle of the block\n * `addr` - Address of the memory to map, page-aligned. So its alignment must be 0x1000.\n * `my_perm` - Memory permissions for the current process\n * `other_perm` - Memory permissions for the other processes\n\n > **Note:** The shared memory block, and its rights, are destroyed when the handle is closed."]
    pub fn svcMapMemoryBlock(
        memblock: Handle,
        addr: u32_,
        my_perm: MemPerm,
        other_perm: MemPerm,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Maps a block of process memory, starting from address 0x00100000.\n # Arguments\n\n* `process` - Handle of the process.\n * `destAddress` - Address of the block of memory to map, in the current (destination) process.\n * `size` - Size of the block of memory to map (truncated to a multiple of 0x1000 bytes)."]
    pub fn svcMapProcessMemory(process: Handle, destAddress: u32_, size: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Unmaps a block of process memory, starting from address 0x00100000.\n # Arguments\n\n* `process` - Handle of the process.\n * `destAddress` - Address of the block of memory to unmap, in the current (destination) process.\n * `size` - Size of the block of memory to unmap (truncated to a multiple of 0x1000 bytes)."]
    pub fn svcUnmapProcessMemory(process: Handle, destAddress: u32_, size: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Unmaps a block of shared memory\n # Arguments\n\n* `memblock` - Handle of the block\n * `addr` - Address of the memory to unmap, page-aligned. So its alignment must be 0x1000."]
    pub fn svcUnmapMemoryBlock(memblock: Handle, addr: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Queries memory information.\n # Arguments\n\n* `info` (direction out) - Pointer to output memory info to.\n * `out` - Pointer to output page info to.\n * `addr` - Virtual memory address to query."]
    pub fn svcQueryMemory(info: *mut MemInfo, out: *mut PageInfo, addr: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Queries process memory information.\n # Arguments\n\n* `info` (direction out) - Pointer to output memory info to.\n * `out` (direction out) - Pointer to output page info to.\n * `process` - Process to query memory from.\n * `addr` - Virtual memory address to query."]
    pub fn svcQueryProcessMemory(
        info: *mut MemInfo,
        out: *mut PageInfo,
        process: Handle,
        addr: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Process management\n# *\n* Gets the handle of a process.\n # Arguments\n\n* `process` (direction out) - The handle of the process\n * `processId` - The ID of the process to open\n/"]
    pub fn svcOpenProcess(process: *mut Handle, processId: u32_) -> Result;
}
extern "C" {
    #[doc = "Exits the current process."]
    pub fn svcExitProcess() -> !;
}
extern "C" {
    #[must_use]
    #[doc = "Terminates a process.\n # Arguments\n\n* `process` - Handle of the process to terminate."]
    pub fn svcTerminateProcess(process: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets information about a process.\n # Arguments\n\n* `out` (direction out) - Pointer to output process info to.\n * `process` - Handle of the process to get information about.\n * `type` - Type of information to retreieve."]
    pub fn svcGetProcessInfo(out: *mut s64, process: Handle, type_: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the ID of a process.\n # Arguments\n\n* `out` (direction out) - Pointer to output the process ID to.\n * `handle` - Handle of the process to get the ID of."]
    pub fn svcGetProcessId(out: *mut u32_, handle: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets a list of running processes.\n # Arguments\n\n* `processCount` (direction out) - Pointer to output the process count to.\n * `processIds` (direction out) - Pointer to output the process IDs to.\n * `processIdMaxCount` - Maximum number of process IDs."]
    pub fn svcGetProcessList(
        processCount: *mut s32,
        processIds: *mut u32_,
        processIdMaxCount: s32,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets a list of the threads of a process.\n # Arguments\n\n* `threadCount` (direction out) - Pointer to output the thread count to.\n * `threadIds` (direction out) - Pointer to output the thread IDs to.\n * `threadIdMaxCount` - Maximum number of thread IDs.\n * `process` - Process handle to list the threads of."]
    pub fn svcGetThreadList(
        threadCount: *mut s32,
        threadIds: *mut u32_,
        threadIdMaxCount: s32,
        process: Handle,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Creates a port.\n # Arguments\n\n* `portServer` (direction out) - Pointer to output the port server handle to.\n * `portClient` (direction out) - Pointer to output the port client handle to.\n * `name` - Name of the port.\n * `maxSessions` - Maximum number of sessions that can connect to the port."]
    pub fn svcCreatePort(
        portServer: *mut Handle,
        portClient: *mut Handle,
        name: *const ::libc::c_char,
        maxSessions: s32,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Connects to a port.\n # Arguments\n\n* `out` (direction out) - Pointer to output the port handle to.\n * `portName` - Name of the port."]
    pub fn svcConnectToPort(out: *mut Handle, portName: *const ::libc::c_char) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets up virtual address space for a new process.\n # Arguments\n\n* `out` (direction out) - Pointer to output the codeset handle to.\n * `info` - Codeset header, contains process name, titleId and segment info.\n * `textSegmentLma` - Address of executable segment in caller's address space.\n * `roSegmentLma` - Address of read-only segment in caller's address space.\n * `dataSegmentLma` - Address of read-write segment in caller's address space.\n > **Note:** On success, the provided segments are unmapped from the caller's address space."]
    pub fn svcCreateCodeSet(
        out: *mut Handle,
        info: *const CodeSetHeader,
        textSegmentLma: u32_,
        roSegmentLma: u32_,
        dataSegmentLma: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Create a new process.\n # Arguments\n\n* `out` (direction out) - Pointer to output the process handle to.\n * `codeset` - Codeset created for this process.\n * `arm11KernelCaps` - Arm11 Kernel Capabilities from exheader.\n * `numArm11KernelCaps` - Number of kernel capabilities."]
    pub fn svcCreateProcess(
        out: *mut Handle,
        codeset: Handle,
        arm11KernelCaps: *const u32_,
        numArm11KernelCaps: s32,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets a process's affinity mask.\n # Arguments\n\n* `affinitymask` (direction out) - Pointer to store the affinity masks.\n * `process` - Handle of the process.\n * `processorcount` - Number of processors."]
    pub fn svcGetProcessAffinityMask(
        affinitymask: *mut u8_,
        process: Handle,
        processorcount: s32,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets a process's affinity mask.\n # Arguments\n\n* `process` - Handle of the process.\n * `affinitymask` - Pointer to retrieve the affinity masks from.\n * `processorcount` - Number of processors."]
    pub fn svcSetProcessAffinityMask(
        process: Handle,
        affinitymask: *const u8_,
        processorcount: s32,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets a process's ideal processor.\n # Arguments\n\n* `processorid` (direction out) - Pointer to store the ID of the process's ideal processor.\n * `process` - Handle of the process."]
    pub fn svcGetProcessIdealProcessor(processorid: *mut s32, process: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets a process's ideal processor.\n # Arguments\n\n* `process` - Handle of the process.\n * `processorid` - ID of the process's ideal processor."]
    pub fn svcSetProcessIdealProcessor(process: Handle, processorid: s32) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Launches the main thread of the process.\n # Arguments\n\n* `process` - Handle of the process.\n * `info` - Pointer to a StartupInfo structure describing information for the main thread."]
    pub fn svcRun(process: Handle, info: *const StartupInfo) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Multithreading\n# *\n* Creates a new thread.\n # Arguments\n\n* `thread` (direction out) - The thread handle\n * `entrypoint` - The function that will be called first upon thread creation\n * `arg` - The argument passed to `entrypoint`\n * `stack_top` - The top of the thread's stack. Must be 0x8 bytes mem-aligned.\n * `thread_priority` - Low values gives the thread higher priority.\n For userland apps, this has to be within the range [0x18;0x3F]\n* * `processor_id` - The id of the processor the thread should be ran on. Those are labelled starting from 0.\n For old 3ds it has to be <2, and for new 3DS <4.\n* Value -1 means all CPUs and -2 read from the Exheader.\n*\n* The processor with ID 1 is the system processor.\n* To enable multi-threading on this core you need to call APT_SetAppCpuTimeLimit at least once with a non-zero value.\n*\n* Since a thread is considered as a waitable object, you can use svcWaitSynchronization\n and svcWaitSynchronizationN to join with it.\n\n* > **Note:** The kernel will clear the `stack_top's` address low 3 bits to make sure it is 0x8-bytes aligned.\n/"]
    pub fn svcCreateThread(
        thread: *mut Handle,
        entrypoint: ThreadFunc,
        arg: u32_,
        stack_top: *mut u32_,
        thread_priority: s32,
        processor_id: s32,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the handle of a thread.\n # Arguments\n\n* `thread` (direction out) - The handle of the thread\n * `process` - The ID of the process linked to the thread"]
    pub fn svcOpenThread(thread: *mut Handle, process: Handle, threadId: u32_) -> Result;
}
extern "C" {
    #[doc = "Exits the current thread.\n\n This will trigger a state change and hence release all svcWaitSynchronization operations.\n It means that you can join a thread by calling svcWaitSynchronization(threadHandle,yourtimeout); "]
    pub fn svcExitThread() -> !;
}
extern "C" {
    #[doc = "Puts the current thread to sleep.\n # Arguments\n\n* `ns` - The minimum number of nanoseconds to sleep for."]
    pub fn svcSleepThread(ns: s64);
}
extern "C" {
    #[must_use]
    #[doc = "Retrieves the priority of a thread."]
    pub fn svcGetThreadPriority(out: *mut s32, handle: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Changes the priority of a thread\n # Arguments\n\n* `prio` - For userland apps, this has to be within the range [0x18;0x3F]\n\n Low values gives the thread higher priority."]
    pub fn svcSetThreadPriority(thread: Handle, prio: s32) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets a thread's affinity mask.\n # Arguments\n\n* `affinitymask` (direction out) - Pointer to output the affinity masks to.\n * `thread` - Handle of the thread.\n * `processorcount` - Number of processors."]
    pub fn svcGetThreadAffinityMask(
        affinitymask: *mut u8_,
        thread: Handle,
        processorcount: s32,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets a thread's affinity mask.\n # Arguments\n\n* `thread` - Handle of the thread.\n * `affinitymask` - Pointer to retrieve the affinity masks from.\n * `processorcount` - Number of processors."]
    pub fn svcSetThreadAffinityMask(
        thread: Handle,
        affinitymask: *const u8_,
        processorcount: s32,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets a thread's ideal processor.\n # Arguments\n\n* `processorid` (direction out) - Pointer to output the ID of the thread's ideal processor to.\n * `thread` - Handle of the thread."]
    pub fn svcGetThreadIdealProcessor(processorid: *mut s32, thread: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets a thread's ideal processor.\n # Arguments\n\n* `thread` - Handle of the thread.\n * `processorid` - ID of the thread's ideal processor."]
    pub fn svcSetThreadIdealProcessor(thread: Handle, processorid: s32) -> Result;
}
extern "C" {
    #[doc = "Returns the ID of the processor the current thread is running on.\n [`svcCreateThread`]"]
    pub fn svcGetProcessorID() -> s32;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the ID of a thread.\n # Arguments\n\n* `out` (direction out) - Pointer to output the thread ID of the thread `handle` to.\n * `handle` - Handle of the thread."]
    pub fn svcGetThreadId(out: *mut u32_, handle: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the resource limit set of a process.\n # Arguments\n\n* `resourceLimit` (direction out) - Pointer to output the resource limit set handle to.\n * `process` - Process to get the resource limits of."]
    pub fn svcGetResourceLimit(resourceLimit: *mut Handle, process: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the value limits of a resource limit set.\n # Arguments\n\n* `values` (direction out) - Pointer to output the value limits to.\n * `resourceLimit` - Resource limit set to use.\n * `names` - Resource limit names to get the limits of.\n * `nameCount` - Number of resource limit names."]
    pub fn svcGetResourceLimitLimitValues(
        values: *mut s64,
        resourceLimit: Handle,
        names: *mut ResourceLimitType,
        nameCount: s32,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the values of a resource limit set.\n # Arguments\n\n* `values` (direction out) - Pointer to output the values to.\n * `resourceLimit` - Resource limit set to use.\n * `names` - Resource limit names to get the values of.\n * `nameCount` - Number of resource limit names."]
    pub fn svcGetResourceLimitCurrentValues(
        values: *mut s64,
        resourceLimit: Handle,
        names: *mut ResourceLimitType,
        nameCount: s32,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the resource limit set of a process.\n # Arguments\n\n* `process` - Process to set the resource limit set to.\n * `resourceLimit` - Resource limit set handle."]
    pub fn svcSetProcessResourceLimits(process: Handle, resourceLimit: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Creates a resource limit set.\n # Arguments\n\n* `resourceLimit` (direction out) - Pointer to output the resource limit set handle to."]
    pub fn svcCreateResourceLimit(resourceLimit: *mut Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the value limits of a resource limit set.\n # Arguments\n\n* `resourceLimit` - Resource limit set to use.\n * `names` - Resource limit names to set the limits of.\n * `values` - Value limits to set. The high 32 bits of RESLIMIT_COMMIT are used to\nset APPMEMALLOC in configuration memory, otherwise those bits are unused.\n * `nameCount` - Number of resource limit names."]
    pub fn svcSetResourceLimitValues(
        resourceLimit: Handle,
        names: *const ResourceLimitType,
        values: *const s64,
        nameCount: s32,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the process ID of a thread.\n # Arguments\n\n* `out` (direction out) - Pointer to output the process ID of the thread `handle` to.\n * `handle` - Handle of the thread.\n [`svcOpenProcess`]"]
    pub fn svcGetProcessIdOfThread(out: *mut u32_, handle: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Checks if a thread handle is valid.\n This requests always return an error when called, it only checks if the handle is a thread or not.\n # Returns\n\n0xD8E007ED (BAD_ENUM) if the Handle is a Thread Handle\n 0xD8E007F7 (BAD_HANDLE) if it isn't."]
    pub fn svcGetThreadInfo(out: *mut s64, thread: Handle, type_: ThreadInfoType) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Synchronization\n# *\n* Creates a mutex.\n # Arguments\n\n* `mutex` (direction out) - Pointer to output the handle of the created mutex to.\n * `initially_locked` - Whether the mutex should be initially locked.\n/"]
    pub fn svcCreateMutex(mutex: *mut Handle, initially_locked: bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Releases a mutex.\n # Arguments\n\n* `handle` - Handle of the mutex."]
    pub fn svcReleaseMutex(handle: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Creates a semaphore.\n # Arguments\n\n* `semaphore` (direction out) - Pointer to output the handle of the created semaphore to.\n * `initial_count` - Initial count of the semaphore.\n * `max_count` - Maximum count of the semaphore."]
    pub fn svcCreateSemaphore(semaphore: *mut Handle, initial_count: s32, max_count: s32)
        -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Releases a semaphore.\n # Arguments\n\n* `count` (direction out) - Pointer to output the current count of the semaphore to.\n * `semaphore` - Handle of the semaphore.\n * `release_count` - Number to increase the semaphore count by."]
    pub fn svcReleaseSemaphore(count: *mut s32, semaphore: Handle, release_count: s32) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Creates an event handle.\n # Arguments\n\n* `event` (direction out) - Pointer to output the created event handle to.\n * `reset_type` - Type of reset the event uses (RESET_ONESHOT/RESET_STICKY)."]
    pub fn svcCreateEvent(event: *mut Handle, reset_type: ResetType) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Signals an event.\n # Arguments\n\n* `handle` - Handle of the event to signal."]
    pub fn svcSignalEvent(handle: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Clears an event.\n # Arguments\n\n* `handle` - Handle of the event to clear."]
    pub fn svcClearEvent(handle: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Waits for synchronization on a handle.\n # Arguments\n\n* `handle` - Handle to wait on.\n * `nanoseconds` - Maximum nanoseconds to wait for."]
    pub fn svcWaitSynchronization(handle: Handle, nanoseconds: s64) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Waits for synchronization on multiple handles.\n # Arguments\n\n* `out` (direction out) - Pointer to output the index of the synchronized handle to.\n * `handles` - Handles to wait on.\n * `handles_num` - Number of handles.\n * `wait_all` - Whether to wait for synchronization on all handles.\n * `nanoseconds` - Maximum nanoseconds to wait for."]
    pub fn svcWaitSynchronizationN(
        out: *mut s32,
        handles: *const Handle,
        handles_num: s32,
        wait_all: bool,
        nanoseconds: s64,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Creates an address arbiter\n # Arguments\n\n* `mutex` (direction out) - Pointer to output the handle of the created address arbiter to.\n [`svcArbitrateAddress`]"]
    pub fn svcCreateAddressArbiter(arbiter: *mut Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Arbitrate an address, can be used for synchronization\n # Arguments\n\n* `arbiter` - Handle of the arbiter\n * `addr` - A pointer to a s32 value.\n * `type` - Type of action to be performed by the arbiter\n * `value` - Number of threads to signal if using ARBITRATION_SIGNAL, or the value used for comparison.\n * `timeout_ns` - Optional timeout in nanoseconds when using TIMEOUT actions, ignored otherwise. If not needed, use svcArbitrateAddressNoTimeout instead.\n > **Note:** Usage of this syscall entails an implicit Data Memory Barrier (dmb).\n Please use syncArbitrateAddressWithTimeout instead."]
    pub fn svcArbitrateAddress(
        arbiter: Handle,
        addr: u32_,
        type_: ArbitrationType,
        value: s32,
        timeout_ns: s64,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Same as svcArbitrateAddress but with the timeout_ns parameter undefined.\n # Arguments\n\n* `arbiter` - Handle of the arbiter\n * `addr` - A pointer to a s32 value.\n * `type` - Type of action to be performed by the arbiter\n * `value` - Number of threads to signal if using ARBITRATION_SIGNAL, or the value used for comparison.\n > **Note:** Usage of this syscall entails an implicit Data Memory Barrier (dmb).\n Please use syncArbitrateAddress instead."]
    pub fn svcArbitrateAddressNoTimeout(
        arbiter: Handle,
        addr: u32_,
        type_: ArbitrationType,
        value: s32,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sends a synchronized request to a session handle.\n # Arguments\n\n* `session` - Handle of the session."]
    pub fn svcSendSyncRequest(session: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Connects to a port via a handle.\n # Arguments\n\n* `clientSession` (direction out) - Pointer to output the client session handle to.\n * `clientPort` - Port client endpoint to connect to."]
    pub fn svcCreateSessionToPort(clientSession: *mut Handle, clientPort: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Creates a linked pair of session endpoints.\n # Arguments\n\n* `serverSession` (direction out) - Pointer to output the created server endpoint handle to.\n * `clientSession` (direction out) - Pointer to output the created client endpoint handle to."]
    pub fn svcCreateSession(serverSession: *mut Handle, clientSession: *mut Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Accepts a session.\n # Arguments\n\n* `session` (direction out) - Pointer to output the created session handle to.\n * `port` - Handle of the port to accept a session from."]
    pub fn svcAcceptSession(session: *mut Handle, port: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Replies to and receives a new request.\n # Arguments\n\n* `index` - Pointer to the index of the request.\n * `handles` - Session handles to receive requests from.\n * `handleCount` - Number of handles.\n * `replyTarget` - Handle of the session to reply to."]
    pub fn svcReplyAndReceive(
        index: *mut s32,
        handles: *const Handle,
        handleCount: s32,
        replyTarget: Handle,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Time\n# *\n* Creates a timer.\n # Arguments\n\n* `timer` (direction out) - Pointer to output the handle of the created timer to.\n * `reset_type` - Type of reset to perform on the timer.\n/"]
    pub fn svcCreateTimer(timer: *mut Handle, reset_type: ResetType) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets a timer.\n # Arguments\n\n* `timer` - Handle of the timer to set.\n * `initial` - Initial value of the timer.\n * `interval` - Interval of the timer."]
    pub fn svcSetTimer(timer: Handle, initial: s64, interval: s64) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Cancels a timer.\n # Arguments\n\n* `timer` - Handle of the timer to cancel."]
    pub fn svcCancelTimer(timer: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Clears a timer.\n # Arguments\n\n* `timer` - Handle of the timer to clear."]
    pub fn svcClearTimer(timer: Handle) -> Result;
}
extern "C" {
    #[doc = "Gets the current system tick.\n # Returns\n\nThe current system tick."]
    pub fn svcGetSystemTick() -> u64_;
}
extern "C" {
    #[must_use]
    #[doc = "System\n# *\n* Closes a handle.\n # Arguments\n\n* `handle` - Handle to close.\n/"]
    pub fn svcCloseHandle(handle: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Duplicates a handle.\n # Arguments\n\n* `out` (direction out) - Pointer to output the duplicated handle to.\n * `original` - Handle to duplicate."]
    pub fn svcDuplicateHandle(out: *mut Handle, original: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets a handle info.\n # Arguments\n\n* `out` (direction out) - Pointer to output the handle info to.\n * `handle` - Handle to get the info for.\n * `param` - Parameter clarifying the handle info type."]
    pub fn svcGetHandleInfo(out: *mut s64, handle: Handle, param: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the system info.\n # Arguments\n\n* `out` (direction out) - Pointer to output the system info to.\n * `type` - Type of system info to retrieve.\n * `param` - Parameter clarifying the system info type."]
    pub fn svcGetSystemInfo(out: *mut s64, type_: u32_, param: s32) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the current kernel state.\n # Arguments\n\n* `type` - Type of state to set (the other parameters depend on it)."]
    pub fn svcKernelSetState(type_: u32_, ...) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Binds an event or semaphore handle to an ARM11 interrupt.\n # Arguments\n\n* `interruptId` - Interrupt identfier (see https://www.3dbrew.org/wiki/ARM11_Interrupts).\n * `eventOrSemaphore` - Event or semaphore handle to bind to the given interrupt.\n * `priority` - Priority of the interrupt for the current process.\n * `isManualClear` - Indicates whether the interrupt has to be manually cleared or not (= level-high active)."]
    pub fn svcBindInterrupt(
        interruptId: u32_,
        eventOrSemaphore: Handle,
        priority: s32,
        isManualClear: bool,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Unbinds an event or semaphore handle from an ARM11 interrupt.\n # Arguments\n\n* `interruptId` - Interrupt identfier, see (see https://www.3dbrew.org/wiki/ARM11_Interrupts).\n * `eventOrSemaphore` - Event or semaphore handle to unbind from the given interrupt."]
    pub fn svcUnbindInterrupt(interruptId: u32_, eventOrSemaphore: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Invalidates a process's data cache.\n # Arguments\n\n* `process` - Handle of the process.\n * `addr` - Address to invalidate.\n * `size` - Size of the memory to invalidate."]
    pub fn svcInvalidateProcessDataCache(process: Handle, addr: u32_, size: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Cleans a process's data cache.\n # Arguments\n\n* `process` - Handle of the process.\n * `addr` - Address to clean.\n * `size` - Size of the memory to clean."]
    pub fn svcStoreProcessDataCache(process: Handle, addr: u32_, size: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Flushes (cleans and invalidates) a process's data cache.\n # Arguments\n\n* `process` - Handle of the process.\n * `addr` - Address to flush.\n * `size` - Size of the memory to flush."]
    pub fn svcFlushProcessDataCache(process: Handle, addr: u32_, size: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Begins an inter-process DMA transfer.\n # Arguments\n\n* `dma` (direction out) - Pointer to output the handle of the DMA channel object to.\n * `dstProcess` - Destination process handle.\n * `dstAddr` - Address in the destination process to write data to.\n * `srcProcess` - Source process handle.\n * `srcAddr` - Address in the source to read data from.\n * `size` - Size of the data to transfer.\n * `cfg` - Configuration structure.\n > **Note:** The handle is signaled when the transfer finishes."]
    pub fn svcStartInterProcessDma(
        dma: *mut Handle,
        dstProcess: Handle,
        dstAddr: u32_,
        srcProcess: Handle,
        srcAddr: u32_,
        size: u32_,
        cfg: *const DmaConfig,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Stops an inter-process DMA transfer.\n # Arguments\n\n* `dma` - Handle of the DMA channel object."]
    pub fn svcStopDma(dma: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the state of an inter-process DMA transfer.\n # Arguments\n\n* `state` (direction out) - Pointer to output the state of the DMA transfer to.\n * `dma` - Handle of the DMA channel object."]
    pub fn svcGetDmaState(state: *mut DmaState, dma: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Restarts a DMA transfer, using the same configuration as before.\n # Arguments\n\n* `state` (direction out) - Pointer to output the state of the DMA transfer to.\n * `dma` - Handle of the DMA channel object.\n * `dstAddr` - Address in the destination process to write data to.\n * `srcAddr` - Address in the source to read data from.\n * `size` - Size of the data to transfer.\n * `flags` - Restart flags, DMARST_UNLOCK and/or DMARST_RESUME_DEVICE.\n > **Note:** The first transfer has to be configured with DMACFG_KEEP_LOCKED."]
    pub fn svcRestartDma(
        dma: Handle,
        dstAddr: u32_,
        srcAddr: u32_,
        size: u32_,
        flags: s8,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the GPU protection register to restrict the range of the GPU DMA. 11.3+ only.\n # Arguments\n\n* `useApplicationRestriction` - Whether to use the register value used for APPLICATION titles."]
    pub fn svcSetGpuProt(useApplicationRestriction: bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Enables or disables Wi-Fi. 11.4+ only.\n # Arguments\n\n* `enabled` - Whether to enable or disable Wi-Fi."]
    pub fn svcSetWifiEnabled(enabled: bool) -> Result;
}
extern "C" {
    #[doc = "Debugging\n# *\n* Breaks execution.\n # Arguments\n\n* `breakReason` - Reason for breaking.\n/"]
    pub fn svcBreak(breakReason: UserBreakType);
}
extern "C" {
    #[doc = "Breaks execution (LOAD_RO and UNLOAD_RO).\n # Arguments\n\n* `breakReason` - Debug reason for breaking.\n * `croInfo` - Library information.\n * `croInfoSize` - Size of the above structure."]
    pub fn svcBreakRO(
        breakReason: UserBreakType,
        croInfo: *const ::libc::c_void,
        croInfoSize: u32_,
    );
}
extern "C" {
    #[must_use]
    #[doc = "Outputs a debug string.\n # Arguments\n\n* `str` - String to output.\n * `length` - Length of the string to output, needs to be positive."]
    pub fn svcOutputDebugString(str_: *const ::libc::c_char, length: s32) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Controls performance monitoring on the CP15 interface and the SCU.\n The meaning of the parameters depend on the operation.\n # Arguments\n\n* `out` (direction out) - Output.\n * `op` - Operation, see details.\n * `param1` - First parameter.\n * `param2` - Second parameter.\n \n\nThe operations are the following:\n - PERFCOUNTEROP_ENABLE (void) -> void, tries to enable and lock perfmon. functionality.\n - PERFCOUNTEROP_DISABLE (void) -> void, disable and forcibly unlocks perfmon. functionality.\n - PERFCOUNTEROP_GET_VALUE (PerfCounterRegister reg) -> u64, gets the value of a particular counter register.\n - PERFCOUNTEROP_SET_VALUE (PerfCounterRegister reg, u64 value) -> void, sets the value of a particular counter register.\n - PERFCOUNTEROP_GET_OVERFLOW_FLAGS (void) -> u32, gets the overflow flags of all CP15 and SCU registers.\n - Format is a bitfield of PerfCounterRegister.\n - PERFCOUNTEROP_RESET (u32 valueResetMask, u32 overflowFlagResetMask) -> void, resets the value and/or\n overflow flags of selected registers.\n - Format is two bitfields of PerfCounterRegister.\n - PERFCOUNTEROP_GET_EVENT (PerfCounterRegister reg) -> PerfCounterEvent, gets the event associated\n to a particular counter register.\n - PERFCOUNTEROP_SET_EVENT (PerfCounterRegister reg, PerfCounterEvent) -> void, sets the event associated\n to a particular counter register.\n - PERFCOUNTEROP_SET_VIRTUAL_COUNTER_ENABLED (bool enabled) -> void, (dis)allows the kernel to track counter overflows\n and to use 64-bit counter values."]
    pub fn svcControlPerformanceCounter(
        out: *mut u64_,
        op: PerfCounterOperation,
        param1: u32_,
        param2: u64_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Creates a debug handle for an active process.\n # Arguments\n\n* `debug` (direction out) - Pointer to output the created debug handle to.\n * `processId` - ID of the process to debug."]
    pub fn svcDebugActiveProcess(debug: *mut Handle, processId: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Breaks a debugged process.\n # Arguments\n\n* `debug` - Debug handle of the process."]
    pub fn svcBreakDebugProcess(debug: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Terminates a debugged process.\n # Arguments\n\n* `debug` - Debug handle of the process."]
    pub fn svcTerminateDebugProcess(debug: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the current debug event of a debugged process.\n # Arguments\n\n* `info` (direction out) - Pointer to output the debug event information to.\n * `debug` - Debug handle of the process."]
    pub fn svcGetProcessDebugEvent(info: *mut DebugEventInfo, debug: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Continues the current debug event of a debugged process (not necessarily the same as svcGetProcessDebugEvent).\n # Arguments\n\n* `debug` - Debug handle of the process.\n * `flags` - Flags to continue with, see DebugFlags."]
    pub fn svcContinueDebugEvent(debug: Handle, flags: DebugFlags) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Fetches the saved registers of a thread, either inactive or awaiting svcContinueDebugEvent, belonging to a debugged process.\n # Arguments\n\n* `context` (direction out) - Values of the registers to fetch, see ThreadContext.\n * `debug` - Debug handle of the parent process.\n * `threadId` - ID of the thread to fetch the saved registers of.\n * `controlFlags` - Which registers to fetch, see ThreadContextControlFlags."]
    pub fn svcGetDebugThreadContext(
        context: *mut ThreadContext,
        debug: Handle,
        threadId: u32_,
        controlFlags: ThreadContextControlFlags,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Updates the saved registers of a thread, either inactive or awaiting svcContinueDebugEvent, belonging to a debugged process.\n # Arguments\n\n* `debug` - Debug handle of the parent process.\n * `threadId` - ID of the thread to update the saved registers of.\n * `context` - Values of the registers to update, see ThreadContext.\n * `controlFlags` - Which registers to update, see ThreadContextControlFlags."]
    pub fn svcSetDebugThreadContext(
        debug: Handle,
        threadId: u32_,
        context: *mut ThreadContext,
        controlFlags: ThreadContextControlFlags,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Queries memory information of a debugged process.\n # Arguments\n\n* `info` (direction out) - Pointer to output memory info to.\n * `out` (direction out) - Pointer to output page info to.\n * `debug` - Debug handle of the process to query memory from.\n * `addr` - Virtual memory address to query."]
    pub fn svcQueryDebugProcessMemory(
        info: *mut MemInfo,
        out: *mut PageInfo,
        debug: Handle,
        addr: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Reads from a debugged process's memory.\n # Arguments\n\n* `buffer` - Buffer to read data to.\n * `debug` - Debug handle of the process.\n * `addr` - Address to read from.\n * `size` - Size of the memory to read."]
    pub fn svcReadProcessMemory(
        buffer: *mut ::libc::c_void,
        debug: Handle,
        addr: u32_,
        size: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Writes to a debugged process's memory.\n # Arguments\n\n* `debug` - Debug handle of the process.\n * `buffer` - Buffer to write data from.\n * `addr` - Address to write to.\n * `size` - Size of the memory to write."]
    pub fn svcWriteProcessMemory(
        debug: Handle,
        buffer: *const ::libc::c_void,
        addr: u32_,
        size: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets an hardware breakpoint or watchpoint. This is an interface to the BRP/WRP registers, see http://infocenter.arm.com/help/topic/com.arm.doc.ddi0360f/CEGEBGFC.html .\n # Arguments\n\n* `registerId` - range 0..5 = breakpoints (BRP0-5), 0x100..0x101 = watchpoints (WRP0-1). The previous stop point for the register is disabled.\n * `control` - Value of the control regiser.\n * `value` - Value of the value register: either and address (if bit21 of control is clear) or the debug handle of a process to fetch the context ID of."]
    pub fn svcSetHardwareBreakPoint(registerId: s32, control: u32_, value: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets a debugged thread's parameter.\n # Arguments\n\n* `unused` (direction out) - Unused.\n * `out` (direction out) - Output value.\n * `debug` - Debug handle of the process.\n * `threadId` - ID of the thread\n * `parameter` - Parameter to fetch, see DebugThreadParameter."]
    pub fn svcGetDebugThreadParam(
        unused: *mut s64,
        out: *mut u32_,
        debug: Handle,
        threadId: u32_,
        parameter: DebugThreadParameter,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Executes a function in supervisor mode.\n # Arguments\n\n* `callback` - Function to execute."]
    pub fn svcBackdoor(callback: ::core::option::Option<unsafe extern "C" fn() -> s32>) -> Result;
}
#[doc = "< Mount \"nand:/\""]
pub const ARM9DESC_MOUNT_NAND: _bindgen_ty_7 = 1;
#[doc = "< Mount nand:/ro/ as read-write"]
pub const ARM9DESC_MOUNT_NANDRO_RW: _bindgen_ty_7 = 2;
#[doc = "< Mount \"twln:/\""]
pub const ARM9DESC_MOUNT_TWLN: _bindgen_ty_7 = 4;
#[doc = "< Mount \"wnand:/\""]
pub const ARM9DESC_MOUNT_WNAND: _bindgen_ty_7 = 8;
#[doc = "< Mount \"cardspi:/\""]
pub const ARM9DESC_MOUNT_CARDSPI: _bindgen_ty_7 = 16;
#[doc = "< Use SDIF3"]
pub const ARM9DESC_USE_SDIF3: _bindgen_ty_7 = 32;
#[doc = "< Create seed (movable.sed)"]
pub const ARM9DESC_CREATE_SEED: _bindgen_ty_7 = 64;
#[doc = "< Use card SPI, required by multiple pxi:dev commands"]
pub const ARM9DESC_USE_CARD_SPI: _bindgen_ty_7 = 128;
#[doc = "< SD application (not checked)"]
pub const ARM9DESC_SD_APPLICATION: _bindgen_ty_7 = 256;
#[doc = "< Mount \"sdmc:/\" as read-write"]
pub const ARM9DESC_MOUNT_SDMC_RW: _bindgen_ty_7 = 512;
#[doc = "ARM9 descriptor flags"]
pub type _bindgen_ty_7 = ::libc::c_uint;
#[doc = "< Category \"system application\""]
pub const FSACCESS_CATEGORY_SYSTEM_APPLICATION: _bindgen_ty_8 = 1;
#[doc = "< Category \"hardware check\""]
pub const FSACCESS_CATEGORY_HARDWARE_CHECK: _bindgen_ty_8 = 2;
#[doc = "< Category \"filesystem tool\""]
pub const FSACCESS_CATEGORY_FILESYSTEM_TOOL: _bindgen_ty_8 = 4;
#[doc = "< Debug"]
pub const FSACCESS_DEBUG: _bindgen_ty_8 = 8;
#[doc = "< TWLCARD backup"]
pub const FSACCESS_TWLCARD_BACKUP: _bindgen_ty_8 = 16;
#[doc = "< TWLNAND data"]
pub const FSACCESS_TWLNAND_DATA: _bindgen_ty_8 = 32;
#[doc = "< BOSS (SpotPass)"]
pub const FSACCESS_BOSS: _bindgen_ty_8 = 64;
#[doc = "< SDMC (read-write)"]
pub const FSACCESS_SDMC_RW: _bindgen_ty_8 = 128;
#[doc = "< Core"]
pub const FSACCESS_CORE: _bindgen_ty_8 = 256;
#[doc = "< nand:/ro/ (read-only)"]
pub const FSACCESS_NANDRO_RO: _bindgen_ty_8 = 512;
#[doc = "< nand:/rw/"]
pub const FSACCESS_NANDRW: _bindgen_ty_8 = 1024;
#[doc = "< nand:/ro/ (read-write)"]
pub const FSACCESS_NANDRO_RW: _bindgen_ty_8 = 2048;
#[doc = "< Category \"System Settings\""]
pub const FSACCESS_CATEGORY_SYSTEM_SETTINGS: _bindgen_ty_8 = 4096;
#[doc = "< Cardboard (System Transfer)"]
pub const FSACCESS_CARDBOARD: _bindgen_ty_8 = 8192;
#[doc = "< Export/Import IVs (movable.sed)"]
pub const FSACCESS_EXPORT_IMPORT_IVS: _bindgen_ty_8 = 16384;
#[doc = "< SDMC (write-only)"]
pub const FSACCESS_SDMC_WO: _bindgen_ty_8 = 32768;
#[doc = "< \"Switch cleanup\" (3.0+)"]
pub const FSACCESS_SWITCH_CLEANUP: _bindgen_ty_8 = 65536;
#[doc = "< Savedata move (5.0+)"]
pub const FSACCESS_SAVEDATA_MOVE: _bindgen_ty_8 = 131072;
#[doc = "< Shop (5.0+)"]
pub const FSACCESS_SHOP: _bindgen_ty_8 = 262144;
#[doc = "< Shop (5.0+)"]
pub const FSACCESS_SHELL: _bindgen_ty_8 = 524288;
#[doc = "< Category \"Home Menu\" (6.0+)"]
pub const FSACCESS_CATEGORY_HOME_MENU: _bindgen_ty_8 = 1048576;
#[doc = "< Seed DB (9.6+)"]
pub const FSACCESS_SEEDDB: _bindgen_ty_8 = 2097152;
#[doc = "Filesystem access flags"]
pub type _bindgen_ty_8 = ::libc::c_uint;
#[doc = "< Regular application"]
pub const RESLIMIT_CATEGORY_APPLICATION: ResourceLimitCategory = 0;
#[doc = "< System applet"]
pub const RESLIMIT_CATEGORY_SYS_APPLET: ResourceLimitCategory = 1;
#[doc = "< Library applet"]
pub const RESLIMIT_CATEGORY_LIB_APPLET: ResourceLimitCategory = 2;
#[doc = "< System modules running inside the BASE memregion"]
pub const RESLIMIT_CATEGORY_OTHER: ResourceLimitCategory = 3;
#[doc = "The resource limit category of a title"]
pub type ResourceLimitCategory = ::libc::c_uint;
#[doc = "< 64MB of usable application memory"]
pub const SYSMODE_O3DS_PROD: SystemMode = 0;
#[doc = "< 124MB of usable application memory. Unusable on O3DS"]
pub const SYSMODE_N3DS_PROD: SystemMode = 1;
#[doc = "< 97MB/178MB of usable application memory"]
pub const SYSMODE_DEV1: SystemMode = 2;
#[doc = "< 80MB/124MB of usable application memory"]
pub const SYSMODE_DEV2: SystemMode = 3;
#[doc = "< 72MB of usable application memory. Same as \"Prod\" on N3DS"]
pub const SYSMODE_DEV3: SystemMode = 4;
#[doc = "< 32MB of usable application memory. Same as \"Prod\" on N3DS"]
pub const SYSMODE_DEV4: SystemMode = 5;
#[doc = "The system mode a title should be launched under"]
pub type SystemMode = ::libc::c_uint;
#[doc = "The system info flags and remaster version of a title"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ExHeader_SystemInfoFlags {
    #[doc = "< Reserved"]
    pub reserved: [u8_; 5usize],
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< Remaster version"]
    pub remaster_version: u16_,
}
impl ExHeader_SystemInfoFlags {
    #[inline]
    pub fn compress_exefs_code(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_compress_exefs_code(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_sd_application(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_sd_application(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        compress_exefs_code: bool,
        is_sd_application: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let compress_exefs_code: u8 = unsafe { ::core::mem::transmute(compress_exefs_code) };
            compress_exefs_code as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let is_sd_application: u8 = unsafe { ::core::mem::transmute(is_sd_application) };
            is_sd_application as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "Information about a title's section"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ExHeader_CodeSectionInfo {
    #[doc = "< The address of the section"]
    pub address: u32_,
    #[doc = "< The number of pages the section occupies"]
    pub num_pages: u32_,
    #[doc = "< The size of the section"]
    pub size: u32_,
}
#[doc = "The name of a title and infomation about its section"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ExHeader_CodeSetInfo {
    #[doc = "< Title name"]
    pub name: [::libc::c_char; 8usize],
    #[doc = "< System info flags, see ExHeader_SystemInfoFlags"]
    pub flags: ExHeader_SystemInfoFlags,
    #[doc = "< .text section info, see ExHeader_CodeSectionInfo"]
    pub text: ExHeader_CodeSectionInfo,
    #[doc = "< Stack size"]
    pub stack_size: u32_,
    #[doc = "< .rodata section info, see ExHeader_CodeSectionInfo"]
    pub rodata: ExHeader_CodeSectionInfo,
    #[doc = "< Reserved"]
    pub reserved: u32_,
    #[doc = "< .data section info, see ExHeader_CodeSectionInfo"]
    pub data: ExHeader_CodeSectionInfo,
    #[doc = "< .bss section size"]
    pub bss_size: u32_,
}
#[doc = "The savedata size and jump ID of a title"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExHeader_SystemInfo {
    #[doc = "< Savedata size"]
    pub savedata_size: u64_,
    #[doc = "< Jump ID"]
    pub jump_id: u64_,
    #[doc = "< Reserved"]
    pub reserved: [u8_; 48usize],
}
impl Default for ExHeader_SystemInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "The code set info, dependencies and system info of a title (SCI)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExHeader_SystemControlInfo {
    #[doc = "< Code set info, see ExHeader_CodeSetInfo"]
    pub codeset_info: ExHeader_CodeSetInfo,
    #[doc = "< Title IDs of the titles that this program depends on"]
    pub dependencies: [u64_; 48usize],
    #[doc = "< System info, see ExHeader_SystemInfo"]
    pub system_info: ExHeader_SystemInfo,
}
impl Default for ExHeader_SystemControlInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "The ARM11 filesystem info of a title"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ExHeader_Arm11StorageInfo {
    #[doc = "< Extdata ID"]
    pub extdata_id: u64_,
    #[doc = "< IDs of the system savedata accessible by the title"]
    pub system_savedata_ids: [u32_; 2usize],
    #[doc = "< IDs of the savedata accessible by the title, 20 bits each, followed by \"Use other variation savedata\""]
    pub accessible_savedata_ids: u64_,
    #[doc = "< FS access flags"]
    pub fs_access_info: u32_,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl ExHeader_Arm11StorageInfo {
    #[inline]
    pub fn reserved(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn no_romfs(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_no_romfs(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn use_extended_savedata_access(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_use_extended_savedata_access(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved: u32_,
        no_romfs: bool,
        use_extended_savedata_access: bool,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let no_romfs: u8 = unsafe { ::core::mem::transmute(no_romfs) };
            no_romfs as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let use_extended_savedata_access: u8 =
                unsafe { ::core::mem::transmute(use_extended_savedata_access) };
            use_extended_savedata_access as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "The CPU-related and memory-layout-related info of a title"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExHeader_Arm11CoreInfo {
    #[doc = "< The low title ID of the target firmware"]
    pub core_version: u32_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    #[doc = "< The priority of the title's main thread"]
    pub priority: u8_,
}
impl Default for ExHeader_Arm11CoreInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl ExHeader_Arm11CoreInfo {
    #[inline]
    pub fn use_cpu_clockrate_804MHz(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_use_cpu_clockrate_804MHz(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enable_l2c(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_enable_l2c(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flag1_unused(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_flag1_unused(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn n3ds_system_mode(&self) -> SystemMode {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_n3ds_system_mode(&mut self, val: SystemMode) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn flag2_unused(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_flag2_unused(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn ideal_processor(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_ideal_processor(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn affinity_mask(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_affinity_mask(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn o3ds_system_mode(&self) -> SystemMode {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_o3ds_system_mode(&mut self, val: SystemMode) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        use_cpu_clockrate_804MHz: bool,
        enable_l2c: bool,
        flag1_unused: u8_,
        n3ds_system_mode: SystemMode,
        flag2_unused: u8_,
        ideal_processor: u8_,
        affinity_mask: u8_,
        o3ds_system_mode: SystemMode,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let use_cpu_clockrate_804MHz: u8 =
                unsafe { ::core::mem::transmute(use_cpu_clockrate_804MHz) };
            use_cpu_clockrate_804MHz as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let enable_l2c: u8 = unsafe { ::core::mem::transmute(enable_l2c) };
            enable_l2c as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let flag1_unused: u8 = unsafe { ::core::mem::transmute(flag1_unused) };
            flag1_unused as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let n3ds_system_mode: u32 = unsafe { ::core::mem::transmute(n3ds_system_mode) };
            n3ds_system_mode as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let flag2_unused: u8 = unsafe { ::core::mem::transmute(flag2_unused) };
            flag2_unused as u64
        });
        __bindgen_bitfield_unit.set(16usize, 2u8, {
            let ideal_processor: u8 = unsafe { ::core::mem::transmute(ideal_processor) };
            ideal_processor as u64
        });
        __bindgen_bitfield_unit.set(18usize, 2u8, {
            let affinity_mask: u8 = unsafe { ::core::mem::transmute(affinity_mask) };
            affinity_mask as u64
        });
        __bindgen_bitfield_unit.set(20usize, 4u8, {
            let o3ds_system_mode: u32 = unsafe { ::core::mem::transmute(o3ds_system_mode) };
            o3ds_system_mode as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "The ARM11 system-local capabilities of a title"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExHeader_Arm11SystemLocalCapabilities {
    #[doc = "< Title ID"]
    pub title_id: u64_,
    #[doc = "< Core info, see ExHeader_Arm11CoreInfo"]
    pub core_info: ExHeader_Arm11CoreInfo,
    #[doc = "< Resource limit descriptors, only \"CpuTime\" (first byte) sems to be used"]
    pub reslimits: [u16_; 16usize],
    #[doc = "< Storage info, see ExHeader_Arm11StorageInfo"]
    pub storage_info: ExHeader_Arm11StorageInfo,
    #[doc = "< List of the services the title has access to. Limited to 32 prior to system version 9.3"]
    pub service_access: [[::libc::c_char; 8usize]; 34usize],
    #[doc = "< Reserved"]
    pub reserved: [u8_; 15usize],
    #[doc = "< Resource limit category, see ExHeader_Arm11SystemLocalCapabilities"]
    pub reslimit_category: ResourceLimitCategory,
}
impl Default for ExHeader_Arm11SystemLocalCapabilities {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "The ARM11 kernel capabilities of a title"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ExHeader_Arm11KernelCapabilities {
    #[doc = "< ARM11 kernel descriptors, see 3dbrew"]
    pub descriptors: [u32_; 28usize],
    #[doc = "< Reserved"]
    pub reserved: [u8_; 16usize],
}
#[doc = "The ARM9 access control of a title"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ExHeader_Arm9AccessControl {
    #[doc = "< Process9 FS descriptors, see 3dbrew"]
    pub descriptors: [u8_; 15usize],
    #[doc = "< Descriptor version"]
    pub descriptor_version: u8_,
}
#[doc = "The access control information of a title"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExHeader_AccessControlInfo {
    #[doc = "< ARM11 system-local capabilities, see ExHeader_Arm11SystemLocalCapabilities"]
    pub local_caps: ExHeader_Arm11SystemLocalCapabilities,
    #[doc = "< ARM11 kernel capabilities, see ExHeader_Arm11SystemLocalCapabilities"]
    pub kernel_caps: ExHeader_Arm11KernelCapabilities,
    #[doc = "< ARM9 access control, see ExHeader_Arm9AccessControl"]
    pub access_control: ExHeader_Arm9AccessControl,
}
impl Default for ExHeader_AccessControlInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Main extended header data, as returned by PXIPM, Loader and FSREG service commands"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExHeader_Info {
    #[doc = "< System control info, see ExHeader_SystemControlInfo"]
    pub sci: ExHeader_SystemControlInfo,
    #[doc = "< Access control info, see ExHeader_AccessControlInfo"]
    pub aci: ExHeader_AccessControlInfo,
}
impl Default for ExHeader_Info {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Extended header access descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExHeader_AccessDescriptor {
    #[doc = "< The signature of the access descriptor (RSA-2048-SHA256)"]
    pub signature: [u8_; 256usize],
    #[doc = "< The modulus used for the above signature, with 65537 as public exponent"]
    pub ncchModulus: [u8_; 256usize],
    #[doc = "< This is compared for equality with the first ACI by Process9, see ExHeader_AccessControlInfo"]
    pub acli: ExHeader_AccessControlInfo,
}
impl Default for ExHeader_AccessDescriptor {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "The NCCH Extended Header of a title"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExHeader {
    #[doc = "< Main extended header data, see ExHeader_Info"]
    pub info: ExHeader_Info,
    #[doc = "< Access descriptor, see ExHeader_AccessDescriptor"]
    pub access_descriptor: ExHeader_AccessDescriptor,
}
impl Default for ExHeader {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[must_use]
    #[doc = "Initializes the service API."]
    pub fn srvInit() -> Result;
}
extern "C" {
    #[doc = "Exits the service API."]
    pub fn srvExit();
}
extern "C" {
    #[doc = "Makes srvGetServiceHandle non-blocking for the current thread (or blocking, the default), in case of unavailable (full) requested services.\n # Arguments\n\n* `blocking` - Whether srvGetServiceHandle should be non-blocking.\n srvGetServiceHandle will always block if the service hasn't been registered yet,\n use srvIsServiceRegistered to check whether that is the case or not."]
    pub fn srvSetBlockingPolicy(nonBlocking: bool);
}
extern "C" {
    #[doc = "Gets the current service API session handle.\n # Returns\n\nThe current service API session handle."]
    pub fn srvGetSessionHandle() -> *mut Handle;
}
extern "C" {
    #[must_use]
    #[doc = "Retrieves a service handle, retrieving from the environment handle list if possible.\n # Arguments\n\n* `out` - Pointer to write the handle to.\n * `name` - Name of the service.\n # Returns\n\n0 if no error occured,\n 0xD8E06406 if the caller has no right to access the service,\n 0xD0401834 if the requested service port is full and srvGetServiceHandle is non-blocking (see srvSetBlockingPolicy)."]
    pub fn srvGetServiceHandle(out: *mut Handle, name: *const ::libc::c_char) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Registers the current process as a client to the service API."]
    pub fn srvRegisterClient() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Enables service notificatios, returning a notification semaphore.\n # Arguments\n\n* `semaphoreOut` - Pointer to output the notification semaphore to."]
    pub fn srvEnableNotification(semaphoreOut: *mut Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Registers the current process as a service.\n # Arguments\n\n* `out` - Pointer to write the service handle to.\n * `name` - Name of the service.\n * `maxSessions` - Maximum number of sessions the service can handle."]
    pub fn srvRegisterService(
        out: *mut Handle,
        name: *const ::libc::c_char,
        maxSessions: ::libc::c_int,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Unregisters the current process as a service.\n # Arguments\n\n* `name` - Name of the service."]
    pub fn srvUnregisterService(name: *const ::libc::c_char) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Retrieves a service handle.\n # Arguments\n\n* `out` - Pointer to output the handle to.\n * `name` - Name of the service.\n * # Returns\n\n0 if no error occured,\n 0xD8E06406 if the caller has no right to access the service,\n 0xD0401834 if the requested service port is full and srvGetServiceHandle is non-blocking (see srvSetBlockingPolicy)."]
    pub fn srvGetServiceHandleDirect(out: *mut Handle, name: *const ::libc::c_char) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Registers a port.\n # Arguments\n\n* `name` - Name of the port.\n * `clientHandle` - Client handle of the port."]
    pub fn srvRegisterPort(name: *const ::libc::c_char, clientHandle: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Unregisters a port.\n # Arguments\n\n* `name` - Name of the port."]
    pub fn srvUnregisterPort(name: *const ::libc::c_char) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Retrieves a port handle.\n # Arguments\n\n* `out` - Pointer to output the handle to.\n * `name` - Name of the port."]
    pub fn srvGetPort(out: *mut Handle, name: *const ::libc::c_char) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Waits for a port to be registered.\n # Arguments\n\n* `name` - Name of the port to wait for registration."]
    pub fn srvWaitForPortRegistered(name: *const ::libc::c_char) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Subscribes to a notification.\n # Arguments\n\n* `notificationId` - ID of the notification."]
    pub fn srvSubscribe(notificationId: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Unsubscribes from a notification.\n # Arguments\n\n* `notificationId` - ID of the notification."]
    pub fn srvUnsubscribe(notificationId: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Receives a notification.\n # Arguments\n\n* `notificationIdOut` - Pointer to output the ID of the received notification to."]
    pub fn srvReceiveNotification(notificationIdOut: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Publishes a notification to subscribers.\n # Arguments\n\n* `notificationId` - ID of the notification.\n * `flags` - Flags to publish with. (bit 0 = only fire if not fired, bit 1 = do not report an error if there are more than 16 pending notifications)"]
    pub fn srvPublishToSubscriber(notificationId: u32_, flags: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Publishes a notification to subscribers and retrieves a list of all processes that were notified.\n # Arguments\n\n* `processIdCountOut` - Pointer to output the number of process IDs to.\n * `processIdsOut` - Pointer to output the process IDs to. Should have size \"60 * sizeof(u32)\".\n * `notificationId` - ID of the notification."]
    pub fn srvPublishAndGetSubscriber(
        processIdCountOut: *mut u32_,
        processIdsOut: *mut u32_,
        notificationId: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Checks whether a service is registered.\n # Arguments\n\n* `registeredOut` - Pointer to output the registration status to.\n * `name` - Name of the service to check."]
    pub fn srvIsServiceRegistered(registeredOut: *mut bool, name: *const ::libc::c_char) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Checks whether a port is registered.\n # Arguments\n\n* `registeredOut` - Pointer to output the registration status to.\n * `name` - Name of the port to check."]
    pub fn srvIsPortRegistered(registeredOut: *mut bool, name: *const ::libc::c_char) -> Result;
}
#[doc = "< Generic fatal error. Shows miscellaneous info, including the address of the caller"]
pub const ERRF_ERRTYPE_GENERIC: ERRF_ErrType = 0;
#[doc = "< Damaged NAND (CC_ERROR after reading CSR)"]
pub const ERRF_ERRTYPE_NAND_DAMAGED: ERRF_ErrType = 1;
#[doc = "< Game content storage medium (cartridge and/or SD card) ejected. Not logged"]
pub const ERRF_ERRTYPE_CARD_REMOVED: ERRF_ErrType = 2;
#[doc = "< CPU or VFP exception"]
pub const ERRF_ERRTYPE_EXCEPTION: ERRF_ErrType = 3;
#[doc = "< Fatal error with a message instead of the caller's address"]
pub const ERRF_ERRTYPE_FAILURE: ERRF_ErrType = 4;
#[doc = "< Log-level failure. Does not display the exception and does not force the system to reboot"]
pub const ERRF_ERRTYPE_LOG_ONLY: ERRF_ErrType = 5;
#[doc = "Types of errors that can be thrown by err:f."]
pub type ERRF_ErrType = ::libc::c_uint;
#[doc = "< Prefetch Abort"]
pub const ERRF_EXCEPTION_PREFETCH_ABORT: ERRF_ExceptionType = 0;
#[doc = "< Data abort"]
pub const ERRF_EXCEPTION_DATA_ABORT: ERRF_ExceptionType = 1;
#[doc = "< Undefined instruction"]
pub const ERRF_EXCEPTION_UNDEFINED: ERRF_ExceptionType = 2;
#[doc = "< VFP (floating point) exception."]
pub const ERRF_EXCEPTION_VFP: ERRF_ExceptionType = 3;
#[doc = "Types of 'Exceptions' thrown for ERRF_ERRTYPE_EXCEPTION"]
pub type ERRF_ExceptionType = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ERRF_ExceptionInfo {
    #[doc = "< Type of the exception. One of the ERRF_EXCEPTION_* values."]
    pub type_: ERRF_ExceptionType,
    pub reserved: [u8_; 3usize],
    #[doc = "< ifsr (prefetch abort) / dfsr (data abort)"]
    pub fsr: u32_,
    #[doc = "< pc = ifar (prefetch abort) / dfar (data abort)"]
    pub far: u32_,
    pub fpexc: u32_,
    pub fpinst: u32_,
    pub fpinst2: u32_,
}
impl Default for ERRF_ExceptionInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ERRF_ExceptionData {
    #[doc = "< Exception info struct"]
    pub excep: ERRF_ExceptionInfo,
    #[doc = "< CPU register dump."]
    pub regs: CpuRegisters,
}
impl Default for ERRF_ExceptionData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ERRF_FatalErrInfo {
    #[doc = "< Type, one of the ERRF_ERRTYPE_* enum"]
    pub type_: ERRF_ErrType,
    #[doc = "< High revison ID"]
    pub revHigh: u8_,
    #[doc = "< Low revision ID"]
    pub revLow: u16_,
    #[doc = "< Result code"]
    pub resCode: u32_,
    #[doc = "< PC address at exception"]
    pub pcAddr: u32_,
    #[doc = "< Process ID of the caller"]
    pub procId: u32_,
    #[doc = "< Title ID of the caller"]
    pub titleId: u64_,
    #[doc = "< Title ID of the running application"]
    pub appTitleId: u64_,
    #[doc = "< The different types of data for errors."]
    pub data: ERRF_FatalErrInfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ERRF_FatalErrInfo__bindgen_ty_1 {
    #[doc = "< Data for when type is ERRF_ERRTYPE_EXCEPTION"]
    pub exception_data: ERRF_ExceptionData,
    #[doc = "< String for when type is ERRF_ERRTYPE_FAILURE"]
    pub failure_mesg: [::libc::c_char; 96usize],
}
impl Default for ERRF_FatalErrInfo__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for ERRF_FatalErrInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[must_use]
    #[doc = "Initializes ERR:f. Unless you plan to call ERRF_Throw yourself, do not use this."]
    pub fn errfInit() -> Result;
}
extern "C" {
    #[doc = "Exits ERR:f. Unless you plan to call ERRF_Throw yourself, do not use this."]
    pub fn errfExit();
}
extern "C" {
    #[doc = "Gets the current err:f API session handle.\n # Returns\n\nThe current err:f API session handle."]
    pub fn errfGetSessionHandle() -> *mut Handle;
}
extern "C" {
    #[must_use]
    #[doc = "Throws a system error and possibly logs it.\n # Arguments\n\n* `error` (direction in) - Error to throw.\n\n ErrDisp may convert the error info to ERRF_ERRTYPE_NAND_DAMAGED or ERRF_ERRTYPE_CARD_REMOVED\n depending on the error code.\n\n Except with ERRF_ERRTYPE_LOG_ONLY, the system will panic and will need to be rebooted.\n Fatal error information will also be logged into a file, unless the type either ERRF_ERRTYPE_NAND_DAMAGED\n or ERRF_ERRTYPE_CARD_REMOVED.\n\n No error will be shown if the system is asleep.\n\n On retail units with vanilla firmware, no detailed information will be displayed on screen.\n\n You may wish to use ERRF_ThrowResult() or ERRF_ThrowResultWithMessage() instead of\n constructing the ERRF_FatalErrInfo struct yourself."]
    pub fn ERRF_Throw(error: *const ERRF_FatalErrInfo) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Throws (and logs) a system error with the given Result code.\n # Arguments\n\n* `failure` (direction in) - Result code to throw.\n\n This calls ERRF_Throw with error type ERRF_ERRTYPE_GENERIC and fills in the required data.\n\n This function _does_ fill in the address where this function was called from."]
    pub fn ERRF_ThrowResult(failure: Result) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Logs a system error with the given Result code.\n # Arguments\n\n* `failure` (direction in) - Result code to log.\n\n Similar to ERRF_Throw, except that it does not display anything on the screen,\n nor does it force the system to reboot.\n\n This function _does_ fill in the address where this function was called from."]
    pub fn ERRF_LogResult(failure: Result) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Throws a system error with the given Result code and message.\n # Arguments\n\n* `failure` (direction in) - Result code to throw.\n * `message` (direction in) - The message to display.\n\n This calls ERRF_Throw with error type ERRF_ERRTYPE_FAILURE and fills in the required data.\n\n This function does _not_ fill in the address where this function was called from because it\n would not be displayed."]
    pub fn ERRF_ThrowResultWithMessage(failure: Result, message: *const ::libc::c_char) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Specify an additional user string to use for error reporting.\n # Arguments\n\n* `user_string` (direction in) - User string (up to 256 bytes, not including NUL byte)"]
    pub fn ERRF_SetUserString(user_string: *const ::libc::c_char) -> Result;
}
extern "C" {
    #[doc = "Handles an exception using ErrDisp.\n # Arguments\n\n* `excep` - Exception information\n * `regs` - CPU registers\n\n You might want to clear ENVINFO's bit0 to be able to see any debugging information.\n [`threadOnException`]"]
    pub fn ERRF_ExceptionHandler(excep: *mut ERRF_ExceptionInfo, regs: *mut CpuRegisters) -> !;
}
#[doc = "Kernel configuration page (read-only)."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct osKernelConfig_s {
    pub kernel_ver: u32_,
    pub update_flag: u32_,
    pub ns_tid: u64_,
    pub kernel_syscore_ver: u32_,
    pub env_info: u8_,
    pub unit_info: u8_,
    pub boot_env: u8_,
    pub unk_0x17: u8_,
    pub kernel_ctrsdk_ver: u32_,
    pub unk_0x1c: u32_,
    pub firmlaunch_flags: u32_,
    pub unk_0x24: [u8_; 12usize],
    pub app_memtype: u32_,
    pub unk_0x34: [u8_; 12usize],
    pub memregion_sz: [u32_; 3usize],
    pub unk_0x4c: [u8_; 20usize],
    pub firm_ver: u32_,
    pub firm_syscore_ver: u32_,
    pub firm_ctrsdk_ver: u32_,
}
#[doc = "Time reference information struct (filled in by PTM)."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct osTimeRef_s {
    #[doc = "< Milliseconds elapsed since January 1900 when this structure was last updated"]
    pub value_ms: u64_,
    #[doc = "< System ticks elapsed since boot when this structure was last updated"]
    pub value_tick: u64_,
    #[doc = "< System clock frequency in Hz adjusted using RTC measurements (usually around SYSCLOCK_ARM11)"]
    pub sysclock_hz: s64,
    #[doc = "< Measured time drift of the system clock (according to the RTC) in milliseconds since the last update"]
    pub drift_ms: s64,
}
#[doc = "Shared system configuration page structure (read-only or read-write depending on exheader)."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct osSharedConfig_s {
    pub timeref_cnt: vu32,
    pub running_hw: u8_,
    pub mcu_hwinfo: u8_,
    pub unk_0x06: [u8_; 26usize],
    pub timeref: [osTimeRef_s; 2usize],
    pub wifi_macaddr: [u8_; 6usize],
    pub wifi_strength: vu8,
    pub network_state: vu8,
    pub unk_0x68: [u8_; 24usize],
    pub slider_3d: f32,
    pub led_3d: vu8,
    pub led_battery: vu8,
    pub unk_flag: vu8,
    pub unk_0x87: u8_,
    pub unk_0x88: [u8_; 24usize],
    pub menu_tid: vu64,
    pub cur_menu_tid: vu64,
    pub unk_0xB0: [u8_; 16usize],
    pub headset_connected: vu8,
}
#[doc = "Tick counter."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TickCounter {
    #[doc = "< Elapsed CPU ticks between measurements."]
    pub elapsed: u64_,
    #[doc = "< Point in time used as reference."]
    pub reference: u64_,
}
#[doc = "OS_VersionBin. Format of the system version: \"<major>.<minor>.<build>-<nupver><region>\""]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct OS_VersionBin {
    pub build: u8_,
    pub minor: u8_,
    pub mainver: u8_,
    pub reserved_x3: u8_,
    pub region: ::libc::c_char,
    pub reserved_x5: [u8_; 3usize],
}
extern "C" {
    #[doc = "Converts an address from virtual (process) memory to physical memory.\n # Arguments\n\n* `vaddr` - Input virtual address.\n # Returns\n\nThe corresponding physical address.\n It is sometimes required by services or when using the GPU command buffer."]
    pub fn osConvertVirtToPhys(vaddr: *const ::libc::c_void) -> u32_;
}
extern "C" {
    #[doc = "Converts 0x14* vmem to 0x30*.\n # Arguments\n\n* `vaddr` - Input virtual address.\n # Returns\n\nThe corresponding address in the 0x30* range, the input address if it's already within the new vmem, or 0 if it's outside of both ranges."]
    pub fn osConvertOldLINEARMemToNew(vaddr: *const ::libc::c_void) -> *mut ::libc::c_void;
}
extern "C" {
    #[doc = "Retrieves basic information about a service error.\n # Arguments\n\n* `error` - Error to retrieve information about.\n # Returns\n\nA string containing a summary of an error.\n\n This can be used to get some details about an error returned by a service call."]
    pub fn osStrError(error: Result) -> *const ::libc::c_char;
}
extern "C" {
    #[doc = "Gets the system's FIRM version.\n # Returns\n\nThe system's FIRM version.\n\n This can be used to compare system versions easily with SYSTEM_VERSION."]
    #[link_name = "osGetFirmVersion__extern"]
    pub fn osGetFirmVersion() -> u32_;
}
extern "C" {
    #[doc = "Gets the system's kernel version.\n # Returns\n\nThe system's kernel version.\n\n This can be used to compare system versions easily with SYSTEM_VERSION.\n\n if(osGetKernelVersion() > SYSTEM_VERSION(2,46,0)) printf(\"You are running 9.0 or higher"]
    #[link_name = "osGetKernelVersion__extern"]
    pub fn osGetKernelVersion() -> u32_;
}
extern "C" {
    #[doc = "Gets the system's \"core version\" (2 on NATIVE_FIRM, 3 on SAFE_FIRM, etc.)"]
    #[link_name = "osGetSystemCoreVersion__extern"]
    pub fn osGetSystemCoreVersion() -> u32_;
}
extern "C" {
    #[doc = "Gets the system's memory layout ID (0-5 on Old 3DS, 6-8 on New 3DS)"]
    #[link_name = "osGetApplicationMemType__extern"]
    pub fn osGetApplicationMemType() -> u32_;
}
extern "C" {
    #[doc = "Gets the size of the specified memory region.\n # Arguments\n\n* `region` - Memory region to check.\n # Returns\n\nThe size of the memory region, in bytes."]
    #[link_name = "osGetMemRegionSize__extern"]
    pub fn osGetMemRegionSize(region: MemRegion) -> u32_;
}
extern "C" {
    #[doc = "Gets the number of used bytes within the specified memory region.\n # Arguments\n\n* `region` - Memory region to check.\n # Returns\n\nThe number of used bytes of memory."]
    #[link_name = "osGetMemRegionUsed__extern"]
    pub fn osGetMemRegionUsed(region: MemRegion) -> u32_;
}
extern "C" {
    #[doc = "Gets the number of free bytes within the specified memory region.\n # Arguments\n\n* `region` - Memory region to check.\n # Returns\n\nThe number of free bytes of memory."]
    #[link_name = "osGetMemRegionFree__extern"]
    pub fn osGetMemRegionFree(region: MemRegion) -> u32_;
}
extern "C" {
    #[doc = "Reads the latest reference timepoint published by PTM.\n # Returns\n\nStructure (see osTimeRef_s)."]
    pub fn osGetTimeRef() -> osTimeRef_s;
}
extern "C" {
    #[doc = "Gets the current time.\n # Returns\n\nThe number of milliseconds since 1st Jan 1900 00:00."]
    pub fn osGetTime() -> u64_;
}
extern "C" {
    #[doc = "Starts a tick counter.\n # Arguments\n\n* `cnt` - The tick counter."]
    #[link_name = "osTickCounterStart__extern"]
    pub fn osTickCounterStart(cnt: *mut TickCounter);
}
extern "C" {
    #[doc = "Updates the elapsed time in a tick counter.\n # Arguments\n\n* `cnt` - The tick counter."]
    #[link_name = "osTickCounterUpdate__extern"]
    pub fn osTickCounterUpdate(cnt: *mut TickCounter);
}
extern "C" {
    #[doc = "Reads the elapsed time in a tick counter.\n # Arguments\n\n* `cnt` - The tick counter.\n # Returns\n\nThe number of milliseconds elapsed."]
    pub fn osTickCounterRead(cnt: *const TickCounter) -> f64;
}
extern "C" {
    #[doc = "Gets the current Wifi signal strength.\n # Returns\n\nThe current Wifi signal strength.\n\n Valid values are 0-3:\n - 0 means the signal strength is terrible or the 3DS is disconnected from\n all networks.\n - 1 means the signal strength is bad.\n - 2 means the signal strength is decent.\n - 3 means the signal strength is good.\n\n Values outside the range of 0-3 should never be returned.\n\n These values correspond with the number of wifi bars displayed by Home Menu."]
    #[link_name = "osGetWifiStrength__extern"]
    pub fn osGetWifiStrength() -> u8_;
}
extern "C" {
    #[doc = "Gets the state of the 3D slider.\n # Returns\n\nThe state of the 3D slider (0.0~1.0)"]
    #[link_name = "osGet3DSliderState__extern"]
    pub fn osGet3DSliderState() -> f32;
}
extern "C" {
    #[doc = "Checks whether a headset is connected.\n # Returns\n\ntrue or false."]
    #[link_name = "osIsHeadsetConnected__extern"]
    pub fn osIsHeadsetConnected() -> bool;
}
extern "C" {
    #[doc = "Configures the New 3DS speedup.\n # Arguments\n\n* `enable` - Specifies whether to enable or disable the speedup."]
    pub fn osSetSpeedupEnable(enable: bool);
}
extern "C" {
    #[must_use]
    #[doc = "Gets the NAND system-version stored in NVer/CVer.\n # Arguments\n\n* `nver_versionbin` - Output OS_VersionBin structure for the data read from NVer.\n * `cver_versionbin` - Output OS_VersionBin structure for the data read from CVer.\n # Returns\n\nThe result-code. This value can be positive if opening \"romfs:/version.bin\" fails with stdio, since errno would be returned in that case. In some cases the error can be special negative values as well."]
    pub fn osGetSystemVersionData(
        nver_versionbin: *mut OS_VersionBin,
        cver_versionbin: *mut OS_VersionBin,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "This is a wrapper for osGetSystemVersionData.\n # Arguments\n\n* `nver_versionbin` - Optional output OS_VersionBin structure for the data read from NVer, can be NULL.\n * `cver_versionbin` - Optional output OS_VersionBin structure for the data read from CVer, can be NULL.\n * `sysverstr` - Output string where the printed system-version will be written, in the same format displayed by the System Settings title.\n * `sysverstr_maxsize` - Max size of the above string buffer, *including* NULL-terminator.\n # Returns\n\nSee osGetSystemVersionData."]
    pub fn osGetSystemVersionDataString(
        nver_versionbin: *mut OS_VersionBin,
        cver_versionbin: *mut OS_VersionBin,
        sysverstr: *mut ::libc::c_char,
        sysverstr_maxsize: u32_,
    ) -> Result;
}
pub type _LOCK_T = i32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __lock_t {
    pub lock: _LOCK_T,
    pub thread_tag: u32,
    pub counter: u32,
}
pub type _LOCK_RECURSIVE_T = __lock_t;
pub type _COND_T = u32;
extern "C" {
    #[link_name = "__libc_lock_init__extern"]
    pub fn __libc_lock_init(lock: *mut _LOCK_T);
}
extern "C" {
    #[link_name = "__libc_lock_close__extern"]
    pub fn __libc_lock_close(lock: *mut _LOCK_T);
}
extern "C" {
    #[link_name = "__libc_lock_init_recursive__extern"]
    pub fn __libc_lock_init_recursive(lock: *mut _LOCK_RECURSIVE_T);
}
extern "C" {
    #[link_name = "__libc_lock_close_recursive__extern"]
    pub fn __libc_lock_close_recursive(lock: *mut _LOCK_RECURSIVE_T);
}
extern "C" {
    pub fn __libc_lock_acquire(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __libc_lock_acquire_recursive(lock: *mut _LOCK_RECURSIVE_T);
}
extern "C" {
    pub fn __libc_lock_release(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __libc_lock_release_recursive(lock: *mut _LOCK_RECURSIVE_T);
}
extern "C" {
    pub fn __libc_lock_try_acquire(lock: *mut _LOCK_T) -> ::libc::c_int;
}
extern "C" {
    pub fn __libc_lock_try_acquire_recursive(lock: *mut _LOCK_RECURSIVE_T) -> ::libc::c_int;
}
extern "C" {
    #[link_name = "__libc_cond_init__extern"]
    pub fn __libc_cond_init(cond: *mut _COND_T) -> ::libc::c_int;
}
extern "C" {
    pub fn __libc_cond_signal(cond: *mut _COND_T) -> ::libc::c_int;
}
extern "C" {
    pub fn __libc_cond_broadcast(cond: *mut _COND_T) -> ::libc::c_int;
}
extern "C" {
    pub fn __libc_cond_wait(
        cond: *mut _COND_T,
        lock: *mut _LOCK_T,
        timeout_ns: u64,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn __libc_cond_wait_recursive(
        cond: *mut _COND_T,
        lock: *mut _LOCK_RECURSIVE_T,
        timeout_ns: u64,
    ) -> ::libc::c_int;
}
#[doc = "A light lock."]
pub type LightLock = _LOCK_T;
#[doc = "A recursive lock."]
pub type RecursiveLock = _LOCK_RECURSIVE_T;
#[doc = "A condition variable."]
pub type CondVar = s32;
#[doc = "A light event."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct LightEvent {
    #[doc = "< State of the event: -2=cleared sticky, -1=cleared oneshot, 0=signaled oneshot, 1=signaled sticky"]
    pub state: s32,
    #[doc = "< Lock used for sticky timer operation"]
    pub lock: LightLock,
}
#[doc = "A light semaphore."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct LightSemaphore {
    #[doc = "< The current release count of the semaphore"]
    pub current_count: s32,
    #[doc = "< Number of threads concurrently acquiring the semaphore"]
    pub num_threads_acq: s16,
    #[doc = "< The maximum release count of the semaphore"]
    pub max_count: s16,
}
extern "C" {
    #[doc = "Performs a Data Synchronization Barrier operation."]
    #[link_name = "__dsb__extern"]
    pub fn __dsb();
}
extern "C" {
    #[doc = "Performs a Data Memory Barrier operation."]
    #[link_name = "__dmb__extern"]
    pub fn __dmb();
}
extern "C" {
    #[doc = "Performs a clrex operation."]
    #[link_name = "__clrex__extern"]
    pub fn __clrex();
}
extern "C" {
    #[doc = "Performs a ldrex operation.\n # Arguments\n\n* `addr` - Address to perform the operation on.\n # Returns\n\nThe resulting value."]
    #[link_name = "__ldrex__extern"]
    pub fn __ldrex(addr: *mut s32) -> s32;
}
extern "C" {
    #[doc = "Performs a strex operation.\n # Arguments\n\n* `addr` - Address to perform the operation on.\n * `val` - Value to store.\n # Returns\n\nWhether the operation was successful."]
    #[link_name = "__strex__extern"]
    pub fn __strex(addr: *mut s32, val: s32) -> bool;
}
extern "C" {
    #[doc = "Performs a ldrexh operation.\n # Arguments\n\n* `addr` - Address to perform the operation on.\n # Returns\n\nThe resulting value."]
    #[link_name = "__ldrexh__extern"]
    pub fn __ldrexh(addr: *mut u16_) -> u16_;
}
extern "C" {
    #[doc = "Performs a strexh operation.\n # Arguments\n\n* `addr` - Address to perform the operation on.\n * `val` - Value to store.\n # Returns\n\nWhether the operation was successful."]
    #[link_name = "__strexh__extern"]
    pub fn __strexh(addr: *mut u16_, val: u16_) -> bool;
}
extern "C" {
    #[doc = "Performs a ldrexb operation.\n # Arguments\n\n* `addr` - Address to perform the operation on.\n # Returns\n\nThe resulting value."]
    #[link_name = "__ldrexb__extern"]
    pub fn __ldrexb(addr: *mut u8_) -> u8_;
}
extern "C" {
    #[doc = "Performs a strexb operation.\n # Arguments\n\n* `addr` - Address to perform the operation on.\n * `val` - Value to store.\n # Returns\n\nWhether the operation was successful."]
    #[link_name = "__strexb__extern"]
    pub fn __strexb(addr: *mut u8_, val: u8_) -> bool;
}
extern "C" {
    #[must_use]
    #[doc = "Function used to implement user-mode synchronization primitives.\n # Arguments\n\n* `addr` - Pointer to a signed 32-bit value whose address will be used to identify waiting threads.\n * `type` - Type of action to be performed by the arbiter\n * `value` - Number of threads to signal if using ARBITRATION_SIGNAL, or the value used for comparison.\n\n This will perform an arbitration based on #type. The comparisons are done between #value and the value at the address #addr.\n\n s32 val=0;\n // Does *nothing* since val >= 0\n syncArbitrateAddress(&val,ARBITRATION_WAIT_IF_LESS_THAN,0);\n > **Note:** Usage of this function entails an implicit Data Memory Barrier (dmb)."]
    pub fn syncArbitrateAddress(addr: *mut s32, type_: ArbitrationType, value: s32) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Function used to implement user-mode synchronization primitives (with timeout).\n # Arguments\n\n* `addr` - Pointer to a signed 32-bit value whose address will be used to identify waiting threads.\n * `type` - Type of action to be performed by the arbiter (must use ARBITRATION_WAIT_IF_LESS_THAN_TIMEOUT or ARBITRATION_DECREMENT_AND_WAIT_IF_LESS_THAN_TIMEOUT)\n * `value` - Number of threads to signal if using ARBITRATION_SIGNAL, or the value used for comparison.\n\n This will perform an arbitration based on #type. The comparisons are done between #value and the value at the address #addr.\n\n s32 val=0;\n // Thread will wait for a signal or wake up after 10000000 nanoseconds because val < 1.\n syncArbitrateAddressWithTimeout(&val,ARBITRATION_WAIT_IF_LESS_THAN_TIMEOUT,1,10000000LL);\n > **Note:** Usage of this function entails an implicit Data Memory Barrier (dmb)."]
    pub fn syncArbitrateAddressWithTimeout(
        addr: *mut s32,
        type_: ArbitrationType,
        value: s32,
        timeout_ns: s64,
    ) -> Result;
}
extern "C" {
    #[doc = "Initializes a light lock.\n # Arguments\n\n* `lock` - Pointer to the lock."]
    pub fn LightLock_Init(lock: *mut LightLock);
}
extern "C" {
    #[doc = "Locks a light lock.\n # Arguments\n\n* `lock` - Pointer to the lock."]
    pub fn LightLock_Lock(lock: *mut LightLock);
}
extern "C" {
    #[doc = "Attempts to lock a light lock.\n # Arguments\n\n* `lock` - Pointer to the lock.\n # Returns\n\nZero on success, non-zero on failure."]
    pub fn LightLock_TryLock(lock: *mut LightLock) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Unlocks a light lock.\n # Arguments\n\n* `lock` - Pointer to the lock."]
    pub fn LightLock_Unlock(lock: *mut LightLock);
}
extern "C" {
    #[doc = "Initializes a recursive lock.\n # Arguments\n\n* `lock` - Pointer to the lock."]
    pub fn RecursiveLock_Init(lock: *mut RecursiveLock);
}
extern "C" {
    #[doc = "Locks a recursive lock.\n # Arguments\n\n* `lock` - Pointer to the lock."]
    pub fn RecursiveLock_Lock(lock: *mut RecursiveLock);
}
extern "C" {
    #[doc = "Attempts to lock a recursive lock.\n # Arguments\n\n* `lock` - Pointer to the lock.\n # Returns\n\nZero on success, non-zero on failure."]
    pub fn RecursiveLock_TryLock(lock: *mut RecursiveLock) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Unlocks a recursive lock.\n # Arguments\n\n* `lock` - Pointer to the lock."]
    pub fn RecursiveLock_Unlock(lock: *mut RecursiveLock);
}
extern "C" {
    #[doc = "Initializes a condition variable.\n # Arguments\n\n* `cv` - Pointer to the condition variable."]
    pub fn CondVar_Init(cv: *mut CondVar);
}
extern "C" {
    #[doc = "Waits on a condition variable.\n # Arguments\n\n* `cv` - Pointer to the condition variable.\n * `lock` - Pointer to the lock to atomically unlock/relock during the wait."]
    pub fn CondVar_Wait(cv: *mut CondVar, lock: *mut LightLock);
}
extern "C" {
    #[doc = "Waits on a condition variable with a timeout.\n # Arguments\n\n* `cv` - Pointer to the condition variable.\n * `lock` - Pointer to the lock to atomically unlock/relock during the wait.\n * `timeout_ns` - Timeout in nanoseconds.\n # Returns\n\nZero on success, non-zero on failure."]
    pub fn CondVar_WaitTimeout(
        cv: *mut CondVar,
        lock: *mut LightLock,
        timeout_ns: s64,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Wakes up threads waiting on a condition variable.\n # Arguments\n\n* `cv` - Pointer to the condition variable.\n * `num_threads` - Maximum number of threads to wake up (or ARBITRATION_SIGNAL_ALL to wake them all)."]
    pub fn CondVar_WakeUp(cv: *mut CondVar, num_threads: s32);
}
extern "C" {
    #[doc = "Wakes up a single thread waiting on a condition variable.\n # Arguments\n\n* `cv` - Pointer to the condition variable."]
    #[link_name = "CondVar_Signal__extern"]
    pub fn CondVar_Signal(cv: *mut CondVar);
}
extern "C" {
    #[doc = "Wakes up all threads waiting on a condition variable.\n # Arguments\n\n* `cv` - Pointer to the condition variable."]
    #[link_name = "CondVar_Broadcast__extern"]
    pub fn CondVar_Broadcast(cv: *mut CondVar);
}
extern "C" {
    #[doc = "Initializes a light event.\n # Arguments\n\n* `event` - Pointer to the event.\n * `reset_type` - Type of reset the event uses (RESET_ONESHOT/RESET_STICKY)."]
    pub fn LightEvent_Init(event: *mut LightEvent, reset_type: ResetType);
}
extern "C" {
    #[doc = "Clears a light event.\n # Arguments\n\n* `event` - Pointer to the event."]
    pub fn LightEvent_Clear(event: *mut LightEvent);
}
extern "C" {
    #[doc = "Wakes up threads waiting on a sticky light event without signaling it. If the event had been signaled before, it is cleared instead.\n # Arguments\n\n* `event` - Pointer to the event."]
    pub fn LightEvent_Pulse(event: *mut LightEvent);
}
extern "C" {
    #[doc = "Signals a light event, waking up threads waiting on it.\n # Arguments\n\n* `event` - Pointer to the event."]
    pub fn LightEvent_Signal(event: *mut LightEvent);
}
extern "C" {
    #[doc = "Attempts to wait on a light event.\n # Arguments\n\n* `event` - Pointer to the event.\n # Returns\n\nNon-zero if the event was signaled, zero otherwise."]
    pub fn LightEvent_TryWait(event: *mut LightEvent) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Waits on a light event.\n # Arguments\n\n* `event` - Pointer to the event."]
    pub fn LightEvent_Wait(event: *mut LightEvent);
}
extern "C" {
    #[doc = "Waits on a light event until either the event is signaled or the timeout is reached.\n # Arguments\n\n* `event` - Pointer to the event.\n * `timeout_ns` - Timeout in nanoseconds.\n # Returns\n\nNon-zero on timeout, zero otherwise."]
    pub fn LightEvent_WaitTimeout(event: *mut LightEvent, timeout_ns: s64) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Initializes a light semaphore.\n # Arguments\n\n* `event` - Pointer to the semaphore.\n * `max_count` - Initial count of the semaphore.\n * `max_count` - Maximum count of the semaphore."]
    pub fn LightSemaphore_Init(semaphore: *mut LightSemaphore, initial_count: s16, max_count: s16);
}
extern "C" {
    #[doc = "Acquires a light semaphore.\n # Arguments\n\n* `semaphore` - Pointer to the semaphore.\n * `count` - Acquire count"]
    pub fn LightSemaphore_Acquire(semaphore: *mut LightSemaphore, count: s32);
}
extern "C" {
    #[doc = "Attempts to acquire a light semaphore.\n # Arguments\n\n* `semaphore` - Pointer to the semaphore.\n * `count` - Acquire count\n # Returns\n\nZero on success, non-zero on failure"]
    pub fn LightSemaphore_TryAcquire(semaphore: *mut LightSemaphore, count: s32) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Releases a light semaphore.\n # Arguments\n\n* `semaphore` - Pointer to the semaphore.\n * `count` - Release count"]
    pub fn LightSemaphore_Release(semaphore: *mut LightSemaphore, count: s32);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Thread_tag {
    _unused: [u8; 0],
}
#[doc = "libctru thread handle type"]
pub type Thread = *mut Thread_tag;
#[doc = "Exception handler type, necessarily an ARM function that does not return."]
pub type ExceptionHandler = ::core::option::Option<
    unsafe extern "C" fn(excep: *mut ERRF_ExceptionInfo, regs: *mut CpuRegisters),
>;
extern "C" {
    #[doc = "Creates a new libctru thread.\n # Arguments\n\n* `entrypoint` - The function that will be called first upon thread creation\n * `arg` - The argument passed to `entrypoint`\n * `stack_size` - The size of the stack that will be allocated for the thread (will be rounded to a multiple of 8 bytes)\n * `prio` - Low values gives the thread higher priority.\n For userland apps, this has to be within the range [0x18;0x3F].\n The main thread usually has a priority of 0x30, but not always. Use svcGetThreadPriority() if you need\n to create a thread with a priority that is explicitly greater or smaller than that of the main thread.\n * `core_id` - The ID of the processor the thread should be ran on. Processor IDs are labeled starting from 0.\n On Old3DS it must be <2, and on New3DS it must be <4.\n Pass -1 to execute the thread on all CPUs and -2 to execute the thread on the default CPU (read from the Exheader).\n * `detached` - When set to true, the thread is automatically freed when it finishes.\n # Returns\n\nThe libctru thread handle on success, NULL on failure.\n\n - Processor #0 is the application core. It is always possible to create a thread on this core.\n - Processor #1 is the system core. If APT_SetAppCpuTimeLimit is used, it is possible to create a single thread on this core.\n - Processor #2 is New3DS exclusive. Normal applications can create threads on this core if the exheader kernel flags bitmask has 0x2000 set.\n - Processor #3 is New3DS exclusive. Normal applications cannot create threads on this core.\n - Processes in the BASE memory region can always create threads on processors #2 and #3.\n\n > **Note:** Default exit code of a thread is 0.\n svcExitThread should never be called from the thread, use threadExit instead."]
    pub fn threadCreate(
        entrypoint: ThreadFunc,
        arg: *mut ::libc::c_void,
        stack_size: usize,
        prio: ::libc::c_int,
        core_id: ::libc::c_int,
        detached: bool,
    ) -> Thread;
}
extern "C" {
    #[doc = "Retrieves the OS thread handle of a libctru thread.\n # Arguments\n\n* `thread` - libctru thread handle\n # Returns\n\nOS thread handle"]
    pub fn threadGetHandle(thread: Thread) -> Handle;
}
extern "C" {
    #[doc = "Retrieves the exit code of a finished libctru thread.\n # Arguments\n\n* `thread` - libctru thread handle\n # Returns\n\nExit code"]
    pub fn threadGetExitCode(thread: Thread) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Frees a finished libctru thread.\n # Arguments\n\n* `thread` - libctru thread handle\n > This function should not be called if the thread is detached, as it is freed automatically when it finishes."]
    pub fn threadFree(thread: Thread);
}
extern "C" {
    #[must_use]
    #[doc = "Waits for a libctru thread to finish (or returns immediately if it is already finished).\n # Arguments\n\n* `thread` - libctru thread handle\n * `timeout_ns` - Timeout in nanoseconds. Pass U64_MAX if a timeout isn't desired"]
    pub fn threadJoin(thread: Thread, timeout_ns: u64_) -> Result;
}
extern "C" {
    #[doc = "Changes a thread's status from attached to detached.\n # Arguments\n\n* `thread` - libctru thread handle"]
    pub fn threadDetach(thread: Thread);
}
extern "C" {
    #[doc = "Retrieves the libctru thread handle of the current thread.\n # Returns\n\nlibctru thread handle of the current thread, or NULL for the main thread"]
    pub fn threadGetCurrent() -> Thread;
}
extern "C" {
    #[doc = "Exits the current libctru thread with an exit code (not usable from the main thread).\n # Arguments\n\n* `rc` - Exit code"]
    pub fn threadExit(rc: ::libc::c_int) -> !;
}
extern "C" {
    #[doc = "Sets the exception handler for the current thread. Called from the main thread, this sets the default handler.\n # Arguments\n\n* `handler` - The exception handler, necessarily an ARM function that does not return\n * `stack_top` - A pointer to the top of the stack that will be used by the handler. See also RUN_HANDLER_ON_FAULTING_STACK\n * `exception_data` - A pointer to the buffer that will contain the exception data.\nSee also WRITE_DATA_TO_HANDLER_STACK and WRITE_DATA_TO_FAULTING_STACK\n\n To have CPU exceptions reported through this mechanism, it is normally necessary that UNITINFO is set to a non-zero value when Kernel11 starts,\n and this mechanism is also controlled by svcKernelSetState type 6, see 3dbrew.\n\n VFP exceptions are always reported this way even if the process is being debugged using the debug SVCs.\n\n The current thread need not be a libctru thread."]
    #[link_name = "threadOnException__extern"]
    pub fn threadOnException(
        handler: ExceptionHandler,
        stack_top: *mut ::libc::c_void,
        exception_data: *mut ERRF_ExceptionData,
    );
}
#[doc = "Framebuffer information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GSPGPU_FramebufferInfo {
    #[doc = "< Active framebuffer. (0 = first, 1 = second)"]
    pub active_framebuf: u32_,
    #[doc = "< Framebuffer virtual address, for the main screen this is the 3D left framebuffer."]
    pub framebuf0_vaddr: *mut u32_,
    #[doc = "< For the main screen: 3D right framebuffer address."]
    pub framebuf1_vaddr: *mut u32_,
    #[doc = "< Value for 0x1EF00X90, controls framebuffer width."]
    pub framebuf_widthbytesize: u32_,
    #[doc = "< Framebuffer format, this u16 is written to the low u16 for LCD register 0x1EF00X70."]
    pub format: u32_,
    #[doc = "< Value for 0x1EF00X78, controls which framebuffer is displayed."]
    pub framebuf_dispselect: u32_,
    #[doc = "< Unknown."]
    pub unk: u32_,
}
impl Default for GSPGPU_FramebufferInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "< RGBA8. (4 bytes)"]
pub const GSP_RGBA8_OES: GSPGPU_FramebufferFormat = 0;
#[doc = "< BGR8. (3 bytes)"]
pub const GSP_BGR8_OES: GSPGPU_FramebufferFormat = 1;
#[doc = "< RGB565. (2 bytes)"]
pub const GSP_RGB565_OES: GSPGPU_FramebufferFormat = 2;
#[doc = "< RGB5A1. (2 bytes)"]
pub const GSP_RGB5_A1_OES: GSPGPU_FramebufferFormat = 3;
#[doc = "< RGBA4. (2 bytes)"]
pub const GSP_RGBA4_OES: GSPGPU_FramebufferFormat = 4;
#[doc = "Framebuffer format."]
pub type GSPGPU_FramebufferFormat = ::libc::c_uint;
#[doc = "Capture info entry."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GSPGPU_CaptureInfoEntry {
    #[doc = "< Left framebuffer."]
    pub framebuf0_vaddr: *mut u32_,
    #[doc = "< Right framebuffer."]
    pub framebuf1_vaddr: *mut u32_,
    #[doc = "< Framebuffer format."]
    pub format: u32_,
    #[doc = "< Framebuffer pitch."]
    pub framebuf_widthbytesize: u32_,
}
impl Default for GSPGPU_CaptureInfoEntry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Capture info."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GSPGPU_CaptureInfo {
    #[doc = "< Capture info entries, one for each screen."]
    pub screencapture: [GSPGPU_CaptureInfoEntry; 2usize],
}
impl Default for GSPGPU_CaptureInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "< Memory fill completed."]
pub const GSPGPU_EVENT_PSC0: GSPGPU_Event = 0;
#[doc = "< TODO"]
pub const GSPGPU_EVENT_PSC1: GSPGPU_Event = 1;
#[doc = "< TODO"]
pub const GSPGPU_EVENT_VBlank0: GSPGPU_Event = 2;
#[doc = "< TODO"]
pub const GSPGPU_EVENT_VBlank1: GSPGPU_Event = 3;
#[doc = "< Display transfer finished."]
pub const GSPGPU_EVENT_PPF: GSPGPU_Event = 4;
#[doc = "< Command list processing finished."]
pub const GSPGPU_EVENT_P3D: GSPGPU_Event = 5;
#[doc = "< TODO"]
pub const GSPGPU_EVENT_DMA: GSPGPU_Event = 6;
#[doc = "< Used to know how many events there are."]
pub const GSPGPU_EVENT_MAX: GSPGPU_Event = 7;
#[doc = "GSPGPU events."]
pub type GSPGPU_Event = ::libc::c_uint;
extern "C" {
    #[doc = "Gets the number of bytes per pixel for the specified format.\n # Arguments\n\n* `format` - See GSPGPU_FramebufferFormat.\n # Returns\n\nBytes per pixel."]
    #[link_name = "gspGetBytesPerPixel__extern"]
    pub fn gspGetBytesPerPixel(format: GSPGPU_FramebufferFormat) -> ::libc::c_uint;
}
extern "C" {
    #[must_use]
    #[doc = "Initializes GSPGPU."]
    pub fn gspInit() -> Result;
}
extern "C" {
    #[doc = "Exits GSPGPU."]
    pub fn gspExit();
}
extern "C" {
    #[doc = "Gets a pointer to the current gsp::Gpu session handle.\n # Returns\n\nA pointer to the current gsp::Gpu session handle."]
    pub fn gspGetSessionHandle() -> *mut Handle;
}
extern "C" {
    #[doc = "Returns true if the application currently has GPU rights."]
    pub fn gspHasGpuRight() -> bool;
}
extern "C" {
    #[doc = "Presents a buffer to the specified screen.\n # Arguments\n\n* `screen` - Screen ID (see GSP_SCREEN_TOP and GSP_SCREEN_BOTTOM)\n * `swap` - Specifies which set of framebuffer registers to configure and activate (0 or 1)\n * `fb_a` - Pointer to the framebuffer (in stereo mode: left eye)\n * `fb_b` - Pointer to the secondary framebuffer (only used in stereo mode for the right eye, otherwise pass the same as fb_a)\n * `stride` - Stride in bytes between scanlines\n * `mode` - Mode configuration to be written to LCD register\n # Returns\n\ntrue if a buffer had already been presented to the screen but not processed yet by GSP, false otherwise.\n > **Note:** The most recently presented buffer is processed and configured during the specified screen's next VBlank event."]
    pub fn gspPresentBuffer(
        screen: ::libc::c_uint,
        swap: ::libc::c_uint,
        fb_a: *const ::libc::c_void,
        fb_b: *const ::libc::c_void,
        stride: u32_,
        mode: u32_,
    ) -> bool;
}
extern "C" {
    #[doc = "Returns true if a prior gspPresentBuffer command is still pending to be processed by GSP.\n # Arguments\n\n* `screen` - Screen ID (see GSP_SCREEN_TOP and GSP_SCREEN_BOTTOM)"]
    pub fn gspIsPresentPending(screen: ::libc::c_uint) -> bool;
}
extern "C" {
    #[doc = "Configures a callback to run when a GSPGPU event occurs.\n # Arguments\n\n* `id` - ID of the event.\n * `cb` - Callback to run.\n * `data` - Data to be passed to the callback.\n * `oneShot` - When true, the callback is only executed once. When false, the callback is executed every time the event occurs."]
    pub fn gspSetEventCallback(
        id: GSPGPU_Event,
        cb: ThreadFunc,
        data: *mut ::libc::c_void,
        oneShot: bool,
    );
}
extern "C" {
    #[doc = "Waits for a GSPGPU event to occur.\n # Arguments\n\n* `id` - ID of the event.\n * `nextEvent` - Whether to discard the current event and wait for the next event."]
    pub fn gspWaitForEvent(id: GSPGPU_Event, nextEvent: bool);
}
extern "C" {
    #[doc = "Waits for any GSPGPU event to occur.\n # Returns\n\nThe ID of the event that occurred.\n\n The function returns immediately if there are unprocessed events at the time of call."]
    pub fn gspWaitForAnyEvent() -> GSPGPU_Event;
}
extern "C" {
    #[must_use]
    #[doc = "Submits a GX command.\n # Arguments\n\n* `gxCommand` - GX command to execute."]
    pub fn gspSubmitGxCommand(gxCommand: *const u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Acquires GPU rights.\n # Arguments\n\n* `flags` - Flags to acquire with."]
    pub fn GSPGPU_AcquireRight(flags: u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Releases GPU rights."]
    pub fn GSPGPU_ReleaseRight() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Retrieves display capture info.\n # Arguments\n\n* `captureinfo` - Pointer to output capture info to."]
    pub fn GSPGPU_ImportDisplayCaptureInfo(captureinfo: *mut GSPGPU_CaptureInfo) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Saves the VRAM sys area."]
    pub fn GSPGPU_SaveVramSysArea() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Resets the GPU"]
    pub fn GSPGPU_ResetGpuCore() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Restores the VRAM sys area."]
    pub fn GSPGPU_RestoreVramSysArea() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets whether to force the LCD to black.\n # Arguments\n\n* `flags` - Whether to force the LCD to black. (0 = no, non-zero = yes)"]
    pub fn GSPGPU_SetLcdForceBlack(flags: u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Updates a screen's framebuffer state.\n # Arguments\n\n* `screenid` - ID of the screen to update.\n * `framebufinfo` - Framebuffer information to update with."]
    pub fn GSPGPU_SetBufferSwap(
        screenid: u32_,
        framebufinfo: *const GSPGPU_FramebufferInfo,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Flushes memory from the data cache.\n # Arguments\n\n* `adr` - Address to flush.\n * `size` - Size of the memory to flush."]
    pub fn GSPGPU_FlushDataCache(adr: *const ::libc::c_void, size: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Invalidates memory in the data cache.\n # Arguments\n\n* `adr` - Address to invalidate.\n * `size` - Size of the memory to invalidate."]
    pub fn GSPGPU_InvalidateDataCache(adr: *const ::libc::c_void, size: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Writes to GPU hardware registers.\n # Arguments\n\n* `regAddr` - Register address to write to.\n * `data` - Data to write.\n * `size` - Size of the data to write."]
    pub fn GSPGPU_WriteHWRegs(regAddr: u32_, data: *const u32_, size: u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Writes to GPU hardware registers with a mask.\n # Arguments\n\n* `regAddr` - Register address to write to.\n * `data` - Data to write.\n * `datasize` - Size of the data to write.\n * `maskdata` - Data of the mask.\n * `masksize` - Size of the mask."]
    pub fn GSPGPU_WriteHWRegsWithMask(
        regAddr: u32_,
        data: *const u32_,
        datasize: u8_,
        maskdata: *const u32_,
        masksize: u8_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Reads from GPU hardware registers.\n # Arguments\n\n* `regAddr` - Register address to read from.\n * `data` - Buffer to read data to.\n * `size` - Size of the buffer."]
    pub fn GSPGPU_ReadHWRegs(regAddr: u32_, data: *mut u32_, size: u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Registers the interrupt relay queue.\n # Arguments\n\n* `eventHandle` - Handle of the GX command event.\n * `flags` - Flags to register with.\n * `outMemHandle` - Pointer to output the shared memory handle to.\n * `threadID` - Pointer to output the GSP thread ID to."]
    pub fn GSPGPU_RegisterInterruptRelayQueue(
        eventHandle: Handle,
        flags: u32_,
        outMemHandle: *mut Handle,
        threadID: *mut u8_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Unregisters the interrupt relay queue."]
    pub fn GSPGPU_UnregisterInterruptRelayQueue() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Triggers a handling of commands written to shared memory."]
    pub fn GSPGPU_TriggerCmdReqQueue() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets 3D_LEDSTATE to the input state value.\n # Arguments\n\n* `disable` - False = 3D LED enable, true = 3D LED disable."]
    pub fn GSPGPU_SetLedForceOff(disable: bool) -> Result;
}
#[doc = "< Top screen"]
pub const GFX_TOP: gfxScreen_t = 0;
#[doc = "< Bottom screen"]
pub const GFX_BOTTOM: gfxScreen_t = 1;
#[doc = "Screen IDs."]
pub type gfxScreen_t = ::libc::c_uint;
#[doc = "< Left eye framebuffer"]
pub const GFX_LEFT: gfx3dSide_t = 0;
#[doc = "< Right eye framebuffer"]
pub const GFX_RIGHT: gfx3dSide_t = 1;
#[doc = "Top screen framebuffer side.\n\n This is only meaningful when stereoscopic 3D is enabled on the top screen.\n In any other case, use GFX_LEFT."]
pub type gfx3dSide_t = ::libc::c_uint;
extern "C" {
    #[doc = "Initializes the LCD framebuffers with default parameters\n This is equivalent to calling: gfxInit(GSP_BGR8_OES,GSP_BGR8_OES,false); "]
    pub fn gfxInitDefault();
}
extern "C" {
    #[doc = "Initializes the LCD framebuffers.\n # Arguments\n\n* `topFormat` - The format of the top screen framebuffers.\n * `bottomFormat` - The format of the bottom screen framebuffers.\n * `vramBuffers` - Whether to allocate the framebuffers in VRAM.\n\n This function allocates memory for the framebuffers in the specified memory region.\n Initially, stereoscopic 3D is disabled and double buffering is enabled.\n\n > **Note:** This function internally calls gspInit."]
    pub fn gfxInit(
        topFormat: GSPGPU_FramebufferFormat,
        bottomFormat: GSPGPU_FramebufferFormat,
        vrambuffers: bool,
    );
}
extern "C" {
    #[doc = "Deinitializes and frees the LCD framebuffers.\n > **Note:** This function internally calls gspExit."]
    pub fn gfxExit();
}
extern "C" {
    #[doc = "Enables or disables the 3D stereoscopic effect on the top screen.\n # Arguments\n\n* `enable` - Pass true to enable, false to disable.\n > **Note:** Stereoscopic 3D is disabled by default."]
    pub fn gfxSet3D(enable: bool);
}
extern "C" {
    #[doc = "Retrieves the status of the 3D stereoscopic effect on the top screen.\n # Returns\n\ntrue if 3D enabled, false otherwise."]
    pub fn gfxIs3D() -> bool;
}
extern "C" {
    #[doc = "Retrieves the status of the 800px (double-height) high resolution display mode of the top screen.\n # Returns\n\ntrue if wide mode enabled, false otherwise."]
    pub fn gfxIsWide() -> bool;
}
extern "C" {
    #[doc = "Enables or disables the 800px (double-height) high resolution display mode of the top screen.\n # Arguments\n\n* `enable` - Pass true to enable, false to disable.\n > **Note:** Wide mode is disabled by default.\n > **Note:** Wide and stereoscopic 3D modes are mutually exclusive.\n > **Note:** In wide mode pixels are not square, since scanlines are half as tall as they normally are.\n Wide mode does not work on Old 2DS consoles (however it does work on New 2DS XL consoles)."]
    pub fn gfxSetWide(enable: bool);
}
extern "C" {
    #[doc = "Changes the pixel format of a screen.\n # Arguments\n\n* `screen` - Screen ID (see gfxScreen_t)\n * `format` - Pixel format (see GSPGPU_FramebufferFormat)\n > **Note:** If the currently allocated framebuffers are too small for the specified format,\n they are freed and new ones are reallocated."]
    pub fn gfxSetScreenFormat(screen: gfxScreen_t, format: GSPGPU_FramebufferFormat);
}
extern "C" {
    #[doc = "Retrieves the current pixel format of a screen.\n # Arguments\n\n* `screen` - Screen ID (see gfxScreen_t)\n # Returns\n\nPixel format (see GSPGPU_FramebufferFormat)"]
    pub fn gfxGetScreenFormat(screen: gfxScreen_t) -> GSPGPU_FramebufferFormat;
}
extern "C" {
    #[doc = "Enables or disables double buffering on a screen.\n # Arguments\n\n* `screen` - Screen ID (see gfxScreen_t)\n * `enable` - Pass true to enable, false to disable.\n > **Note:** Double buffering is enabled by default."]
    pub fn gfxSetDoubleBuffering(screen: gfxScreen_t, enable: bool);
}
extern "C" {
    #[doc = "Retrieves the framebuffer of the specified screen to which graphics should be rendered.\n # Arguments\n\n* `screen` - Screen ID (see gfxScreen_t)\n * `side` - Framebuffer side (see gfx3dSide_t) (pass GFX_LEFT if not using stereoscopic 3D)\n * `width` - Pointer that will hold the width of the framebuffer in pixels.\n * `height` - Pointer that will hold the height of the framebuffer in pixels.\n # Returns\n\nA pointer to the current framebuffer of the chosen screen.\n\n Please remember that the returned pointer will change every frame if double buffering is enabled."]
    pub fn gfxGetFramebuffer(
        screen: gfxScreen_t,
        side: gfx3dSide_t,
        width: *mut u16_,
        height: *mut u16_,
    ) -> *mut u8_;
}
extern "C" {
    #[doc = "Flushes the data cache for the current framebuffers.\n This is **only used during software rendering**. Since this function has significant overhead,\n it is preferred to call this only once per frame, after all software rendering is completed."]
    pub fn gfxFlushBuffers();
}
extern "C" {
    #[doc = "Updates the configuration of the specified screen, swapping the buffers if double buffering is enabled.\n # Arguments\n\n* `scr` - Screen ID (see gfxScreen_t)\n * `hasStereo` - For the top screen in 3D mode: true if the framebuffer contains individual images\n for both eyes, or false if the left image should be duplicated to the right eye.\n > **Note:** Previously rendered content will be displayed on the screen after the next VBlank.\n > **Note:** This function is still useful even if double buffering is disabled, as it must be used to commit configuration changes.\n Only call this once per screen per frame, otherwise graphical glitches will occur\n since this API does not implement triple buffering."]
    pub fn gfxScreenSwapBuffers(scr: gfxScreen_t, hasStereo: bool);
}
extern "C" {
    #[doc = "Same as gfxScreenSwapBuffers, but with hasStereo set to true.\n # Arguments\n\n* `scr` - Screen ID (see gfxScreen_t)\n * `immediate` - This parameter no longer has any effect and is thus ignored.\n > **Deprecated** This function has been superseded by gfxScreenSwapBuffers, please use that instead."]
    pub fn gfxConfigScreen(scr: gfxScreen_t, immediate: bool);
}
extern "C" {
    #[doc = "Updates the configuration of both screens.\n > **Note:** This function is equivalent to: gfxScreenSwapBuffers(GFX_TOP,true); gfxScreenSwapBuffers(GFX_BOTTOM,true); "]
    pub fn gfxSwapBuffers();
}
extern "C" {
    #[doc = "Same as gfxSwapBuffers (formerly different)."]
    pub fn gfxSwapBuffersGpu();
}
#[doc = "A callback for printing a character."]
pub type ConsolePrint = ::core::option::Option<
    unsafe extern "C" fn(con: *mut ::libc::c_void, c: ::libc::c_int) -> bool,
>;
#[doc = "A font struct for the console."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ConsoleFont {
    #[doc = "< A pointer to the font graphics"]
    pub gfx: *mut u8_,
    #[doc = "< Offset to the first valid character in the font table"]
    pub asciiOffset: u16_,
    #[doc = "< Number of characters in the font graphics"]
    pub numChars: u16_,
}
impl Default for ConsoleFont {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Console structure used to store the state of a console render context.\n\n Default values from consoleGetDefault();\n PrintConsole defaultConsole =\n {\n \t//Font:\n \t{\n \t\t(u8*)default_font_bin, //font gfx\n \t\t0, //first ascii character in the set\n \t\t128, //number of characters in the font set\n\t},\n\t0,0, //cursorX cursorY\n\t0,0, //prevcursorX prevcursorY\n\t40, //console width\n\t30, //console height\n\t0, //window x\n\t0, //window y\n\t32, //window width\n\t24, //window height\n\t3, //tab size\n\t0, //font character offset\n\t0, //print callback\n\tfalse //console initialized\n };\n "]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PrintConsole {
    #[doc = "< Font of the console"]
    pub font: ConsoleFont,
    #[doc = "< Framebuffer address"]
    pub frameBuffer: *mut u16_,
    #[doc = "< Current X location of the cursor (as a tile offset by default)"]
    pub cursorX: ::libc::c_int,
    #[doc = "< Current Y location of the cursor (as a tile offset by default)"]
    pub cursorY: ::libc::c_int,
    #[doc = "< Internal state"]
    pub prevCursorX: ::libc::c_int,
    #[doc = "< Internal state"]
    pub prevCursorY: ::libc::c_int,
    #[doc = "< Width of the console hardware layer in characters"]
    pub consoleWidth: ::libc::c_int,
    #[doc = "< Height of the console hardware layer in characters"]
    pub consoleHeight: ::libc::c_int,
    #[doc = "< Window X location in characters (not implemented)"]
    pub windowX: ::libc::c_int,
    #[doc = "< Window Y location in characters (not implemented)"]
    pub windowY: ::libc::c_int,
    #[doc = "< Window width in characters (not implemented)"]
    pub windowWidth: ::libc::c_int,
    #[doc = "< Window height in characters (not implemented)"]
    pub windowHeight: ::libc::c_int,
    #[doc = "< Size of a tab"]
    pub tabSize: ::libc::c_int,
    #[doc = "< Foreground color"]
    pub fg: u16_,
    #[doc = "< Background color"]
    pub bg: u16_,
    #[doc = "< Reverse/bright flags"]
    pub flags: ::libc::c_int,
    #[doc = "< Callback for printing a character. Should return true if it has handled rendering the graphics (else the print engine will attempt to render via tiles)."]
    pub PrintChar: ConsolePrint,
    #[doc = "< True if the console is initialized"]
    pub consoleInitialised: bool,
}
impl Default for PrintConsole {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "< Swallows prints to stderr"]
pub const debugDevice_NULL: debugDevice = 0;
#[doc = "< Outputs stderr debug statements using svcOutputDebugString, which can then be captured by interactive debuggers"]
pub const debugDevice_SVC: debugDevice = 1;
#[doc = "< Directs stderr debug statements to 3DS console window"]
pub const debugDevice_CONSOLE: debugDevice = 2;
pub const debugDevice_3DMOO: debugDevice = 1;
#[doc = "Console debug devices supported by libnds."]
pub type debugDevice = ::libc::c_uint;
extern "C" {
    #[doc = "Loads the font into the console.\n # Arguments\n\n* `console` - Pointer to the console to update, if NULL it will update the current console.\n * `font` - The font to load."]
    pub fn consoleSetFont(console: *mut PrintConsole, font: *mut ConsoleFont);
}
extern "C" {
    #[doc = "Sets the print window.\n # Arguments\n\n* `console` - Console to set, if NULL it will set the current console window.\n * `x` - X location of the window.\n * `y` - Y location of the window.\n * `width` - Width of the window.\n * `height` - Height of the window."]
    pub fn consoleSetWindow(
        console: *mut PrintConsole,
        x: ::libc::c_int,
        y: ::libc::c_int,
        width: ::libc::c_int,
        height: ::libc::c_int,
    );
}
extern "C" {
    #[doc = "Gets a pointer to the console with the default values.\n This should only be used when using a single console or without changing the console that is returned, otherwise use consoleInit().\n # Returns\n\nA pointer to the console with the default values."]
    pub fn consoleGetDefault() -> *mut PrintConsole;
}
extern "C" {
    #[doc = "Make the specified console the render target.\n # Arguments\n\n* `console` - A pointer to the console struct (must have been initialized with consoleInit(PrintConsole* console)).\n # Returns\n\nA pointer to the previous console."]
    pub fn consoleSelect(console: *mut PrintConsole) -> *mut PrintConsole;
}
extern "C" {
    #[doc = "Initialise the console.\n # Arguments\n\n* `screen` - The screen to use for the console.\n * `console` - A pointer to the console data to initialize (if it's NULL, the default console will be used).\n # Returns\n\nA pointer to the current console."]
    pub fn consoleInit(screen: gfxScreen_t, console: *mut PrintConsole) -> *mut PrintConsole;
}
extern "C" {
    #[doc = "Initializes debug console output on stderr to the specified device.\n # Arguments\n\n* `device` - The debug device (or devices) to output debug print statements to."]
    pub fn consoleDebugInit(device: debugDevice);
}
extern "C" {
    #[doc = "Clears the screen by using iprintf(\""]
    pub fn consoleClear();
}
#[doc = "< Use APT workaround."]
pub const RUNFLAG_APTWORKAROUND: _bindgen_ty_9 = 1;
#[doc = "< Reinitialize APT."]
pub const RUNFLAG_APTREINIT: _bindgen_ty_9 = 2;
#[doc = "< Chainload APT on return."]
pub const RUNFLAG_APTCHAINLOAD: _bindgen_ty_9 = 4;
#[doc = "System run-flags."]
pub type _bindgen_ty_9 = ::libc::c_uint;
extern "C" {
    #[doc = "Gets whether the application was launched from a homebrew environment.\n # Returns\n\nWhether the application was launched from a homebrew environment."]
    #[link_name = "envIsHomebrew__extern"]
    pub fn envIsHomebrew() -> bool;
}
extern "C" {
    #[doc = "Retrieves a handle from the environment handle list.\n # Arguments\n\n* `name` - Name of the handle.\n # Returns\n\nThe retrieved handle."]
    pub fn envGetHandle(name: *const ::libc::c_char) -> Handle;
}
extern "C" {
    #[doc = "Gets the environment-recommended app ID to use with APT.\n # Returns\n\nThe APT app ID."]
    #[link_name = "envGetAptAppId__extern"]
    pub fn envGetAptAppId() -> u32_;
}
extern "C" {
    #[doc = "Gets the size of the application heap.\n # Returns\n\nThe application heap size."]
    #[link_name = "envGetHeapSize__extern"]
    pub fn envGetHeapSize() -> u32_;
}
extern "C" {
    #[doc = "Gets the size of the linear heap.\n # Returns\n\nThe linear heap size."]
    #[link_name = "envGetLinearHeapSize__extern"]
    pub fn envGetLinearHeapSize() -> u32_;
}
extern "C" {
    #[doc = "Gets the environment argument list.\n # Returns\n\nThe argument list."]
    #[link_name = "envGetSystemArgList__extern"]
    pub fn envGetSystemArgList() -> *const ::libc::c_char;
}
extern "C" {
    #[doc = "Gets the environment run flags.\n # Returns\n\nThe run flags."]
    #[link_name = "envGetSystemRunFlags__extern"]
    pub fn envGetSystemRunFlags() -> u32_;
}
pub type _off_t = __int64_t;
pub type _fpos_t = __int64_t;
pub type __ino_t = __uint32_t;
pub type __dev_t = __uint32_t;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = __intptr_t;
pub type wint_t = ::libc::c_int;
pub type __blkcnt_t = ::libc::c_long;
pub type __blksize_t = ::libc::c_long;
pub type __fsblkcnt_t = __uint64_t;
pub type __fsfilcnt_t = __uint32_t;
pub type __pid_t = ::libc::c_int;
pub type __uid_t = ::libc::c_ushort;
pub type __gid_t = ::libc::c_ushort;
pub type __id_t = __uint32_t;
pub type __mode_t = __uint32_t;
pub type _off64_t = ::libc::c_longlong;
pub type __off_t = _off_t;
pub type __loff_t = _off64_t;
pub type __key_t = ::libc::c_long;
pub type __size_t = ::libc::c_uint;
pub type _ssize_t = ::libc::c_int;
pub type __ssize_t = _ssize_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _mbstate_t {
    pub __count: ::libc::c_int,
    pub __value: _mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _mbstate_t__bindgen_ty_1 {
    pub __wch: wint_t,
    pub __wchb: [::libc::c_uchar; 4usize],
}
impl Default for _mbstate_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _mbstate_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type _iconv_t = *mut ::libc::c_void;
pub type __clock_t = ::libc::c_ulong;
pub type __time_t = __int_least64_t;
pub type __clockid_t = ::libc::c_ulong;
pub type __daddr_t = ::libc::c_long;
pub type __timer_t = ::libc::c_ulong;
pub type __sa_family_t = __uint8_t;
pub type __socklen_t = __uint32_t;
pub type __nl_item = ::libc::c_int;
pub type __nlink_t = ::libc::c_ushort;
pub type __suseconds_t = ::libc::c_long;
pub type __useconds_t = ::libc::c_ulong;
pub type __sigset_t = ::libc::c_ulong;
pub type suseconds_t = __suseconds_t;
pub type time_t = __int_least64_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timeval {
    pub tv_sec: time_t,
    pub tv_usec: suseconds_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: ::libc::c_long,
}
extern "C" {
    pub fn timespec2nsec(ts: *const timespec) -> __uint64_t;
}
extern "C" {
    pub fn abstimespec2nsec(clock_id: __clockid_t, ts: *const timespec) -> __uint64_t;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
pub type sigset_t = __sigset_t;
pub type __fd_mask = ::libc::c_ulong;
pub type fd_mask = __fd_mask;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 2usize],
}
extern "C" {
    pub fn select(
        __n: ::libc::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pselect(
        __n: ::libc::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __set: *const sigset_t,
    ) -> ::libc::c_int;
}
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type u_register_t = __uintptr_t;
pub type u_char = ::libc::c_uchar;
pub type u_short = ::libc::c_ushort;
pub type u_int = ::libc::c_uint;
pub type u_long = ::libc::c_ulong;
pub type ushort = ::libc::c_ushort;
pub type uint = ::libc::c_uint;
pub type ulong = ::libc::c_ulong;
pub type blkcnt_t = __blkcnt_t;
pub type blksize_t = __blksize_t;
pub type clock_t = ::libc::c_ulong;
pub type daddr_t = __daddr_t;
pub type caddr_t = *mut ::libc::c_char;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type id_t = __id_t;
pub type ino_t = __ino_t;
pub type off_t = __off_t;
pub type dev_t = __dev_t;
pub type uid_t = __uid_t;
pub type gid_t = __gid_t;
pub type pid_t = __pid_t;
pub type key_t = __key_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub type useconds_t = __useconds_t;
pub type sbintime_t = __int64_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: ::libc::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_t {
    _unused: [u8; 0],
}
pub type pthread_t = *mut __pthread_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_attr_t {
    pub stackaddr: *mut ::libc::c_void,
    pub stacksize: ::libc::c_int,
    pub schedparam: sched_param,
    pub detachstate: ::libc::c_int,
}
impl Default for pthread_attr_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pthread_mutex_t {
    pub type_: ::libc::c_int,
    pub __bindgen_anon_1: pthread_mutex_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t__bindgen_ty_1 {
    pub normal: _LOCK_T,
    pub recursive: _LOCK_RECURSIVE_T,
}
impl Default for pthread_mutex_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for pthread_mutex_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pthread_mutexattr_t {
    pub type_: ::libc::c_int,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pthread_cond_t {
    pub clock_id: clockid_t,
    pub cond: _COND_T,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pthread_condattr_t {
    pub clock_id: clockid_t,
}
pub type pthread_key_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pthread_once_t {
    pub status: ::libc::c_int,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pthread_barrier_t {
    pub lock: _LOCK_T,
    pub cond: _COND_T,
    pub reload: ::libc::c_uint,
    pub counter: ::libc::c_uint,
    pub cycle: ::libc::c_uint,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pthread_barrierattr_t {}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pthread_rwlock_t {
    pub lock: _LOCK_T,
    pub cond_r: _COND_T,
    pub cond_w: _COND_T,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl pthread_rwlock_t {
    #[inline]
    pub fn cnt_r(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_cnt_r(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn cnt_w(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_cnt_w(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(cnt_r: u32, cnt_w: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 30u8, {
            let cnt_r: u32 = unsafe { ::core::mem::transmute(cnt_r) };
            cnt_r as u64
        });
        __bindgen_bitfield_unit.set(30usize, 2u8, {
            let cnt_w: u32 = unsafe { ::core::mem::transmute(cnt_w) };
            cnt_w as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pthread_rwlockattr_t {}
#[doc = "< Dummy compression"]
pub const DECOMPRESS_DUMMY: decompressType = 0;
#[doc = "< LZSS/LZ10 compression"]
pub const DECOMPRESS_LZSS: decompressType = 16;
#[doc = "< LZSS/LZ10 compression"]
pub const DECOMPRESS_LZ10: decompressType = 16;
#[doc = "< LZ11 compression"]
pub const DECOMPRESS_LZ11: decompressType = 17;
#[doc = "< Huffman compression with 1-bit data"]
pub const DECOMPRESS_HUFF1: decompressType = 33;
#[doc = "< Huffman compression with 2-bit data"]
pub const DECOMPRESS_HUFF2: decompressType = 34;
#[doc = "< Huffman compression with 3-bit data"]
pub const DECOMPRESS_HUFF3: decompressType = 35;
#[doc = "< Huffman compression with 4-bit data"]
pub const DECOMPRESS_HUFF4: decompressType = 36;
#[doc = "< Huffman compression with 5-bit data"]
pub const DECOMPRESS_HUFF5: decompressType = 37;
#[doc = "< Huffman compression with 6-bit data"]
pub const DECOMPRESS_HUFF6: decompressType = 38;
#[doc = "< Huffman compression with 7-bit data"]
pub const DECOMPRESS_HUFF7: decompressType = 39;
#[doc = "< Huffman compression with 8-bit data"]
pub const DECOMPRESS_HUFF8: decompressType = 40;
#[doc = "< Huffman compression with 8-bit data"]
pub const DECOMPRESS_HUFF: decompressType = 40;
#[doc = "< Run-length encoding compression"]
pub const DECOMPRESS_RLE: decompressType = 48;
#[doc = "Compression types"]
pub type decompressType = ::libc::c_uint;
#[doc = "I/O vector"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct decompressIOVec {
    #[doc = "< I/O buffer"]
    pub data: *mut ::libc::c_void,
    #[doc = "< Buffer size"]
    pub size: usize,
}
impl Default for decompressIOVec {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Data callback"]
pub type decompressCallback = ::core::option::Option<
    unsafe extern "C" fn(
        userdata: *mut ::libc::c_void,
        buffer: *mut ::libc::c_void,
        size: usize,
    ) -> isize,
>;
extern "C" {
    #[doc = "Decompression callback for file descriptors\n # Arguments\n\n* `userdata` (direction in) - Address of file descriptor\n * `buffer` (direction in) - Buffer to write into\n * `size` (direction in) - Size to read from file descriptor\n # Returns\n\nNumber of bytes read"]
    pub fn decompressCallback_FD(
        userdata: *mut ::libc::c_void,
        buffer: *mut ::libc::c_void,
        size: usize,
    ) -> isize;
}
extern "C" {
    #[doc = "Decompression callback for stdio FILE*\n # Arguments\n\n* `userdata` (direction in) - FILE*\n * `buffer` (direction in) - Buffer to write into\n * `size` (direction in) - Size to read from file descriptor\n # Returns\n\nNumber of bytes read"]
    pub fn decompressCallback_Stdio(
        userdata: *mut ::libc::c_void,
        buffer: *mut ::libc::c_void,
        size: usize,
    ) -> isize;
}
extern "C" {
    #[doc = "Decode decompression header\n # Arguments\n\n* `type` (direction out) - Decompression type\n * `size` (direction out) - Decompressed size\n * `callback` (direction in) - Data callback (see decompressV())\n * `userdata` (direction in) - User data passed to callback (see decompressV())\n * `insize` (direction in) - Size of userdata (see decompressV())\n # Returns\n\nBytes consumed\n * `-1` - error"]
    pub fn decompressHeader(
        type_: *mut decompressType,
        size: *mut usize,
        callback: decompressCallback,
        userdata: *mut ::libc::c_void,
        insize: usize,
    ) -> isize;
}
extern "C" {
    #[doc = "Decompress data\n # Arguments\n\n* `iov` (direction in) - Output vector\n * `iovcnt` (direction in) - Number of buffers\n * `callback` (direction in) - Data callback (see note)\n * `userdata` (direction in) - User data passed to callback (see note)\n * `insize` (direction in) - Size of userdata (see note)\n # Returns\n\nWhether succeeded\n\n > **Note:** If callback is null, userdata is a pointer to memory to read from,\n and insize is the size of that data. If callback is not null,\n userdata is passed to callback to fetch more data, and insize is\n unused."]
    pub fn decompressV(
        iov: *const decompressIOVec,
        iovcnt: usize,
        callback: decompressCallback,
        userdata: *mut ::libc::c_void,
        insize: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "Decompress data\n # Arguments\n\n* `output` (direction in) - Output buffer\n * `size` (direction in) - Output size limit\n * `callback` (direction in) - Data callback (see decompressV())\n * `userdata` (direction in) - User data passed to callback (see decompressV())\n * `insize` (direction in) - Size of userdata (see decompressV())\n # Returns\n\nWhether succeeded"]
    #[link_name = "decompress__extern"]
    pub fn decompress(
        output: *mut ::libc::c_void,
        size: usize,
        callback: decompressCallback,
        userdata: *mut ::libc::c_void,
        insize: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "Decompress LZSS/LZ10\n # Arguments\n\n* `iov` (direction in) - Output vector\n * `iovcnt` (direction in) - Number of buffers\n * `callback` (direction in) - Data callback (see decompressV())\n * `userdata` (direction in) - User data passed to callback (see decompressV())\n * `insize` (direction in) - Size of userdata (see decompressV())\n # Returns\n\nWhether succeeded"]
    pub fn decompressV_LZSS(
        iov: *const decompressIOVec,
        iovcnt: usize,
        callback: decompressCallback,
        userdata: *mut ::libc::c_void,
        insize: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "Decompress LZSS/LZ10\n # Arguments\n\n* `output` (direction in) - Output buffer\n * `size` (direction in) - Output size limit\n * `callback` (direction in) - Data callback (see decompressV())\n * `userdata` (direction in) - User data passed to callback (see decompressV())\n * `insize` (direction in) - Size of userdata (see decompressV())\n # Returns\n\nWhether succeeded"]
    #[link_name = "decompress_LZSS__extern"]
    pub fn decompress_LZSS(
        output: *mut ::libc::c_void,
        size: usize,
        callback: decompressCallback,
        userdata: *mut ::libc::c_void,
        insize: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "Decompress LZ11\n # Arguments\n\n* `iov` (direction in) - Output vector\n * `iovcnt` (direction in) - Number of buffers\n * `callback` (direction in) - Data callback (see decompressV())\n * `userdata` (direction in) - User data passed to callback (see decompressV())\n * `insize` (direction in) - Size of userdata (see decompressV())\n # Returns\n\nWhether succeeded"]
    pub fn decompressV_LZ11(
        iov: *const decompressIOVec,
        iovcnt: usize,
        callback: decompressCallback,
        userdata: *mut ::libc::c_void,
        insize: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "Decompress LZ11\n # Arguments\n\n* `output` (direction in) - Output buffer\n * `size` (direction in) - Output size limit\n * `callback` (direction in) - Data callback (see decompressV())\n * `userdata` (direction in) - User data passed to callback (see decompressV())\n * `insize` (direction in) - Size of userdata (see decompressV())\n # Returns\n\nWhether succeeded"]
    #[link_name = "decompress_LZ11__extern"]
    pub fn decompress_LZ11(
        output: *mut ::libc::c_void,
        size: usize,
        callback: decompressCallback,
        userdata: *mut ::libc::c_void,
        insize: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "Decompress Huffman\n # Arguments\n\n* `bits` (direction in) - Data size in bits (usually 4 or 8)\n * `iov` (direction in) - Output vector\n * `iovcnt` (direction in) - Number of buffers\n * `callback` (direction in) - Data callback (see decompressV())\n * `userdata` (direction in) - User data passed to callback (see decompressV())\n * `insize` (direction in) - Size of userdata (see decompressV())\n # Returns\n\nWhether succeeded"]
    pub fn decompressV_Huff(
        bits: usize,
        iov: *const decompressIOVec,
        iovcnt: usize,
        callback: decompressCallback,
        userdata: *mut ::libc::c_void,
        insize: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "Decompress Huffman\n # Arguments\n\n* `bits` (direction in) - Data size in bits (usually 4 or 8)\n * `output` (direction in) - Output buffer\n * `size` (direction in) - Output size limit\n * `callback` (direction in) - Data callback (see decompressV())\n * `userdata` (direction in) - User data passed to callback (see decompressV())\n * `insize` (direction in) - Size of userdata (see decompressV())\n # Returns\n\nWhether succeeded"]
    #[link_name = "decompress_Huff__extern"]
    pub fn decompress_Huff(
        bits: usize,
        output: *mut ::libc::c_void,
        size: usize,
        callback: decompressCallback,
        userdata: *mut ::libc::c_void,
        insize: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "Decompress run-length encoding\n # Arguments\n\n* `iov` (direction in) - Output vector\n * `iovcnt` (direction in) - Number of buffers\n * `callback` (direction in) - Data callback (see decompressV())\n * `userdata` (direction in) - User data passed to callback (see decompressV())\n * `insize` (direction in) - Size of userdata (see decompressV())\n # Returns\n\nWhether succeeded"]
    pub fn decompressV_RLE(
        iov: *const decompressIOVec,
        iovcnt: usize,
        callback: decompressCallback,
        userdata: *mut ::libc::c_void,
        insize: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "Decompress run-length encoding\n # Arguments\n\n* `output` (direction in) - Output buffer\n * `size` (direction in) - Output size limit\n * `callback` (direction in) - Data callback (see decompressV())\n * `userdata` (direction in) - User data passed to callback (see decompressV())\n * `insize` (direction in) - Size of userdata (see decompressV())\n # Returns\n\nWhether succeeded"]
    #[link_name = "decompress_RLE__extern"]
    pub fn decompress_RLE(
        output: *mut ::libc::c_void,
        size: usize,
        callback: decompressCallback,
        userdata: *mut ::libc::c_void,
        insize: usize,
    ) -> bool;
}
extern "C" {
    #[doc = "Convert a UTF-8 sequence into a UTF-32 codepoint\n\n # Arguments\n\n* `out` (direction out) - Output codepoint\n * `in` (direction in) - Input sequence\n\n # Returns\n\nnumber of input code units consumed\n -1 for error"]
    pub fn decode_utf8(out: *mut u32, in_: *const u8) -> isize;
}
extern "C" {
    #[doc = "Convert a UTF-16 sequence into a UTF-32 codepoint\n\n # Arguments\n\n* `out` (direction out) - Output codepoint\n * `in` (direction in) - Input sequence\n\n # Returns\n\nnumber of input code units consumed\n -1 for error"]
    pub fn decode_utf16(out: *mut u32, in_: *const u16) -> isize;
}
extern "C" {
    #[doc = "Convert a UTF-32 codepoint into a UTF-8 sequence\n\n # Arguments\n\n* `out` (direction out) - Output sequence\n * `in` (direction in) - Input codepoint\n\n # Returns\n\nnumber of output code units produced\n -1 for error\n\n > **Note:** _out_ must be able to store 4 code units"]
    pub fn encode_utf8(out: *mut u8, in_: u32) -> isize;
}
extern "C" {
    #[doc = "Convert a UTF-32 codepoint into a UTF-16 sequence\n\n # Arguments\n\n* `out` (direction out) - Output sequence\n * `in` (direction in) - Input codepoint\n\n # Returns\n\nnumber of output code units produced\n -1 for error\n\n > **Note:** _out_ must be able to store 2 code units"]
    pub fn encode_utf16(out: *mut u16, in_: u32) -> isize;
}
extern "C" {
    #[doc = "Convert a UTF-8 sequence into a UTF-16 sequence\n\n Fills the output buffer up to _len_ code units.\n Returns the number of code units that the input would produce;\n if it returns greater than _len,_ the output has been\n truncated.\n\n # Arguments\n\n* `out` (direction out) - Output sequence\n * `in` (direction in) - Input sequence (null-terminated)\n * `len` (direction in) - Output length\n\n # Returns\n\nnumber of output code units produced\n -1 for error\n\n > **Note:** _out_ is not null-terminated"]
    pub fn utf8_to_utf16(out: *mut u16, in_: *const u8, len: usize) -> isize;
}
extern "C" {
    #[doc = "Convert a UTF-8 sequence into a UTF-32 sequence\n\n Fills the output buffer up to _len_ code units.\n Returns the number of code units that the input would produce;\n if it returns greater than _len,_ the output has been\n truncated.\n\n # Arguments\n\n* `out` (direction out) - Output sequence\n * `in` (direction in) - Input sequence (null-terminated)\n * `len` (direction in) - Output length\n\n # Returns\n\nnumber of output code units produced\n -1 for error\n\n > **Note:** _out_ is not null-terminated"]
    pub fn utf8_to_utf32(out: *mut u32, in_: *const u8, len: usize) -> isize;
}
extern "C" {
    #[doc = "Convert a UTF-16 sequence into a UTF-8 sequence\n\n Fills the output buffer up to _len_ code units.\n Returns the number of code units that the input would produce;\n if it returns greater than _len,_ the output has been\n truncated.\n\n # Arguments\n\n* `out` (direction out) - Output sequence\n * `in` (direction in) - Input sequence (null-terminated)\n * `len` (direction in) - Output length\n\n # Returns\n\nnumber of output code units produced\n -1 for error\n\n > **Note:** _out_ is not null-terminated"]
    pub fn utf16_to_utf8(out: *mut u8, in_: *const u16, len: usize) -> isize;
}
extern "C" {
    #[doc = "Convert a UTF-16 sequence into a UTF-32 sequence\n\n Fills the output buffer up to _len_ code units.\n Returns the number of code units that the input would produce;\n if it returns greater than _len,_ the output has been\n truncated.\n\n # Arguments\n\n* `out` (direction out) - Output sequence\n * `in` (direction in) - Input sequence (null-terminated)\n * `len` (direction in) - Output length\n\n # Returns\n\nnumber of output code units produced\n -1 for error\n\n > **Note:** _out_ is not null-terminated"]
    pub fn utf16_to_utf32(out: *mut u32, in_: *const u16, len: usize) -> isize;
}
extern "C" {
    #[doc = "Convert a UTF-32 sequence into a UTF-8 sequence\n\n Fills the output buffer up to _len_ code units.\n Returns the number of code units that the input would produce;\n if it returns greater than _len,_ the output has been\n truncated.\n\n # Arguments\n\n* `out` (direction out) - Output sequence\n * `in` (direction in) - Input sequence (null-terminated)\n * `len` (direction in) - Output length\n\n # Returns\n\nnumber of output code units produced\n -1 for error\n\n > **Note:** _out_ is not null-terminated"]
    pub fn utf32_to_utf8(out: *mut u8, in_: *const u32, len: usize) -> isize;
}
extern "C" {
    #[doc = "Convert a UTF-32 sequence into a UTF-16 sequence\n\n # Arguments\n\n* `out` (direction out) - Output sequence\n * `in` (direction in) - Input sequence (null-terminated)\n * `len` (direction in) - Output length\n\n # Returns\n\nnumber of output code units produced\n -1 for error\n\n > **Note:** _out_ is not null-terminated"]
    pub fn utf32_to_utf16(out: *mut u16, in_: *const u32, len: usize) -> isize;
}
extern "C" {
    #[doc = "Allocates a 0x80-byte aligned buffer.\n # Arguments\n\n* `size` - Size of the buffer to allocate.\n # Returns\n\nThe allocated buffer."]
    pub fn linearAlloc(size: usize) -> *mut ::libc::c_void;
}
extern "C" {
    #[doc = "Allocates a buffer aligned to the given size.\n # Arguments\n\n* `size` - Size of the buffer to allocate.\n * `alignment` - Alignment to use.\n # Returns\n\nThe allocated buffer."]
    pub fn linearMemAlign(size: usize, alignment: usize) -> *mut ::libc::c_void;
}
extern "C" {
    #[doc = "Reallocates a buffer.\n Note: Not implemented yet.\n # Arguments\n\n* `mem` - Buffer to reallocate.\n * `size` - Size of the buffer to allocate.\n # Returns\n\nThe reallocated buffer."]
    pub fn linearRealloc(mem: *mut ::libc::c_void, size: usize) -> *mut ::libc::c_void;
}
extern "C" {
    #[doc = "Retrieves the allocated size of a buffer.\n # Returns\n\nThe size of the buffer."]
    pub fn linearGetSize(mem: *mut ::libc::c_void) -> usize;
}
extern "C" {
    #[doc = "Frees a buffer.\n # Arguments\n\n* `mem` - Buffer to free."]
    pub fn linearFree(mem: *mut ::libc::c_void);
}
extern "C" {
    #[doc = "Gets the current linear free space.\n # Returns\n\nThe current linear free space."]
    pub fn linearSpaceFree() -> u32_;
}
extern "C" {
    #[doc = "Initializes the mappable allocator.\n # Arguments\n\n* `addrMin` - Minimum address.\n * `addrMax` - Maxium address."]
    pub fn mappableInit(addrMin: u32_, addrMax: u32_);
}
extern "C" {
    #[doc = "Finds a mappable memory area.\n # Arguments\n\n* `size` - Size of the area to find.\n # Returns\n\nThe mappable area."]
    pub fn mappableAlloc(size: usize) -> *mut ::libc::c_void;
}
extern "C" {
    #[doc = "Frees a mappable area (stubbed).\n # Arguments\n\n* `mem` - Mappable area to free."]
    pub fn mappableFree(mem: *mut ::libc::c_void);
}
pub const VRAM_ALLOC_A: vramAllocPos = 1;
pub const VRAM_ALLOC_B: vramAllocPos = 2;
pub const VRAM_ALLOC_ANY: vramAllocPos = 3;
pub type vramAllocPos = ::libc::c_uint;
extern "C" {
    #[doc = "Allocates a 0x80-byte aligned buffer.\n # Arguments\n\n* `size` - Size of the buffer to allocate.\n # Returns\n\nThe allocated buffer."]
    pub fn vramAlloc(size: usize) -> *mut ::libc::c_void;
}
extern "C" {
    #[doc = "Allocates a 0x80-byte aligned buffer in the given VRAM bank.\n # Arguments\n\n* `size` - Size of the buffer to allocate.\n * `pos` - VRAM bank to use (see vramAllocPos).\n # Returns\n\nThe allocated buffer."]
    pub fn vramAllocAt(size: usize, pos: vramAllocPos) -> *mut ::libc::c_void;
}
extern "C" {
    #[doc = "Allocates a buffer aligned to the given size.\n # Arguments\n\n* `size` - Size of the buffer to allocate.\n * `alignment` - Alignment to use.\n # Returns\n\nThe allocated buffer."]
    pub fn vramMemAlign(size: usize, alignment: usize) -> *mut ::libc::c_void;
}
extern "C" {
    #[doc = "Allocates a buffer aligned to the given size in the given VRAM bank.\n # Arguments\n\n* `size` - Size of the buffer to allocate.\n * `alignment` - Alignment to use.\n * `pos` - VRAM bank to use (see vramAllocPos).\n # Returns\n\nThe allocated buffer."]
    pub fn vramMemAlignAt(size: usize, alignment: usize, pos: vramAllocPos) -> *mut ::libc::c_void;
}
extern "C" {
    #[doc = "Reallocates a buffer.\n Note: Not implemented yet.\n # Arguments\n\n* `mem` - Buffer to reallocate.\n * `size` - Size of the buffer to allocate.\n # Returns\n\nThe reallocated buffer."]
    pub fn vramRealloc(mem: *mut ::libc::c_void, size: usize) -> *mut ::libc::c_void;
}
extern "C" {
    #[doc = "Retrieves the allocated size of a buffer.\n # Returns\n\nThe size of the buffer."]
    pub fn vramGetSize(mem: *mut ::libc::c_void) -> usize;
}
extern "C" {
    #[doc = "Frees a buffer.\n # Arguments\n\n* `mem` - Buffer to free."]
    pub fn vramFree(mem: *mut ::libc::c_void);
}
extern "C" {
    #[doc = "Gets the current VRAM free space.\n # Returns\n\nThe current VRAM free space."]
    pub fn vramSpaceFree() -> u32_;
}
#[doc = "< Open authentication."]
pub const AC_OPEN: acSecurityMode = 0;
#[doc = "< WEP 40-bit authentication."]
pub const AC_WEP_40BIT: acSecurityMode = 1;
#[doc = "< WEP 104-bit authentication."]
pub const AC_WEP_104BIT: acSecurityMode = 2;
#[doc = "< WEP 128-bit authentication."]
pub const AC_WEP_128BIT: acSecurityMode = 3;
#[doc = "< WPA TKIP authentication."]
pub const AC_WPA_TKIP: acSecurityMode = 4;
#[doc = "< WPA2 TKIP authentication."]
pub const AC_WPA2_TKIP: acSecurityMode = 5;
#[doc = "< WPA AES authentication."]
pub const AC_WPA_AES: acSecurityMode = 6;
#[doc = "< WPA2 AES authentication."]
pub const AC_WPA2_AES: acSecurityMode = 7;
#[doc = "Wifi security modes."]
pub type acSecurityMode = ::libc::c_uint;
#[doc = "Struct to contain the data for connecting to a Wifi network from a stored slot."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct acuConfig {
    pub reserved: [u8_; 512usize],
}
impl Default for acuConfig {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[must_use]
    #[doc = "Initializes AC."]
    pub fn acInit() -> Result;
}
extern "C" {
    #[doc = "Exits AC."]
    pub fn acExit();
}
extern "C" {
    #[must_use]
    #[doc = "Waits for the system to connect to the internet."]
    pub fn acWaitInternetConnection() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the connected Wifi status.\n # Arguments\n\n* `out` - Pointer to output the connected Wifi status to. (0 = not connected, 1 = O3DS Internet, 2 = N3DS Internet)"]
    pub fn ACU_GetWifiStatus(out: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the connected Wifi status.\n # Arguments\n\n* `out` - Pointer to output the connected Wifi status to. (1 = not connected, 3 = connected)"]
    pub fn ACU_GetStatus(out: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the connected Wifi security mode.\n # Arguments\n\n* `mode` - Pointer to output the connected Wifi security mode to. (0 = Open Authentication, 1 = WEP 40-bit, 2 = WEP 104-bit, 3 = WEP 128-bit, 4 = WPA TKIP, 5 = WPA2 TKIP, 6 = WPA AES, 7 = WPA2 AES)"]
    pub fn ACU_GetSecurityMode(mode: *mut acSecurityMode) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the connected Wifi SSID.\n # Arguments\n\n* `SSID` - Pointer to output the connected Wifi SSID to."]
    pub fn ACU_GetSSID(SSID: *mut ::libc::c_char) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the connected Wifi SSID length.\n # Arguments\n\n* `out` - Pointer to output the connected Wifi SSID length to."]
    pub fn ACU_GetSSIDLength(out: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Determines whether proxy is enabled for the connected network.\n # Arguments\n\n* `enable` - Pointer to output the proxy status to."]
    pub fn ACU_GetProxyEnable(enable: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the connected network's proxy port.\n # Arguments\n\n* `out` - Pointer to output the proxy port to."]
    pub fn ACU_GetProxyPort(out: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the connected network's proxy username.\n # Arguments\n\n* `username` - Pointer to output the proxy username to. (The size must be at least 0x20-bytes)"]
    pub fn ACU_GetProxyUserName(username: *mut ::libc::c_char) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the connected network's proxy password.\n # Arguments\n\n* `password` - Pointer to output the proxy password to. (The size must be at least 0x20-bytes)"]
    pub fn ACU_GetProxyPassword(password: *mut ::libc::c_char) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the last error to occur during a connection.\n # Arguments\n\n* `errorCode` - Pointer to output the error code to."]
    pub fn ACU_GetLastErrorCode(errorCode: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the last detailed error to occur during a connection.\n # Arguments\n\n* `errorCode` - Pointer to output the error code to."]
    pub fn ACU_GetLastDetailErrorCode(errorCode: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Prepares a buffer to hold the configuration data to start a connection.\n # Arguments\n\n* `config` - Pointer to an acuConfig struct to contain the data."]
    pub fn ACU_CreateDefaultConfig(config: *mut acuConfig) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets something that makes the connection reliable.\n # Arguments\n\n* `config` - Pointer to an acuConfig struct used with ACU_CreateDefaultConfig previously.\n * `area` - Always 2 ?"]
    pub fn ACU_SetNetworkArea(config: *mut acuConfig, area: u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the slot to use when connecting.\n # Arguments\n\n* `config` - Pointer to an acuConfig struct used with ACU_CreateDefaultConfig previously.\n * `type` - Allowed slots flag. BIT(0) for slot 1, BIT(1) for slot 2, BIT(2) for slot 3."]
    pub fn ACU_SetAllowApType(config: *mut acuConfig, type_: u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets something that makes the connection reliable.\n # Arguments\n\n* `config` - Pointer to an acuConfig struct used with ACU_CreateDefaultConfig previously."]
    pub fn ACU_SetRequestEulaVersion(config: *mut acuConfig) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Starts the connection procedure.\n # Arguments\n\n* `config` - Pointer to an acuConfig struct used with ACU_CreateDefaultConfig previously.\n * `connectionHandle` - Handle created with svcCreateEvent to wait on until the connection succeeds or fails."]
    pub fn ACU_ConnectAsync(config: *const acuConfig, connectionHandle: Handle) -> Result;
}
#[doc = "< Open for reading."]
pub const FS_OPEN_READ: _bindgen_ty_10 = 1;
#[doc = "< Open for writing."]
pub const FS_OPEN_WRITE: _bindgen_ty_10 = 2;
#[doc = "< Create file."]
pub const FS_OPEN_CREATE: _bindgen_ty_10 = 4;
#[doc = "Open flags."]
pub type _bindgen_ty_10 = ::libc::c_uint;
#[doc = "< Flush."]
pub const FS_WRITE_FLUSH: _bindgen_ty_11 = 1;
#[doc = "< Update file timestamp."]
pub const FS_WRITE_UPDATE_TIME: _bindgen_ty_11 = 256;
#[doc = "Write flags."]
pub type _bindgen_ty_11 = ::libc::c_uint;
#[doc = "< Directory."]
pub const FS_ATTRIBUTE_DIRECTORY: _bindgen_ty_12 = 1;
#[doc = "< Hidden."]
pub const FS_ATTRIBUTE_HIDDEN: _bindgen_ty_12 = 256;
#[doc = "< Archive."]
pub const FS_ATTRIBUTE_ARCHIVE: _bindgen_ty_12 = 65536;
#[doc = "< Read-only."]
pub const FS_ATTRIBUTE_READ_ONLY: _bindgen_ty_12 = 16777216;
#[doc = "Attribute flags."]
pub type _bindgen_ty_12 = ::libc::c_uint;
#[doc = "< NAND."]
pub const MEDIATYPE_NAND: FS_MediaType = 0;
#[doc = "< SD card."]
pub const MEDIATYPE_SD: FS_MediaType = 1;
#[doc = "< Game card."]
pub const MEDIATYPE_GAME_CARD: FS_MediaType = 2;
#[doc = "Media types."]
pub type FS_MediaType = ::libc::c_uint;
#[doc = "< CTR NAND."]
pub const SYSTEM_MEDIATYPE_CTR_NAND: FS_SystemMediaType = 0;
#[doc = "< TWL NAND."]
pub const SYSTEM_MEDIATYPE_TWL_NAND: FS_SystemMediaType = 1;
#[doc = "< SD card."]
pub const SYSTEM_MEDIATYPE_SD: FS_SystemMediaType = 2;
#[doc = "< TWL Photo."]
pub const SYSTEM_MEDIATYPE_TWL_PHOTO: FS_SystemMediaType = 3;
#[doc = "System media types."]
pub type FS_SystemMediaType = ::libc::c_uint;
#[doc = "< RomFS archive."]
pub const ARCHIVE_ROMFS: FS_ArchiveID = 3;
#[doc = "< Save data archive."]
pub const ARCHIVE_SAVEDATA: FS_ArchiveID = 4;
#[doc = "< Ext data archive."]
pub const ARCHIVE_EXTDATA: FS_ArchiveID = 6;
#[doc = "< Shared ext data archive."]
pub const ARCHIVE_SHARED_EXTDATA: FS_ArchiveID = 7;
#[doc = "< System save data archive."]
pub const ARCHIVE_SYSTEM_SAVEDATA: FS_ArchiveID = 8;
#[doc = "< SDMC archive."]
pub const ARCHIVE_SDMC: FS_ArchiveID = 9;
#[doc = "< Write-only SDMC archive."]
pub const ARCHIVE_SDMC_WRITE_ONLY: FS_ArchiveID = 10;
#[doc = "< BOSS ext data archive."]
pub const ARCHIVE_BOSS_EXTDATA: FS_ArchiveID = 305419896;
#[doc = "< Card SPI FS archive."]
pub const ARCHIVE_CARD_SPIFS: FS_ArchiveID = 305419897;
#[doc = "< Ext data and BOSS ext data archive."]
pub const ARCHIVE_EXTDATA_AND_BOSS_EXTDATA: FS_ArchiveID = 305419899;
#[doc = "< System save data archive."]
pub const ARCHIVE_SYSTEM_SAVEDATA2: FS_ArchiveID = 305419900;
#[doc = "< Read-write NAND archive."]
pub const ARCHIVE_NAND_RW: FS_ArchiveID = 305419901;
#[doc = "< Read-only NAND archive."]
pub const ARCHIVE_NAND_RO: FS_ArchiveID = 305419902;
#[doc = "< Read-only write access NAND archive."]
pub const ARCHIVE_NAND_RO_WRITE_ACCESS: FS_ArchiveID = 305419903;
#[doc = "< User save data and ExeFS/RomFS archive."]
pub const ARCHIVE_SAVEDATA_AND_CONTENT: FS_ArchiveID = 591751050;
#[doc = "< User save data and ExeFS/RomFS archive (only ExeFS for fs:LDR)."]
pub const ARCHIVE_SAVEDATA_AND_CONTENT2: FS_ArchiveID = 591751054;
#[doc = "< NAND CTR FS archive."]
pub const ARCHIVE_NAND_CTR_FS: FS_ArchiveID = 1450741931;
#[doc = "< TWL PHOTO archive."]
pub const ARCHIVE_TWL_PHOTO: FS_ArchiveID = 1450741932;
#[doc = "< TWL SOUND archive."]
pub const ARCHIVE_TWL_SOUND: FS_ArchiveID = 1450741933;
#[doc = "< NAND TWL FS archive."]
pub const ARCHIVE_NAND_TWL_FS: FS_ArchiveID = 1450741934;
#[doc = "< NAND W FS archive."]
pub const ARCHIVE_NAND_W_FS: FS_ArchiveID = 1450741935;
#[doc = "< Game card save data archive."]
pub const ARCHIVE_GAMECARD_SAVEDATA: FS_ArchiveID = 1450741937;
#[doc = "< User save data archive."]
pub const ARCHIVE_USER_SAVEDATA: FS_ArchiveID = 1450741938;
#[doc = "< Demo save data archive."]
pub const ARCHIVE_DEMO_SAVEDATA: FS_ArchiveID = 1450741940;
#[doc = "Archive IDs."]
pub type FS_ArchiveID = ::libc::c_uint;
#[doc = "< Invalid path."]
pub const PATH_INVALID: FS_PathType = 0;
#[doc = "< Empty path."]
pub const PATH_EMPTY: FS_PathType = 1;
#[doc = "< Binary path. Meaning is per-archive."]
pub const PATH_BINARY: FS_PathType = 2;
#[doc = "< ASCII text path."]
pub const PATH_ASCII: FS_PathType = 3;
#[doc = "< UTF-16 text path."]
pub const PATH_UTF16: FS_PathType = 4;
#[doc = "Path types."]
pub type FS_PathType = ::libc::c_uint;
#[doc = "< SD application."]
pub const SECUREVALUE_SLOT_SD: FS_SecureValueSlot = 4096;
#[doc = "Secure value slot."]
pub type FS_SecureValueSlot = ::libc::c_uint;
#[doc = "< 512KHz."]
pub const BAUDRATE_512KHZ: FS_CardSpiBaudRate = 0;
#[doc = "< 1MHz."]
pub const BAUDRATE_1MHZ: FS_CardSpiBaudRate = 1;
#[doc = "< 2MHz."]
pub const BAUDRATE_2MHZ: FS_CardSpiBaudRate = 2;
#[doc = "< 4MHz."]
pub const BAUDRATE_4MHZ: FS_CardSpiBaudRate = 3;
#[doc = "< 8MHz."]
pub const BAUDRATE_8MHZ: FS_CardSpiBaudRate = 4;
#[doc = "< 16MHz."]
pub const BAUDRATE_16MHZ: FS_CardSpiBaudRate = 5;
#[doc = "Card SPI baud rate."]
pub type FS_CardSpiBaudRate = ::libc::c_uint;
#[doc = "< 1-bit."]
pub const BUSMODE_1BIT: FS_CardSpiBusMode = 0;
#[doc = "< 4-bit."]
pub const BUSMODE_4BIT: FS_CardSpiBusMode = 1;
#[doc = "Card SPI bus mode."]
pub type FS_CardSpiBusMode = ::libc::c_uint;
#[doc = "< Update."]
pub const SPECIALCONTENT_UPDATE: FS_SpecialContentType = 1;
#[doc = "< Manual."]
pub const SPECIALCONTENT_MANUAL: FS_SpecialContentType = 2;
#[doc = "< DLP child."]
pub const SPECIALCONTENT_DLP_CHILD: FS_SpecialContentType = 3;
#[doc = "Card SPI bus mode."]
pub type FS_SpecialContentType = ::libc::c_uint;
#[doc = "< CTR card."]
pub const CARD_CTR: FS_CardType = 0;
#[doc = "< TWL card."]
pub const CARD_TWL: FS_CardType = 1;
pub type FS_CardType = ::libc::c_uint;
pub const FS_ACTION_UNKNOWN: FS_Action = 0;
#[doc = "FS control actions."]
pub type FS_Action = ::libc::c_uint;
#[doc = "< Commits save data changes. No inputs/outputs."]
pub const ARCHIVE_ACTION_COMMIT_SAVE_DATA: FS_ArchiveAction = 0;
#[doc = "< Retrieves a file's last-modified timestamp. In: \"u16*, UTF-16 Path\", Out: \"u64, Time Stamp\"."]
pub const ARCHIVE_ACTION_GET_TIMESTAMP: FS_ArchiveAction = 1;
pub const ARCHIVE_ACTION_UNKNOWN: FS_ArchiveAction = 30877;
#[doc = "Archive control actions."]
pub type FS_ArchiveAction = ::libc::c_uint;
#[doc = "< Deletes a save's secure value. In: \"u64, ((SecureValueSlot << 32) | (TitleUniqueId << 8) | TitleVariation)\", Out: \"u8, Value Existed\""]
pub const SECURESAVE_ACTION_DELETE: FS_SecureSaveAction = 0;
#[doc = "< Formats a save. No inputs/outputs."]
pub const SECURESAVE_ACTION_FORMAT: FS_SecureSaveAction = 1;
#[doc = "Secure save control actions."]
pub type FS_SecureSaveAction = ::libc::c_uint;
pub const FILE_ACTION_UNKNOWN: FS_FileAction = 0;
#[doc = "File control actions."]
pub type FS_FileAction = ::libc::c_uint;
pub const DIRECTORY_ACTION_UNKNOWN: FS_DirectoryAction = 0;
#[doc = "Directory control actions."]
pub type FS_DirectoryAction = ::libc::c_uint;
#[doc = "Directory entry."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FS_DirectoryEntry {
    #[doc = "< UTF-16 directory name."]
    pub name: [u16_; 262usize],
    #[doc = "< File name."]
    pub shortName: [::libc::c_char; 10usize],
    #[doc = "< File extension."]
    pub shortExt: [::libc::c_char; 4usize],
    #[doc = "< Valid flag. (Always 1)"]
    pub valid: u8_,
    #[doc = "< Reserved."]
    pub reserved: u8_,
    #[doc = "< Attributes."]
    pub attributes: u32_,
    #[doc = "< File size."]
    pub fileSize: u64_,
}
impl Default for FS_DirectoryEntry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Archive resource information."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FS_ArchiveResource {
    #[doc = "< Size of each sector, in bytes."]
    pub sectorSize: u32_,
    #[doc = "< Size of each cluster, in bytes."]
    pub clusterSize: u32_,
    #[doc = "< Total number of clusters."]
    pub totalClusters: u32_,
    #[doc = "< Number of free clusters."]
    pub freeClusters: u32_,
}
#[doc = "Program information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FS_ProgramInfo {
    #[doc = "< Program ID."]
    pub programId: u64_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< Padding."]
    pub padding: [u8_; 7usize],
}
impl Default for FS_ProgramInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl FS_ProgramInfo {
    #[inline]
    pub fn mediaType(&self) -> FS_MediaType {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_mediaType(&mut self, val: FS_MediaType) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(mediaType: FS_MediaType) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let mediaType: u32 = unsafe { ::core::mem::transmute(mediaType) };
            mediaType as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "Product information."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FS_ProductInfo {
    #[doc = "< Product code."]
    pub productCode: [::libc::c_char; 16usize],
    #[doc = "< Company code."]
    pub companyCode: [::libc::c_char; 2usize],
    #[doc = "< Remaster version."]
    pub remasterVersion: u16_,
}
#[doc = "Integrity verification seed."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FS_IntegrityVerificationSeed {
    #[doc = "< AES-CBC MAC over a SHA256 hash, which hashes the first 0x110-bytes of the cleartext SEED."]
    pub aesCbcMac: [u8_; 16usize],
    #[doc = "< The \"nand/private/movable.sed\", encrypted with AES-CTR using the above MAC for the counter."]
    pub movableSed: [u8_; 288usize],
}
impl Default for FS_IntegrityVerificationSeed {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Ext save data information."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct FS_ExtSaveDataInfo {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< Unknown."]
    pub unknown: u8_,
    #[doc = "< Reserved."]
    pub reserved1: u16_,
    #[doc = "< Save ID."]
    pub saveId: u64_,
    #[doc = "< Reserved."]
    pub reserved2: u32_,
}
impl Default for FS_ExtSaveDataInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl FS_ExtSaveDataInfo {
    #[inline]
    pub fn mediaType(&self) -> FS_MediaType {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_mediaType(&mut self, val: FS_MediaType) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(mediaType: FS_MediaType) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let mediaType: u32 = unsafe { ::core::mem::transmute(mediaType) };
            mediaType as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "System save data information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FS_SystemSaveDataInfo {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< Unknown."]
    pub unknown: u8_,
    #[doc = "< Reserved."]
    pub reserved: u16_,
    #[doc = "< Save ID."]
    pub saveId: u32_,
}
impl Default for FS_SystemSaveDataInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl FS_SystemSaveDataInfo {
    #[inline]
    pub fn mediaType(&self) -> FS_MediaType {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_mediaType(&mut self, val: FS_MediaType) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(mediaType: FS_MediaType) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let mediaType: u32 = unsafe { ::core::mem::transmute(mediaType) };
            mediaType as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "Device move context."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FS_DeviceMoveContext {
    #[doc = "< IVs."]
    pub ivs: [u8_; 16usize],
    #[doc = "< Encrypt parameter."]
    pub encryptParameter: [u8_; 16usize],
}
#[doc = "Filesystem path data, detailing the specific target of an operation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FS_Path {
    #[doc = "< FS path type."]
    pub type_: FS_PathType,
    #[doc = "< FS path size."]
    pub size: u32_,
    #[doc = "< Pointer to FS path data."]
    pub data: *const ::libc::c_void,
}
impl Default for FS_Path {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "SDMC/NAND speed information"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FS_SdMmcSpeedInfo {
    #[doc = "< Whether or not High Speed Mode is enabled."]
    pub highSpeedModeEnabled: bool,
    #[doc = "< Whether or not a clock divider of 2 is being used."]
    pub usesHighestClockRate: bool,
    #[doc = "< The value of the SD_CLK_CTRL register."]
    pub sdClkCtrl: u16_,
}
#[doc = "Filesystem archive handle, providing access to a filesystem's contents."]
pub type FS_Archive = u64_;
extern "C" {
    #[must_use]
    #[doc = "Initializes FS."]
    pub fn fsInit() -> Result;
}
extern "C" {
    #[doc = "Exits FS."]
    pub fn fsExit();
}
extern "C" {
    #[doc = "Sets the FSUSER session to use in the current thread.\n # Arguments\n\n* `session` - The handle of the FSUSER session to use."]
    pub fn fsUseSession(session: Handle);
}
extern "C" {
    #[doc = "Disables the FSUSER session override in the current thread."]
    pub fn fsEndUseSession();
}
extern "C" {
    #[doc = "Exempts an archive from using alternate FS session handles provided with fsUseSession\n Instead, the archive will use the default FS session handle, opened with srvGetSessionHandle\n # Arguments\n\n* `archive` - Archive to exempt."]
    pub fn fsExemptFromSession(archive: FS_Archive);
}
extern "C" {
    #[doc = "Unexempts an archive from using alternate FS session handles provided with fsUseSession\n # Arguments\n\n* `archive` - Archive to remove from the exemption list."]
    pub fn fsUnexemptFromSession(archive: FS_Archive);
}
extern "C" {
    #[doc = "Creates an FS_Path instance.\n # Arguments\n\n* `type` - Type of path.\n * `path` - Path to use.\n # Returns\n\nThe created FS_Path instance."]
    pub fn fsMakePath(type_: FS_PathType, path: *const ::libc::c_void) -> FS_Path;
}
extern "C" {
    #[doc = "Gets the current FS session handle.\n # Returns\n\nThe current FS session handle."]
    pub fn fsGetSessionHandle() -> *mut Handle;
}
extern "C" {
    #[must_use]
    #[doc = "Performs a control operation on the filesystem.\n # Arguments\n\n* `action` - Action to perform.\n * `input` - Buffer to read input from.\n * `inputSize` - Size of the input.\n * `output` - Buffer to write output to.\n * `outputSize` - Size of the output."]
    pub fn FSUSER_Control(
        action: FS_Action,
        input: *mut ::libc::c_void,
        inputSize: u32_,
        output: *mut ::libc::c_void,
        outputSize: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initializes a FSUSER session.\n # Arguments\n\n* `session` - The handle of the FSUSER session to initialize."]
    pub fn FSUSER_Initialize(session: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Opens a file.\n # Arguments\n\n* `out` - Pointer to output the file handle to.\n * `archive` - Archive containing the file.\n * `path` - Path of the file.\n * `openFlags` - Flags to open the file with.\n * `attributes` - Attributes of the file."]
    pub fn FSUSER_OpenFile(
        out: *mut Handle,
        archive: FS_Archive,
        path: FS_Path,
        openFlags: u32_,
        attributes: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Opens a file directly, bypassing the requirement of an opened archive handle.\n # Arguments\n\n* `out` - Pointer to output the file handle to.\n * `archiveId` - ID of the archive containing the file.\n * `archivePath` - Path of the archive containing the file.\n * `filePath` - Path of the file.\n * `openFlags` - Flags to open the file with.\n * `attributes` - Attributes of the file."]
    pub fn FSUSER_OpenFileDirectly(
        out: *mut Handle,
        archiveId: FS_ArchiveID,
        archivePath: FS_Path,
        filePath: FS_Path,
        openFlags: u32_,
        attributes: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Deletes a file.\n # Arguments\n\n* `archive` - Archive containing the file.\n * `path` - Path of the file."]
    pub fn FSUSER_DeleteFile(archive: FS_Archive, path: FS_Path) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Renames a file.\n # Arguments\n\n* `srcArchive` - Archive containing the source file.\n * `srcPath` - Path of the source file.\n * `dstArchive` - Archive containing the destination file.\n * `dstPath` - Path of the destination file."]
    pub fn FSUSER_RenameFile(
        srcArchive: FS_Archive,
        srcPath: FS_Path,
        dstArchive: FS_Archive,
        dstPath: FS_Path,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Deletes a directory, failing if it is not empty.\n # Arguments\n\n* `archive` - Archive containing the directory.\n * `path` - Path of the directory."]
    pub fn FSUSER_DeleteDirectory(archive: FS_Archive, path: FS_Path) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Deletes a directory, also deleting its contents.\n # Arguments\n\n* `archive` - Archive containing the directory.\n * `path` - Path of the directory."]
    pub fn FSUSER_DeleteDirectoryRecursively(archive: FS_Archive, path: FS_Path) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Creates a file.\n # Arguments\n\n* `archive` - Archive to create the file in.\n * `path` - Path of the file.\n * `attributes` - Attributes of the file.\n * `fileSize` - Size of the file."]
    pub fn FSUSER_CreateFile(
        archive: FS_Archive,
        path: FS_Path,
        attributes: u32_,
        fileSize: u64_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Creates a directory\n # Arguments\n\n* `archive` - Archive to create the directory in.\n * `path` - Path of the directory.\n * `attributes` - Attributes of the directory."]
    pub fn FSUSER_CreateDirectory(archive: FS_Archive, path: FS_Path, attributes: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Renames a directory.\n # Arguments\n\n* `srcArchive` - Archive containing the source directory.\n * `srcPath` - Path of the source directory.\n * `dstArchive` - Archive containing the destination directory.\n * `dstPath` - Path of the destination directory."]
    pub fn FSUSER_RenameDirectory(
        srcArchive: FS_Archive,
        srcPath: FS_Path,
        dstArchive: FS_Archive,
        dstPath: FS_Path,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Opens a directory.\n # Arguments\n\n* `out` - Pointer to output the directory handle to.\n * `archive` - Archive containing the directory.\n * `path` - Path of the directory."]
    pub fn FSUSER_OpenDirectory(out: *mut Handle, archive: FS_Archive, path: FS_Path) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Opens an archive.\n # Arguments\n\n* `archive` - Pointer to output the opened archive to.\n * `id` - ID of the archive.\n * `path` - Path of the archive."]
    pub fn FSUSER_OpenArchive(archive: *mut FS_Archive, id: FS_ArchiveID, path: FS_Path) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Performs a control operation on an archive.\n # Arguments\n\n* `archive` - Archive to control.\n * `action` - Action to perform.\n * `input` - Buffer to read input from.\n * `inputSize` - Size of the input.\n * `output` - Buffer to write output to.\n * `outputSize` - Size of the output."]
    pub fn FSUSER_ControlArchive(
        archive: FS_Archive,
        action: FS_ArchiveAction,
        input: *mut ::libc::c_void,
        inputSize: u32_,
        output: *mut ::libc::c_void,
        outputSize: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Closes an archive.\n # Arguments\n\n* `archive` - Archive to close."]
    pub fn FSUSER_CloseArchive(archive: FS_Archive) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the number of free bytes within an archive.\n # Arguments\n\n* `freeBytes` - Pointer to output the free bytes to.\n * `archive` - Archive to check."]
    pub fn FSUSER_GetFreeBytes(freeBytes: *mut u64_, archive: FS_Archive) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the inserted card type.\n # Arguments\n\n* `type` - Pointer to output the card type to."]
    pub fn FSUSER_GetCardType(type_: *mut FS_CardType) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the SDMC archive resource information.\n # Arguments\n\n* `archiveResource` - Pointer to output the archive resource information to."]
    pub fn FSUSER_GetSdmcArchiveResource(archiveResource: *mut FS_ArchiveResource) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the NAND archive resource information.\n # Arguments\n\n* `archiveResource` - Pointer to output the archive resource information to."]
    pub fn FSUSER_GetNandArchiveResource(archiveResource: *mut FS_ArchiveResource) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the last SDMC fatfs error.\n # Arguments\n\n* `error` - Pointer to output the error to."]
    pub fn FSUSER_GetSdmcFatfsError(error: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets whether an SD card is detected.\n # Arguments\n\n* `detected` - Pointer to output the detection status to."]
    pub fn FSUSER_IsSdmcDetected(detected: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets whether the SD card is writable.\n # Arguments\n\n* `writable` - Pointer to output the writable status to."]
    pub fn FSUSER_IsSdmcWritable(writable: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the SDMC CID.\n # Arguments\n\n* `out` - Pointer to output the CID to.\n * `length` - Length of the CID buffer. (should be 0x10)"]
    pub fn FSUSER_GetSdmcCid(out: *mut u8_, length: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the NAND CID.\n # Arguments\n\n* `out` - Pointer to output the CID to.\n * `length` - Length of the CID buffer. (should be 0x10)"]
    pub fn FSUSER_GetNandCid(out: *mut u8_, length: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the SDMC speed info.\n # Arguments\n\n* `speedInfo` - Pointer to output the speed info to."]
    pub fn FSUSER_GetSdmcSpeedInfo(speedInfo: *mut FS_SdMmcSpeedInfo) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the NAND speed info.\n # Arguments\n\n* `speedInfo` - Pointer to output the speed info to."]
    pub fn FSUSER_GetNandSpeedInfo(speedInfo: *mut FS_SdMmcSpeedInfo) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the SDMC log.\n # Arguments\n\n* `out` - Pointer to output the log to.\n * `length` - Length of the log buffer."]
    pub fn FSUSER_GetSdmcLog(out: *mut u8_, length: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the NAND log.\n # Arguments\n\n* `out` - Pointer to output the log to.\n * `length` - Length of the log buffer."]
    pub fn FSUSER_GetNandLog(out: *mut u8_, length: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Clears the SDMC log."]
    pub fn FSUSER_ClearSdmcLog() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Clears the NAND log."]
    pub fn FSUSER_ClearNandLog() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets whether a card is inserted.\n # Arguments\n\n* `inserted` - Pointer to output the insertion status to."]
    pub fn FSUSER_CardSlotIsInserted(inserted: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Powers on the card slot.\n # Arguments\n\n* `status` - Pointer to output the power status to."]
    pub fn FSUSER_CardSlotPowerOn(status: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Powers off the card slot.\n # Arguments\n\n* `status` - Pointer to output the power status to."]
    pub fn FSUSER_CardSlotPowerOff(status: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the card's power status.\n # Arguments\n\n* `status` - Pointer to output the power status to."]
    pub fn FSUSER_CardSlotGetCardIFPowerStatus(status: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Executes a CARDNOR direct command.\n # Arguments\n\n* `commandId` - ID of the command."]
    pub fn FSUSER_CardNorDirectCommand(commandId: u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Executes a CARDNOR direct command with an address.\n # Arguments\n\n* `commandId` - ID of the command.\n * `address` - Address to provide."]
    pub fn FSUSER_CardNorDirectCommandWithAddress(commandId: u8_, address: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Executes a CARDNOR direct read.\n # Arguments\n\n* `commandId` - ID of the command.\n * `size` - Size of the output buffer.\n * `output` - Output buffer."]
    pub fn FSUSER_CardNorDirectRead(
        commandId: u8_,
        size: u32_,
        output: *mut ::libc::c_void,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Executes a CARDNOR direct read with an address.\n # Arguments\n\n* `commandId` - ID of the command.\n * `address` - Address to provide.\n * `size` - Size of the output buffer.\n * `output` - Output buffer."]
    pub fn FSUSER_CardNorDirectReadWithAddress(
        commandId: u8_,
        address: u32_,
        size: u32_,
        output: *mut ::libc::c_void,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Executes a CARDNOR direct write.\n # Arguments\n\n* `commandId` - ID of the command.\n * `size` - Size of the input buffer.\n * `output` - Input buffer."]
    pub fn FSUSER_CardNorDirectWrite(
        commandId: u8_,
        size: u32_,
        input: *const ::libc::c_void,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Executes a CARDNOR direct write with an address.\n # Arguments\n\n* `commandId` - ID of the command.\n * `address` - Address to provide.\n * `size` - Size of the input buffer.\n * `input` - Input buffer."]
    pub fn FSUSER_CardNorDirectWriteWithAddress(
        commandId: u8_,
        address: u32_,
        size: u32_,
        input: *const ::libc::c_void,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Executes a CARDNOR 4xIO direct read.\n # Arguments\n\n* `commandId` - ID of the command.\n * `address` - Address to provide.\n * `size` - Size of the output buffer.\n * `output` - Output buffer."]
    pub fn FSUSER_CardNorDirectRead_4xIO(
        commandId: u8_,
        address: u32_,
        size: u32_,
        output: *mut ::libc::c_void,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Executes a CARDNOR direct CPU write without verify.\n # Arguments\n\n* `address` - Address to provide.\n * `size` - Size of the input buffer.\n * `output` - Input buffer."]
    pub fn FSUSER_CardNorDirectCpuWriteWithoutVerify(
        address: u32_,
        size: u32_,
        input: *const ::libc::c_void,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Executes a CARDNOR direct sector erase without verify.\n # Arguments\n\n* `address` - Address to provide."]
    pub fn FSUSER_CardNorDirectSectorEraseWithoutVerify(address: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets a process's product info.\n # Arguments\n\n* `info` - Pointer to output the product info to.\n * `processId` - ID of the process."]
    pub fn FSUSER_GetProductInfo(info: *mut FS_ProductInfo, processId: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets a process's program launch info.\n # Arguments\n\n* `info` - Pointer to output the program launch info to.\n * `processId` - ID of the process."]
    pub fn FSUSER_GetProgramLaunchInfo(info: *mut FS_ProgramInfo, processId: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the CARDSPI baud rate.\n # Arguments\n\n* `baudRate` - Baud rate to set."]
    pub fn FSUSER_SetCardSpiBaudRate(baudRate: FS_CardSpiBaudRate) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the CARDSPI bus mode.\n # Arguments\n\n* `busMode` - Bus mode to set."]
    pub fn FSUSER_SetCardSpiBusMode(busMode: FS_CardSpiBusMode) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sends initialization info to ARM9."]
    pub fn FSUSER_SendInitializeInfoTo9() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets a special content's index.\n # Arguments\n\n* `index` - Pointer to output the index to.\n * `mediaType` - Media type of the special content.\n * `programId` - Program ID owning the special content.\n * `type` - Type of special content."]
    pub fn FSUSER_GetSpecialContentIndex(
        index: *mut u16_,
        mediaType: FS_MediaType,
        programId: u64_,
        type_: FS_SpecialContentType,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the legacy ROM header of a program.\n # Arguments\n\n* `mediaType` - Media type of the program.\n * `programId` - ID of the program.\n * `header` - Pointer to output the legacy ROM header to. (size = 0x3B4)"]
    pub fn FSUSER_GetLegacyRomHeader(
        mediaType: FS_MediaType,
        programId: u64_,
        header: *mut ::libc::c_void,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the legacy banner data of a program.\n # Arguments\n\n* `mediaType` - Media type of the program.\n * `programId` - ID of the program.\n * `header` - Pointer to output the legacy banner data to. (size = 0x23C0)"]
    pub fn FSUSER_GetLegacyBannerData(
        mediaType: FS_MediaType,
        programId: u64_,
        banner: *mut ::libc::c_void,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Checks a process's authority to access a save data archive.\n # Arguments\n\n* `access` - Pointer to output the access status to.\n * `mediaType` - Media type of the save data.\n * `saveId` - ID of the save data.\n * `processId` - ID of the process to check."]
    pub fn FSUSER_CheckAuthorityToAccessExtSaveData(
        access: *mut bool,
        mediaType: FS_MediaType,
        saveId: u64_,
        processId: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Queries the total quota size of a save data archive.\n # Arguments\n\n* `quotaSize` - Pointer to output the quota size to.\n * `directories` - Number of directories.\n * `files` - Number of files.\n * `fileSizeCount` - Number of file sizes to provide.\n * `fileSizes` - File sizes to provide."]
    pub fn FSUSER_QueryTotalQuotaSize(
        quotaSize: *mut u64_,
        directories: u32_,
        files: u32_,
        fileSizeCount: u32_,
        fileSizes: *mut u64_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Abnegates an access right.\n # Arguments\n\n* `accessRight` - Access right to abnegate."]
    pub fn FSUSER_AbnegateAccessRight(accessRight: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Deletes the 3DS SDMC root."]
    pub fn FSUSER_DeleteSdmcRoot() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Deletes all ext save data on the NAND."]
    pub fn FSUSER_DeleteAllExtSaveDataOnNand() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initializes the CTR file system."]
    pub fn FSUSER_InitializeCtrFileSystem() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Creates the FS seed."]
    pub fn FSUSER_CreateSeed() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Retrieves archive format info.\n # Arguments\n\n* `totalSize` - Pointer to output the total size to.\n * `directories` - Pointer to output the number of directories to.\n * `files` - Pointer to output the number of files to.\n * `duplicateData` - Pointer to output whether to duplicate data to.\n * `archiveId` - ID of the archive.\n * `path` - Path of the archive."]
    pub fn FSUSER_GetFormatInfo(
        totalSize: *mut u32_,
        directories: *mut u32_,
        files: *mut u32_,
        duplicateData: *mut bool,
        archiveId: FS_ArchiveID,
        path: FS_Path,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the legacy ROM header of a program.\n # Arguments\n\n* `headerSize` - Size of the ROM header.\n * `mediaType` - Media type of the program.\n * `programId` - ID of the program.\n * `header` - Pointer to output the legacy ROM header to."]
    pub fn FSUSER_GetLegacyRomHeader2(
        headerSize: u32_,
        mediaType: FS_MediaType,
        programId: u64_,
        header: *mut ::libc::c_void,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the CTR SDMC root path.\n # Arguments\n\n* `out` - Pointer to output the root path to.\n * `length` - Length of the output buffer."]
    pub fn FSUSER_GetSdmcCtrRootPath(out: *mut u8_, length: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets an archive's resource information.\n # Arguments\n\n* `archiveResource` - Pointer to output the archive resource information to.\n * `mediaType` - System media type to check."]
    pub fn FSUSER_GetArchiveResource(
        archiveResource: *mut FS_ArchiveResource,
        mediaType: FS_SystemMediaType,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Exports the integrity verification seed.\n # Arguments\n\n* `seed` - Pointer to output the seed to."]
    pub fn FSUSER_ExportIntegrityVerificationSeed(
        seed: *mut FS_IntegrityVerificationSeed,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Imports an integrity verification seed.\n # Arguments\n\n* `seed` - Seed to import."]
    pub fn FSUSER_ImportIntegrityVerificationSeed(
        seed: *mut FS_IntegrityVerificationSeed,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Formats save data.\n # Arguments\n\n* `archiveId` - ID of the save data archive.\n * `path` - Path of the save data.\n * `blocks` - Size of the save data in blocks. (512 bytes)\n * `directories` - Number of directories.\n * `files` - Number of files.\n * `directoryBuckets` - Directory hash tree bucket count.\n * `fileBuckets` - File hash tree bucket count.\n * `duplicateData` - Whether to store an internal duplicate of the data."]
    pub fn FSUSER_FormatSaveData(
        archiveId: FS_ArchiveID,
        path: FS_Path,
        blocks: u32_,
        directories: u32_,
        files: u32_,
        directoryBuckets: u32_,
        fileBuckets: u32_,
        duplicateData: bool,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the legacy sub banner data of a program.\n # Arguments\n\n* `bannerSize` - Size of the banner.\n * `mediaType` - Media type of the program.\n * `programId` - ID of the program.\n * `header` - Pointer to output the legacy sub banner data to."]
    pub fn FSUSER_GetLegacySubBannerData(
        bannerSize: u32_,
        mediaType: FS_MediaType,
        programId: u64_,
        banner: *mut ::libc::c_void,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Hashes the given data and outputs a SHA256 hash.\n # Arguments\n\n* `data` - Pointer to the data to be hashed.\n * `inputSize` - The size of the data.\n * `hash` - Hash output pointer."]
    pub fn FSUSER_UpdateSha256Context(
        data: *const ::libc::c_void,
        inputSize: u32_,
        hash: *mut u8_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Reads from a special file.\n # Arguments\n\n* `bytesRead` - Pointer to output the number of bytes read to.\n * `fileOffset` - Offset of the file.\n * `size` - Size of the buffer.\n * `data` - Buffer to read to."]
    pub fn FSUSER_ReadSpecialFile(
        bytesRead: *mut u32_,
        fileOffset: u64_,
        size: u32_,
        data: *mut ::libc::c_void,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the size of a special file.\n # Arguments\n\n* `fileSize` - Pointer to output the size to."]
    pub fn FSUSER_GetSpecialFileSize(fileSize: *mut u64_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Creates ext save data.\n # Arguments\n\n* `info` - Info of the save data.\n * `directories` - Number of directories.\n * `files` - Number of files.\n * `sizeLimit` - Size limit of the save data.\n * `smdhSize` - Size of the save data's SMDH data.\n * `smdh` - SMDH data."]
    pub fn FSUSER_CreateExtSaveData(
        info: FS_ExtSaveDataInfo,
        directories: u32_,
        files: u32_,
        sizeLimit: u64_,
        smdhSize: u32_,
        smdh: *mut u8_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Deletes ext save data.\n # Arguments\n\n* `info` - Info of the save data."]
    pub fn FSUSER_DeleteExtSaveData(info: FS_ExtSaveDataInfo) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Reads the SMDH icon of ext save data.\n # Arguments\n\n* `bytesRead` - Pointer to output the number of bytes read to.\n * `info` - Info of the save data.\n * `smdhSize` - Size of the save data SMDH.\n * `smdh` - Pointer to output SMDH data to."]
    pub fn FSUSER_ReadExtSaveDataIcon(
        bytesRead: *mut u32_,
        info: FS_ExtSaveDataInfo,
        smdhSize: u32_,
        smdh: *mut u8_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets an ext data archive's block information.\n # Arguments\n\n* `totalBlocks` - Pointer to output the total blocks to.\n * `freeBlocks` - Pointer to output the free blocks to.\n * `blockSize` - Pointer to output the block size to.\n * `info` - Info of the save data."]
    pub fn FSUSER_GetExtDataBlockSize(
        totalBlocks: *mut u64_,
        freeBlocks: *mut u64_,
        blockSize: *mut u32_,
        info: FS_ExtSaveDataInfo,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Enumerates ext save data.\n # Arguments\n\n* `idsWritten` - Pointer to output the number of IDs written to.\n * `idsSize` - Size of the IDs buffer.\n * `mediaType` - Media type to enumerate over.\n * `idSize` - Size of each ID element.\n * `shared` - Whether to enumerate shared ext save data.\n * `ids` - Pointer to output IDs to."]
    pub fn FSUSER_EnumerateExtSaveData(
        idsWritten: *mut u32_,
        idsSize: u32_,
        mediaType: FS_MediaType,
        idSize: u32_,
        shared: bool,
        ids: *mut u8_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Creates system save data.\n # Arguments\n\n* `info` - Info of the save data.\n * `totalSize` - Total size of the save data.\n * `blockSize` - Block size of the save data. (usually 0x1000)\n * `directories` - Number of directories.\n * `files` - Number of files.\n * `directoryBuckets` - Directory hash tree bucket count.\n * `fileBuckets` - File hash tree bucket count.\n * `duplicateData` - Whether to store an internal duplicate of the data."]
    pub fn FSUSER_CreateSystemSaveData(
        info: FS_SystemSaveDataInfo,
        totalSize: u32_,
        blockSize: u32_,
        directories: u32_,
        files: u32_,
        directoryBuckets: u32_,
        fileBuckets: u32_,
        duplicateData: bool,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Deletes system save data.\n # Arguments\n\n* `info` - Info of the save data."]
    pub fn FSUSER_DeleteSystemSaveData(info: FS_SystemSaveDataInfo) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initiates a device move as the source device.\n # Arguments\n\n* `context` - Pointer to output the context to."]
    pub fn FSUSER_StartDeviceMoveAsSource(context: *mut FS_DeviceMoveContext) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initiates a device move as the destination device.\n # Arguments\n\n* `context` - Context to use.\n * `clear` - Whether to clear the device's data first."]
    pub fn FSUSER_StartDeviceMoveAsDestination(
        context: FS_DeviceMoveContext,
        clear: bool,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets an archive's priority.\n # Arguments\n\n* `archive` - Archive to use.\n * `priority` - Priority to set."]
    pub fn FSUSER_SetArchivePriority(archive: FS_Archive, priority: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets an archive's priority.\n # Arguments\n\n* `priority` - Pointer to output the priority to.\n * `archive` - Archive to use."]
    pub fn FSUSER_GetArchivePriority(priority: *mut u32_, archive: FS_Archive) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Configures CTRCARD latency emulation.\n # Arguments\n\n* `latency` - Latency to apply, in milliseconds.\n * `emulateEndurance` - Whether to emulate card endurance."]
    pub fn FSUSER_SetCtrCardLatencyParameter(latency: u64_, emulateEndurance: bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Toggles cleaning up invalid save data.\n # Arguments\n\n* `enable` - Whether to enable cleaning up invalid save data."]
    pub fn FSUSER_SwitchCleanupInvalidSaveData(enable: bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Enumerates system save data.\n # Arguments\n\n* `idsWritten` - Pointer to output the number of IDs written to.\n * `idsSize` - Size of the IDs buffer.\n * `ids` - Pointer to output IDs to."]
    pub fn FSUSER_EnumerateSystemSaveData(
        idsWritten: *mut u32_,
        idsSize: u32_,
        ids: *mut u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initializes a FSUSER session with an SDK version.\n # Arguments\n\n* `session` - The handle of the FSUSER session to initialize.\n * `version` - SDK version to initialize with."]
    pub fn FSUSER_InitializeWithSdkVersion(session: Handle, version: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the file system priority.\n # Arguments\n\n* `priority` - Priority to set."]
    pub fn FSUSER_SetPriority(priority: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the file system priority.\n # Arguments\n\n* `priority` - Pointer to output the priority to."]
    pub fn FSUSER_GetPriority(priority: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the save data secure value.\n # Arguments\n\n* `value` - Secure value to set.\n * `slot` - Slot of the secure value.\n * `titleUniqueId` - Unique ID of the title. (default = 0)\n * `titleVariation` - Variation of the title. (default = 0)"]
    pub fn FSUSER_SetSaveDataSecureValue(
        value: u64_,
        slot: FS_SecureValueSlot,
        titleUniqueId: u32_,
        titleVariation: u8_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the save data secure value.\n # Arguments\n\n* `exists` - Pointer to output whether the secure value exists to.\n * `value` - Pointer to output the secure value to.\n * `slot` - Slot of the secure value.\n * `titleUniqueId` - Unique ID of the title. (default = 0)\n * `titleVariation` - Variation of the title. (default = 0)"]
    pub fn FSUSER_GetSaveDataSecureValue(
        exists: *mut bool,
        value: *mut u64_,
        slot: FS_SecureValueSlot,
        titleUniqueId: u32_,
        titleVariation: u8_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Performs a control operation on a secure save.\n # Arguments\n\n* `action` - Action to perform.\n * `input` - Buffer to read input from.\n * `inputSize` - Size of the input.\n * `output` - Buffer to write output to.\n * `outputSize` - Size of the output."]
    pub fn FSUSER_ControlSecureSave(
        action: FS_SecureSaveAction,
        input: *mut ::libc::c_void,
        inputSize: u32_,
        output: *mut ::libc::c_void,
        outputSize: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the media type of the current application.\n # Arguments\n\n* `mediaType` - Pointer to output the media type to."]
    pub fn FSUSER_GetMediaType(mediaType: *mut FS_MediaType) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Performs a control operation on a file.\n # Arguments\n\n* `handle` - Handle of the file.\n * `action` - Action to perform.\n * `input` - Buffer to read input from.\n * `inputSize` - Size of the input.\n * `output` - Buffer to write output to.\n * `outputSize` - Size of the output."]
    pub fn FSFILE_Control(
        handle: Handle,
        action: FS_FileAction,
        input: *mut ::libc::c_void,
        inputSize: u32_,
        output: *mut ::libc::c_void,
        outputSize: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Opens a handle to a sub-section of a file.\n # Arguments\n\n* `handle` - Handle of the file.\n * `subFile` - Pointer to output the sub-file to.\n * `offset` - Offset of the sub-section.\n * `size` - Size of the sub-section."]
    pub fn FSFILE_OpenSubFile(
        handle: Handle,
        subFile: *mut Handle,
        offset: u64_,
        size: u64_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Reads from a file.\n # Arguments\n\n* `handle` - Handle of the file.\n * `bytesRead` - Pointer to output the number of bytes read to.\n * `offset` - Offset to read from.\n * `buffer` - Buffer to read to.\n * `size` - Size of the buffer."]
    pub fn FSFILE_Read(
        handle: Handle,
        bytesRead: *mut u32_,
        offset: u64_,
        buffer: *mut ::libc::c_void,
        size: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Writes to a file.\n # Arguments\n\n* `handle` - Handle of the file.\n * `bytesWritten` - Pointer to output the number of bytes written to.\n * `offset` - Offset to write to.\n * `buffer` - Buffer to write from.\n * `size` - Size of the buffer.\n * `flags` - Flags to use when writing."]
    pub fn FSFILE_Write(
        handle: Handle,
        bytesWritten: *mut u32_,
        offset: u64_,
        buffer: *const ::libc::c_void,
        size: u32_,
        flags: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the size of a file.\n # Arguments\n\n* `handle` - Handle of the file.\n * `size` - Pointer to output the size to."]
    pub fn FSFILE_GetSize(handle: Handle, size: *mut u64_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the size of a file.\n # Arguments\n\n* `handle` - Handle of the file.\n * `size` - Size to set."]
    pub fn FSFILE_SetSize(handle: Handle, size: u64_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the attributes of a file.\n # Arguments\n\n* `handle` - Handle of the file.\n * `attributes` - Pointer to output the attributes to."]
    pub fn FSFILE_GetAttributes(handle: Handle, attributes: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the attributes of a file.\n # Arguments\n\n* `handle` - Handle of the file.\n * `attributes` - Attributes to set."]
    pub fn FSFILE_SetAttributes(handle: Handle, attributes: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Closes a file.\n # Arguments\n\n* `handle` - Handle of the file."]
    pub fn FSFILE_Close(handle: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Flushes a file's contents.\n # Arguments\n\n* `handle` - Handle of the file."]
    pub fn FSFILE_Flush(handle: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets a file's priority.\n # Arguments\n\n* `handle` - Handle of the file.\n * `priority` - Priority to set."]
    pub fn FSFILE_SetPriority(handle: Handle, priority: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets a file's priority.\n # Arguments\n\n* `handle` - Handle of the file.\n * `priority` - Pointer to output the priority to."]
    pub fn FSFILE_GetPriority(handle: Handle, priority: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Opens a duplicate handle to a file.\n # Arguments\n\n* `handle` - Handle of the file.\n * `linkFile` - Pointer to output the link handle to."]
    pub fn FSFILE_OpenLinkFile(handle: Handle, linkFile: *mut Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Performs a control operation on a directory.\n # Arguments\n\n* `handle` - Handle of the directory.\n * `action` - Action to perform.\n * `input` - Buffer to read input from.\n * `inputSize` - Size of the input.\n * `output` - Buffer to write output to.\n * `outputSize` - Size of the output."]
    pub fn FSDIR_Control(
        handle: Handle,
        action: FS_DirectoryAction,
        input: *mut ::libc::c_void,
        inputSize: u32_,
        output: *mut ::libc::c_void,
        outputSize: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Reads one or more directory entries.\n # Arguments\n\n* `handle` - Handle of the directory.\n * `entriesRead` - Pointer to output the number of entries read to.\n * `entryCount` - Number of entries to read.\n * `entryOut` - Pointer to output directory entries to."]
    pub fn FSDIR_Read(
        handle: Handle,
        entriesRead: *mut u32_,
        entryCount: u32_,
        entries: *mut FS_DirectoryEntry,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Closes a directory.\n # Arguments\n\n* `handle` - Handle of the directory."]
    pub fn FSDIR_Close(handle: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets a directory's priority.\n # Arguments\n\n* `handle` - Handle of the directory.\n * `priority` - Priority to set."]
    pub fn FSDIR_SetPriority(handle: Handle, priority: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets a directory's priority.\n # Arguments\n\n* `handle` - Handle of the directory.\n * `priority` - Pointer to output the priority to."]
    pub fn FSDIR_GetPriority(handle: Handle, priority: *mut u32_) -> Result;
}
#[doc = "Contains basic information about a title."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AM_TitleEntry {
    #[doc = "< The title's ID."]
    pub titleID: u64_,
    #[doc = "< The title's installed size."]
    pub size: u64_,
    #[doc = "< The title's version."]
    pub version: u16_,
    #[doc = "< Unknown title data."]
    pub unk: [u8_; 6usize],
}
#[doc = "< Titles currently installing."]
pub const AM_STATUS_MASK_INSTALLING: _bindgen_ty_13 = 1;
#[doc = "< Titles awaiting finalization."]
pub const AM_STATUS_MASK_AWAITING_FINALIZATION: _bindgen_ty_13 = 2;
#[doc = "Pending title status mask values."]
pub type _bindgen_ty_13 = ::libc::c_uint;
#[doc = "< Install aborted."]
pub const AM_STATUS_ABORTED: AM_InstallStatus = 2;
#[doc = "< Title saved, but not installed."]
pub const AM_STATUS_SAVED: AM_InstallStatus = 3;
#[doc = "< Install in progress."]
pub const AM_STATUS_INSTALL_IN_PROGRESS: AM_InstallStatus = 2050;
#[doc = "< Awaiting finalization."]
pub const AM_STATUS_AWAITING_FINALIZATION: AM_InstallStatus = 2051;
#[doc = "Pending title status values."]
pub type AM_InstallStatus = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AM_PendingTitleEntry {
    #[doc = "< Title ID"]
    pub titleId: u64_,
    #[doc = "< Version"]
    pub version: u16_,
    #[doc = "< AM_InstallStatus"]
    pub status: u16_,
    #[doc = "< Title Type"]
    pub titleType: u32_,
    #[doc = "< Unknown"]
    pub unk: [u8_; 8usize],
}
#[doc = "< Non-system titles."]
pub const AM_DELETE_PENDING_NON_SYSTEM: _bindgen_ty_14 = 1;
#[doc = "< System titles."]
pub const AM_DELETE_PENDING_SYSTEM: _bindgen_ty_14 = 2;
#[doc = "Pending title deletion flags."]
pub type _bindgen_ty_14 = ::libc::c_uint;
#[doc = "Information about the TWL NAND partition."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AM_TWLPartitionInfo {
    #[doc = "< Total capacity."]
    pub capacity: u64_,
    #[doc = "< Total free space."]
    pub freeSpace: u64_,
    #[doc = "< Capacity for titles."]
    pub titlesCapacity: u64_,
    #[doc = "< Free space for titles."]
    pub titlesFreeSpace: u64_,
}
#[doc = "Contains information about a title's content."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct AM_ContentInfo {
    #[doc = "< Index of the content in the title."]
    pub index: u16_,
    #[doc = "< ?"]
    pub type_: u16_,
    #[doc = "< ID of the content in the title."]
    pub contentId: u32_,
    #[doc = "< Size of the content in the title."]
    pub size: u64_,
    #[doc = "< AM_ContentInfoFlags"]
    pub flags: u8_,
    #[doc = "< Padding"]
    pub padding: [u8_; 7usize],
}
#[doc = "< ?"]
pub const AM_CONTENT_DOWNLOADED: AM_ContentInfoFlags = 1;
#[doc = "< ?"]
pub const AM_CONTENT_OWNED: AM_ContentInfoFlags = 2;
#[doc = "Title ContentInfo flags."]
pub type AM_ContentInfoFlags = ::libc::c_uint;
extern "C" {
    #[must_use]
    #[doc = "Initializes AM. This doesn't initialize with \"am:app\", see amAppInit()."]
    pub fn amInit() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initializes AM with a service which has access to the amapp-commands. This should only be used when using the amapp commands, not non-amapp AM commands."]
    pub fn amAppInit() -> Result;
}
extern "C" {
    #[doc = "Exits AM."]
    pub fn amExit();
}
extern "C" {
    #[doc = "Gets the current AM session handle."]
    pub fn amGetSessionHandle() -> *mut Handle;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the number of titles for a given media type.\n # Arguments\n\n* `mediatype` - Media type to get titles from.\n * `count` (direction out) - Pointer to write the title count to."]
    pub fn AM_GetTitleCount(mediatype: FS_MediaType, count: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets a list of title IDs present in a mediatype.\n # Arguments\n\n* `titlesRead` (direction out) - Pointer to output the number of read titles to.\n * `mediatype` - Media type to get titles from.\n * `titleCount` - Number of title IDs to get.\n * `titleIds` - Buffer to output the retrieved title IDs to."]
    pub fn AM_GetTitleList(
        titlesRead: *mut u32_,
        mediatype: FS_MediaType,
        titleCount: u32_,
        titleIds: *mut u64_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets a list of details about installed titles.\n # Arguments\n\n* `mediatype` - Media type to get titles from.\n * `titleCount` - Number of titles to list.\n * `titleIds` - List of title IDs to retrieve details for.\n * `titleInfo` - Buffer to write AM_TitleEntry's to."]
    pub fn AM_GetTitleInfo(
        mediatype: FS_MediaType,
        titleCount: u32_,
        titleIds: *mut u64_,
        titleInfo: *mut AM_TitleEntry,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the number of tickets installed on the system.\n # Arguments\n\n* `count` (direction out) - Pointer to output the ticket count to."]
    pub fn AM_GetTicketCount(count: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets a list of tickets installed on the system.\n # Arguments\n\n* `ticketsRead` (direction out) - Pointer to output the number of read tickets to.\n * `ticketCount` - Number of tickets to read.\n * `skip` - Number of tickets to skip.\n * `ticketIds` - Buffer to output the retrieved ticket IDs to."]
    pub fn AM_GetTicketList(
        ticketsRead: *mut u32_,
        ticketCount: u32_,
        skip: u32_,
        ticketIds: *mut u64_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the number of pending titles on this system.\n # Arguments\n\n* `count` (direction out) - Pointer to output the pending title count to.\n * `mediatype` - Media type of pending titles to count.\n * `statusMask` - Bit mask of status values to include."]
    pub fn AM_GetPendingTitleCount(
        count: *mut u32_,
        mediatype: FS_MediaType,
        statusMask: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets a list of pending titles on this system.\n # Arguments\n\n* `titlesRead` (direction out) - Pointer to output the number of read pending titles to.\n * `titleCount` - Number of pending titles to read.\n * `mediatype` - Media type of pending titles to list.\n * `statusMask` - Bit mask of status values to include.\n * `titleIds` - Buffer to output the retrieved pending title IDs to."]
    pub fn AM_GetPendingTitleList(
        titlesRead: *mut u32_,
        titleCount: u32_,
        mediatype: FS_MediaType,
        statusMask: u32_,
        titleIds: *mut u64_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets information about pending titles on this system.\n # Arguments\n\n* `titleCount` - Number of pending titles to read.\n * `mediatype` - Media type of pending titles to get information on.\n * `titleIds` - IDs of the titles to get information about.\n * `titleInfo` - Buffer to output the retrieved pending title info to."]
    pub fn AM_GetPendingTitleInfo(
        titleCount: u32_,
        mediatype: FS_MediaType,
        titleIds: *mut u64_,
        titleInfo: *mut AM_PendingTitleEntry,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets a 32-bit device-specific ID.\n # Arguments\n\n* `deviceID` - Pointer to write the device ID to."]
    pub fn AM_GetDeviceId(deviceID: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Exports DSiWare to the specified filepath.\n # Arguments\n\n* `titleID` - TWL titleID.\n * `operation` - DSiWare operation type.\n * `workbuf` - Work buffer.\n * `workbuf_size` - Work buffer size, must be >=0x20000.\n * `filepath` - UTF-8 filepath(converted to UTF-16 internally)."]
    pub fn AM_ExportTwlBackup(
        titleID: u64_,
        operation: u8_,
        workbuf: *mut ::libc::c_void,
        workbuf_size: u32_,
        filepath: *const ::libc::c_char,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Imports DSiWare from the specified file.\n # Arguments\n\n* `filehandle` - FSUSER file handle.\n * `operation` - DSiWare operation type.\n * `buffer` - Work buffer.\n * `size` - Buffer size, must be >=0x20000."]
    pub fn AM_ImportTwlBackup(
        filehandle: Handle,
        operation: u8_,
        buffer: *mut ::libc::c_void,
        size: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Reads info from the specified DSiWare export file. This can only be used with DSiWare exported with certain operation value(s).\n # Arguments\n\n* `filehandle` - FSUSER file handle.\n * `outinfo` - Output info buffer.\n * `outinfo_size` - Output info buffer size.\n * `workbuf` - Work buffer.\n * `workbuf_size` - Work buffer size.\n * `banner` - Output banner buffer.\n * `banner_size` - Output banner buffer size."]
    pub fn AM_ReadTwlBackupInfo(
        filehandle: Handle,
        outinfo: *mut ::libc::c_void,
        outinfo_size: u32_,
        workbuf: *mut ::libc::c_void,
        workbuf_size: u32_,
        banner: *mut ::libc::c_void,
        banner_size: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Retrieves information about the NAND TWL partition.\n # Arguments\n\n* `info` (direction out) - Pointer to output the TWL partition info to."]
    pub fn AM_GetTWLPartitionInfo(info: *mut AM_TWLPartitionInfo) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initializes the CIA install process, returning a handle to write CIA data to.\n # Arguments\n\n* `mediatype` - Media type to install the CIA to.\n * `ciaHandle` (direction out) - Pointer to write the CIA handle to."]
    pub fn AM_StartCiaInstall(mediatype: FS_MediaType, ciaHandle: *mut Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initializes the CIA install process for Download Play CIAs, returning a handle to write CIA data to.\n # Arguments\n\n* `ciaHandle` (direction out) - Pointer to write the CIA handle to."]
    pub fn AM_StartDlpChildCiaInstall(ciaHandle: *mut Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Aborts the CIA install process.\n # Arguments\n\n* `ciaHandle` - CIA handle to cancel."]
    pub fn AM_CancelCIAInstall(ciaHandle: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Finalizes the CIA install process.\n # Arguments\n\n* `ciaHandle` - CIA handle to finalize."]
    pub fn AM_FinishCiaInstall(ciaHandle: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Finalizes the CIA install process without committing the title to title.db or tmp*.db.\n # Arguments\n\n* `ciaHandle` - CIA handle to finalize."]
    pub fn AM_FinishCiaInstallWithoutCommit(ciaHandle: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Commits installed CIAs.\n # Arguments\n\n* `mediaType` - Location of the titles to finalize.\n * `titleCount` - Number of titles to finalize.\n * `temp` - Whether the titles being finalized are in the temporary database.\n * `titleIds` - Title IDs to finalize."]
    pub fn AM_CommitImportPrograms(
        mediaType: FS_MediaType,
        titleCount: u32_,
        temp: bool,
        titleIds: *const u64_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Deletes a title.\n # Arguments\n\n* `mediatype` - Media type to delete from.\n * `titleID` - ID of the title to delete."]
    pub fn AM_DeleteTitle(mediatype: FS_MediaType, titleID: u64_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Deletes a title, provided that it is not a system title.\n # Arguments\n\n* `mediatype` - Media type to delete from.\n * `titleID` - ID of the title to delete."]
    pub fn AM_DeleteAppTitle(mediatype: FS_MediaType, titleID: u64_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Deletes a ticket.\n # Arguments\n\n* `titleID` - ID of the ticket to delete."]
    pub fn AM_DeleteTicket(ticketId: u64_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Deletes a pending title.\n # Arguments\n\n* `mediatype` - Media type to delete from.\n * `titleId` - ID of the pending title to delete."]
    pub fn AM_DeletePendingTitle(mediatype: FS_MediaType, titleId: u64_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Deletes pending titles.\n # Arguments\n\n* `mediatype` - Media type to delete from.\n * `flags` - Flags used to select pending titles."]
    pub fn AM_DeletePendingTitles(mediatype: FS_MediaType, flags: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Deletes all pending titles.\n # Arguments\n\n* `mediatype` - Media type to delete from."]
    pub fn AM_DeleteAllPendingTitles(mediatype: FS_MediaType) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Installs the current NATIVE_FIRM title to NAND (firm0:/ & firm1:/)"]
    pub fn AM_InstallNativeFirm() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Installs a NATIVE_FIRM title to NAND. Accepts 0004013800000002 or 0004013820000002 (N3DS).\n # Arguments\n\n* `titleID` - Title ID of the NATIVE_FIRM to install."]
    pub fn AM_InstallFirm(titleID: u64_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the product code of a title.\n # Arguments\n\n* `mediatype` - Media type of the title.\n * `titleID` - ID of the title.\n * `productCode` (direction out) - Pointer to output the product code to. (length = 16)"]
    pub fn AM_GetTitleProductCode(
        mediatype: FS_MediaType,
        titleId: u64_,
        productCode: *mut ::libc::c_char,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the ext data ID of a title.\n # Arguments\n\n* `extDataId` (direction out) - Pointer to output the ext data ID to.\n * `mediatype` - Media type of the title.\n * `titleID` - ID of the title."]
    pub fn AM_GetTitleExtDataId(
        extDataId: *mut u64_,
        mediatype: FS_MediaType,
        titleId: u64_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets an AM_TitleEntry instance for a CIA file.\n # Arguments\n\n* `mediatype` - Media type that this CIA would be installed to.\n * `titleEntry` (direction out) - Pointer to write the AM_TitleEntry instance to.\n * `fileHandle` - Handle of the CIA file."]
    pub fn AM_GetCiaFileInfo(
        mediatype: FS_MediaType,
        titleEntry: *mut AM_TitleEntry,
        fileHandle: Handle,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the SMDH icon data of a CIA file.\n # Arguments\n\n* `icon` - Buffer to store the icon data in. Must be of size 0x36C0 bytes.\n * `fileHandle` - Handle of the CIA file."]
    pub fn AM_GetCiaIcon(icon: *mut ::libc::c_void, fileHandle: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the title ID dependency list of a CIA file.\n # Arguments\n\n* `dependencies` - Buffer to store dependency title IDs in. Must be of size 0x300 bytes.\n * `fileHandle` - Handle of the CIA file."]
    pub fn AM_GetCiaDependencies(dependencies: *mut u64_, fileHandle: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the meta section offset of a CIA file.\n # Arguments\n\n* `metaOffset` (direction out) - Pointer to output the meta section offset to.\n * `fileHandle` - Handle of the CIA file."]
    pub fn AM_GetCiaMetaOffset(metaOffset: *mut u64_, fileHandle: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the core version of a CIA file.\n # Arguments\n\n* `coreVersion` (direction out) - Pointer to output the core version to.\n * `fileHandle` - Handle of the CIA file."]
    pub fn AM_GetCiaCoreVersion(coreVersion: *mut u32_, fileHandle: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the free space, in bytes, required to install a CIA file.\n # Arguments\n\n* `requiredSpace` (direction out) - Pointer to output the required free space to.\n * `mediaType` - Media type to check free space needed to install to.\n * `fileHandle` - Handle of the CIA file."]
    pub fn AM_GetCiaRequiredSpace(
        requiredSpace: *mut u64_,
        mediaType: FS_MediaType,
        fileHandle: Handle,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the full meta section of a CIA file.\n # Arguments\n\n* `meta` - Buffer to store the meta section in.\n * `size` - Size of the buffer. Must be greater than or equal to the actual section data's size.\n * `fileHandle` - Handle of the CIA file."]
    pub fn AM_GetCiaMetaSection(
        meta: *mut ::libc::c_void,
        size: u32_,
        fileHandle: Handle,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initializes the external (SD) title database.\n # Arguments\n\n* `overwrite` - Overwrites the database if it already exists."]
    pub fn AM_InitializeExternalTitleDatabase(overwrite: bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Queries whether the external title database is available.\n # Arguments\n\n* `available` (direction out) - Pointer to output the availability status to."]
    pub fn AM_QueryAvailableExternalTitleDatabase(available: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Begins installing a ticket.\n # Arguments\n\n* `ticketHandle` (direction out) - Pointer to output a handle to write ticket data to."]
    pub fn AM_InstallTicketBegin(ticketHandle: *mut Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Aborts installing a ticket.\n # Arguments\n\n* `ticketHandle` - Handle of the installation to abort."]
    pub fn AM_InstallTicketAbort(ticketHandle: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Finishes installing a ticket.\n # Arguments\n\n* `ticketHandle` - Handle of the installation to finalize."]
    pub fn AM_InstallTicketFinish(ticketHandle: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Begins installing a title.\n # Arguments\n\n* `mediaType` - Destination to install to.\n * `titleId` - ID of the title to install.\n * `unk` - Unknown. (usually false)"]
    pub fn AM_InstallTitleBegin(mediaType: FS_MediaType, titleId: u64_, unk: bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Stops installing a title, generally to be resumed later."]
    pub fn AM_InstallTitleStop() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Resumes installing a title.\n # Arguments\n\n* `mediaType` - Destination to install to.\n * `titleId` - ID of the title to install."]
    pub fn AM_InstallTitleResume(mediaType: FS_MediaType, titleId: u64_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Aborts installing a title."]
    pub fn AM_InstallTitleAbort() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Finishes installing a title."]
    pub fn AM_InstallTitleFinish() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Commits installed titles.\n # Arguments\n\n* `mediaType` - Location of the titles to finalize.\n * `titleCount` - Number of titles to finalize.\n * `temp` - Whether the titles being finalized are in the temporary database.\n * `titleIds` - Title IDs to finalize."]
    pub fn AM_CommitImportTitles(
        mediaType: FS_MediaType,
        titleCount: u32_,
        temp: bool,
        titleIds: *const u64_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Begins installing a TMD.\n # Arguments\n\n* `tmdHandle` (direction out) - Pointer to output a handle to write TMD data to."]
    pub fn AM_InstallTmdBegin(tmdHandle: *mut Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Aborts installing a TMD.\n # Arguments\n\n* `tmdHandle` - Handle of the installation to abort."]
    pub fn AM_InstallTmdAbort(tmdHandle: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Finishes installing a TMD.\n # Arguments\n\n* `tmdHandle` - Handle of the installation to finalize.\n * `unk` - Unknown. (usually true)"]
    pub fn AM_InstallTmdFinish(tmdHandle: Handle, unk: bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Prepares to import title contents.\n # Arguments\n\n* `contentCount` - Number of contents to be imported.\n * `contentIndices` - Indices of the contents to be imported."]
    pub fn AM_CreateImportContentContexts(contentCount: u32_, contentIndices: *mut u16_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Begins installing title content.\n # Arguments\n\n* `contentHandle` (direction out) - Pointer to output a handle to write content data to.\n * `index` - Index of the content to install."]
    pub fn AM_InstallContentBegin(contentHandle: *mut Handle, index: u16_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Stops installing title content, generally to be resumed later.\n # Arguments\n\n* `contentHandle` - Handle of the installation to abort."]
    pub fn AM_InstallContentStop(contentHandle: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Resumes installing title content.\n # Arguments\n\n* `contentHandle` (direction out) - Pointer to output a handle to write content data to.\n * `resumeOffset` (direction out) - Pointer to write the offset to resume content installation at to.\n * `index` - Index of the content to install."]
    pub fn AM_InstallContentResume(
        contentHandle: *mut Handle,
        resumeOffset: *mut u64_,
        index: u16_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Cancels installing title content.\n # Arguments\n\n* `contentHandle` - Handle of the installation to finalize."]
    pub fn AM_InstallContentCancel(contentHandle: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Finishes installing title content.\n # Arguments\n\n* `contentHandle` - Handle of the installation to finalize."]
    pub fn AM_InstallContentFinish(contentHandle: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Imports up to four certificates into the ticket certificate chain.\n # Arguments\n\n* `cert1Size` - Size of the first certificate.\n * `cert1` - Data of the first certificate.\n * `cert2Size` - Size of the second certificate.\n * `cert2` - Data of the second certificate.\n * `cert3Size` - Size of the third certificate.\n * `cert3` - Data of the third certificate.\n * `cert4Size` - Size of the fourth certificate.\n * `cert4` - Data of the fourth certificate."]
    pub fn AM_ImportCertificates(
        cert1Size: u32_,
        cert1: *mut ::libc::c_void,
        cert2Size: u32_,
        cert2: *mut ::libc::c_void,
        cert3Size: u32_,
        cert3: *mut ::libc::c_void,
        cert4Size: u32_,
        cert4: *mut ::libc::c_void,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Imports a certificate into the ticket certificate chain.\n # Arguments\n\n* `certSize` - Size of the certificate.\n * `cert` - Data of the certificate."]
    pub fn AM_ImportCertificate(certSize: u32_, cert: *mut ::libc::c_void) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Commits installed titles, and updates FIRM if necessary.\n # Arguments\n\n* `mediaType` - Location of the titles to finalize.\n * `titleCount` - Number of titles to finalize.\n * `temp` - Whether the titles being finalized are in the temporary database.\n * `titleIds` - Title IDs to finalize."]
    pub fn AM_CommitImportTitlesAndUpdateFirmwareAuto(
        mediaType: FS_MediaType,
        titleCount: u32_,
        temp: bool,
        titleIds: *mut u64_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Resets play count of all installed demos by deleting their launch info."]
    pub fn AM_DeleteAllDemoLaunchInfos() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Deletes temporary titles."]
    pub fn AM_DeleteAllTemporaryTitles() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Deletes all expired titles.\n # Arguments\n\n* `mediatype` - Media type to delete from."]
    pub fn AM_DeleteAllExpiredTitles(mediatype: FS_MediaType) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Deletes all TWL titles."]
    pub fn AM_DeleteAllTwlTitles() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the number of content index installed under the specified DLC title.\n # Arguments\n\n* `count` (direction out) - Pointer to output the number of content indices to.\n * `mediatype` - Media type of the title.\n * `titleID` - Title ID to retrieve the count for (high-id is 0x0004008C)."]
    pub fn AMAPP_GetDLCContentInfoCount(
        count: *mut u32_,
        mediatype: FS_MediaType,
        titleID: u64_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets content infos installed under the specified DLC title.\n # Arguments\n\n* `contentInfoRead` (direction out) - Pointer to output the number of content infos read to.\n * `mediatype` - Media type of the title.\n * `titleID` - Title ID to retrieve the content infos for (high-id is 0x0004008C).\n * `contentInfoCount` - Number of content infos to retrieve.\n * `offset` - Offset from the first content index the count starts at.\n * `contentInfos` (direction out) - Pointer to output the content infos read to."]
    pub fn AMAPP_ListDLCContentInfos(
        contentInfoRead: *mut u32_,
        mediatype: FS_MediaType,
        titleID: u64_,
        contentInfoCount: u32_,
        offset: u32_,
        contentInfos: *mut AM_ContentInfo,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initializes AMPXI.\n # Arguments\n\n* `servhandle` - Optional service session handle to use for AMPXI, if zero srvGetServiceHandle() will be used."]
    pub fn ampxiInit(servhandle: Handle) -> Result;
}
extern "C" {
    #[doc = "Exits AMPXI."]
    pub fn ampxiExit();
}
extern "C" {
    #[must_use]
    #[doc = "Writes a TWL save-file to NAND. https://www.3dbrew.org/wiki/AMPXI:WriteTWLSavedata\n # Arguments\n\n* `titleid` - ID of the TWL title.\n * `buffer` - Savedata buffer ptr.\n * `size` - Size of the savedata buffer.\n * `image_filepos` - Filepos to use for writing the data to the NAND savedata file.\n * `section_type` - https://www.3dbrew.org/wiki/AMPXI:WriteTWLSavedata\n * `operation` - https://3dbrew.org/wiki/AM:ImportDSiWare"]
    pub fn AMPXI_WriteTWLSavedata(
        titleid: u64_,
        buffer: *mut u8_,
        size: u32_,
        image_filepos: u32_,
        section_type: u8_,
        operation: u8_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Finalizes title installation. https://3dbrew.org/wiki/AMPXI:InstallTitlesFinish\n # Arguments\n\n* `mediaType` - Mediatype of the titles to finalize.\n * `db` - Which title database to use.\n * `size` - Size of the savedata buffer.\n * `titlecount` - Total titles.\n * `tidlist` - List of titleIDs."]
    pub fn AMPXI_InstallTitlesFinish(
        mediaType: FS_MediaType,
        db: u8_,
        titlecount: u32_,
        tidlist: *mut u64_,
    ) -> Result;
}
pub const APPID_NONE: NS_APPID = 0;
#[doc = "< Home Menu"]
pub const APPID_HOMEMENU: NS_APPID = 257;
#[doc = "< Camera applet"]
pub const APPID_CAMERA: NS_APPID = 272;
#[doc = "< Friends List applet"]
pub const APPID_FRIENDS_LIST: NS_APPID = 274;
#[doc = "< Game Notes applet"]
pub const APPID_GAME_NOTES: NS_APPID = 275;
#[doc = "< Internet Browser"]
pub const APPID_WEB: NS_APPID = 276;
#[doc = "< Instruction Manual applet"]
pub const APPID_INSTRUCTION_MANUAL: NS_APPID = 277;
#[doc = "< Notifications applet"]
pub const APPID_NOTIFICATIONS: NS_APPID = 278;
#[doc = "< Miiverse applet (olv)"]
pub const APPID_MIIVERSE: NS_APPID = 279;
#[doc = "< Miiverse posting applet (solv3)"]
pub const APPID_MIIVERSE_POSTING: NS_APPID = 280;
#[doc = "< Amiibo settings applet (cabinet)"]
pub const APPID_AMIIBO_SETTINGS: NS_APPID = 281;
#[doc = "< Application"]
pub const APPID_APPLICATION: NS_APPID = 768;
#[doc = "< eShop (tiger)"]
pub const APPID_ESHOP: NS_APPID = 769;
#[doc = "< Software Keyboard"]
pub const APPID_SOFTWARE_KEYBOARD: NS_APPID = 1025;
#[doc = "< appletEd"]
pub const APPID_APPLETED: NS_APPID = 1026;
#[doc = "< PNOTE_AP"]
pub const APPID_PNOTE_AP: NS_APPID = 1028;
#[doc = "< SNOTE_AP"]
pub const APPID_SNOTE_AP: NS_APPID = 1029;
#[doc = "< error"]
pub const APPID_ERROR: NS_APPID = 1030;
#[doc = "< mint"]
pub const APPID_MINT: NS_APPID = 1031;
#[doc = "< extrapad"]
pub const APPID_EXTRAPAD: NS_APPID = 1032;
#[doc = "< memolib"]
pub const APPID_MEMOLIB: NS_APPID = 1033;
#[doc = "NS Application IDs.\n\n Retrieved from http://3dbrew.org/wiki/NS_and_APT_Services#AppIDs"]
pub type NS_APPID = ::libc::c_uint;
#[doc = "< No position specified."]
pub const APTPOS_NONE: APT_AppletPos = -1;
#[doc = "< Application."]
pub const APTPOS_APP: APT_AppletPos = 0;
#[doc = "< Application library (?)."]
pub const APTPOS_APPLIB: APT_AppletPos = 1;
#[doc = "< System applet."]
pub const APTPOS_SYS: APT_AppletPos = 2;
#[doc = "< System library (?)."]
pub const APTPOS_SYSLIB: APT_AppletPos = 3;
#[doc = "< Resident applet."]
pub const APTPOS_RESIDENT: APT_AppletPos = 4;
#[doc = "APT applet position."]
pub type APT_AppletPos = ::libc::c_int;
pub type APT_AppletAttr = u8_;
extern "C" {
    #[doc = "Create an APT_AppletAttr bitfield from its components."]
    #[link_name = "aptMakeAppletAttr__extern"]
    pub fn aptMakeAppletAttr(
        pos: APT_AppletPos,
        manualGpuRights: bool,
        manualDspRights: bool,
    ) -> APT_AppletAttr;
}
pub const APTREPLY_REJECT: APT_QueryReply = 0;
pub const APTREPLY_ACCEPT: APT_QueryReply = 1;
pub const APTREPLY_LATER: APT_QueryReply = 2;
#[doc = "APT query reply."]
pub type APT_QueryReply = ::libc::c_uint;
#[doc = "< No signal received."]
pub const APTSIGNAL_NONE: APT_Signal = 0;
#[doc = "< HOME button pressed."]
pub const APTSIGNAL_HOMEBUTTON: APT_Signal = 1;
#[doc = "< HOME button pressed (again?)."]
pub const APTSIGNAL_HOMEBUTTON2: APT_Signal = 2;
#[doc = "< Prepare to enter sleep mode."]
pub const APTSIGNAL_SLEEP_QUERY: APT_Signal = 3;
#[doc = "< Triggered when ptm:s GetShellStatus() returns 5."]
pub const APTSIGNAL_SLEEP_CANCEL: APT_Signal = 4;
#[doc = "< Enter sleep mode."]
pub const APTSIGNAL_SLEEP_ENTER: APT_Signal = 5;
#[doc = "< Wake from sleep mode."]
pub const APTSIGNAL_SLEEP_WAKEUP: APT_Signal = 6;
#[doc = "< Shutdown."]
pub const APTSIGNAL_SHUTDOWN: APT_Signal = 7;
#[doc = "< POWER button pressed."]
pub const APTSIGNAL_POWERBUTTON: APT_Signal = 8;
#[doc = "< POWER button cleared (?)."]
pub const APTSIGNAL_POWERBUTTON2: APT_Signal = 9;
#[doc = "< System sleeping (?)."]
pub const APTSIGNAL_TRY_SLEEP: APT_Signal = 10;
#[doc = "< Order to close (such as when an error happens?)."]
pub const APTSIGNAL_ORDERTOCLOSE: APT_Signal = 11;
#[doc = "APT signals."]
pub type APT_Signal = ::libc::c_uint;
#[doc = "< No command received."]
pub const APTCMD_NONE: APT_Command = 0;
#[doc = "< Applet should wake up."]
pub const APTCMD_WAKEUP: APT_Command = 1;
#[doc = "< Source applet sent us a parameter."]
pub const APTCMD_REQUEST: APT_Command = 2;
#[doc = "< Target applet replied to our parameter."]
pub const APTCMD_RESPONSE: APT_Command = 3;
#[doc = "< Exit (??)"]
pub const APTCMD_EXIT: APT_Command = 4;
#[doc = "< Message (??)"]
pub const APTCMD_MESSAGE: APT_Command = 5;
#[doc = "< HOME button pressed once."]
pub const APTCMD_HOMEBUTTON_ONCE: APT_Command = 6;
#[doc = "< HOME button pressed twice (double-pressed)."]
pub const APTCMD_HOMEBUTTON_TWICE: APT_Command = 7;
#[doc = "< DSP should sleep (manual DSP rights related?)."]
pub const APTCMD_DSP_SLEEP: APT_Command = 8;
#[doc = "< DSP should wake up (manual DSP rights related?)."]
pub const APTCMD_DSP_WAKEUP: APT_Command = 9;
#[doc = "< Applet wakes up due to a different applet exiting."]
pub const APTCMD_WAKEUP_EXIT: APT_Command = 10;
#[doc = "< Applet wakes up after being paused through HOME menu."]
pub const APTCMD_WAKEUP_PAUSE: APT_Command = 11;
#[doc = "< Applet wakes up due to being cancelled."]
pub const APTCMD_WAKEUP_CANCEL: APT_Command = 12;
#[doc = "< Applet wakes up due to all applets being cancelled."]
pub const APTCMD_WAKEUP_CANCELALL: APT_Command = 13;
#[doc = "< Applet wakes up due to POWER button being pressed (?)."]
pub const APTCMD_WAKEUP_POWERBUTTON: APT_Command = 14;
#[doc = "< Applet wakes up and is instructed to jump to HOME menu (?)."]
pub const APTCMD_WAKEUP_JUMPTOHOME: APT_Command = 15;
#[doc = "< Request for sysapplet (?)."]
pub const APTCMD_SYSAPPLET_REQUEST: APT_Command = 16;
#[doc = "< Applet wakes up and is instructed to launch another applet (?)."]
pub const APTCMD_WAKEUP_LAUNCHAPP: APT_Command = 17;
#[doc = "APT commands."]
pub type APT_Command = ::libc::c_uint;
#[doc = "APT capture buffer information."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct aptCaptureBufInfo {
    pub size: u32_,
    pub is3D: u32_,
    pub top: aptCaptureBufInfo__bindgen_ty_1,
    pub bottom: aptCaptureBufInfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct aptCaptureBufInfo__bindgen_ty_1 {
    pub leftOffset: u32_,
    pub rightOffset: u32_,
    pub format: u32_,
}
#[doc = "< App suspended."]
pub const APTHOOK_ONSUSPEND: APT_HookType = 0;
#[doc = "< App restored."]
pub const APTHOOK_ONRESTORE: APT_HookType = 1;
#[doc = "< App sleeping."]
pub const APTHOOK_ONSLEEP: APT_HookType = 2;
#[doc = "< App waking up."]
pub const APTHOOK_ONWAKEUP: APT_HookType = 3;
#[doc = "< App exiting."]
pub const APTHOOK_ONEXIT: APT_HookType = 4;
#[doc = "< Number of APT hook types."]
pub const APTHOOK_COUNT: APT_HookType = 5;
#[doc = "APT hook types."]
pub type APT_HookType = ::libc::c_uint;
#[doc = "APT hook function."]
pub type aptHookFn =
    ::core::option::Option<unsafe extern "C" fn(hook: APT_HookType, param: *mut ::libc::c_void)>;
#[doc = "APT hook cookie."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tag_aptHookCookie {
    #[doc = "< Next cookie."]
    pub next: *mut tag_aptHookCookie,
    #[doc = "< Hook callback."]
    pub callback: aptHookFn,
    #[doc = "< Callback parameter."]
    pub param: *mut ::libc::c_void,
}
impl Default for tag_aptHookCookie {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "APT hook cookie."]
pub type aptHookCookie = tag_aptHookCookie;
#[doc = "APT message callback."]
pub type aptMessageCb = ::core::option::Option<
    unsafe extern "C" fn(
        user: *mut ::libc::c_void,
        sender: NS_APPID,
        msg: *mut ::libc::c_void,
        msgsize: usize,
    ),
>;
extern "C" {
    #[must_use]
    #[doc = "Initializes APT."]
    pub fn aptInit() -> Result;
}
extern "C" {
    #[doc = "Exits APT."]
    pub fn aptExit();
}
extern "C" {
    #[must_use]
    #[doc = "Sends an APT command through IPC, taking care of locking, opening and closing an APT session.\n # Arguments\n\n* `aptcmdbuf` - Pointer to command buffer (should have capacity for at least 16 words)."]
    pub fn aptSendCommand(aptcmdbuf: *mut u32_) -> Result;
}
extern "C" {
    #[doc = "Returns true if the application is currently in the foreground."]
    pub fn aptIsActive() -> bool;
}
extern "C" {
    #[doc = "Returns true if the system has told the application to close."]
    pub fn aptShouldClose() -> bool;
}
extern "C" {
    #[doc = "Returns true if the system can enter sleep mode while the application is active."]
    pub fn aptIsSleepAllowed() -> bool;
}
extern "C" {
    #[doc = "Configures whether the system can enter sleep mode while the application is active."]
    pub fn aptSetSleepAllowed(allowed: bool);
}
extern "C" {
    #[doc = "Handles incoming sleep mode requests."]
    pub fn aptHandleSleep();
}
extern "C" {
    #[doc = "Returns true if the user can press the HOME button to jump back to the HOME menu while the application is active."]
    pub fn aptIsHomeAllowed() -> bool;
}
extern "C" {
    #[doc = "Configures whether the user can press the HOME button to jump back to the HOME menu while the application is active."]
    pub fn aptSetHomeAllowed(allowed: bool);
}
extern "C" {
    #[doc = "Returns true if the system requires the application to jump back to the HOME menu."]
    pub fn aptShouldJumpToHome() -> bool;
}
extern "C" {
    #[doc = "Returns true if there is an incoming HOME button press rejected by the policy set by aptSetHomeAllowed (use this to show a \"no HOME allowed\" icon)."]
    pub fn aptCheckHomePressRejected() -> bool;
}
extern "C" {
    #[doc = "> **Deprecated** Alias for aptCheckHomePressRejected."]
    #[link_name = "aptIsHomePressed__extern"]
    pub fn aptIsHomePressed() -> bool;
}
extern "C" {
    #[doc = "Jumps back to the HOME menu."]
    pub fn aptJumpToHomeMenu();
}
extern "C" {
    #[doc = "Handles incoming jump-to-HOME requests."]
    #[link_name = "aptHandleJumpToHome__extern"]
    pub fn aptHandleJumpToHome();
}
extern "C" {
    #[doc = "Main function which handles sleep mode and HOME/power buttons - call this at the beginning of every frame.\n # Returns\n\ntrue if the application should keep running, false otherwise (see aptShouldClose)."]
    pub fn aptMainLoop() -> bool;
}
extern "C" {
    #[doc = "Sets up an APT status hook.\n # Arguments\n\n* `cookie` - Hook cookie to use.\n * `callback` - Function to call when APT's status changes.\n * `param` - User-defined parameter to pass to the callback."]
    pub fn aptHook(cookie: *mut aptHookCookie, callback: aptHookFn, param: *mut ::libc::c_void);
}
extern "C" {
    #[doc = "Removes an APT status hook.\n # Arguments\n\n* `cookie` - Hook cookie to remove."]
    pub fn aptUnhook(cookie: *mut aptHookCookie);
}
extern "C" {
    #[doc = "Sets the function to be called when an APT message from another applet is received.\n # Arguments\n\n* `callback` - Callback function.\n * `user` - User-defined data to be passed to the callback."]
    pub fn aptSetMessageCallback(callback: aptMessageCb, user: *mut ::libc::c_void);
}
extern "C" {
    #[doc = "Launches a library applet.\n # Arguments\n\n* `appId` - ID of the applet to launch.\n * `buf` - Input/output buffer that contains launch parameters on entry and result data on exit.\n * `bufsize` - Size of the buffer.\n * `handle` - Handle to pass to the library applet."]
    pub fn aptLaunchLibraryApplet(
        appId: NS_APPID,
        buf: *mut ::libc::c_void,
        bufsize: usize,
        handle: Handle,
    );
}
extern "C" {
    #[doc = "Clears the chainloader state."]
    pub fn aptClearChainloader();
}
extern "C" {
    #[doc = "Configures the chainloader to launch a specific application.\n # Arguments\n\n* `programID` - ID of the program to chainload to.\n * `mediatype` - Media type of the program to chainload to."]
    pub fn aptSetChainloader(programID: u64_, mediatype: u8_);
}
extern "C" {
    #[doc = "Configures the chainloader to launch the previous application."]
    pub fn aptSetChainloaderToCaller();
}
extern "C" {
    #[doc = "Configures the chainloader to relaunch the current application (i.e. soft-reset)"]
    pub fn aptSetChainloaderToSelf();
}
extern "C" {
    #[doc = "Sets the \"deliver arg\" and HMAC for the chainloader, which will\n be passed to the target 3DS/DS(i) application. The meaning of each\n parameter varies on a per-application basis.\n # Arguments\n\n* `deliverArg` - Deliver arg to pass to the target application.\n * `deliverArgSize` - Size of the deliver arg, maximum 0x300 bytes.\n * `hmac` - HMAC buffer, 32 bytes. Use NULL to pass an all-zero dummy HMAC."]
    pub fn aptSetChainloaderArgs(
        deliverArg: *const ::libc::c_void,
        deliverArgSize: usize,
        hmac: *const ::libc::c_void,
    );
}
extern "C" {
    #[must_use]
    #[doc = "Gets an APT lock handle.\n # Arguments\n\n* `flags` - Flags to use.\n * `lockHandle` - Pointer to output the lock handle to."]
    pub fn APT_GetLockHandle(flags: u16_, lockHandle: *mut Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initializes an application's registration with APT.\n # Arguments\n\n* `appId` - ID of the application.\n * `attr` - Attributes of the application.\n * `signalEvent` - Pointer to output the signal event handle to.\n * `resumeEvent` - Pointer to output the resume event handle to."]
    pub fn APT_Initialize(
        appId: NS_APPID,
        attr: APT_AppletAttr,
        signalEvent: *mut Handle,
        resumeEvent: *mut Handle,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Terminates an application's registration with APT.\n # Arguments\n\n* `appID` - ID of the application."]
    pub fn APT_Finalize(appId: NS_APPID) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Asynchronously resets the hardware."]
    pub fn APT_HardwareResetAsync() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Enables APT.\n # Arguments\n\n* `attr` - Attributes of the application."]
    pub fn APT_Enable(attr: APT_AppletAttr) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets applet management info.\n # Arguments\n\n* `inpos` - Requested applet position.\n * `outpos` - Pointer to output the position of the current applet to.\n * `req_appid` - Pointer to output the AppID of the applet at the requested position to.\n * `menu_appid` - Pointer to output the HOME menu AppID to.\n * `active_appid` - Pointer to output the AppID of the currently active applet to."]
    pub fn APT_GetAppletManInfo(
        inpos: APT_AppletPos,
        outpos: *mut APT_AppletPos,
        req_appid: *mut NS_APPID,
        menu_appid: *mut NS_APPID,
        active_appid: *mut NS_APPID,
    ) -> Result;
}
extern "C" {
    #[doc = "Gets the menu's app ID.\n # Returns\n\nThe menu's app ID."]
    #[link_name = "aptGetMenuAppID__extern"]
    pub fn aptGetMenuAppID() -> NS_APPID;
}
extern "C" {
    #[must_use]
    #[doc = "Gets an applet's information.\n # Arguments\n\n* `appID` - AppID of the applet.\n * `pProgramID` - Pointer to output the program ID to.\n * `pMediaType` - Pointer to output the media type to.\n * `pRegistered` - Pointer to output the registration status to.\n * `pLoadState` - Pointer to output the load state to.\n * `pAttributes` - Pointer to output the applet atrributes to."]
    pub fn APT_GetAppletInfo(
        appID: NS_APPID,
        pProgramID: *mut u64_,
        pMediaType: *mut u8_,
        pRegistered: *mut bool,
        pLoadState: *mut bool,
        pAttributes: *mut APT_AppletAttr,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets an applet's program information.\n # Arguments\n\n* `id` - ID of the applet.\n * `flags` - Flags to use when retreiving the information.\n * `titleversion` - Pointer to output the applet's title version to.\n\n Flags:\n - 0x01: Use AM_ListTitles with NAND media type.\n - 0x02: Use AM_ListTitles with SDMC media type.\n - 0x04: Use AM_ListTitles with GAMECARD media type.\n - 0x10: Input ID is an app ID. Must be set if 0x20 is not.\n - 0x20: Input ID is a program ID. Must be set if 0x10 is not.\n - 0x100: Sets program ID high to 0x00040000, else it is 0x00040010. Only used when 0x20 is set."]
    pub fn APT_GetAppletProgramInfo(id: u32_, flags: u32_, titleversion: *mut u16_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the current application's program ID.\n # Arguments\n\n* `pProgramID` - Pointer to output the program ID to."]
    pub fn APT_GetProgramID(pProgramID: *mut u64_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Prepares to jump to the home menu."]
    pub fn APT_PrepareToJumpToHomeMenu() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Jumps to the home menu.\n # Arguments\n\n* `param` - Parameters to jump with.\n * `Size` - of the parameter buffer.\n * `handle` - Handle to pass."]
    pub fn APT_JumpToHomeMenu(
        param: *const ::libc::c_void,
        paramSize: usize,
        handle: Handle,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Prepares to jump to an application.\n # Arguments\n\n* `exiting` - Specifies whether the applet is exiting."]
    pub fn APT_PrepareToJumpToApplication(exiting: bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Jumps to an application.\n # Arguments\n\n* `param` - Parameters to jump with.\n * `Size` - of the parameter buffer.\n * `handle` - Handle to pass."]
    pub fn APT_JumpToApplication(
        param: *const ::libc::c_void,
        paramSize: usize,
        handle: Handle,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets whether an application is registered.\n # Arguments\n\n* `appID` - ID of the application.\n * `out` - Pointer to output the registration state to."]
    pub fn APT_IsRegistered(appID: NS_APPID, out: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Inquires as to whether a signal has been received.\n # Arguments\n\n* `appID` - ID of the application.\n * `signalType` - Pointer to output the signal type to."]
    pub fn APT_InquireNotification(appID: u32_, signalType: *mut APT_Signal) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Requests to enter sleep mode, and later sets wake events if allowed to.\n # Arguments\n\n* `wakeEvents` - The wake events. Limited to \"shell\" (bit 1) for the PDN wake events part\n and \"shell opened\", \"shell closed\" and \"HOME button pressed\" for the MCU interrupts part."]
    pub fn APT_SleepSystem(wakeEvents: *const PtmWakeEvents) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Notifies an application to wait.\n # Arguments\n\n* `appID` - ID of the application."]
    pub fn APT_NotifyToWait(appID: NS_APPID) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Calls an applet utility function.\n # Arguments\n\n* `id` - Utility function to call.\n * `out` - Pointer to write output data to.\n * `outSize` - Size of the output buffer.\n * `in` - Pointer to the input data.\n * `inSize` - Size of the input buffer."]
    pub fn APT_AppletUtility(
        id: ::libc::c_int,
        out: *mut ::libc::c_void,
        outSize: usize,
        in_: *const ::libc::c_void,
        inSize: usize,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sleeps if shell is closed (?)."]
    pub fn APT_SleepIfShellClosed() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Locks a transition (?).\n # Arguments\n\n* `transition` - Transition ID.\n * `flag` - Flag (?)"]
    pub fn APT_LockTransition(transition: u32_, flag: bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Tries to lock a transition (?).\n # Arguments\n\n* `transition` - Transition ID.\n * `succeeded` - Pointer to output whether the lock was successfully applied."]
    pub fn APT_TryLockTransition(transition: u32_, succeeded: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Unlocks a transition (?).\n # Arguments\n\n* `transition` - Transition ID."]
    pub fn APT_UnlockTransition(transition: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Glances at a receieved parameter without removing it from the queue.\n # Arguments\n\n* `appID` - AppID of the application.\n * `buffer` - Buffer to receive to.\n * `bufferSize` - Size of the buffer.\n * `sender` - Pointer to output the sender's AppID to.\n * `command` - Pointer to output the command ID to.\n * `actualSize` - Pointer to output the actual received data size to.\n * `parameter` - Pointer to output the parameter handle to."]
    pub fn APT_GlanceParameter(
        appID: NS_APPID,
        buffer: *mut ::libc::c_void,
        bufferSize: usize,
        sender: *mut NS_APPID,
        command: *mut APT_Command,
        actualSize: *mut usize,
        parameter: *mut Handle,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Receives a parameter.\n # Arguments\n\n* `appID` - AppID of the application.\n * `buffer` - Buffer to receive to.\n * `bufferSize` - Size of the buffer.\n * `sender` - Pointer to output the sender's AppID to.\n * `command` - Pointer to output the command ID to.\n * `actualSize` - Pointer to output the actual received data size to.\n * `parameter` - Pointer to output the parameter handle to."]
    pub fn APT_ReceiveParameter(
        appID: NS_APPID,
        buffer: *mut ::libc::c_void,
        bufferSize: usize,
        sender: *mut NS_APPID,
        command: *mut APT_Command,
        actualSize: *mut usize,
        parameter: *mut Handle,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sends a parameter.\n # Arguments\n\n* `source` - AppID of the source application.\n * `dest` - AppID of the destination application.\n * `command` - Command to send.\n * `buffer` - Buffer to send.\n * `bufferSize` - Size of the buffer.\n * `parameter` - Parameter handle to pass."]
    pub fn APT_SendParameter(
        source: NS_APPID,
        dest: NS_APPID,
        command: APT_Command,
        buffer: *const ::libc::c_void,
        bufferSize: u32_,
        parameter: Handle,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Cancels a parameter which matches the specified source and dest AppIDs.\n # Arguments\n\n* `source` - AppID of the source application (use APPID_NONE to disable the check).\n * `dest` - AppID of the destination application (use APPID_NONE to disable the check).\n * `success` - Pointer to output true if a parameter was cancelled, or false otherwise."]
    pub fn APT_CancelParameter(source: NS_APPID, dest: NS_APPID, success: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sends capture buffer information.\n # Arguments\n\n* `captureBuf` - Capture buffer information to send."]
    pub fn APT_SendCaptureBufferInfo(captureBuf: *const aptCaptureBufInfo) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Replies to a sleep query.\n # Arguments\n\n* `appID` - ID of the application.\n * `reply` - Query reply value."]
    pub fn APT_ReplySleepQuery(appID: NS_APPID, reply: APT_QueryReply) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Replies that a sleep notification has been completed.\n # Arguments\n\n* `appID` - ID of the application."]
    pub fn APT_ReplySleepNotificationComplete(appID: NS_APPID) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Prepares to close the application.\n # Arguments\n\n* `cancelPreload` - Whether applet preloads should be cancelled."]
    pub fn APT_PrepareToCloseApplication(cancelPreload: bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Closes the application.\n # Arguments\n\n* `param` - Parameters to close with.\n * `paramSize` - Size of param.\n * `handle` - Handle to pass."]
    pub fn APT_CloseApplication(
        param: *const ::libc::c_void,
        paramSize: usize,
        handle: Handle,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the application's CPU time limit.\n # Arguments\n\n* `percent` - CPU time limit percentage to set."]
    pub fn APT_SetAppCpuTimeLimit(percent: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the application's CPU time limit.\n # Arguments\n\n* `percent` - Pointer to output the CPU time limit percentage to."]
    pub fn APT_GetAppCpuTimeLimit(percent: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Checks whether the system is a New 3DS.\n # Arguments\n\n* `out` - Pointer to write the New 3DS flag to."]
    pub fn APT_CheckNew3DS(out: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Prepares for an applicaton jump.\n # Arguments\n\n* `flags` - Flags to use.\n * `programID` - ID of the program to jump to.\n * `mediatype` - Media type of the program to jump to."]
    pub fn APT_PrepareToDoApplicationJump(flags: u8_, programID: u64_, mediatype: u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Performs an application jump.\n # Arguments\n\n* `param` - Parameter buffer.\n * `paramSize` - Size of parameter buffer.\n * `hmac` - HMAC buffer (should be 0x20 bytes long)."]
    pub fn APT_DoApplicationJump(
        param: *const ::libc::c_void,
        paramSize: usize,
        hmac: *const ::libc::c_void,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Prepares to start a library applet.\n # Arguments\n\n* `appID` - AppID of the applet to start."]
    pub fn APT_PrepareToStartLibraryApplet(appID: NS_APPID) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Starts a library applet.\n # Arguments\n\n* `appID` - AppID of the applet to launch.\n * `param` - Buffer containing applet parameters.\n * `paramsize` - Size of the buffer.\n * `handle` - Handle to pass to the applet."]
    pub fn APT_StartLibraryApplet(
        appID: NS_APPID,
        param: *const ::libc::c_void,
        paramSize: usize,
        handle: Handle,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Prepares to start a system applet.\n # Arguments\n\n* `appID` - AppID of the applet to start."]
    pub fn APT_PrepareToStartSystemApplet(appID: NS_APPID) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Starts a system applet.\n # Arguments\n\n* `appID` - AppID of the applet to launch.\n * `param` - Buffer containing applet parameters.\n * `paramSize` - Size of the parameter buffer.\n * `handle` - Handle to pass to the applet."]
    pub fn APT_StartSystemApplet(
        appID: NS_APPID,
        param: *const ::libc::c_void,
        paramSize: usize,
        handle: Handle,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Retrieves the shared system font.\n fontHandle Pointer to write the handle of the system font memory block to.\n mapAddr Pointer to write the mapping address of the system font memory block to."]
    pub fn APT_GetSharedFont(fontHandle: *mut Handle, mapAddr: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Receives the deliver (launch) argument\n # Arguments\n\n* `param` - Parameter buffer.\n * `paramSize` - Size of parameter buffer.\n * `hmac` - HMAC buffer (should be 0x20 bytes long).\n * `sender` - Pointer to output the sender's AppID to.\n * `received` - Pointer to output whether an argument was received to."]
    pub fn APT_ReceiveDeliverArg(
        param: *mut ::libc::c_void,
        paramSize: usize,
        hmac: *mut ::libc::c_void,
        sender: *mut u64_,
        received: *mut bool,
    ) -> Result;
}
#[doc = "BOSS context."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bossContext {
    pub property: [u32_; 7usize],
    pub url: [::libc::c_char; 512usize],
    pub property_x8: u32_,
    pub property_x9: u8_,
    pub property_xa: [u8_; 256usize],
    pub property_xb: [u8_; 512usize],
    pub property_xd: [::libc::c_char; 864usize],
    pub property_xe: u32_,
    pub property_xf: [u32_; 3usize],
    pub property_x10: u8_,
    pub property_x11: u8_,
    pub property_x12: u8_,
    pub property_x13: u32_,
    pub property_x14: u32_,
    pub property_x15: [u8_; 64usize],
    pub property_x16: u32_,
    pub property_x3b: u32_,
    pub property_x3e: [u8_; 512usize],
}
impl Default for bossContext {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const BOSSTASKSTATUS_STARTED: bossTaskStatus = 2;
pub const BOSSTASKSTATUS_ERROR: bossTaskStatus = 7;
#[doc = "BOSS task status."]
pub type bossTaskStatus = ::libc::c_uint;
pub const bossNsDataHeaderInfoType_ContentSize: bossNsDataHeaderInfoTypes = 3;
#[doc = "Type values for bossGetNsDataHeaderInfo()."]
pub type bossNsDataHeaderInfoTypes = ::libc::c_uint;
pub const bossNsDataHeaderInfoTypeSize_ContentSize: bossNsDataHeaderInfoTypeSizes = 4;
#[doc = "Size of the output data for bossGetNsDataHeaderInfo()."]
pub type bossNsDataHeaderInfoTypeSizes = ::libc::c_uint;
extern "C" {
    #[must_use]
    #[doc = "Initializes BOSS.\n # Arguments\n\n* `programID` - programID to use, 0 for the current process. Only used when BOSSP is available without *hax payload.\n * `force_user` - When true, just use bossU instead of trying to initialize with bossP first."]
    pub fn bossInit(programID: u64_, force_user: bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Run the InitializeSession service cmd. This is mainly for changing the programID associated with the current BOSS session.\n # Arguments\n\n* `programID` - programID to use, 0 for the current process."]
    pub fn bossReinit(programID: u64_) -> Result;
}
extern "C" {
    #[doc = "Exits BOSS."]
    pub fn bossExit();
}
extern "C" {
    #[doc = "Returns the BOSS session handle."]
    pub fn bossGetSessionHandle() -> Handle;
}
extern "C" {
    #[must_use]
    #[doc = "Set the content data storage location.\n # Arguments\n\n* `extdataID` - u64 extdataID, must have the high word set to the shared-extdata value when it's for NAND.\n * `boss_size` - Probably the max size in the extdata which BOSS can use.\n * `mediaType` - Roughly the same as FS mediatype."]
    pub fn bossSetStorageInfo(extdataID: u64_, boss_size: u32_, mediaType: u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Unregister the content data storage location, which includes unregistering the BOSS-session programID with BOSS."]
    pub fn bossUnregisterStorage() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Register a task.\n # Arguments\n\n* `taskID` - BOSS taskID.\n * `unk0` - Unknown, usually zero.\n * `unk1` - Unknown, usually zero."]
    pub fn bossRegisterTask(taskID: *const ::libc::c_char, unk0: u8_, unk1: u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Send a property.\n # Arguments\n\n* `PropertyID` - PropertyID\n * `buf` - Input buffer data.\n * `size` - Buffer size."]
    pub fn bossSendProperty(PropertyID: u16_, buf: *const ::libc::c_void, size: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Deletes the content file for the specified NsDataId.\n # Arguments\n\n* `NsDataId` - NsDataId"]
    pub fn bossDeleteNsData(NsDataId: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets header info for the specified NsDataId.\n # Arguments\n\n* `NsDataId` - NsDataId\n * `type` - Type of data to load.\n * `buffer` - Output buffer.\n * `size` - Output buffer size."]
    pub fn bossGetNsDataHeaderInfo(
        NsDataId: u32_,
        type_: u8_,
        buffer: *mut ::libc::c_void,
        size: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Reads data from the content for the specified NsDataId.\n # Arguments\n\n* `NsDataId` - NsDataId\n * `offset` - Offset in the content.\n * `buffer` - Output buffer.\n * `size` - Output buffer size.\n * `transfer_total` - Optional output actual read size, can be NULL.\n * `unk_out` - Optional unknown output, can be NULL."]
    pub fn bossReadNsData(
        NsDataId: u32_,
        offset: u64_,
        buffer: *mut ::libc::c_void,
        size: u32_,
        transfer_total: *mut u32_,
        unk_out: *mut u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Starts a task soon after running this command.\n # Arguments\n\n* `taskID` - BOSS taskID."]
    pub fn bossStartTaskImmediate(taskID: *const ::libc::c_char) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Similar to bossStartTaskImmediate?\n # Arguments\n\n* `taskID` - BOSS taskID."]
    pub fn bossStartBgImmediate(taskID: *const ::libc::c_char) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Deletes a task by using CancelTask and UnregisterTask internally.\n # Arguments\n\n* `taskID` - BOSS taskID.\n * `unk` - Unknown, usually zero?"]
    pub fn bossDeleteTask(taskID: *const ::libc::c_char, unk: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Returns task state.\n # Arguments\n\n* `taskID` - BOSS taskID.\n * `inval` - Unknown, normally 0?\n * `status` - Output status, see bossTaskStatus.\n * `out1` - Output field.\n * `out2` - Output field."]
    pub fn bossGetTaskState(
        taskID: *const ::libc::c_char,
        inval: s8,
        status: *mut u8_,
        out1: *mut u32_,
        out2: *mut u8_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "This loads the current state of PropertyID 0x0 for the specified task.\n # Arguments\n\n* `taskID` - BOSS taskID."]
    pub fn bossGetTaskProperty0(taskID: *const ::libc::c_char, out: *mut u8_) -> Result;
}
extern "C" {
    #[doc = "Setup a BOSS context with the default config.\n # Arguments\n\n* `bossContext` - BOSS context.\n * `seconds_interval` - Interval in seconds for running the task automatically.\n * `url` - Task URL."]
    pub fn bossSetupContextDefault(
        ctx: *mut bossContext,
        seconds_interval: u32_,
        url: *const ::libc::c_char,
    );
}
extern "C" {
    #[must_use]
    #[doc = "Sends the config stored in the context. Used before registering a task.\n # Arguments\n\n* `bossContext` - BOSS context."]
    pub fn bossSendContextConfig(ctx: *mut bossContext) -> Result;
}
#[doc = "< 8-bit per component, planar YUV 4:2:2, 16bpp, (1 Cr & Cb sample per 2x1 Y samples).Usually named YUV422P."]
pub const INPUT_YUV422_INDIV_8: Y2RU_InputFormat = 0;
#[doc = "< 8-bit per component, planar YUV 4:2:0, 12bpp, (1 Cr & Cb sample per 2x2 Y samples).Usually named YUV420P."]
pub const INPUT_YUV420_INDIV_8: Y2RU_InputFormat = 1;
#[doc = "< 16-bit per component, planar YUV 4:2:2, 32bpp, (1 Cr & Cb sample per 2x1 Y samples).Usually named YUV422P16."]
pub const INPUT_YUV422_INDIV_16: Y2RU_InputFormat = 2;
#[doc = "< 16-bit per component, planar YUV 4:2:0, 24bpp, (1 Cr & Cb sample per 2x2 Y samples).Usually named YUV420P16."]
pub const INPUT_YUV420_INDIV_16: Y2RU_InputFormat = 3;
#[doc = "< 8-bit per component, packed YUV 4:2:2, 16bpp, (Y0 Cb Y1 Cr).Usually named YUYV422."]
pub const INPUT_YUV422_BATCH: Y2RU_InputFormat = 4;
#[doc = "Input color formats\n\n For the 16-bit per component formats, bits 15-8 are padding and 7-0 contains the value."]
pub type Y2RU_InputFormat = ::libc::c_uint;
#[doc = "< 32-bit RGBA8888. The alpha component is the 8-bit value set by Y2RU_SetAlpha"]
pub const OUTPUT_RGB_32: Y2RU_OutputFormat = 0;
#[doc = "< 24-bit RGB888."]
pub const OUTPUT_RGB_24: Y2RU_OutputFormat = 1;
#[doc = "< 16-bit RGBA5551. The alpha bit is the 7th bit of the alpha value set by Y2RU_SetAlpha"]
pub const OUTPUT_RGB_16_555: Y2RU_OutputFormat = 2;
#[doc = "< 16-bit RGB565."]
pub const OUTPUT_RGB_16_565: Y2RU_OutputFormat = 3;
#[doc = "Output color formats\n\n Those are the same as the framebuffer and GPU texture formats."]
pub type Y2RU_OutputFormat = ::libc::c_uint;
#[doc = "< No rotation."]
pub const ROTATION_NONE: Y2RU_Rotation = 0;
#[doc = "< Clockwise 90 degrees."]
pub const ROTATION_CLOCKWISE_90: Y2RU_Rotation = 1;
#[doc = "< Clockwise 180 degrees."]
pub const ROTATION_CLOCKWISE_180: Y2RU_Rotation = 2;
#[doc = "< Clockwise 270 degrees."]
pub const ROTATION_CLOCKWISE_270: Y2RU_Rotation = 3;
#[doc = "Rotation to be applied to the output."]
pub type Y2RU_Rotation = ::libc::c_uint;
#[doc = "< The result buffer will be laid out in linear format, the usual way."]
pub const BLOCK_LINE: Y2RU_BlockAlignment = 0;
#[doc = "< The result will be stored as 8x8 blocks in Z-order.Useful for textures since it is the format used by the PICA200."]
pub const BLOCK_8_BY_8: Y2RU_BlockAlignment = 1;
#[doc = "Block alignment of output\n\n Defines the way the output will be laid out in memory."]
pub type Y2RU_BlockAlignment = ::libc::c_uint;
#[doc = "Coefficients of the YUV->RGB conversion formula.\n\n A set of coefficients configuring the RGB to YUV conversion. Coefficients 0-4 are unsigned 2.8\n fixed pointer numbers representing entries on the conversion matrix, while coefficient 5-7 are\n signed 11.5 fixed point numbers added as offsets to the RGB result.\n\n The overall conversion process formula is:\n R = trunc((rgb_Y * Y + r_V * V) + 0.75 + r_offset)\n G = trunc((rgb_Y * Y - g_U * U - g_V * V) + 0.75 + g_offset)\n B = trunc((rgb_Y * Y + b_U * U ) + 0.75 + b_offset)\n "]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Y2RU_ColorCoefficients {
    #[doc = "< RGB per unit Y."]
    pub rgb_Y: u16_,
    #[doc = "< Red per unit V."]
    pub r_V: u16_,
    #[doc = "< Green per unit V."]
    pub g_V: u16_,
    #[doc = "< Green per unit U."]
    pub g_U: u16_,
    #[doc = "< Blue per unit U."]
    pub b_U: u16_,
    #[doc = "< Red offset."]
    pub r_offset: u16_,
    #[doc = "< Green offset."]
    pub g_offset: u16_,
    #[doc = "< Blue offset."]
    pub b_offset: u16_,
}
#[doc = "< Coefficients from the ITU-R BT.601 standard with PC ranges."]
pub const COEFFICIENT_ITU_R_BT_601: Y2RU_StandardCoefficient = 0;
#[doc = "< Coefficients from the ITU-R BT.709 standard with PC ranges."]
pub const COEFFICIENT_ITU_R_BT_709: Y2RU_StandardCoefficient = 1;
#[doc = "< Coefficients from the ITU-R BT.601 standard with TV ranges."]
pub const COEFFICIENT_ITU_R_BT_601_SCALING: Y2RU_StandardCoefficient = 2;
#[doc = "< Coefficients from the ITU-R BT.709 standard with TV ranges."]
pub const COEFFICIENT_ITU_R_BT_709_SCALING: Y2RU_StandardCoefficient = 3;
#[doc = "Preset conversion coefficients based on ITU standards for the YUV->RGB formula.\n\n For more details refer to Y2RU_ColorCoefficients"]
pub type Y2RU_StandardCoefficient = ::libc::c_uint;
#[doc = "Structure used to configure all parameters at once.\n\n You can send a batch of configuration parameters using this structure and Y2RU_SetConversionParams."]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct Y2RU_ConversionParams {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    #[doc = "< Value passed to Y2RU_SetInputLineWidth"]
    pub input_line_width: s16,
    #[doc = "< Value passed to Y2RU_SetInputLines"]
    pub input_lines: s16,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< Unused."]
    pub unused: u8_,
    #[doc = "< Value passed to Y2RU_SetAlpha"]
    pub alpha: u16_,
}
impl Default for Y2RU_ConversionParams {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Y2RU_ConversionParams {
    #[inline]
    pub fn input_format(&self) -> Y2RU_InputFormat {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_input_format(&mut self, val: Y2RU_InputFormat) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn output_format(&self) -> Y2RU_OutputFormat {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_output_format(&mut self, val: Y2RU_OutputFormat) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn rotation(&self) -> Y2RU_Rotation {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_rotation(&mut self, val: Y2RU_Rotation) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn block_alignment(&self) -> Y2RU_BlockAlignment {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_block_alignment(&mut self, val: Y2RU_BlockAlignment) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        input_format: Y2RU_InputFormat,
        output_format: Y2RU_OutputFormat,
        rotation: Y2RU_Rotation,
        block_alignment: Y2RU_BlockAlignment,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let input_format: u32 = unsafe { ::core::mem::transmute(input_format) };
            input_format as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let output_format: u32 = unsafe { ::core::mem::transmute(output_format) };
            output_format as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let rotation: u32 = unsafe { ::core::mem::transmute(rotation) };
            rotation as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let block_alignment: u32 = unsafe { ::core::mem::transmute(block_alignment) };
            block_alignment as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn standard_coefficient(&self) -> Y2RU_StandardCoefficient {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_standard_coefficient(&mut self, val: Y2RU_StandardCoefficient) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        standard_coefficient: Y2RU_StandardCoefficient,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let standard_coefficient: u32 = unsafe { ::core::mem::transmute(standard_coefficient) };
            standard_coefficient as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "Dithering weights."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Y2RU_DitheringWeightParams {
    #[doc = "< Weight 0 for even X, even Y."]
    pub w0_xEven_yEven: u16_,
    #[doc = "< Weight 0 for odd X, even Y."]
    pub w0_xOdd_yEven: u16_,
    #[doc = "< Weight 0 for even X, odd Y."]
    pub w0_xEven_yOdd: u16_,
    #[doc = "< Weight 0 for odd X, odd Y."]
    pub w0_xOdd_yOdd: u16_,
    #[doc = "< Weight 1 for even X, even Y."]
    pub w1_xEven_yEven: u16_,
    #[doc = "< Weight 1 for odd X, even Y."]
    pub w1_xOdd_yEven: u16_,
    #[doc = "< Weight 1 for even X, odd Y."]
    pub w1_xEven_yOdd: u16_,
    #[doc = "< Weight 1 for odd X, odd Y."]
    pub w1_xOdd_yOdd: u16_,
    #[doc = "< Weight 2 for even X, even Y."]
    pub w2_xEven_yEven: u16_,
    #[doc = "< Weight 2 for odd X, even Y."]
    pub w2_xOdd_yEven: u16_,
    #[doc = "< Weight 2 for even X, odd Y."]
    pub w2_xEven_yOdd: u16_,
    #[doc = "< Weight 2 for odd X, odd Y."]
    pub w2_xOdd_yOdd: u16_,
    #[doc = "< Weight 3 for even X, even Y."]
    pub w3_xEven_yEven: u16_,
    #[doc = "< Weight 3 for odd X, even Y."]
    pub w3_xOdd_yEven: u16_,
    #[doc = "< Weight 3 for even X, odd Y."]
    pub w3_xEven_yOdd: u16_,
    #[doc = "< Weight 3 for odd X, odd Y."]
    pub w3_xOdd_yOdd: u16_,
}
extern "C" {
    #[must_use]
    #[doc = "Initializes the y2r service.\n\n This will internally get the handle of the service, and on success call Y2RU_DriverInitialize."]
    pub fn y2rInit() -> Result;
}
extern "C" {
    #[doc = "Closes the y2r service.\n\n This will internally call Y2RU_DriverFinalize and close the handle of the service."]
    pub fn y2rExit();
}
extern "C" {
    #[must_use]
    #[doc = "Used to configure the input format.\n # Arguments\n\n* `format` - Input format to use.\n\n > **Note:** Prefer using Y2RU_SetConversionParams if you have to set multiple parameters."]
    pub fn Y2RU_SetInputFormat(format: Y2RU_InputFormat) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the configured input format.\n # Arguments\n\n* `format` - Pointer to output the input format to."]
    pub fn Y2RU_GetInputFormat(format: *mut Y2RU_InputFormat) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Used to configure the output format.\n # Arguments\n\n* `format` - Output format to use.\n\n > **Note:** Prefer using Y2RU_SetConversionParams if you have to set multiple parameters."]
    pub fn Y2RU_SetOutputFormat(format: Y2RU_OutputFormat) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the configured output format.\n # Arguments\n\n* `format` - Pointer to output the output format to."]
    pub fn Y2RU_GetOutputFormat(format: *mut Y2RU_OutputFormat) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Used to configure the rotation of the output.\n # Arguments\n\n* `rotation` - Rotation to use.\n\n It seems to apply the rotation per batch of 8 lines, so the output will be (height/8) images of size 8 x width.\n\n > **Note:** Prefer using Y2RU_SetConversionParams if you have to set multiple parameters."]
    pub fn Y2RU_SetRotation(rotation: Y2RU_Rotation) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the configured rotation.\n # Arguments\n\n* `rotation` - Pointer to output the rotation to."]
    pub fn Y2RU_GetRotation(rotation: *mut Y2RU_Rotation) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Used to configure the alignment of the output buffer.\n # Arguments\n\n* `alignment` - Alignment to use.\n\n > **Note:** Prefer using Y2RU_SetConversionParams if you have to set multiple parameters."]
    pub fn Y2RU_SetBlockAlignment(alignment: Y2RU_BlockAlignment) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the configured alignment.\n # Arguments\n\n* `alignment` - Pointer to output the alignment to."]
    pub fn Y2RU_GetBlockAlignment(alignment: *mut Y2RU_BlockAlignment) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets whether to use spacial dithering.\n # Arguments\n\n* `enable` - Whether to use spacial dithering."]
    pub fn Y2RU_SetSpacialDithering(enable: bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets whether to use spacial dithering.\n # Arguments\n\n* `enable` - Pointer to output the spacial dithering state to."]
    pub fn Y2RU_GetSpacialDithering(enabled: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets whether to use temporal dithering.\n # Arguments\n\n* `enable` - Whether to use temporal dithering."]
    pub fn Y2RU_SetTemporalDithering(enable: bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets whether to use temporal dithering.\n # Arguments\n\n* `enable` - Pointer to output the temporal dithering state to."]
    pub fn Y2RU_GetTemporalDithering(enabled: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Used to configure the width of the image.\n # Arguments\n\n* `line_width` - Width of the image in pixels. Must be a multiple of 8, up to 1024.\n\n > **Note:** Prefer using Y2RU_SetConversionParams if you have to set multiple parameters."]
    pub fn Y2RU_SetInputLineWidth(line_width: u16_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the configured input line width.\n # Arguments\n\n* `line_width` - Pointer to output the line width to."]
    pub fn Y2RU_GetInputLineWidth(line_width: *mut u16_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Used to configure the height of the image.\n # Arguments\n\n* `num_lines` - Number of lines to be converted.\n\n A multiple of 8 seems to be preferred.\n If using the BLOCK_8_BY_8 mode, it must be a multiple of 8.\n\n > **Note:** Prefer using Y2RU_SetConversionParams if you have to set multiple parameters."]
    pub fn Y2RU_SetInputLines(num_lines: u16_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the configured number of input lines.\n # Arguments\n\n* `num_lines` - Pointer to output the input lines to."]
    pub fn Y2RU_GetInputLines(num_lines: *mut u16_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Used to configure the color conversion formula.\n # Arguments\n\n* `coefficients` - Coefficients to use.\n\n See Y2RU_ColorCoefficients for more information about the coefficients.\n\n > **Note:** Prefer using Y2RU_SetConversionParams if you have to set multiple parameters."]
    pub fn Y2RU_SetCoefficients(coefficients: *const Y2RU_ColorCoefficients) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the configured color coefficients.\n # Arguments\n\n* `num_lines` - Pointer to output the coefficients to."]
    pub fn Y2RU_GetCoefficients(coefficients: *mut Y2RU_ColorCoefficients) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Used to configure the color conversion formula with ITU stantards coefficients.\n # Arguments\n\n* `coefficient` - Standard coefficient to use.\n\n See Y2RU_ColorCoefficients for more information about the coefficients.\n\n > **Note:** Prefer using Y2RU_SetConversionParams if you have to set multiple parameters."]
    pub fn Y2RU_SetStandardCoefficient(coefficient: Y2RU_StandardCoefficient) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the color coefficient parameters of a standard coefficient.\n # Arguments\n\n* `coefficients` - Pointer to output the coefficients to.\n * `standardCoeff` - Standard coefficient to check."]
    pub fn Y2RU_GetStandardCoefficient(
        coefficients: *mut Y2RU_ColorCoefficients,
        standardCoeff: Y2RU_StandardCoefficient,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Used to configure the alpha value of the output.\n # Arguments\n\n* `alpha` - 8-bit value to be used for the output when the format requires it.\n\n > **Note:** Prefer using Y2RU_SetConversionParams if you have to set multiple parameters."]
    pub fn Y2RU_SetAlpha(alpha: u16_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the configured output alpha value.\n # Arguments\n\n* `alpha` - Pointer to output the alpha value to."]
    pub fn Y2RU_GetAlpha(alpha: *mut u16_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Used to enable the end of conversion interrupt.\n # Arguments\n\n* `should_interrupt` - Enables the interrupt if true, disable it if false.\n\n It is possible to fire an interrupt when the conversion is finished, and that the DMA is done copying the data.\n This interrupt will then be used to fire an event. See Y2RU_GetTransferEndEvent.\n By default the interrupt is enabled.\n\n > **Note:** It seems that the event can be fired too soon in some cases, depending the transfer_unit size.Please see the note at Y2RU_SetReceiving"]
    pub fn Y2RU_SetTransferEndInterrupt(should_interrupt: bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets whether the transfer end interrupt is enabled.\n # Arguments\n\n* `should_interrupt` - Pointer to output the interrupt state to."]
    pub fn Y2RU_GetTransferEndInterrupt(should_interrupt: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets an handle to the end of conversion event.\n # Arguments\n\n* `end_event` - Pointer to the event handle to be set to the end of conversion event. It isn't necessary to create or close this handle.\n\n To enable this event you have to use C} Y2RU_SetTransferEndInterrupt(true);The event will be triggered when the corresponding interrupt is fired.\n\n > **Note:** It is recommended to use a timeout when waiting on this event, as it sometimes (but rarely) isn't triggered."]
    pub fn Y2RU_GetTransferEndEvent(end_event: *mut Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Configures the Y plane buffer.\n # Arguments\n\n* `src_buf` - A pointer to the beginning of your Y data buffer.\n * `image_size` - The total size of the data buffer.\n * `transfer_unit` - Specifies the size of 1 DMA transfer. Usually set to 1 line. This has to be a divisor of image_size.\n * `transfer_gap` - Specifies the gap (offset) to be added after each transfer. Can be used to convert images with stride or only a part of it.\n\n transfer_unit+transfer_gap must be less than 32768 (0x8000)\n\n This specifies the Y data buffer for the planar input formats (INPUT_YUV42*_INDIV_*).\n The actual transfer will only happen after calling Y2RU_StartConversion."]
    pub fn Y2RU_SetSendingY(
        src_buf: *const ::libc::c_void,
        image_size: u32_,
        transfer_unit: s16,
        transfer_gap: s16,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Configures the U plane buffer.\n # Arguments\n\n* `src_buf` - A pointer to the beginning of your Y data buffer.\n * `image_size` - The total size of the data buffer.\n * `transfer_unit` - Specifies the size of 1 DMA transfer. Usually set to 1 line. This has to be a divisor of image_size.\n * `transfer_gap` - Specifies the gap (offset) to be added after each transfer. Can be used to convert images with stride or only a part of it.\n\n transfer_unit+transfer_gap must be less than 32768 (0x8000)\n\n This specifies the U data buffer for the planar input formats (INPUT_YUV42*_INDIV_*).\n The actual transfer will only happen after calling Y2RU_StartConversion."]
    pub fn Y2RU_SetSendingU(
        src_buf: *const ::libc::c_void,
        image_size: u32_,
        transfer_unit: s16,
        transfer_gap: s16,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Configures the V plane buffer.\n # Arguments\n\n* `src_buf` - A pointer to the beginning of your Y data buffer.\n * `image_size` - The total size of the data buffer.\n * `transfer_unit` - Specifies the size of 1 DMA transfer. Usually set to 1 line. This has to be a divisor of image_size.\n * `transfer_gap` - Specifies the gap (offset) to be added after each transfer. Can be used to convert images with stride or only a part of it.\n\n transfer_unit+transfer_gap must be less than 32768 (0x8000)\n\n This specifies the V data buffer for the planar input formats (INPUT_YUV42*_INDIV_*).\n The actual transfer will only happen after calling Y2RU_StartConversion."]
    pub fn Y2RU_SetSendingV(
        src_buf: *const ::libc::c_void,
        image_size: u32_,
        transfer_unit: s16,
        transfer_gap: s16,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Configures the YUYV source buffer.\n # Arguments\n\n* `src_buf` - A pointer to the beginning of your Y data buffer.\n * `image_size` - The total size of the data buffer.\n * `transfer_unit` - Specifies the size of 1 DMA transfer. Usually set to 1 line. This has to be a divisor of image_size.\n * `transfer_gap` - Specifies the gap (offset) to be added after each transfer. Can be used to convert images with stride or only a part of it.\n\n transfer_unit+transfer_gap must be less than 32768 (0x8000)\n\n This specifies the YUYV data buffer for the packed input format INPUT_YUV422_BATCH.\n The actual transfer will only happen after calling Y2RU_StartConversion."]
    pub fn Y2RU_SetSendingYUYV(
        src_buf: *const ::libc::c_void,
        image_size: u32_,
        transfer_unit: s16,
        transfer_gap: s16,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Configures the destination buffer.\n # Arguments\n\n* `src_buf` - A pointer to the beginning of your destination buffer in FCRAM\n * `image_size` - The total size of the data buffer.\n * `transfer_unit` - Specifies the size of 1 DMA transfer. Usually set to 1 line. This has to be a divisor of image_size.\n * `transfer_gap` - Specifies the gap (offset) to be added after each transfer. Can be used to convert images with stride or only a part of it.\n\n This specifies the destination buffer of the conversion.\n The actual transfer will only happen after calling Y2RU_StartConversion.\n The buffer does NOT need to be allocated in the linear heap.\n\n transfer_unit+transfer_gap must be less than 32768 (0x8000)\n\n > **Note:** It seems that depending on the size of the image and of the transfer unit,it is possible for the end of conversion interrupt to be triggered right after the conversion began.One line as transfer_unit seems to trigger this issue for 400x240, setting to 2/4/8 lines fixes it.\n\n > **Note:** Setting a transfer_unit of 4 or 8 lines seems to bring the best results in terms of speed for a 400x240 image."]
    pub fn Y2RU_SetReceiving(
        dst_buf: *mut ::libc::c_void,
        image_size: u32_,
        transfer_unit: s16,
        transfer_gap: s16,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Checks if the DMA has finished sending the Y buffer.\n # Arguments\n\n* `is_done` - Pointer to the boolean that will hold the result.\n\n True if the DMA has finished transferring the Y plane, false otherwise. To be used with Y2RU_SetSendingY."]
    pub fn Y2RU_IsDoneSendingY(is_done: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Checks if the DMA has finished sending the U buffer.\n # Arguments\n\n* `is_done` - Pointer to the boolean that will hold the result.\n\n True if the DMA has finished transferring the U plane, false otherwise. To be used with Y2RU_SetSendingU."]
    pub fn Y2RU_IsDoneSendingU(is_done: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Checks if the DMA has finished sending the V buffer.\n # Arguments\n\n* `is_done` - Pointer to the boolean that will hold the result.\n\n True if the DMA has finished transferring the V plane, false otherwise. To be used with Y2RU_SetSendingV."]
    pub fn Y2RU_IsDoneSendingV(is_done: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Checks if the DMA has finished sending the YUYV buffer.\n # Arguments\n\n* `is_done` - Pointer to the boolean that will hold the result.\n\n True if the DMA has finished transferring the YUYV buffer, false otherwise. To be used with Y2RU_SetSendingYUYV."]
    pub fn Y2RU_IsDoneSendingYUYV(is_done: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Checks if the DMA has finished sending the converted result.\n # Arguments\n\n* `is_done` - Pointer to the boolean that will hold the result.\n\n True if the DMA has finished transferring data to your destination buffer, false otherwise."]
    pub fn Y2RU_IsDoneReceiving(is_done: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Configures the dithering weight parameters.\n # Arguments\n\n* `params` - Dithering weight parameters to use."]
    pub fn Y2RU_SetDitheringWeightParams(params: *const Y2RU_DitheringWeightParams) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the configured dithering weight parameters.\n # Arguments\n\n* `params` - Pointer to output the dithering weight parameters to."]
    pub fn Y2RU_GetDitheringWeightParams(params: *mut Y2RU_DitheringWeightParams) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets all of the parameters of Y2RU_ConversionParams at once.\n # Arguments\n\n* `params` - Conversion parameters to set.\n\n Faster than calling the individual value through Y2R_Set* because only one system call is made."]
    pub fn Y2RU_SetConversionParams(params: *const Y2RU_ConversionParams) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Starts the conversion process"]
    pub fn Y2RU_StartConversion() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Cancels the conversion"]
    pub fn Y2RU_StopConversion() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Checks if the conversion and DMA transfer are finished.\n # Arguments\n\n* `is_busy` - Pointer to output the busy state to.\n\n This can have the same problems as the event and interrupt. See Y2RU_SetTransferEndInterrupt."]
    pub fn Y2RU_IsBusyConversion(is_busy: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Checks whether Y2R is ready to be used.\n # Arguments\n\n* `ping` - Pointer to output the ready status to."]
    pub fn Y2RU_PingProcess(ping: *mut u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initializes the Y2R driver."]
    pub fn Y2RU_DriverInitialize() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Terminates the Y2R driver."]
    pub fn Y2RU_DriverFinalize() -> Result;
}
#[doc = "< No port."]
pub const PORT_NONE: _bindgen_ty_15 = 0;
#[doc = "< CAM1 port."]
pub const PORT_CAM1: _bindgen_ty_15 = 1;
#[doc = "< CAM2 port."]
pub const PORT_CAM2: _bindgen_ty_15 = 2;
#[doc = "< Both ports."]
pub const PORT_BOTH: _bindgen_ty_15 = 3;
#[doc = "Camera connection target ports."]
pub type _bindgen_ty_15 = ::libc::c_uint;
#[doc = "< No camera."]
pub const SELECT_NONE: _bindgen_ty_16 = 0;
#[doc = "< Outer camera 1."]
pub const SELECT_OUT1: _bindgen_ty_16 = 1;
#[doc = "< Inner camera 1."]
pub const SELECT_IN1: _bindgen_ty_16 = 2;
#[doc = "< Outer camera 2."]
pub const SELECT_OUT2: _bindgen_ty_16 = 4;
#[doc = "< Outer camera 1 and inner camera 1."]
pub const SELECT_IN1_OUT1: _bindgen_ty_16 = 3;
#[doc = "< Both outer cameras."]
pub const SELECT_OUT1_OUT2: _bindgen_ty_16 = 5;
#[doc = "< Inner camera 1 and outer camera 2."]
pub const SELECT_IN1_OUT2: _bindgen_ty_16 = 6;
#[doc = "< All cameras."]
pub const SELECT_ALL: _bindgen_ty_16 = 7;
#[doc = "Camera combinations."]
pub type _bindgen_ty_16 = ::libc::c_uint;
#[doc = "< No context."]
pub const CONTEXT_NONE: CAMU_Context = 0;
#[doc = "< Context A."]
pub const CONTEXT_A: CAMU_Context = 1;
#[doc = "< Context B."]
pub const CONTEXT_B: CAMU_Context = 2;
#[doc = "< Both contexts."]
pub const CONTEXT_BOTH: CAMU_Context = 3;
#[doc = "Camera contexts."]
pub type CAMU_Context = ::libc::c_uint;
#[doc = "< No flip."]
pub const FLIP_NONE: CAMU_Flip = 0;
#[doc = "< Horizontal flip."]
pub const FLIP_HORIZONTAL: CAMU_Flip = 1;
#[doc = "< Vertical flip."]
pub const FLIP_VERTICAL: CAMU_Flip = 2;
#[doc = "< Reverse flip."]
pub const FLIP_REVERSE: CAMU_Flip = 3;
#[doc = "Ways to flip the camera image."]
pub type CAMU_Flip = ::libc::c_uint;
#[doc = "< VGA size. (640x480)"]
pub const SIZE_VGA: CAMU_Size = 0;
#[doc = "< QVGA size. (320x240)"]
pub const SIZE_QVGA: CAMU_Size = 1;
#[doc = "< QQVGA size. (160x120)"]
pub const SIZE_QQVGA: CAMU_Size = 2;
#[doc = "< CIF size. (352x288)"]
pub const SIZE_CIF: CAMU_Size = 3;
#[doc = "< QCIF size. (176x144)"]
pub const SIZE_QCIF: CAMU_Size = 4;
#[doc = "< DS LCD size. (256x192)"]
pub const SIZE_DS_LCD: CAMU_Size = 5;
#[doc = "< DS LCD x4 size. (512x384)"]
pub const SIZE_DS_LCDx4: CAMU_Size = 6;
#[doc = "< CTR Top LCD size. (400x240)"]
pub const SIZE_CTR_TOP_LCD: CAMU_Size = 7;
#[doc = "< CTR Bottom LCD size. (320x240)"]
pub const SIZE_CTR_BOTTOM_LCD: CAMU_Size = 1;
#[doc = "Camera image resolutions."]
pub type CAMU_Size = ::libc::c_uint;
#[doc = "< 15 FPS."]
pub const FRAME_RATE_15: CAMU_FrameRate = 0;
#[doc = "< 15-5 FPS."]
pub const FRAME_RATE_15_TO_5: CAMU_FrameRate = 1;
#[doc = "< 15-2 FPS."]
pub const FRAME_RATE_15_TO_2: CAMU_FrameRate = 2;
#[doc = "< 10 FPS."]
pub const FRAME_RATE_10: CAMU_FrameRate = 3;
#[doc = "< 8.5 FPS."]
pub const FRAME_RATE_8_5: CAMU_FrameRate = 4;
#[doc = "< 5 FPS."]
pub const FRAME_RATE_5: CAMU_FrameRate = 5;
#[doc = "< 20 FPS."]
pub const FRAME_RATE_20: CAMU_FrameRate = 6;
#[doc = "< 20-5 FPS."]
pub const FRAME_RATE_20_TO_5: CAMU_FrameRate = 7;
#[doc = "< 30 FPS."]
pub const FRAME_RATE_30: CAMU_FrameRate = 8;
#[doc = "< 30-5 FPS."]
pub const FRAME_RATE_30_TO_5: CAMU_FrameRate = 9;
#[doc = "< 15-10 FPS."]
pub const FRAME_RATE_15_TO_10: CAMU_FrameRate = 10;
#[doc = "< 20-10 FPS."]
pub const FRAME_RATE_20_TO_10: CAMU_FrameRate = 11;
#[doc = "< 30-10 FPS."]
pub const FRAME_RATE_30_TO_10: CAMU_FrameRate = 12;
#[doc = "Camera capture frame rates."]
pub type CAMU_FrameRate = ::libc::c_uint;
#[doc = "< Auto white balance."]
pub const WHITE_BALANCE_AUTO: CAMU_WhiteBalance = 0;
#[doc = "< 3200K white balance."]
pub const WHITE_BALANCE_3200K: CAMU_WhiteBalance = 1;
#[doc = "< 4150K white balance."]
pub const WHITE_BALANCE_4150K: CAMU_WhiteBalance = 2;
#[doc = "< 5200K white balance."]
pub const WHITE_BALANCE_5200K: CAMU_WhiteBalance = 3;
#[doc = "< 6000K white balance."]
pub const WHITE_BALANCE_6000K: CAMU_WhiteBalance = 4;
#[doc = "< 7000K white balance."]
pub const WHITE_BALANCE_7000K: CAMU_WhiteBalance = 5;
pub const WHITE_BALANCE_NORMAL: CAMU_WhiteBalance = 0;
pub const WHITE_BALANCE_TUNGSTEN: CAMU_WhiteBalance = 1;
pub const WHITE_BALANCE_WHITE_FLUORESCENT_LIGHT: CAMU_WhiteBalance = 2;
pub const WHITE_BALANCE_DAYLIGHT: CAMU_WhiteBalance = 3;
pub const WHITE_BALANCE_CLOUDY: CAMU_WhiteBalance = 4;
pub const WHITE_BALANCE_HORIZON: CAMU_WhiteBalance = 4;
pub const WHITE_BALANCE_SHADE: CAMU_WhiteBalance = 5;
#[doc = "Camera white balance modes."]
pub type CAMU_WhiteBalance = ::libc::c_uint;
#[doc = "< Normal mode."]
pub const PHOTO_MODE_NORMAL: CAMU_PhotoMode = 0;
#[doc = "< Portrait mode."]
pub const PHOTO_MODE_PORTRAIT: CAMU_PhotoMode = 1;
#[doc = "< Landscape mode."]
pub const PHOTO_MODE_LANDSCAPE: CAMU_PhotoMode = 2;
#[doc = "< Night mode."]
pub const PHOTO_MODE_NIGHTVIEW: CAMU_PhotoMode = 3;
#[doc = "< Letter mode."]
pub const PHOTO_MODE_LETTER: CAMU_PhotoMode = 4;
#[doc = "Camera photo modes."]
pub type CAMU_PhotoMode = ::libc::c_uint;
#[doc = "< No effects."]
pub const EFFECT_NONE: CAMU_Effect = 0;
#[doc = "< Mono effect."]
pub const EFFECT_MONO: CAMU_Effect = 1;
#[doc = "< Sepia effect."]
pub const EFFECT_SEPIA: CAMU_Effect = 2;
#[doc = "< Negative effect."]
pub const EFFECT_NEGATIVE: CAMU_Effect = 3;
#[doc = "< Negative film effect."]
pub const EFFECT_NEGAFILM: CAMU_Effect = 4;
#[doc = "< Sepia effect."]
pub const EFFECT_SEPIA01: CAMU_Effect = 5;
#[doc = "Camera special effects."]
pub type CAMU_Effect = ::libc::c_uint;
#[doc = "< Pattern 1."]
pub const CONTRAST_PATTERN_01: CAMU_Contrast = 0;
#[doc = "< Pattern 2."]
pub const CONTRAST_PATTERN_02: CAMU_Contrast = 1;
#[doc = "< Pattern 3."]
pub const CONTRAST_PATTERN_03: CAMU_Contrast = 2;
#[doc = "< Pattern 4."]
pub const CONTRAST_PATTERN_04: CAMU_Contrast = 3;
#[doc = "< Pattern 5."]
pub const CONTRAST_PATTERN_05: CAMU_Contrast = 4;
#[doc = "< Pattern 6."]
pub const CONTRAST_PATTERN_06: CAMU_Contrast = 5;
#[doc = "< Pattern 7."]
pub const CONTRAST_PATTERN_07: CAMU_Contrast = 6;
#[doc = "< Pattern 8."]
pub const CONTRAST_PATTERN_08: CAMU_Contrast = 7;
#[doc = "< Pattern 9."]
pub const CONTRAST_PATTERN_09: CAMU_Contrast = 8;
#[doc = "< Pattern 10."]
pub const CONTRAST_PATTERN_10: CAMU_Contrast = 9;
#[doc = "< Pattern 11."]
pub const CONTRAST_PATTERN_11: CAMU_Contrast = 10;
#[doc = "< Low contrast. (5)"]
pub const CONTRAST_LOW: CAMU_Contrast = 4;
#[doc = "< Normal contrast. (6)"]
pub const CONTRAST_NORMAL: CAMU_Contrast = 5;
#[doc = "< High contrast. (7)"]
pub const CONTRAST_HIGH: CAMU_Contrast = 6;
#[doc = "Camera contrast patterns."]
pub type CAMU_Contrast = ::libc::c_uint;
#[doc = "< No lens correction."]
pub const LENS_CORRECTION_OFF: CAMU_LensCorrection = 0;
#[doc = "< Edge-to-center brightness ratio of 70."]
pub const LENS_CORRECTION_ON_70: CAMU_LensCorrection = 1;
#[doc = "< Edge-to-center brightness ratio of 90."]
pub const LENS_CORRECTION_ON_90: CAMU_LensCorrection = 2;
#[doc = "< Dark lens correction. (OFF)"]
pub const LENS_CORRECTION_DARK: CAMU_LensCorrection = 0;
#[doc = "< Normal lens correction. (70)"]
pub const LENS_CORRECTION_NORMAL: CAMU_LensCorrection = 1;
#[doc = "< Bright lens correction. (90)"]
pub const LENS_CORRECTION_BRIGHT: CAMU_LensCorrection = 2;
#[doc = "Camera lens correction modes."]
pub type CAMU_LensCorrection = ::libc::c_uint;
#[doc = "< YUV422"]
pub const OUTPUT_YUV_422: CAMU_OutputFormat = 0;
#[doc = "< RGB565"]
pub const OUTPUT_RGB_565: CAMU_OutputFormat = 1;
#[doc = "Camera image output formats."]
pub type CAMU_OutputFormat = ::libc::c_uint;
#[doc = "< Normal shutter sound."]
pub const SHUTTER_SOUND_TYPE_NORMAL: CAMU_ShutterSoundType = 0;
#[doc = "< Shutter sound to begin a movie."]
pub const SHUTTER_SOUND_TYPE_MOVIE: CAMU_ShutterSoundType = 1;
#[doc = "< Shutter sound to end a movie."]
pub const SHUTTER_SOUND_TYPE_MOVIE_END: CAMU_ShutterSoundType = 2;
#[doc = "Camera shutter sounds."]
pub type CAMU_ShutterSoundType = ::libc::c_uint;
#[doc = "Image quality calibration data."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CAMU_ImageQualityCalibrationData {
    #[doc = "< Auto exposure base target brightness."]
    pub aeBaseTarget: s16,
    #[doc = "< Left color correction matrix red normalization coefficient."]
    pub kRL: s16,
    #[doc = "< Left color correction matrix green normalization coefficient."]
    pub kGL: s16,
    #[doc = "< Left color correction matrix blue normalization coefficient."]
    pub kBL: s16,
    #[doc = "< Color correction matrix position."]
    pub ccmPosition: s16,
    #[doc = "< Right camera, left color correction matrix red/green gain."]
    pub awbCcmL9Right: u16_,
    #[doc = "< Left camera, left color correction matrix red/green gain."]
    pub awbCcmL9Left: u16_,
    #[doc = "< Right camera, left color correction matrix blue/green gain."]
    pub awbCcmL10Right: u16_,
    #[doc = "< Left camera, left color correction matrix blue/green gain."]
    pub awbCcmL10Left: u16_,
    #[doc = "< Right camera, color correction matrix position threshold."]
    pub awbX0Right: u16_,
    #[doc = "< Left camera, color correction matrix position threshold."]
    pub awbX0Left: u16_,
}
#[doc = "Stereo camera calibration data."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CAMU_StereoCameraCalibrationData {
    #[doc = "< #bool Whether the X and Y rotation data is valid."]
    pub isValidRotationXY: u8_,
    #[doc = "< Padding. (Aligns isValidRotationXY to 4 bytes)"]
    pub padding: [u8_; 3usize],
    #[doc = "< Scale to match the left camera image with the right."]
    pub scale: f32,
    #[doc = "< Z axis rotation to match the left camera image with the right."]
    pub rotationZ: f32,
    #[doc = "< X axis translation to match the left camera image with the right."]
    pub translationX: f32,
    #[doc = "< Y axis translation to match the left camera image with the right."]
    pub translationY: f32,
    #[doc = "< X axis rotation to match the left camera image with the right."]
    pub rotationX: f32,
    #[doc = "< Y axis rotation to match the left camera image with the right."]
    pub rotationY: f32,
    #[doc = "< Right camera angle of view."]
    pub angleOfViewRight: f32,
    #[doc = "< Left camera angle of view."]
    pub angleOfViewLeft: f32,
    #[doc = "< Distance between cameras and measurement chart."]
    pub distanceToChart: f32,
    #[doc = "< Distance between left and right cameras."]
    pub distanceCameras: f32,
    #[doc = "< Image width."]
    pub imageWidth: s16,
    #[doc = "< Image height."]
    pub imageHeight: s16,
    #[doc = "< Reserved for future use. (unused)"]
    pub reserved: [u8_; 16usize],
}
#[doc = "Batch camera configuration for use without a context."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CAMU_PackageParameterCameraSelect {
    #[doc = "< Selected camera."]
    pub camera: u8_,
    #[doc = "< Camera exposure."]
    pub exposure: s8,
    #[doc = "< #CAMU_WhiteBalance Camera white balance."]
    pub whiteBalance: u8_,
    #[doc = "< Camera sharpness."]
    pub sharpness: s8,
    #[doc = "< #bool Whether to automatically determine the proper exposure."]
    pub autoExposureOn: u8_,
    #[doc = "< #bool Whether to automatically determine the white balance mode."]
    pub autoWhiteBalanceOn: u8_,
    #[doc = "< #CAMU_FrameRate Camera frame rate."]
    pub frameRate: u8_,
    #[doc = "< #CAMU_PhotoMode Camera photo mode."]
    pub photoMode: u8_,
    #[doc = "< #CAMU_Contrast Camera contrast."]
    pub contrast: u8_,
    #[doc = "< #CAMU_LensCorrection Camera lens correction."]
    pub lensCorrection: u8_,
    #[doc = "< #bool Whether to enable the camera's noise filter."]
    pub noiseFilterOn: u8_,
    #[doc = "< Padding. (Aligns last 3 fields to 4 bytes)"]
    pub padding: u8_,
    #[doc = "< X of the region to use for auto exposure."]
    pub autoExposureWindowX: s16,
    #[doc = "< Y of the region to use for auto exposure."]
    pub autoExposureWindowY: s16,
    #[doc = "< Width of the region to use for auto exposure."]
    pub autoExposureWindowWidth: s16,
    #[doc = "< Height of the region to use for auto exposure."]
    pub autoExposureWindowHeight: s16,
    #[doc = "< X of the region to use for auto white balance."]
    pub autoWhiteBalanceWindowX: s16,
    #[doc = "< Y of the region to use for auto white balance."]
    pub autoWhiteBalanceWindowY: s16,
    #[doc = "< Width of the region to use for auto white balance."]
    pub autoWhiteBalanceWindowWidth: s16,
    #[doc = "< Height of the region to use for auto white balance."]
    pub autoWhiteBalanceWindowHeight: s16,
}
#[doc = "Batch camera configuration for use with a context."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CAMU_PackageParameterContext {
    #[doc = "< Selected camera."]
    pub camera: u8_,
    #[doc = "< #CAMU_Context Selected context."]
    pub context: u8_,
    #[doc = "< #CAMU_Flip Camera image flip mode."]
    pub flip: u8_,
    #[doc = "< #CAMU_Effect Camera image special effects."]
    pub effect: u8_,
    #[doc = "< #CAMU_Size Camera image resolution."]
    pub size: u8_,
}
#[doc = "Batch camera configuration for use with a context and with detailed size information."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CAMU_PackageParameterContextDetail {
    #[doc = "< Selected camera."]
    pub camera: u8_,
    #[doc = "< #CAMU_Context Selected context."]
    pub context: u8_,
    #[doc = "< #CAMU_Flip Camera image flip mode."]
    pub flip: u8_,
    #[doc = "< #CAMU_Effect Camera image special effects."]
    pub effect: u8_,
    #[doc = "< Image width."]
    pub width: s16,
    #[doc = "< Image height."]
    pub height: s16,
    #[doc = "< First crop point X."]
    pub cropX0: s16,
    #[doc = "< First crop point Y."]
    pub cropY0: s16,
    #[doc = "< Second crop point X."]
    pub cropX1: s16,
    #[doc = "< Second crop point Y."]
    pub cropY1: s16,
}
extern "C" {
    #[must_use]
    #[doc = "Initializes the cam service.\n\n This will internally get the handle of the service, and on success call CAMU_DriverInitialize."]
    pub fn camInit() -> Result;
}
extern "C" {
    #[doc = "Closes the cam service.\n\n This will internally call CAMU_DriverFinalize and close the handle of the service."]
    pub fn camExit();
}
extern "C" {
    #[must_use]
    #[doc = "Begins capture on the specified camera port.\n # Arguments\n\n* `port` - Port to begin capture on."]
    pub fn CAMU_StartCapture(port: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Terminates capture on the specified camera port.\n # Arguments\n\n* `port` - Port to terminate capture on."]
    pub fn CAMU_StopCapture(port: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets whether the specified camera port is busy.\n # Arguments\n\n* `busy` - Pointer to output the busy state to.\n * `port` - Port to check."]
    pub fn CAMU_IsBusy(busy: *mut bool, port: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Clears the buffer and error flags of the specified camera port.\n # Arguments\n\n* `port` - Port to clear."]
    pub fn CAMU_ClearBuffer(port: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets a handle to the event signaled on vsync interrupts.\n # Arguments\n\n* `event` - Pointer to output the event handle to.\n * `port` - Port to use."]
    pub fn CAMU_GetVsyncInterruptEvent(event: *mut Handle, port: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets a handle to the event signaled on camera buffer errors.\n # Arguments\n\n* `event` - Pointer to output the event handle to.\n * `port` - Port to use."]
    pub fn CAMU_GetBufferErrorInterruptEvent(event: *mut Handle, port: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initiates the process of receiving a camera frame.\n # Arguments\n\n* `event` - Pointer to output the completion event handle to.\n * `dst` - Buffer to write data to.\n * `port` - Port to receive from.\n * `imageSize` - Size of the image to receive.\n * `transferUnit` - Transfer unit to use when receiving."]
    pub fn CAMU_SetReceiving(
        event: *mut Handle,
        dst: *mut ::libc::c_void,
        port: u32_,
        imageSize: u32_,
        transferUnit: s16,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets whether the specified camera port has finished receiving image data.\n # Arguments\n\n* `finishedReceiving` - Pointer to output the receiving status to.\n * `port` - Port to check."]
    pub fn CAMU_IsFinishedReceiving(finishedReceiving: *mut bool, port: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the number of lines to transfer into an image buffer.\n # Arguments\n\n* `port` - Port to use.\n * `lines` - Lines to transfer.\n * `width` - Width of the image.\n * `height` - Height of the image."]
    pub fn CAMU_SetTransferLines(port: u32_, lines: s16, width: s16, height: s16) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the maximum number of lines that can be saved to an image buffer.\n # Arguments\n\n* `maxLines` - Pointer to write the maximum number of lines to.\n * `width` - Width of the image.\n * `height` - Height of the image."]
    pub fn CAMU_GetMaxLines(maxLines: *mut s16, width: s16, height: s16) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the number of bytes to transfer into an image buffer.\n # Arguments\n\n* `port` - Port to use.\n * `bytes` - Bytes to transfer.\n * `width` - Width of the image.\n * `height` - Height of the image."]
    pub fn CAMU_SetTransferBytes(port: u32_, bytes: u32_, width: s16, height: s16) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the number of bytes to transfer into an image buffer.\n # Arguments\n\n* `transferBytes` - Pointer to write the number of bytes to.\n * `port` - Port to use."]
    pub fn CAMU_GetTransferBytes(transferBytes: *mut u32_, port: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the maximum number of bytes that can be saved to an image buffer.\n # Arguments\n\n* `maxBytes` - Pointer to write the maximum number of bytes to.\n * `width` - Width of the image.\n * `height` - Height of the image."]
    pub fn CAMU_GetMaxBytes(maxBytes: *mut u32_, width: s16, height: s16) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets whether image trimming is enabled.\n # Arguments\n\n* `port` - Port to use.\n * `trimming` - Whether image trimming is enabled."]
    pub fn CAMU_SetTrimming(port: u32_, trimming: bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets whether image trimming is enabled.\n # Arguments\n\n* `trimming` - Pointer to output the trim state to.\n * `port` - Port to use."]
    pub fn CAMU_IsTrimming(trimming: *mut bool, port: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the parameters used for trimming images.\n # Arguments\n\n* `port` - Port to use.\n * `xStart` - Start X coordinate.\n * `yStart` - Start Y coordinate.\n * `xEnd` - End X coordinate.\n * `yEnd` - End Y coordinate."]
    pub fn CAMU_SetTrimmingParams(
        port: u32_,
        xStart: s16,
        yStart: s16,
        xEnd: s16,
        yEnd: s16,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the parameters used for trimming images.\n # Arguments\n\n* `xStart` - Pointer to write the start X coordinate to.\n * `yStart` - Pointer to write the start Y coordinate to.\n * `xEnd` - Pointer to write the end X coordinate to.\n * `yEnd` - Pointer to write the end Y coordinate to.\n * `port` - Port to use."]
    pub fn CAMU_GetTrimmingParams(
        xStart: *mut s16,
        yStart: *mut s16,
        xEnd: *mut s16,
        yEnd: *mut s16,
        port: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the parameters used for trimming images, relative to the center of the image.\n # Arguments\n\n* `port` - Port to use.\n * `trimWidth` - Trim width.\n * `trimHeight` - Trim height.\n * `camWidth` - Camera width.\n * `camHeight` - Camera height."]
    pub fn CAMU_SetTrimmingParamsCenter(
        port: u32_,
        trimWidth: s16,
        trimHeight: s16,
        camWidth: s16,
        camHeight: s16,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Activates the specified camera.\n # Arguments\n\n* `select` - Camera to use."]
    pub fn CAMU_Activate(select: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Switches the specified camera's active context.\n # Arguments\n\n* `select` - Camera to use.\n * `context` - Context to use."]
    pub fn CAMU_SwitchContext(select: u32_, context: CAMU_Context) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the exposure value of the specified camera.\n # Arguments\n\n* `select` - Camera to use.\n * `exposure` - Exposure value to use."]
    pub fn CAMU_SetExposure(select: u32_, exposure: s8) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the white balance mode of the specified camera.\n # Arguments\n\n* `select` - Camera to use.\n * `whiteBalance` - White balance mode to use."]
    pub fn CAMU_SetWhiteBalance(select: u32_, whiteBalance: CAMU_WhiteBalance) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the white balance mode of the specified camera.\n TODO: Explain \"without base up\"?\n # Arguments\n\n* `select` - Camera to use.\n * `whiteBalance` - White balance mode to use."]
    pub fn CAMU_SetWhiteBalanceWithoutBaseUp(
        select: u32_,
        whiteBalance: CAMU_WhiteBalance,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the sharpness of the specified camera.\n # Arguments\n\n* `select` - Camera to use.\n * `sharpness` - Sharpness to use."]
    pub fn CAMU_SetSharpness(select: u32_, sharpness: s8) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets whether auto exposure is enabled on the specified camera.\n # Arguments\n\n* `select` - Camera to use.\n * `autoWhiteBalance` - Whether auto exposure is enabled."]
    pub fn CAMU_SetAutoExposure(select: u32_, autoExposure: bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets whether auto exposure is enabled on the specified camera.\n # Arguments\n\n* `autoExposure` - Pointer to output the auto exposure state to.\n * `select` - Camera to use."]
    pub fn CAMU_IsAutoExposure(autoExposure: *mut bool, select: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets whether auto white balance is enabled on the specified camera.\n # Arguments\n\n* `select` - Camera to use.\n * `autoWhiteBalance` - Whether auto white balance is enabled."]
    pub fn CAMU_SetAutoWhiteBalance(select: u32_, autoWhiteBalance: bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets whether auto white balance is enabled on the specified camera.\n # Arguments\n\n* `autoWhiteBalance` - Pointer to output the auto white balance state to.\n * `select` - Camera to use."]
    pub fn CAMU_IsAutoWhiteBalance(autoWhiteBalance: *mut bool, select: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Flips the image of the specified camera in the specified context.\n # Arguments\n\n* `select` - Camera to use.\n * `flip` - Flip mode to use.\n * `context` - Context to use."]
    pub fn CAMU_FlipImage(select: u32_, flip: CAMU_Flip, context: CAMU_Context) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the image resolution of the given camera in the given context, in detail.\n # Arguments\n\n* `select` - Camera to use.\n * `width` - Width to use.\n * `height` - Height to use.\n * `cropX0` - First crop point X.\n * `cropY0` - First crop point Y.\n * `cropX1` - Second crop point X.\n * `cropY1` - Second crop point Y.\n * `context` - Context to use."]
    pub fn CAMU_SetDetailSize(
        select: u32_,
        width: s16,
        height: s16,
        cropX0: s16,
        cropY0: s16,
        cropX1: s16,
        cropY1: s16,
        context: CAMU_Context,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the image resolution of the given camera in the given context.\n # Arguments\n\n* `select` - Camera to use.\n * `size` - Size to use.\n * `context` - Context to use."]
    pub fn CAMU_SetSize(select: u32_, size: CAMU_Size, context: CAMU_Context) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the frame rate of the given camera.\n # Arguments\n\n* `select` - Camera to use.\n * `frameRate` - Frame rate to use."]
    pub fn CAMU_SetFrameRate(select: u32_, frameRate: CAMU_FrameRate) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the photo mode of the given camera.\n # Arguments\n\n* `select` - Camera to use.\n * `photoMode` - Photo mode to use."]
    pub fn CAMU_SetPhotoMode(select: u32_, photoMode: CAMU_PhotoMode) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the special effects of the given camera in the given context.\n # Arguments\n\n* `select` - Camera to use.\n * `effect` - Effect to use.\n * `context` - Context to use."]
    pub fn CAMU_SetEffect(select: u32_, effect: CAMU_Effect, context: CAMU_Context) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the contrast mode of the given camera.\n # Arguments\n\n* `select` - Camera to use.\n * `contrast` - Contrast mode to use."]
    pub fn CAMU_SetContrast(select: u32_, contrast: CAMU_Contrast) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the lens correction mode of the given camera.\n # Arguments\n\n* `select` - Camera to use.\n * `lensCorrection` - Lens correction mode to use."]
    pub fn CAMU_SetLensCorrection(select: u32_, lensCorrection: CAMU_LensCorrection) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the output format of the given camera in the given context.\n # Arguments\n\n* `select` - Camera to use.\n * `format` - Format to output.\n * `context` - Context to use."]
    pub fn CAMU_SetOutputFormat(
        select: u32_,
        format: CAMU_OutputFormat,
        context: CAMU_Context,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the region to base auto exposure off of for the specified camera.\n # Arguments\n\n* `select` - Camera to use.\n * `x` - X of the region.\n * `y` - Y of the region.\n * `width` - Width of the region.\n * `height` - Height of the region."]
    pub fn CAMU_SetAutoExposureWindow(
        select: u32_,
        x: s16,
        y: s16,
        width: s16,
        height: s16,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the region to base auto white balance off of for the specified camera.\n # Arguments\n\n* `select` - Camera to use.\n * `x` - X of the region.\n * `y` - Y of the region.\n * `width` - Width of the region.\n * `height` - Height of the region."]
    pub fn CAMU_SetAutoWhiteBalanceWindow(
        select: u32_,
        x: s16,
        y: s16,
        width: s16,
        height: s16,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets whether the specified camera's noise filter is enabled.\n # Arguments\n\n* `select` - Camera to use.\n * `noiseFilter` - Whether the noise filter is enabled."]
    pub fn CAMU_SetNoiseFilter(select: u32_, noiseFilter: bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Synchronizes the specified cameras' vsync timing.\n # Arguments\n\n* `select1` - First camera.\n * `select2` - Second camera."]
    pub fn CAMU_SynchronizeVsyncTiming(select1: u32_, select2: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the vsync timing record of the specified camera for the specified number of signals.\n # Arguments\n\n* `timing` - Pointer to write timing data to. (size \"past * sizeof(s64)\")\n * `port` - Port to use.\n * `past` - Number of past timings to retrieve."]
    pub fn CAMU_GetLatestVsyncTiming(timing: *mut s64, port: u32_, past: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the specified camera's stereo camera calibration data.\n # Arguments\n\n* `data` - Pointer to output the stereo camera data to."]
    pub fn CAMU_GetStereoCameraCalibrationData(
        data: *mut CAMU_StereoCameraCalibrationData,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the specified camera's stereo camera calibration data.\n # Arguments\n\n* `data` - Data to set."]
    pub fn CAMU_SetStereoCameraCalibrationData(data: CAMU_StereoCameraCalibrationData) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Writes to the specified I2C register of the specified camera.\n # Arguments\n\n* `select` - Camera to write to.\n * `addr` - Address to write to.\n * `data` - Data to write."]
    pub fn CAMU_WriteRegisterI2c(select: u32_, addr: u16_, data: u16_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Writes to the specified MCU variable of the specified camera.\n # Arguments\n\n* `select` - Camera to write to.\n * `addr` - Address to write to.\n * `data` - Data to write."]
    pub fn CAMU_WriteMcuVariableI2c(select: u32_, addr: u16_, data: u16_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Reads the specified I2C register of the specified camera.\n # Arguments\n\n* `data` - Pointer to read data to.\n * `select` - Camera to read from.\n * `addr` - Address to read."]
    pub fn CAMU_ReadRegisterI2cExclusive(data: *mut u16_, select: u32_, addr: u16_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Reads the specified MCU variable of the specified camera.\n # Arguments\n\n* `data` - Pointer to read data to.\n * `select` - Camera to read from.\n * `addr` - Address to read."]
    pub fn CAMU_ReadMcuVariableI2cExclusive(data: *mut u16_, select: u32_, addr: u16_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the specified camera's image quality calibration data.\n # Arguments\n\n* `data` - Data to set."]
    pub fn CAMU_SetImageQualityCalibrationData(data: CAMU_ImageQualityCalibrationData) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the specified camera's image quality calibration data.\n # Arguments\n\n* `data` - Pointer to write the quality data to."]
    pub fn CAMU_GetImageQualityCalibrationData(
        data: *mut CAMU_ImageQualityCalibrationData,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Configures a camera with pre-packaged configuration data without a context.\n # Arguments\n\n* `Parameter` - to use."]
    pub fn CAMU_SetPackageParameterWithoutContext(
        param: CAMU_PackageParameterCameraSelect,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Configures a camera with pre-packaged configuration data with a context.\n # Arguments\n\n* `Parameter` - to use."]
    pub fn CAMU_SetPackageParameterWithContext(param: CAMU_PackageParameterContext) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Configures a camera with pre-packaged configuration data without a context and extra resolution details.\n # Arguments\n\n* `Parameter` - to use."]
    pub fn CAMU_SetPackageParameterWithContextDetail(
        param: CAMU_PackageParameterContextDetail,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the Y2R coefficient applied to image data by the camera.\n # Arguments\n\n* `coefficient` - Pointer to output the Y2R coefficient to."]
    pub fn CAMU_GetSuitableY2rStandardCoefficient(
        coefficient: *mut Y2RU_StandardCoefficient,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Plays the specified shutter sound.\n # Arguments\n\n* `sound` - Shutter sound to play."]
    pub fn CAMU_PlayShutterSound(sound: CAMU_ShutterSoundType) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initializes the camera driver."]
    pub fn CAMU_DriverInitialize() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Finalizes the camera driver."]
    pub fn CAMU_DriverFinalize() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the current activated camera.\n # Arguments\n\n* `select` - Pointer to output the current activated camera to."]
    pub fn CAMU_GetActivatedCamera(select: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the current sleep camera.\n # Arguments\n\n* `select` - Pointer to output the current sleep camera to."]
    pub fn CAMU_GetSleepCamera(select: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the current sleep camera.\n # Arguments\n\n* `select` - Camera to set."]
    pub fn CAMU_SetSleepCamera(select: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets whether to enable synchronization of left and right camera brightnesses.\n # Arguments\n\n* `brightnessSynchronization` - Whether to enable brightness synchronization."]
    pub fn CAMU_SetBrightnessSynchronization(brightnessSynchronization: bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initializes CFGNOR.\n # Arguments\n\n* `value` - Unknown, usually 1."]
    pub fn cfgnorInit(value: u8_) -> Result;
}
extern "C" {
    #[doc = "Exits CFGNOR"]
    pub fn cfgnorExit();
}
extern "C" {
    #[must_use]
    #[doc = "Dumps the NOR flash.\n # Arguments\n\n* `buf` - Buffer to dump to.\n * `size` - Size of the buffer."]
    pub fn cfgnorDumpFlash(buf: *mut u32_, size: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Writes the NOR flash.\n # Arguments\n\n* `buf` - Buffer to write from.\n * `size` - Size of the buffer."]
    pub fn cfgnorWriteFlash(buf: *mut u32_, size: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initializes the CFGNOR session.\n # Arguments\n\n* `value` - Unknown, usually 1."]
    pub fn CFGNOR_Initialize(value: u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Shuts down the CFGNOR session."]
    pub fn CFGNOR_Shutdown() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Reads data from NOR.\n # Arguments\n\n* `offset` - Offset to read from.\n * `buf` - Buffer to read data to.\n * `size` - Size of the buffer."]
    pub fn CFGNOR_ReadData(offset: u32_, buf: *mut u32_, size: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Writes data to NOR.\n # Arguments\n\n* `offset` - Offset to write to.\n * `buf` - Buffer to write data from.\n * `size` - Size of the buffer."]
    pub fn CFGNOR_WriteData(offset: u32_, buf: *mut u32_, size: u32_) -> Result;
}
#[doc = "< Japan"]
pub const CFG_REGION_JPN: CFG_Region = 0;
#[doc = "< USA"]
pub const CFG_REGION_USA: CFG_Region = 1;
#[doc = "< Europe"]
pub const CFG_REGION_EUR: CFG_Region = 2;
#[doc = "< Australia"]
pub const CFG_REGION_AUS: CFG_Region = 3;
#[doc = "< China"]
pub const CFG_REGION_CHN: CFG_Region = 4;
#[doc = "< Korea"]
pub const CFG_REGION_KOR: CFG_Region = 5;
#[doc = "< Taiwan"]
pub const CFG_REGION_TWN: CFG_Region = 6;
#[doc = "Configuration region values."]
pub type CFG_Region = ::libc::c_uint;
#[doc = "< Japanese"]
pub const CFG_LANGUAGE_JP: CFG_Language = 0;
#[doc = "< English"]
pub const CFG_LANGUAGE_EN: CFG_Language = 1;
#[doc = "< French"]
pub const CFG_LANGUAGE_FR: CFG_Language = 2;
#[doc = "< German"]
pub const CFG_LANGUAGE_DE: CFG_Language = 3;
#[doc = "< Italian"]
pub const CFG_LANGUAGE_IT: CFG_Language = 4;
#[doc = "< Spanish"]
pub const CFG_LANGUAGE_ES: CFG_Language = 5;
#[doc = "< Simplified Chinese"]
pub const CFG_LANGUAGE_ZH: CFG_Language = 6;
#[doc = "< Korean"]
pub const CFG_LANGUAGE_KO: CFG_Language = 7;
#[doc = "< Dutch"]
pub const CFG_LANGUAGE_NL: CFG_Language = 8;
#[doc = "< Portugese"]
pub const CFG_LANGUAGE_PT: CFG_Language = 9;
#[doc = "< Russian"]
pub const CFG_LANGUAGE_RU: CFG_Language = 10;
#[doc = "< Traditional Chinese"]
pub const CFG_LANGUAGE_TW: CFG_Language = 11;
#[doc = "Configuration language values."]
pub type CFG_Language = ::libc::c_uint;
#[doc = "< Old 3DS (CTR)"]
pub const CFG_MODEL_3DS: CFG_SystemModel = 0;
#[doc = "< Old 3DS XL (SPR)"]
pub const CFG_MODEL_3DSXL: CFG_SystemModel = 1;
#[doc = "< New 3DS (KTR)"]
pub const CFG_MODEL_N3DS: CFG_SystemModel = 2;
#[doc = "< Old 2DS (FTR)"]
pub const CFG_MODEL_2DS: CFG_SystemModel = 3;
#[doc = "< New 3DS XL (RED)"]
pub const CFG_MODEL_N3DSXL: CFG_SystemModel = 4;
#[doc = "< New 2DS XL (JAN)"]
pub const CFG_MODEL_N2DSXL: CFG_SystemModel = 5;
pub type CFG_SystemModel = ::libc::c_uint;
extern "C" {
    #[must_use]
    #[doc = "Initializes CFGU."]
    pub fn cfguInit() -> Result;
}
extern "C" {
    #[doc = "Exits CFGU."]
    pub fn cfguExit();
}
extern "C" {
    #[must_use]
    #[doc = "Gets the system's region from secure info.\n # Arguments\n\n* `region` - Pointer to output the region to. (see CFG_Region)"]
    pub fn CFGU_SecureInfoGetRegion(region: *mut u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Generates a console-unique hash.\n # Arguments\n\n* `appIDSalt` - Salt to use.\n * `hash` - Pointer to output the hash to."]
    pub fn CFGU_GenHashConsoleUnique(appIDSalt: u32_, hash: *mut u64_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets whether the system's region is Canada or USA.\n # Arguments\n\n* `value` - Pointer to output the result to. (0 = no, 1 = yes)"]
    pub fn CFGU_GetRegionCanadaUSA(value: *mut u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the system's model.\n # Arguments\n\n* `model` - Pointer to output the model to. (see CFG_SystemModel)"]
    pub fn CFGU_GetSystemModel(model: *mut u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets whether the system is a 2DS.\n # Arguments\n\n* `value` - Pointer to output the result to. (0 = yes, 1 = no)"]
    pub fn CFGU_GetModelNintendo2DS(value: *mut u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets a string representing a country code.\n # Arguments\n\n* `code` - Country code to use.\n * `string` - Pointer to output the string to."]
    pub fn CFGU_GetCountryCodeString(code: u16_, string: *mut u16_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets a country code ID from its string.\n # Arguments\n\n* `string` - String to use.\n * `code` - Pointer to output the country code to."]
    pub fn CFGU_GetCountryCodeID(string: u16_, code: *mut u16_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Checks if NFC (code name: fangate) is supported.\n # Arguments\n\n* `isSupported` - pointer to the output the result to."]
    pub fn CFGU_IsNFCSupported(isSupported: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets a config info block with flags = 2.\n # Arguments\n\n* `size` - Size of the data to retrieve.\n * `blkID` - ID of the block to retrieve.\n * `outData` - Pointer to write the block data to."]
    pub fn CFGU_GetConfigInfoBlk2(size: u32_, blkID: u32_, outData: *mut ::libc::c_void) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets a config info block with flags = 4.\n # Arguments\n\n* `size` - Size of the data to retrieve.\n * `blkID` - ID of the block to retrieve.\n * `outData` - Pointer to write the block data to."]
    pub fn CFG_GetConfigInfoBlk4(size: u32_, blkID: u32_, outData: *mut ::libc::c_void) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets a config info block with flags = 8.\n # Arguments\n\n* `size` - Size of the data to retrieve.\n * `blkID` - ID of the block to retrieve.\n * `outData` - Pointer to write the block data to."]
    pub fn CFG_GetConfigInfoBlk8(size: u32_, blkID: u32_, outData: *mut ::libc::c_void) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets a config info block with flags = 4.\n # Arguments\n\n* `size` - Size of the data to retrieve.\n * `blkID` - ID of the block to retrieve.\n * `inData` - Pointer to block data to write."]
    pub fn CFG_SetConfigInfoBlk4(size: u32_, blkID: u32_, inData: *const ::libc::c_void) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets a config info block with flags = 8.\n # Arguments\n\n* `size` - Size of the data to retrieve.\n * `blkID` - ID of the block to retrieve.\n * `inData` - Pointer to block data to write."]
    pub fn CFG_SetConfigInfoBlk8(size: u32_, blkID: u32_, inData: *const ::libc::c_void) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Writes the CFG buffer in memory to the savegame in NAND."]
    pub fn CFG_UpdateConfigSavegame() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the system's language.\n # Arguments\n\n* `language` - Pointer to write the language to. (see CFG_Language)"]
    pub fn CFGU_GetSystemLanguage(language: *mut u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Deletes the NAND LocalFriendCodeSeed file, then recreates it using the LocalFriendCodeSeed data stored in memory."]
    pub fn CFGI_RestoreLocalFriendCodeSeed() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Deletes the NAND SecureInfo file, then recreates it using the SecureInfo data stored in memory."]
    pub fn CFGI_RestoreSecureInfo() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Deletes the \"config\" file stored in the NAND Config_Savegame."]
    pub fn CFGI_DeleteConfigSavefile() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Formats Config_Savegame."]
    pub fn CFGI_FormatConfig() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Clears parental controls"]
    pub fn CFGI_ClearParentalControls() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Verifies the RSA signature for the LocalFriendCodeSeed data already stored in memory."]
    pub fn CFGI_VerifySigLocalFriendCodeSeed() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Verifies the RSA signature for the SecureInfo data already stored in memory."]
    pub fn CFGI_VerifySigSecureInfo() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the system's serial number.\n # Arguments\n\n* `serial` - Pointer to output the serial to. (This is normally 0xF)"]
    pub fn CFGI_SecureInfoGetSerialNumber(serial: *mut u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the 0x110-byte buffer containing the data for the LocalFriendCodeSeed.\n # Arguments\n\n* `data` - Pointer to output the buffer. (The size must be at least 0x110-bytes)"]
    pub fn CFGI_GetLocalFriendCodeSeedData(data: *mut u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the 64-bit local friend code seed.\n # Arguments\n\n* `seed` - Pointer to write the friend code seed to."]
    pub fn CFGI_GetLocalFriendCodeSeed(seed: *mut u64_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the 0x11-byte data following the SecureInfo signature.\n # Arguments\n\n* `data` - Pointer to output the buffer. (The size must be at least 0x11-bytes)"]
    pub fn CFGI_GetSecureInfoData(data: *mut u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the 0x100-byte RSA-2048 SecureInfo signature.\n # Arguments\n\n* `data` - Pointer to output the buffer. (The size must be at least 0x100-bytes)"]
    pub fn CFGI_GetSecureInfoSignature(data: *mut u8_) -> Result;
}
extern "C" {
    #[doc = "Converts a vol-pan pair into a left/right volume pair used by the hardware.\n # Arguments\n\n* `vol` - Volume to use.\n * `pan` - Pan to use.\n # Returns\n\nA left/right volume pair for use by hardware."]
    #[link_name = "CSND_VOL__extern"]
    pub fn CSND_VOL(vol: f32, pan: f32) -> u32_;
}
#[doc = "< PCM8"]
pub const CSND_ENCODING_PCM8: _bindgen_ty_17 = 0;
#[doc = "< PCM16"]
pub const CSND_ENCODING_PCM16: _bindgen_ty_17 = 1;
#[doc = "< IMA-ADPCM"]
pub const CSND_ENCODING_ADPCM: _bindgen_ty_17 = 2;
#[doc = "< PSG (Similar to DS?)"]
pub const CSND_ENCODING_PSG: _bindgen_ty_17 = 3;
#[doc = "CSND encodings."]
pub type _bindgen_ty_17 = ::libc::c_uint;
#[doc = "< Manual loop."]
pub const CSND_LOOPMODE_MANUAL: _bindgen_ty_18 = 0;
#[doc = "< Normal loop."]
pub const CSND_LOOPMODE_NORMAL: _bindgen_ty_18 = 1;
#[doc = "< Do not loop."]
pub const CSND_LOOPMODE_ONESHOT: _bindgen_ty_18 = 2;
#[doc = "< Don't reload."]
pub const CSND_LOOPMODE_NORELOAD: _bindgen_ty_18 = 3;
#[doc = "CSND loop modes."]
pub type _bindgen_ty_18 = ::libc::c_uint;
#[doc = "< Linear interpolation."]
pub const SOUND_LINEAR_INTERP: _bindgen_ty_19 = 64;
#[doc = "< Repeat the sound."]
pub const SOUND_REPEAT: _bindgen_ty_19 = 1024;
#[doc = "< Play the sound once."]
pub const SOUND_ONE_SHOT: _bindgen_ty_19 = 2048;
#[doc = "< PCM8"]
pub const SOUND_FORMAT_8BIT: _bindgen_ty_19 = 0;
#[doc = "< PCM16"]
pub const SOUND_FORMAT_16BIT: _bindgen_ty_19 = 4096;
#[doc = "< ADPCM"]
pub const SOUND_FORMAT_ADPCM: _bindgen_ty_19 = 8192;
#[doc = "< PSG"]
pub const SOUND_FORMAT_PSG: _bindgen_ty_19 = 12288;
#[doc = "< Enable sound."]
pub const SOUND_ENABLE: _bindgen_ty_19 = 16384;
#[doc = "Sound flags."]
pub type _bindgen_ty_19 = ::libc::c_uint;
#[doc = "< Repeat capture."]
pub const CAPTURE_REPEAT: _bindgen_ty_20 = 0;
#[doc = "< Capture once."]
pub const CAPTURE_ONE_SHOT: _bindgen_ty_20 = 1;
#[doc = "< PCM16"]
pub const CAPTURE_FORMAT_16BIT: _bindgen_ty_20 = 0;
#[doc = "< PCM8"]
pub const CAPTURE_FORMAT_8BIT: _bindgen_ty_20 = 2;
#[doc = "< Enable capture."]
pub const CAPTURE_ENABLE: _bindgen_ty_20 = 32768;
#[doc = "Capture modes."]
pub type _bindgen_ty_20 = ::libc::c_uint;
#[doc = "< 0.0% duty cycle"]
pub const DutyCycle_0: CSND_DutyCycle = 7;
#[doc = "< 12.5% duty cycle"]
pub const DutyCycle_12: CSND_DutyCycle = 0;
#[doc = "< 25.0% duty cycle"]
pub const DutyCycle_25: CSND_DutyCycle = 1;
#[doc = "< 37.5% duty cycle"]
pub const DutyCycle_37: CSND_DutyCycle = 2;
#[doc = "< 50.0% duty cycle"]
pub const DutyCycle_50: CSND_DutyCycle = 3;
#[doc = "< 62.5% duty cycle"]
pub const DutyCycle_62: CSND_DutyCycle = 4;
#[doc = "< 75.0% duty cycle"]
pub const DutyCycle_75: CSND_DutyCycle = 5;
#[doc = "< 87.5% duty cycle"]
pub const DutyCycle_87: CSND_DutyCycle = 6;
#[doc = "Duty cycles for a PSG channel."]
pub type CSND_DutyCycle = ::libc::c_uint;
#[doc = "Channel info."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union CSND_ChnInfo {
    #[doc = "< Raw values."]
    pub value: [u32_; 3usize],
    pub __bindgen_anon_1: CSND_ChnInfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CSND_ChnInfo__bindgen_ty_1 {
    #[doc = "< Channel active."]
    pub active: u8_,
    #[doc = "< Padding."]
    pub _pad1: u8_,
    #[doc = "< Padding."]
    pub _pad2: u16_,
    #[doc = "< Current ADPCM sample."]
    pub adpcmSample: s16,
    #[doc = "< Current ADPCM index."]
    pub adpcmIndex: u8_,
    #[doc = "< Padding."]
    pub _pad3: u8_,
    #[doc = "< Unknown."]
    pub unknownZero: u32_,
}
impl Default for CSND_ChnInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Capture info."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union CSND_CapInfo {
    #[doc = "< Raw values."]
    pub value: [u32_; 2usize],
    pub __bindgen_anon_1: CSND_CapInfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CSND_CapInfo__bindgen_ty_1 {
    #[doc = "< Capture active."]
    pub active: u8_,
    #[doc = "< Padding."]
    pub _pad1: u8_,
    #[doc = "< Padding."]
    pub _pad2: u16_,
    #[doc = "< Unknown."]
    pub unknownZero: u32_,
}
impl Default for CSND_CapInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = "< CSND shared memory."]
    pub static mut csndSharedMem: *mut vu32;
}
extern "C" {
    #[doc = "< CSND shared memory size."]
    pub static mut csndSharedMemSize: u32_;
}
extern "C" {
    #[doc = "< Bitmask of channels that are allowed for usage."]
    pub static mut csndChannels: u32_;
}
extern "C" {
    #[must_use]
    #[doc = "Acquires a capture unit.\n # Arguments\n\n* `capUnit` - Pointer to output the capture unit to."]
    pub fn CSND_AcquireCapUnit(capUnit: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Releases a capture unit.\n # Arguments\n\n* `capUnit` - Capture unit to release."]
    pub fn CSND_ReleaseCapUnit(capUnit: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Flushes the data cache of a memory region.\n # Arguments\n\n* `adr` - Address of the memory region.\n * `size` - Size of the memory region."]
    pub fn CSND_FlushDataCache(adr: *const ::libc::c_void, size: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Stores the data cache of a memory region.\n # Arguments\n\n* `adr` - Address of the memory region.\n * `size` - Size of the memory region."]
    pub fn CSND_StoreDataCache(adr: *const ::libc::c_void, size: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Invalidates the data cache of a memory region.\n # Arguments\n\n* `adr` - Address of the memory region.\n * `size` - Size of the memory region."]
    pub fn CSND_InvalidateDataCache(adr: *const ::libc::c_void, size: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Resets CSND.\n Note: Currently breaks sound, don't use for now!"]
    pub fn CSND_Reset() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initializes CSND."]
    pub fn csndInit() -> Result;
}
extern "C" {
    #[doc = "Exits CSND."]
    pub fn csndExit();
}
extern "C" {
    #[doc = "Adds a command to the list, returning a buffer to write arguments to.\n # Arguments\n\n* `cmdid` - ID of the command to add.\n # Returns\n\nA buffer to write command arguments to."]
    pub fn csndAddCmd(cmdid: ::libc::c_int) -> *mut u32_;
}
extern "C" {
    #[doc = "Adds a command to the list, copying its arguments from a buffer.\n # Arguments\n\n* `cmdid` - ID of the command to add.\n * `cmdparams` - Buffer containing the command's parameters."]
    pub fn csndWriteCmd(cmdid: ::libc::c_int, cmdparams: *mut u8_);
}
extern "C" {
    #[must_use]
    #[doc = "Executes pending CSND commands.\n # Arguments\n\n* `waitDone` - Whether to wait until the commands have finished executing."]
    pub fn csndExecCmds(waitDone: bool) -> Result;
}
extern "C" {
    #[doc = "Sets a channel's play state, resetting registers on stop.\n # Arguments\n\n* `channel` - Channel to use.\n * `value` - Play state to set."]
    pub fn CSND_SetPlayStateR(channel: u32_, value: u32_);
}
extern "C" {
    #[doc = "Sets a channel's play state.\n # Arguments\n\n* `channel` - Channel to use.\n * `value` - Play state to set."]
    pub fn CSND_SetPlayState(channel: u32_, value: u32_);
}
extern "C" {
    #[doc = "Sets a channel's encoding.\n # Arguments\n\n* `channel` - Channel to use.\n * `value` - Encoding to set."]
    pub fn CSND_SetEncoding(channel: u32_, value: u32_);
}
extern "C" {
    #[doc = "Sets the data of a channel's block.\n # Arguments\n\n* `channel` - Channel to use.\n * `block` - Block to set.\n * `physaddr` - Physical address to set the block to.\n * `size` - Size of the block."]
    pub fn CSND_SetBlock(channel: u32_, block: ::libc::c_int, physaddr: u32_, size: u32_);
}
extern "C" {
    #[doc = "Sets whether to loop a channel.\n # Arguments\n\n* `channel` - Channel to use.\n * `value` - Whether to loop the channel."]
    pub fn CSND_SetLooping(channel: u32_, value: u32_);
}
extern "C" {
    #[doc = "Sets bit 7 of a channel.\n # Arguments\n\n* `channel` - Channel to use.\n * `set` - Value to set."]
    pub fn CSND_SetBit7(channel: u32_, set: bool);
}
extern "C" {
    #[doc = "Sets whether a channel should use interpolation.\n # Arguments\n\n* `channel` - Channel to use.\n * `interp` - Whether to use interpolation."]
    pub fn CSND_SetInterp(channel: u32_, interp: bool);
}
extern "C" {
    #[doc = "Sets a channel's duty.\n # Arguments\n\n* `channel` - Channel to use.\n * `duty` - Duty to set."]
    pub fn CSND_SetDuty(channel: u32_, duty: CSND_DutyCycle);
}
extern "C" {
    #[doc = "Sets a channel's timer.\n # Arguments\n\n* `channel` - Channel to use.\n * `timer` - Timer to set."]
    pub fn CSND_SetTimer(channel: u32_, timer: u32_);
}
extern "C" {
    #[doc = "Sets a channel's volume.\n # Arguments\n\n* `channel` - Channel to use.\n * `chnVolumes` - Channel volume data to set.\n * `capVolumes` - Capture volume data to set."]
    pub fn CSND_SetVol(channel: u32_, chnVolumes: u32_, capVolumes: u32_);
}
extern "C" {
    #[doc = "Sets a channel's ADPCM state.\n # Arguments\n\n* `channel` - Channel to use.\n * `block` - Current block.\n * `sample` - Current sample.\n * `index` - Current index."]
    pub fn CSND_SetAdpcmState(
        channel: u32_,
        block: ::libc::c_int,
        sample: ::libc::c_int,
        index: ::libc::c_int,
    );
}
extern "C" {
    #[doc = "Sets a whether channel's ADPCM data should be reloaded when the second block is played.\n # Arguments\n\n* `channel` - Channel to use.\n * `reload` - Whether to reload ADPCM data."]
    pub fn CSND_SetAdpcmReload(channel: u32_, reload: bool);
}
extern "C" {
    #[doc = "Sets CSND's channel registers.\n # Arguments\n\n* `flags` - Flags to set.\n * `physaddr0` - Physical address of the first buffer to play.\n * `physaddr1` - Physical address of the second buffer to play.\n * `totalbytesize` - Total size of the data to play.\n * `chnVolumes` - Channel volume data.\n * `capVolumes` - Capture volume data."]
    pub fn CSND_SetChnRegs(
        flags: u32_,
        physaddr0: u32_,
        physaddr1: u32_,
        totalbytesize: u32_,
        chnVolumes: u32_,
        capVolumes: u32_,
    );
}
extern "C" {
    #[doc = "Sets CSND's PSG channel registers.\n # Arguments\n\n* `flags` - Flags to set.\n * `chnVolumes` - Channel volume data.\n * `capVolumes` - Capture volume data.\n * `duty` - Duty value to set."]
    pub fn CSND_SetChnRegsPSG(
        flags: u32_,
        chnVolumes: u32_,
        capVolumes: u32_,
        duty: CSND_DutyCycle,
    );
}
extern "C" {
    #[doc = "Sets CSND's noise channel registers.\n # Arguments\n\n* `flags` - Flags to set.\n * `chnVolumes` - Channel volume data.\n * `capVolumes` - Capture volume data."]
    pub fn CSND_SetChnRegsNoise(flags: u32_, chnVolumes: u32_, capVolumes: u32_);
}
extern "C" {
    #[doc = "Sets whether a capture unit is enabled.\n # Arguments\n\n* `capUnit` - Capture unit to use.\n * `enable` - Whether to enable the capture unit."]
    pub fn CSND_CapEnable(capUnit: u32_, enable: bool);
}
extern "C" {
    #[doc = "Sets whether a capture unit should repeat.\n # Arguments\n\n* `capUnit` - Capture unit to use.\n * `repeat` - Whether the capture unit should repeat."]
    pub fn CSND_CapSetRepeat(capUnit: u32_, repeat: bool);
}
extern "C" {
    #[doc = "Sets a capture unit's format.\n # Arguments\n\n* `capUnit` - Capture unit to use.\n * `eightbit` - Format to use."]
    pub fn CSND_CapSetFormat(capUnit: u32_, eightbit: bool);
}
extern "C" {
    #[doc = "Sets a capture unit's second bit.\n # Arguments\n\n* `capUnit` - Capture unit to use.\n * `set` - Value to set."]
    pub fn CSND_CapSetBit2(capUnit: u32_, set: bool);
}
extern "C" {
    #[doc = "Sets a capture unit's timer.\n # Arguments\n\n* `capUnit` - Capture unit to use.\n * `timer` - Timer to set."]
    pub fn CSND_CapSetTimer(capUnit: u32_, timer: u32_);
}
extern "C" {
    #[doc = "Sets a capture unit's buffer.\n # Arguments\n\n* `capUnit` - Capture unit to use.\n * `addr` - Buffer address to use.\n * `size` - Size of the buffer."]
    pub fn CSND_CapSetBuffer(capUnit: u32_, addr: u32_, size: u32_);
}
extern "C" {
    #[doc = "Sets a capture unit's capture registers.\n # Arguments\n\n* `capUnit` - Capture unit to use.\n * `flags` - Capture unit flags.\n * `addr` - Capture unit buffer address.\n * `size` - Buffer size."]
    pub fn CSND_SetCapRegs(capUnit: u32_, flags: u32_, addr: u32_, size: u32_);
}
extern "C" {
    #[must_use]
    #[doc = "Sets up DSP flags.\n # Arguments\n\n* `waitDone` - Whether to wait for completion."]
    pub fn CSND_SetDspFlags(waitDone: bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Updates CSND information.\n # Arguments\n\n* `waitDone` - Whether to wait for completion."]
    pub fn CSND_UpdateInfo(waitDone: bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Plays a sound.\n # Arguments\n\n* `chn` - Channel to play the sound on.\n * `flags` - Flags containing information about the sound.\n * `sampleRate` - Sample rate of the sound.\n * `vol` - The volume, ranges from 0.0 to 1.0 included.\n * `pan` - The pan, ranges from -1.0 to 1.0 included.\n * `data0` - First block of sound data.\n * `data1` - Second block of sound data. This is the block that will be looped over.\n * `size` - Size of the sound data.\n\n In this implementation if the loop mode is used, data1 must be in the range [data0 ; data0 + size]. Sound will be played once from data0 to data0 + size and then loop between data1 and data0+size."]
    pub fn csndPlaySound(
        chn: ::libc::c_int,
        flags: u32_,
        sampleRate: u32_,
        vol: f32,
        pan: f32,
        data0: *mut ::libc::c_void,
        data1: *mut ::libc::c_void,
        size: u32_,
    ) -> Result;
}
extern "C" {
    #[doc = "Gets CSND's DSP flags.\n Note: Requires previous CSND_UpdateInfo()\n # Arguments\n\n* `outSemFlags` - Pointer to write semaphore flags to.\n * `outIrqFlags` - Pointer to write interrupt flags to."]
    pub fn csndGetDspFlags(outSemFlags: *mut u32_, outIrqFlags: *mut u32_);
}
extern "C" {
    #[doc = "Gets a channel's information.\n Note: Requires previous CSND_UpdateInfo()\n # Arguments\n\n* `channel` - Channel to get information for.\n # Returns\n\nThe channel's information."]
    pub fn csndGetChnInfo(channel: u32_) -> *mut CSND_ChnInfo;
}
extern "C" {
    #[doc = "Gets a capture unit's information.\n Note: Requires previous CSND_UpdateInfo()\n # Arguments\n\n* `capUnit` - Capture unit to get information for.\n # Returns\n\nThe capture unit's information."]
    pub fn csndGetCapInfo(capUnit: u32_) -> *mut CSND_CapInfo;
}
extern "C" {
    #[must_use]
    #[doc = "Gets a channel's state.\n # Arguments\n\n* `channel` - Channel to get the state of.\n * `out` - Pointer to output channel information to."]
    pub fn csndGetState(channel: u32_, out: *mut CSND_ChnInfo) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets whether a channel is playing.\n # Arguments\n\n* `channel` - Channel to check.\n * `status` - Pointer to output the channel status to."]
    pub fn csndIsPlaying(channel: u32_, status: *mut u8_) -> Result;
}
#[doc = "< Pipe interrupt."]
pub const DSP_INTERRUPT_PIPE: DSP_InterruptType = 2;
#[doc = "DSP interrupt types."]
pub type DSP_InterruptType = ::libc::c_uint;
#[doc = "< DSP is going to sleep."]
pub const DSPHOOK_ONSLEEP: DSP_HookType = 0;
#[doc = "< DSP is waking up."]
pub const DSPHOOK_ONWAKEUP: DSP_HookType = 1;
#[doc = "< DSP was sleeping and the app was cancelled."]
pub const DSPHOOK_ONCANCEL: DSP_HookType = 2;
#[doc = "DSP hook types."]
pub type DSP_HookType = ::libc::c_uint;
#[doc = "DSP hook function."]
pub type dspHookFn = ::core::option::Option<unsafe extern "C" fn(hook: DSP_HookType)>;
#[doc = "DSP hook cookie."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tag_dspHookCookie {
    #[doc = "< Next cookie."]
    pub next: *mut tag_dspHookCookie,
    #[doc = "< Hook callback."]
    pub callback: dspHookFn,
}
impl Default for tag_dspHookCookie {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "DSP hook cookie."]
pub type dspHookCookie = tag_dspHookCookie;
extern "C" {
    #[must_use]
    #[doc = "Initializes the dsp service.\n\n Call this before calling any DSP_* function.\n > **Note:** This will also unload any previously loaded DSP binary.\n It is done this way since you have to provide your binary when the 3DS leaves sleep mode anyway."]
    pub fn dspInit() -> Result;
}
extern "C" {
    #[doc = "Closes the dsp service.\n > **Note:** This will also unload the DSP binary."]
    pub fn dspExit();
}
extern "C" {
    #[doc = "Returns true if a component is loaded, false otherwise."]
    pub fn dspIsComponentLoaded() -> bool;
}
extern "C" {
    #[doc = "Sets up a DSP status hook.\n # Arguments\n\n* `cookie` - Hook cookie to use.\n * `callback` - Function to call when DSP's status changes."]
    pub fn dspHook(cookie: *mut dspHookCookie, callback: dspHookFn);
}
extern "C" {
    #[doc = "Removes a DSP status hook.\n # Arguments\n\n* `cookie` - Hook cookie to remove."]
    pub fn dspUnhook(cookie: *mut dspHookCookie);
}
extern "C" {
    #[must_use]
    #[doc = "Checks if a headphone is inserted.\n # Arguments\n\n* `is_inserted` - Pointer to output the insertion status to."]
    pub fn DSP_GetHeadphoneStatus(is_inserted: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Flushes the cache\n # Arguments\n\n* `address` - Beginning of the memory range to flush, inside the Linear or DSP memory regions\n * `size` - Size of the memory range to flush\n\n Flushes the cache for the specified memory range and invalidates the cache"]
    pub fn DSP_FlushDataCache(address: *const ::libc::c_void, size: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Invalidates the cache\n # Arguments\n\n* `address` - Beginning of the memory range to invalidate, inside the Linear or DSP memory regions\n * `size` - Size of the memory range to flush\n\n Invalidates the cache for the specified memory range"]
    pub fn DSP_InvalidateDataCache(address: *const ::libc::c_void, size: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Retrieves the handle of the DSP semaphore.\n # Arguments\n\n* `semaphore` - Pointer to output the semaphore to."]
    pub fn DSP_GetSemaphoreHandle(semaphore: *mut Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the DSP hardware semaphore value.\n # Arguments\n\n* `value` - Value to set."]
    pub fn DSP_SetSemaphore(value: u16_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Masks the DSP hardware semaphore value.\n # Arguments\n\n* `mask` - Mask to apply."]
    pub fn DSP_SetSemaphoreMask(mask: u16_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Loads a DSP binary and starts the DSP\n # Arguments\n\n* `component` - The program file address in memory\n * `size` - The size of the program\n * `prog_mask` - DSP memory block related ? Default is 0xff.\n * `data_mask` - DSP memory block related ? Default is 0xff.\n * `is_loaded` - Indicates if the DSP was succesfully loaded.\n\n > **Note:** The binary must be signed (http://3dbrew.org/wiki/DSP_Binary)\n > **Note:** Seems to be called when the 3ds leaves the Sleep mode"]
    pub fn DSP_LoadComponent(
        component: *const ::libc::c_void,
        size: u32_,
        prog_mask: u16_,
        data_mask: u16_,
        is_loaded: *mut bool,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Stops the DSP by unloading the binary."]
    pub fn DSP_UnloadComponent() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Registers an event handle with the DSP through IPC\n # Arguments\n\n* `handle` - Event handle to register.\n * `interrupt` - The type of interrupt that will trigger the event. Usual value is DSP_INTERRUPT_PIPE.\n * `channel` - The pipe channel. Usual value is 2\n\n > **Note:** It is possible that interrupt are inverted"]
    pub fn DSP_RegisterInterruptEvents(handle: Handle, interrupt: u32_, channel: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Reads a pipe if possible.\n # Arguments\n\n* `channel` - unknown. Usually 2\n * `peer` - unknown. Usually 0\n * `buffer` - The buffer that will store the values read from the pipe\n * `length` - Length of the buffer\n * `length_read` - Number of bytes read by the command"]
    pub fn DSP_ReadPipeIfPossible(
        channel: u32_,
        peer: u32_,
        buffer: *mut ::libc::c_void,
        length: u16_,
        length_read: *mut u16_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Writes to a pipe.\n # Arguments\n\n* `channel` - unknown. Usually 2\n * `buffer` - The message to send to the DSP process\n * `length` - Length of the message"]
    pub fn DSP_WriteProcessPipe(
        channel: u32_,
        buffer: *const ::libc::c_void,
        length: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Converts a DSP memory address to a virtual address usable by the process.\n # Arguments\n\n* `dsp_address` - Address to convert.\n * `arm_address` - Pointer to output the converted address to."]
    pub fn DSP_ConvertProcessAddressFromDspDram(
        dsp_address: u32_,
        arm_address: *mut u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Reads a DSP register\n # Arguments\n\n* `regNo` - Offset of the hardware register, base address is 0x1EC40000\n * `value` - Pointer to read the register value to."]
    pub fn DSP_RecvData(regNo: u16_, value: *mut u16_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Checks if you can read a DSP register\n # Arguments\n\n* `regNo` - Offset of the hardware register, base address is 0x1EC40000\n * `is_ready` - Pointer to write the ready status to.\n\n This call might hang if the data is not ready. See DSP_SendDataIsEmpty."]
    pub fn DSP_RecvDataIsReady(regNo: u16_, is_ready: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Writes to a DSP register\n # Arguments\n\n* `regNo` - Offset of the hardware register, base address is 0x1EC40000\n * `value` - Value to write.\n\n This call might hang if the SendData is not empty. See DSP_SendDataIsEmpty."]
    pub fn DSP_SendData(regNo: u16_, value: u16_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Checks if you can write to a DSP register ?\n # Arguments\n\n* `regNo` - Offset of the hardware register, base address is 0x1EC40000\n * `is_empty` - Pointer to write the empty status to."]
    pub fn DSP_SendDataIsEmpty(regNo: u16_, is_empty: *mut bool) -> Result;
}
pub type FSPXI_Archive = u64_;
pub type FSPXI_File = u64_;
pub type FSPXI_Directory = u64_;
extern "C" {
    #[must_use]
    #[doc = "Opens a file.\n # Arguments\n\n* `out` - Pointer to output the file handle to.\n * `archive` - Archive containing the file.\n * `path` - Path of the file.\n * `flags` - Flags to open the file with.\n * `attributes` - Attributes of the file."]
    pub fn FSPXI_OpenFile(
        serviceHandle: Handle,
        out: *mut FSPXI_File,
        archive: FSPXI_Archive,
        path: FS_Path,
        flags: u32_,
        attributes: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Deletes a file.\n # Arguments\n\n* `archive` - Archive containing the file.\n * `path` - Path of the file."]
    pub fn FSPXI_DeleteFile(serviceHandle: Handle, archive: FSPXI_Archive, path: FS_Path)
        -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Renames a file.\n # Arguments\n\n* `srcArchive` - Archive containing the source file.\n * `srcPath` - Path of the source file.\n * `dstArchive` - Archive containing the destination file.\n * `dstPath` - Path of the destination file."]
    pub fn FSPXI_RenameFile(
        serviceHandle: Handle,
        srcArchive: FSPXI_Archive,
        srcPath: FS_Path,
        dstArchive: FSPXI_Archive,
        dstPath: FS_Path,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Deletes a directory.\n # Arguments\n\n* `archive` - Archive containing the directory.\n * `path` - Path of the directory."]
    pub fn FSPXI_DeleteDirectory(
        serviceHandle: Handle,
        archive: FSPXI_Archive,
        path: FS_Path,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Creates a file.\n # Arguments\n\n* `archive` - Archive to create the file in.\n * `path` - Path of the file.\n * `attributes` - Attributes of the file.\n * `size` - Size of the file."]
    pub fn FSPXI_CreateFile(
        serviceHandle: Handle,
        archive: FSPXI_Archive,
        path: FS_Path,
        attributes: u32_,
        fileSize: u64_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Creates a directory.\n # Arguments\n\n* `archive` - Archive to create the directory in.\n * `path` - Path of the directory.\n * `attributes` - Attributes of the directory."]
    pub fn FSPXI_CreateDirectory(
        serviceHandle: Handle,
        archive: FSPXI_Archive,
        path: FS_Path,
        attributes: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Renames a directory.\n # Arguments\n\n* `srcArchive` - Archive containing the source directory.\n * `srcPath` - Path of the source directory.\n * `dstArchive` - Archive containing the destination directory.\n * `dstPath` - Path of the destination directory."]
    pub fn FSPXI_RenameDirectory(
        serviceHandle: Handle,
        srcArchive: FSPXI_Archive,
        srcPath: FS_Path,
        dstArchive: FSPXI_Archive,
        dstPath: FS_Path,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Opens a directory.\n # Arguments\n\n* `out` - Pointer to output the directory handle to.\n * `archive` - Archive containing the directory.\n * `path` - Path of the directory."]
    pub fn FSPXI_OpenDirectory(
        serviceHandle: Handle,
        out: *mut FSPXI_Directory,
        archive: FSPXI_Archive,
        path: FS_Path,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Reads from a file.\n # Arguments\n\n* `file` - File to read from.\n * `bytesRead` - Pointer to output the number of read bytes to.\n * `offset` - Offset to read from.\n * `buffer` - Buffer to read to.\n * `size` - Size of the buffer."]
    pub fn FSPXI_ReadFile(
        serviceHandle: Handle,
        file: FSPXI_File,
        bytesRead: *mut u32_,
        offset: u64_,
        buffer: *mut ::libc::c_void,
        size: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Calculate SHA256 of a file.\n # Arguments\n\n* `file` - File to calculate the hash of.\n * `buffer` - Buffer to output the hash to.\n * `size` - Size of the buffer."]
    pub fn FSPXI_CalculateFileHashSHA256(
        serviceHandle: Handle,
        file: FSPXI_File,
        buffer: *mut ::libc::c_void,
        size: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Writes to a file.\n # Arguments\n\n* `file` - File to write to.\n * `bytesWritten` - Pointer to output the number of bytes written to.\n * `offset` - Offset to write to.\n * `buffer` - Buffer to write from.\n * `size` - Size of the buffer.\n * `flags` - Flags to use when writing."]
    pub fn FSPXI_WriteFile(
        serviceHandle: Handle,
        file: FSPXI_File,
        bytesWritten: *mut u32_,
        offset: u64_,
        buffer: *const ::libc::c_void,
        size: u32_,
        flags: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Calculates the MAC used in a DISA/DIFF header?\n # Arguments\n\n* `file` - Unsure\n * `inBuffer` - 0x100-byte DISA/DIFF input buffer.\n * `inSize` - Size of inBuffer.\n * `outBuffer` - Buffer to write MAC to.\n * `outSize` - Size of outBuffer."]
    pub fn FSPXI_CalcSavegameMAC(
        serviceHandle: Handle,
        file: FSPXI_File,
        inBuffer: *const ::libc::c_void,
        inSize: u32_,
        outBuffer: *mut ::libc::c_void,
        outSize: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Get size of a file\n # Arguments\n\n* `file` - File to get the size of.\n * `size` - Pointer to output size to."]
    pub fn FSPXI_GetFileSize(serviceHandle: Handle, file: FSPXI_File, size: *mut u64_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Set size of a file\n # Arguments\n\n* `file` - File to set the size of\n * `size` - Size to set the file to"]
    pub fn FSPXI_SetFileSize(serviceHandle: Handle, file: FSPXI_File, size: u64_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Close a file\n # Arguments\n\n* `file` - File to close"]
    pub fn FSPXI_CloseFile(serviceHandle: Handle, file: FSPXI_File) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Reads one or more directory entries.\n # Arguments\n\n* `directory` - Directory to read from.\n * `entriesRead` - Pointer to output the number of entries read to.\n * `entryCount` - Number of entries to read.\n * `entryOut` - Pointer to output directory entries to."]
    pub fn FSPXI_ReadDirectory(
        serviceHandle: Handle,
        directory: FSPXI_Directory,
        entriesRead: *mut u32_,
        entryCount: u32_,
        entries: *mut FS_DirectoryEntry,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Close a directory\n # Arguments\n\n* `directory` - Directory to close."]
    pub fn FSPXI_CloseDirectory(serviceHandle: Handle, directory: FSPXI_Directory) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Opens an archive.\n # Arguments\n\n* `archive` - Pointer to output the opened archive to.\n * `id` - ID of the archive.\n * `path` - Path of the archive."]
    pub fn FSPXI_OpenArchive(
        serviceHandle: Handle,
        archive: *mut FSPXI_Archive,
        archiveID: FS_ArchiveID,
        path: FS_Path,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Checks if the archive contains a file at path.\n # Arguments\n\n* `archive` - Archive to check.\n * `out` - Pointer to output existence to.\n * `path` - Path to check for file"]
    pub fn FSPXI_HasFile(
        serviceHandle: Handle,
        archive: FSPXI_Archive,
        out: *mut bool,
        path: FS_Path,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Checks if the archive contains a directory at path.\n # Arguments\n\n* `archive` - Archive to check.\n * `out` - Pointer to output existence to.\n * `path` - Path to check for directory"]
    pub fn FSPXI_HasDirectory(
        serviceHandle: Handle,
        archive: FSPXI_Archive,
        out: *mut bool,
        path: FS_Path,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Commits an archive's save data.\n # Arguments\n\n* `archive` - Archive to commit.\n * `id` - Archive action sent by FSUSER_ControlArchive. Must not be 0 or 0x789D\n > Unsure why id is sent. This appears to be the default action for FSUSER_ControlArchive, with every action other than 0 and 0x789D being sent to this command."]
    pub fn FSPXI_CommitSaveData(serviceHandle: Handle, archive: FSPXI_Archive, id: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Close an archive\n # Arguments\n\n* `archive` - Archive to close."]
    pub fn FSPXI_CloseArchive(serviceHandle: Handle, archive: FSPXI_Archive) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Unknown 0x17. Appears to be an \"is archive handle valid\" command?\n # Arguments\n\n* `archive` - Archive handle to check validity of.\n * `out` - Pointer to output validity to."]
    pub fn FSPXI_Unknown0x17(
        serviceHandle: Handle,
        archive: FSPXI_Archive,
        out: *mut bool,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the inserted card type.\n # Arguments\n\n* `out` - Pointer to output the card type to."]
    pub fn FSPXI_GetCardType(serviceHandle: Handle, out: *mut FS_CardType) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the SDMC archive resource information.\n # Arguments\n\n* `out` - Pointer to output the archive resource information to."]
    pub fn FSPXI_GetSdmcArchiveResource(
        serviceHandle: Handle,
        out: *mut FS_ArchiveResource,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the NAND archive resource information.\n # Arguments\n\n* `out` - Pointer to output the archive resource information to."]
    pub fn FSPXI_GetNandArchiveResource(
        serviceHandle: Handle,
        out: *mut FS_ArchiveResource,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the error code from the SDMC FatFS driver\n # Arguments\n\n* `out` - Pointer to output the error code to"]
    pub fn FSPXI_GetSdmcFatFsError(serviceHandle: Handle, out: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets whether PXIFS0 detects the SD\n # Arguments\n\n* `out` - Pointer to output the detection status to"]
    pub fn FSPXI_IsSdmcDetected(serviceHandle: Handle, out: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets whether PXIFS0 can write to the SD\n # Arguments\n\n* `out` - Pointer to output the writable status to"]
    pub fn FSPXI_IsSdmcWritable(serviceHandle: Handle, out: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the SDMC CID\n # Arguments\n\n* `out` - Buffer to output the CID to.\n * `size` - Size of buffer."]
    pub fn FSPXI_GetSdmcCid(serviceHandle: Handle, out: *mut ::libc::c_void, size: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the NAND CID\n # Arguments\n\n* `out` - Buffer to output the CID to.\n * `size` - Size of buffer."]
    pub fn FSPXI_GetNandCid(serviceHandle: Handle, out: *mut ::libc::c_void, size: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the SDMC speed info\n # Arguments\n\n* `out` - Buffer to output the speed info to."]
    pub fn FSPXI_GetSdmcSpeedInfo(serviceHandle: Handle, out: *mut FS_SdMmcSpeedInfo) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the NAND speed info\n # Arguments\n\n* `out` - Buffer to output the speed info to."]
    pub fn FSPXI_GetNandSpeedInfo(serviceHandle: Handle, out: *mut FS_SdMmcSpeedInfo) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the SDMC log\n # Arguments\n\n* `out` - Buffer to output the log to.\n * `size` - Size of buffer."]
    pub fn FSPXI_GetSdmcLog(serviceHandle: Handle, out: *mut ::libc::c_void, size: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the NAND log\n # Arguments\n\n* `out` - Buffer to output the log to.\n * `size` - Size of buffer."]
    pub fn FSPXI_GetNandLog(serviceHandle: Handle, out: *mut ::libc::c_void, size: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Clears the SDMC log"]
    pub fn FSPXI_ClearSdmcLog(serviceHandle: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Clears the NAND log"]
    pub fn FSPXI_ClearNandLog(serviceHandle: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets whether a card is inserted.\n # Arguments\n\n* `inserted` - Pointer to output the insertion status to."]
    pub fn FSPXI_CardSlotIsInserted(serviceHandle: Handle, inserted: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Powers on the card slot.\n # Arguments\n\n* `status` - Pointer to output the power status to."]
    pub fn FSPXI_CardSlotPowerOn(serviceHandle: Handle, status: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Powers off the card slot.\n # Arguments\n\n* `status` - Pointer to output the power status to."]
    pub fn FSPXI_CardSlotPowerOff(serviceHandle: Handle, status: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the card's power status.\n # Arguments\n\n* `status` - Pointer to output the power status to."]
    pub fn FSPXI_CardSlotGetCardIFPowerStatus(serviceHandle: Handle, status: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Executes a CARDNOR direct command.\n # Arguments\n\n* `commandId` - ID of the command."]
    pub fn FSPXI_CardNorDirectCommand(serviceHandle: Handle, commandId: u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Executes a CARDNOR direct command with an address.\n # Arguments\n\n* `commandId` - ID of the command.\n * `address` - Address to provide."]
    pub fn FSPXI_CardNorDirectCommandWithAddress(
        serviceHandle: Handle,
        commandId: u8_,
        address: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Executes a CARDNOR direct read.\n # Arguments\n\n* `commandId` - ID of the command.\n * `size` - Size of the output buffer.\n * `output` - Output buffer."]
    pub fn FSPXI_CardNorDirectRead(
        serviceHandle: Handle,
        commandId: u8_,
        size: u32_,
        output: *mut ::libc::c_void,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Executes a CARDNOR direct read with an address.\n # Arguments\n\n* `commandId` - ID of the command.\n * `address` - Address to provide.\n * `size` - Size of the output buffer.\n * `output` - Output buffer."]
    pub fn FSPXI_CardNorDirectReadWithAddress(
        serviceHandle: Handle,
        commandId: u8_,
        address: u32_,
        size: u32_,
        output: *mut ::libc::c_void,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Executes a CARDNOR direct write.\n # Arguments\n\n* `commandId` - ID of the command.\n * `size` - Size of the input buffer.\n * `output` - Input buffer.\n > Stubbed in latest firmware, since ?.?.?"]
    pub fn FSPXI_CardNorDirectWrite(
        serviceHandle: Handle,
        commandId: u8_,
        size: u32_,
        input: *const ::libc::c_void,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Executes a CARDNOR direct write with an address.\n # Arguments\n\n* `commandId` - ID of the command.\n * `address` - Address to provide.\n * `size` - Size of the input buffer.\n * `input` - Input buffer."]
    pub fn FSPXI_CardNorDirectWriteWithAddress(
        serviceHandle: Handle,
        commandId: u8_,
        address: u32_,
        size: u32_,
        input: *const ::libc::c_void,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Executes a CARDNOR 4xIO direct read.\n # Arguments\n\n* `commandId` - ID of the command.\n * `address` - Address to provide.\n * `size` - Size of the output buffer.\n * `output` - Output buffer."]
    pub fn FSPXI_CardNorDirectRead_4xIO(
        serviceHandle: Handle,
        commandId: u8_,
        address: u32_,
        size: u32_,
        output: *mut ::libc::c_void,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Executes a CARDNOR direct CPU write without verify.\n # Arguments\n\n* `address` - Address to provide.\n * `size` - Size of the input buffer.\n * `output` - Input buffer."]
    pub fn FSPXI_CardNorDirectCpuWriteWithoutVerify(
        serviceHandle: Handle,
        address: u32_,
        size: u32_,
        input: *const ::libc::c_void,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Executes a CARDNOR direct sector erase without verify.\n # Arguments\n\n* `address` - Address to provide."]
    pub fn FSPXI_CardNorDirectSectorEraseWithoutVerify(
        serviceHandle: Handle,
        address: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets an NCCH's product info\n # Arguments\n\n* `info` - Pointer to output the product info to.\n * `archive` - Open NCCH content archive"]
    pub fn FSPXI_GetProductInfo(
        serviceHandle: Handle,
        info: *mut FS_ProductInfo,
        archive: FSPXI_Archive,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the CARDSPI baud rate.\n # Arguments\n\n* `baudRate` - Baud rate to set."]
    pub fn FSPXI_SetCardSpiBaudrate(serviceHandle: Handle, baudRate: FS_CardSpiBaudRate) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the CARDSPI bus mode.\n # Arguments\n\n* `busMode` - Bus mode to set."]
    pub fn FSPXI_SetCardSpiBusMode(serviceHandle: Handle, busMode: FS_CardSpiBusMode) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sends initialization info to ARM9\n # Arguments\n\n* `unk` - FS sends *(0x1FF81086)"]
    pub fn FSPXI_SendInitializeInfoTo9(serviceHandle: Handle, unk: u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Creates ext save data.\n # Arguments\n\n* `info` - Info of the save data."]
    pub fn FSPXI_CreateExtSaveData(serviceHandle: Handle, info: FS_ExtSaveDataInfo) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Deletes ext save data.\n # Arguments\n\n* `info` - Info of the save data."]
    pub fn FSPXI_DeleteExtSaveData(serviceHandle: Handle, info: FS_ExtSaveDataInfo) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Enumerates ext save data.\n # Arguments\n\n* `idsWritten` - Pointer to output the number of IDs written to.\n * `idsSize` - Size of the IDs buffer.\n * `mediaType` - Media type to enumerate over.\n * `idSize` - Size of each ID element.\n * `shared` - Whether to enumerate shared ext save data.\n * `ids` - Pointer to output IDs to."]
    pub fn FSPXI_EnumerateExtSaveData(
        serviceHandle: Handle,
        idsWritten: *mut u32_,
        idsSize: u32_,
        mediaType: FS_MediaType,
        idSize: u32_,
        shared: bool,
        ids: *mut u8_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets a special content's index.\n # Arguments\n\n* `index` - Pointer to output the index to.\n * `mediaType` - Media type of the special content.\n * `programId` - Program ID owning the special content.\n * `type` - Type of special content."]
    pub fn FSPXI_GetSpecialContentIndex(
        serviceHandle: Handle,
        index: *mut u16_,
        mediaType: FS_MediaType,
        programId: u64_,
        type_: FS_SpecialContentType,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the legacy ROM header of a program.\n # Arguments\n\n* `mediaType` - Media type of the program.\n * `programId` - ID of the program.\n * `header` - Pointer to output the legacy ROM header to. (size = 0x3B4)"]
    pub fn FSPXI_GetLegacyRomHeader(
        serviceHandle: Handle,
        mediaType: FS_MediaType,
        programId: u64_,
        header: *mut ::libc::c_void,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the legacy banner data of a program.\n # Arguments\n\n* `mediaType` - Media type of the program.\n * `programId` - ID of the program.\n * `banner` - Pointer to output the legacy banner data to. (size = 0x23C0)\n * `unk` - Unknown. Always 1?"]
    pub fn FSPXI_GetLegacyBannerData(
        serviceHandle: Handle,
        mediaType: FS_MediaType,
        programId: u64_,
        banner: *mut ::libc::c_void,
        unk: u8_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Formats the CARDNOR device.\n # Arguments\n\n* `unk` - Unknown. Transaction?"]
    pub fn FSPXI_FormatCardNorDevice(serviceHandle: Handle, unk: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Deletes the 3DS SDMC root."]
    pub fn FSPXI_DeleteSdmcRoot(serviceHandle: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Deletes all ext save data on the NAND."]
    pub fn FSPXI_DeleteAllExtSaveDataOnNand(serviceHandle: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initializes the CTR file system."]
    pub fn FSPXI_InitializeCtrFilesystem(serviceHandle: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Creates the FS seed."]
    pub fn FSPXI_CreateSeed(serviceHandle: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the CTR SDMC root path.\n # Arguments\n\n* `out` - Pointer to output the root path to.\n * `length` - Length of the output buffer in bytes."]
    pub fn FSPXI_GetSdmcCtrRootPath(serviceHandle: Handle, out: *mut u16_, length: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets an archive's resource information.\n # Arguments\n\n* `archiveResource` - Pointer to output the archive resource information to.\n * `mediaType` - System media type to check."]
    pub fn FSPXI_GetArchiveResource(
        serviceHandle: Handle,
        archiveResource: *mut FS_ArchiveResource,
        mediaType: FS_SystemMediaType,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Exports the integrity verification seed.\n # Arguments\n\n* `seed` - Pointer to output the seed to."]
    pub fn FSPXI_ExportIntegrityVerificationSeed(
        serviceHandle: Handle,
        seed: *mut FS_IntegrityVerificationSeed,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Imports an integrity verification seed.\n # Arguments\n\n* `seed` - Seed to import."]
    pub fn FSPXI_ImportIntegrityVerificationSeed(
        serviceHandle: Handle,
        seed: *const FS_IntegrityVerificationSeed,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the legacy sub banner data of a program.\n # Arguments\n\n* `bannerSize` - Size of the banner.\n * `mediaType` - Media type of the program.\n * `programId` - ID of the program.\n * `header` - Pointer to output the legacy sub banner data to."]
    pub fn FSPXI_GetLegacySubBannerData(
        serviceHandle: Handle,
        bannerSize: u32_,
        mediaType: FS_MediaType,
        programId: u64_,
        banner: *mut ::libc::c_void,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Generates random bytes. Uses same code as PSPXI_GenerateRandomBytes\n # Arguments\n\n* `buf` - Buffer to output random bytes to.\n * `size` - Size of buffer."]
    pub fn FSPXI_GenerateRandomBytes(
        serviceHandle: Handle,
        buffer: *mut ::libc::c_void,
        size: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the last modified time of a file in an archive.\n # Arguments\n\n* `archive` - The archive that contains the file.\n * `out` - The pointer to write the timestamp to.\n * `path` - The UTF-16 path of the file.\n * `size` - The size of the path."]
    pub fn FSPXI_GetFileLastModified(
        serviceHandle: Handle,
        archive: FSPXI_Archive,
        out: *mut u64_,
        path: *const u16_,
        size: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Reads from a special file.\n # Arguments\n\n* `bytesRead` - Pointer to output the number of bytes read to.\n * `fileOffset` - Offset of the file.\n * `size` - Size of the buffer.\n * `data` - Buffer to read to."]
    pub fn FSPXI_ReadSpecialFile(
        serviceHandle: Handle,
        bytesRead: *mut u32_,
        fileOffset: u64_,
        size: u32_,
        data: *mut ::libc::c_void,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the size of a special file.\n # Arguments\n\n* `fileSize` - Pointer to output the size to."]
    pub fn FSPXI_GetSpecialFileSize(serviceHandle: Handle, fileSize: *mut u64_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initiates a device move as the source device.\n # Arguments\n\n* `context` - Pointer to output the context to."]
    pub fn FSPXI_StartDeviceMoveAsSource(
        serviceHandle: Handle,
        context: *mut FS_DeviceMoveContext,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initiates a device move as the destination device.\n # Arguments\n\n* `context` - Context to use.\n * `clear` - Whether to clear the device's data first."]
    pub fn FSPXI_StartDeviceMoveAsDestination(
        serviceHandle: Handle,
        context: FS_DeviceMoveContext,
        clear: bool,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Reads data and stores SHA256 hashes of blocks\n # Arguments\n\n* `file` - File to read from.\n * `bytesRead` - Pointer to output the number of read bytes to.\n * `offset` - Offset to read from.\n * `readBuffer` - Pointer to store read data in.\n * `readBufferSize` - Size of readBuffer.\n * `hashtable` - Pointer to store SHA256 hashes in.\n * `hashtableSize` - Size of hashtable.\n * `unk` - Unknown. Always 0x00001000? Possibly block size?"]
    pub fn FSPXI_ReadFileSHA256(
        serviceHandle: Handle,
        file: FSPXI_File,
        bytesRead: *mut u32_,
        offset: u64_,
        readBuffer: *mut ::libc::c_void,
        readBufferSize: u32_,
        hashtable: *mut ::libc::c_void,
        hashtableSize: u32_,
        unk: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Assumedly writes data and stores SHA256 hashes of blocks\n # Arguments\n\n* `file` - File to write to.\n * `bytesWritten` - Pointer to output the number of written bytes to.\n * `offset` - Offset to write to.\n * `writeBuffer` - Buffer to write from.\n * `writeBufferSize` - Size of writeBuffer.\n * `hashtable` - Pointer to store SHA256 hashes in.\n * `hashtableSize` - Size of hashtable\n * `unk1` - Unknown. Might match with ReadFileSHA256's unknown?\n * `unk2` - Unknown. Might match with ReadFileSHA256's unknown?"]
    pub fn FSPXI_WriteFileSHA256(
        serviceHandle: Handle,
        file: FSPXI_File,
        bytesWritten: *mut u32_,
        offset: u64_,
        writeBuffer: *const ::libc::c_void,
        writeBufferSize: u32_,
        hashtable: *mut ::libc::c_void,
        hashtableSize: u32_,
        unk1: u32_,
        unk2: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Configures CTRCARD latency emulation.\n # Arguments\n\n* `latency` - Latency to apply."]
    pub fn FSPXI_SetCtrCardLatencyParameter(serviceHandle: Handle, latency: u64_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the file system priority.\n # Arguments\n\n* `priority` - Priority to set."]
    pub fn FSPXI_SetPriority(serviceHandle: Handle, priority: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Toggles cleaning up invalid save data.\n # Arguments\n\n* `enable` - Whether to enable cleaning up invalid save data."]
    pub fn FSPXI_SwitchCleanupInvalidSaveData(serviceHandle: Handle, enable: bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Enumerates system save data.\n # Arguments\n\n* `idsWritten` - Pointer to output the number of IDs written to.\n * `idsSize` - Size of the IDs buffer.\n * `ids` - Pointer to output IDs to."]
    pub fn FSPXI_EnumerateSystemSaveData(
        serviceHandle: Handle,
        idsWritten: *mut u32_,
        idsSize: u32_,
        ids: *mut u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Reads the NAND report.\n # Arguments\n\n* `unk` - Unknown\n * `buffer` - Buffer to write the report to.\n * `size` - Size of buffer"]
    pub fn FSPXI_ReadNandReport(
        serviceHandle: Handle,
        buffer: *mut ::libc::c_void,
        size: u32_,
        unk: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Unknown command 0x56\n > Called by FSUSER_ControlArchive with ArchiveAction 0x789D"]
    pub fn FSPXI_Unknown0x56(
        serviceHandle: Handle,
        out: *mut u32_,
        archive: FS_Archive,
        path: FS_Path,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initializes fs:REG."]
    pub fn fsRegInit() -> Result;
}
extern "C" {
    #[doc = "Exits fs:REG."]
    pub fn fsRegExit();
}
extern "C" {
    #[doc = "Gets the current fs:REG session handle.\n # Returns\n\nThe current fs:REG session handle."]
    pub fn fsRegGetSessionHandle() -> *mut Handle;
}
extern "C" {
    #[must_use]
    #[doc = "Registers a program's storage information.\n # Arguments\n\n* `pid` - The Process ID of the program.\n * `programHandle` - The program handle.\n * `programInfo` - Information about the program.\n * `storageInfo` - Storage information to register."]
    pub fn FSREG_Register(
        pid: u32_,
        programHandle: u64_,
        programInfo: *const FS_ProgramInfo,
        storageInfo: *const ExHeader_Arm11StorageInfo,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Unregisters a program's storage information.\n # Arguments\n\n* `pid` - The Process ID of the program."]
    pub fn FSREG_Unregister(pid: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Retrives the exheader information set(s) (SCI+ACI) about a program.\n # Arguments\n\n* `exheaderInfos[out]` - Pointer to the output exheader information set(s).\n * `maxNumEntries` - The maximum number of entries.\n * `programHandle` - The program handle."]
    pub fn FSREG_GetProgramInfo(
        exheaderInfos: *mut ExHeader_Info,
        maxNumEntries: u32_,
        programHandle: u64_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Loads a program.\n # Arguments\n\n* `programHandle[out]` - Pointer to the output the program handle to.\n * `programInfo` - Information about the program to load."]
    pub fn FSREG_LoadProgram(
        programHandle: *mut u64_,
        programInfo: *const FS_ProgramInfo,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Unloads a program.\n # Arguments\n\n* `programHandle` - The program handle."]
    pub fn FSREG_UnloadProgram(programHandle: u64_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Checks if a program has been loaded by fs:REG.\n # Arguments\n\n* `programHandle` - The program handle."]
    pub fn FSREG_CheckHostLoadId(programHandle: u64_) -> Result;
}
#[doc = "Shared Mii struct"]
#[repr(C)]
#[repr(align(1))]
pub struct MiiData {
    pub _bindgen_opaque_blob: [u8; 92usize],
}
#[doc = "Mii options"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MiiData__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl MiiData__bindgen_ty_1 {
    #[inline]
    pub fn allow_copying(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_allow_copying(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_private_name(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_private_name(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn region_lock(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_region_lock(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn char_set(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_char_set(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        allow_copying: bool,
        is_private_name: bool,
        region_lock: u8_,
        char_set: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let allow_copying: u8 = unsafe { ::core::mem::transmute(allow_copying) };
            allow_copying as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let is_private_name: u8 = unsafe { ::core::mem::transmute(is_private_name) };
            is_private_name as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let region_lock: u8 = unsafe { ::core::mem::transmute(region_lock) };
            region_lock as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let char_set: u8 = unsafe { ::core::mem::transmute(char_set) };
            char_set as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "Mii position in Mii selector or Mii maker"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MiiData__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl MiiData__bindgen_ty_2 {
    #[inline]
    pub fn page_index(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_page_index(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn slot_index(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_slot_index(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(page_index: u8_, slot_index: u8_) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let page_index: u8 = unsafe { ::core::mem::transmute(page_index) };
            page_index as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let slot_index: u8 = unsafe { ::core::mem::transmute(slot_index) };
            slot_index as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "Console Identity"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MiiData__bindgen_ty_3 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl MiiData__bindgen_ty_3 {
    #[inline]
    pub fn unknown0(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_unknown0(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn origin_console(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_origin_console(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        unknown0: u8_,
        origin_console: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let unknown0: u8 = unsafe { ::core::mem::transmute(unknown0) };
            unknown0 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 3u8, {
            let origin_console: u8 = unsafe { ::core::mem::transmute(origin_console) };
            origin_console as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "Mii details"]
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone)]
pub struct MiiData__bindgen_ty_4 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl MiiData__bindgen_ty_4 {
    #[inline]
    pub fn sex(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sex(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bday_month(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_bday_month(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn bday_day(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_bday_day(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn shirt_color(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_shirt_color(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn favorite(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_favorite(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sex: bool,
        bday_month: u16_,
        bday_day: u16_,
        shirt_color: u16_,
        favorite: bool,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let sex: u8 = unsafe { ::core::mem::transmute(sex) };
            sex as u64
        });
        __bindgen_bitfield_unit.set(1usize, 4u8, {
            let bday_month: u16 = unsafe { ::core::mem::transmute(bday_month) };
            bday_month as u64
        });
        __bindgen_bitfield_unit.set(5usize, 5u8, {
            let bday_day: u16 = unsafe { ::core::mem::transmute(bday_day) };
            bday_day as u64
        });
        __bindgen_bitfield_unit.set(10usize, 4u8, {
            let shirt_color: u16 = unsafe { ::core::mem::transmute(shirt_color) };
            shirt_color as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let favorite: u8 = unsafe { ::core::mem::transmute(favorite) };
            favorite as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "Face style"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MiiData__bindgen_ty_5 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl MiiData__bindgen_ty_5 {
    #[inline]
    pub fn disable_sharing(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_disable_sharing(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shape(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_shape(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn skinColor(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_skinColor(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        disable_sharing: bool,
        shape: u8_,
        skinColor: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let disable_sharing: u8 = unsafe { ::core::mem::transmute(disable_sharing) };
            disable_sharing as u64
        });
        __bindgen_bitfield_unit.set(1usize, 4u8, {
            let shape: u8 = unsafe { ::core::mem::transmute(shape) };
            shape as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let skinColor: u8 = unsafe { ::core::mem::transmute(skinColor) };
            skinColor as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "Face details"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MiiData__bindgen_ty_6 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl MiiData__bindgen_ty_6 {
    #[inline]
    pub fn wrinkles(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_wrinkles(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn makeup(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_makeup(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(wrinkles: u8_, makeup: u8_) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let wrinkles: u8 = unsafe { ::core::mem::transmute(wrinkles) };
            wrinkles as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let makeup: u8 = unsafe { ::core::mem::transmute(makeup) };
            makeup as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "Hair details"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MiiData__bindgen_ty_7 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl MiiData__bindgen_ty_7 {
    #[inline]
    pub fn color(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_color(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn flip(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_flip(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(color: u8_, flip: bool) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let color: u8 = unsafe { ::core::mem::transmute(color) };
            color as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let flip: u8 = unsafe { ::core::mem::transmute(flip) };
            flip as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "Eye details"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct MiiData__bindgen_ty_8 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl MiiData__bindgen_ty_8 {
    #[inline]
    pub fn style(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_style(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn color(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_color(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn scale(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_scale(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn yscale(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_yscale(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn rotation(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_rotation(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn xspacing(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_xspacing(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn yposition(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_yposition(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        style: u32_,
        color: u32_,
        scale: u32_,
        yscale: u32_,
        rotation: u32_,
        xspacing: u32_,
        yposition: u32_,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let style: u32 = unsafe { ::core::mem::transmute(style) };
            style as u64
        });
        __bindgen_bitfield_unit.set(6usize, 3u8, {
            let color: u32 = unsafe { ::core::mem::transmute(color) };
            color as u64
        });
        __bindgen_bitfield_unit.set(9usize, 4u8, {
            let scale: u32 = unsafe { ::core::mem::transmute(scale) };
            scale as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let yscale: u32 = unsafe { ::core::mem::transmute(yscale) };
            yscale as u64
        });
        __bindgen_bitfield_unit.set(16usize, 5u8, {
            let rotation: u32 = unsafe { ::core::mem::transmute(rotation) };
            rotation as u64
        });
        __bindgen_bitfield_unit.set(21usize, 4u8, {
            let xspacing: u32 = unsafe { ::core::mem::transmute(xspacing) };
            xspacing as u64
        });
        __bindgen_bitfield_unit.set(25usize, 5u8, {
            let yposition: u32 = unsafe { ::core::mem::transmute(yposition) };
            yposition as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "Eyebrow details"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct MiiData__bindgen_ty_9 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl MiiData__bindgen_ty_9 {
    #[inline]
    pub fn style(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_style(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn color(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_color(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn scale(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_scale(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn yscale(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_yscale(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn pad(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pad(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rotation(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_rotation(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn xspacing(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_xspacing(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn yposition(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_yposition(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        style: u32_,
        color: u32_,
        scale: u32_,
        yscale: u32_,
        pad: u32_,
        rotation: u32_,
        xspacing: u32_,
        yposition: u32_,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let style: u32 = unsafe { ::core::mem::transmute(style) };
            style as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let color: u32 = unsafe { ::core::mem::transmute(color) };
            color as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let scale: u32 = unsafe { ::core::mem::transmute(scale) };
            scale as u64
        });
        __bindgen_bitfield_unit.set(12usize, 3u8, {
            let yscale: u32 = unsafe { ::core::mem::transmute(yscale) };
            yscale as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let pad: u32 = unsafe { ::core::mem::transmute(pad) };
            pad as u64
        });
        __bindgen_bitfield_unit.set(16usize, 5u8, {
            let rotation: u32 = unsafe { ::core::mem::transmute(rotation) };
            rotation as u64
        });
        __bindgen_bitfield_unit.set(21usize, 4u8, {
            let xspacing: u32 = unsafe { ::core::mem::transmute(xspacing) };
            xspacing as u64
        });
        __bindgen_bitfield_unit.set(25usize, 5u8, {
            let yposition: u32 = unsafe { ::core::mem::transmute(yposition) };
            yposition as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "Nose details"]
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone)]
pub struct MiiData__bindgen_ty_10 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl MiiData__bindgen_ty_10 {
    #[inline]
    pub fn style(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_style(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn scale(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_scale(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn yposition(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_yposition(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        style: u16_,
        scale: u16_,
        yposition: u16_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let style: u16 = unsafe { ::core::mem::transmute(style) };
            style as u64
        });
        __bindgen_bitfield_unit.set(5usize, 4u8, {
            let scale: u16 = unsafe { ::core::mem::transmute(scale) };
            scale as u64
        });
        __bindgen_bitfield_unit.set(9usize, 5u8, {
            let yposition: u16 = unsafe { ::core::mem::transmute(yposition) };
            yposition as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "Mouth details"]
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone)]
pub struct MiiData__bindgen_ty_11 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl MiiData__bindgen_ty_11 {
    #[inline]
    pub fn style(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u16) }
    }
    #[inline]
    pub fn set_style(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn color(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_color(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn scale(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_scale(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn yscale(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_yscale(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        style: u16_,
        color: u16_,
        scale: u16_,
        yscale: u16_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let style: u16 = unsafe { ::core::mem::transmute(style) };
            style as u64
        });
        __bindgen_bitfield_unit.set(6usize, 3u8, {
            let color: u16 = unsafe { ::core::mem::transmute(color) };
            color as u64
        });
        __bindgen_bitfield_unit.set(9usize, 4u8, {
            let scale: u16 = unsafe { ::core::mem::transmute(scale) };
            scale as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let yscale: u16 = unsafe { ::core::mem::transmute(yscale) };
            yscale as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "Mustache details"]
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone)]
pub struct MiiData__bindgen_ty_12 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl MiiData__bindgen_ty_12 {
    #[inline]
    pub fn mouth_yposition(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_mouth_yposition(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn mustach_style(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_mustach_style(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn pad(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_pad(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mouth_yposition: u16_,
        mustach_style: u16_,
        pad: u16_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let mouth_yposition: u16 = unsafe { ::core::mem::transmute(mouth_yposition) };
            mouth_yposition as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let mustach_style: u16 = unsafe { ::core::mem::transmute(mustach_style) };
            mustach_style as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let pad: u16 = unsafe { ::core::mem::transmute(pad) };
            pad as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "Beard details"]
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone)]
pub struct MiiData__bindgen_ty_13 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl MiiData__bindgen_ty_13 {
    #[inline]
    pub fn style(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_style(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn color(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_color(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn scale(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_scale(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn ypos(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_ypos(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        style: u16_,
        color: u16_,
        scale: u16_,
        ypos: u16_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let style: u16 = unsafe { ::core::mem::transmute(style) };
            style as u64
        });
        __bindgen_bitfield_unit.set(3usize, 3u8, {
            let color: u16 = unsafe { ::core::mem::transmute(color) };
            color as u64
        });
        __bindgen_bitfield_unit.set(6usize, 4u8, {
            let scale: u16 = unsafe { ::core::mem::transmute(scale) };
            scale as u64
        });
        __bindgen_bitfield_unit.set(10usize, 5u8, {
            let ypos: u16 = unsafe { ::core::mem::transmute(ypos) };
            ypos as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "Glasses details"]
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone)]
pub struct MiiData__bindgen_ty_14 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl MiiData__bindgen_ty_14 {
    #[inline]
    pub fn style(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_style(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn color(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_color(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn scale(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_scale(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn ypos(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_ypos(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        style: u16_,
        color: u16_,
        scale: u16_,
        ypos: u16_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let style: u16 = unsafe { ::core::mem::transmute(style) };
            style as u64
        });
        __bindgen_bitfield_unit.set(4usize, 3u8, {
            let color: u16 = unsafe { ::core::mem::transmute(color) };
            color as u64
        });
        __bindgen_bitfield_unit.set(7usize, 4u8, {
            let scale: u16 = unsafe { ::core::mem::transmute(scale) };
            scale as u64
        });
        __bindgen_bitfield_unit.set(11usize, 5u8, {
            let ypos: u16 = unsafe { ::core::mem::transmute(ypos) };
            ypos as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "Mole details"]
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Default, Copy, Clone)]
pub struct MiiData__bindgen_ty_15 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl MiiData__bindgen_ty_15 {
    #[inline]
    pub fn enable(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_enable(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scale(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_scale(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn xpos(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_xpos(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn ypos(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_ypos(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        enable: bool,
        scale: u16_,
        xpos: u16_,
        ypos: u16_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enable: u8 = unsafe { ::core::mem::transmute(enable) };
            enable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 5u8, {
            let scale: u16 = unsafe { ::core::mem::transmute(scale) };
            scale as u64
        });
        __bindgen_bitfield_unit.set(6usize, 5u8, {
            let xpos: u16 = unsafe { ::core::mem::transmute(xpos) };
            xpos as u64
        });
        __bindgen_bitfield_unit.set(11usize, 5u8, {
            let ypos: u16 = unsafe { ::core::mem::transmute(ypos) };
            ypos as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for MiiData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Friend key data"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FriendKey {
    pub principalId: u32_,
    pub padding: u32_,
    pub localFriendCode: u64_,
}
#[doc = "Friend Title data"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TitleData {
    pub tid: u64_,
    pub version: u32_,
    pub unk: u32_,
}
#[doc = "Friend profile data"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FriendProfile {
    #[doc = "< The region code for the hardware."]
    pub region: u8_,
    #[doc = "< Country code."]
    pub country: u8_,
    #[doc = "< Area code."]
    pub area: u8_,
    #[doc = "< Language code."]
    pub language: u8_,
    #[doc = "< Platform code."]
    pub platform: u8_,
    pub padding: u32_,
}
#[doc = "Game Description structure"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct GameDescription {
    pub data: TitleData,
    pub desc: [u16_; 128usize],
}
impl Default for GameDescription {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Friend Notification Event structure"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NotificationEvent {
    pub type_: u8_,
    pub padding3: [u8_; 3usize],
    pub padding: u32_,
    pub key: FriendKey,
}
#[doc = "< Self went online"]
pub const USER_WENT_ONLINE: NotificationTypes = 1;
#[doc = "< Self went offline"]
pub const USER_WENT_OFFLINE: NotificationTypes = 2;
#[doc = "< Friend Went Online"]
pub const FRIEND_WENT_ONLINE: NotificationTypes = 3;
#[doc = "< Friend Presence changed"]
pub const FRIEND_UPDATED_PRESENCE: NotificationTypes = 4;
#[doc = "< Friend Mii changed"]
pub const FRIEND_UPDATED_MII: NotificationTypes = 5;
#[doc = "< Friend Profile changed"]
pub const FRIEND_UPDATED_PROFILE: NotificationTypes = 6;
#[doc = "< Friend went offline"]
pub const FRIEND_WENT_OFFLINE: NotificationTypes = 7;
#[doc = "< Friend registered self as friend"]
pub const FRIEND_REGISTERED_USER: NotificationTypes = 8;
#[doc = "< Friend Sent invitation"]
pub const FRIEND_SENT_INVITATION: NotificationTypes = 9;
#[doc = "Enum to use with FRD_GetNotificationEvent"]
pub type NotificationTypes = ::libc::c_uint;
extern "C" {
    #[must_use]
    #[doc = "Initializes FRD service."]
    pub fn frdInit() -> Result;
}
extern "C" {
    #[doc = "Exists FRD."]
    pub fn frdExit();
}
extern "C" {
    #[doc = "Get FRD handle."]
    pub fn frdGetSessionHandle() -> *mut Handle;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the login status of the current user.\n # Arguments\n\n* `state` - Pointer to write the current user's login status to."]
    pub fn FRDU_HasLoggedIn(state: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the online status of the current user.\n # Arguments\n\n* `state` - Pointer to write the current user's online status to."]
    pub fn FRDU_IsOnline(state: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Logs out of Nintendo's friend server."]
    pub fn FRD_Logout() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Log in to Nintendo's friend server.\n # Arguments\n\n* `event` - Event to signal when Login is done."]
    pub fn FRD_Login(event: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the current user's friend key.\n # Arguments\n\n* `key` - Pointer to write the current user's friend key to."]
    pub fn FRD_GetMyFriendKey(key: *mut FriendKey) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the current user's privacy information.\n # Arguments\n\n* `isPublicMode` - Determines whether friends are notified of the current user's online status.\n * `isShowGameName` - Determines whether friends are notified of the application that the current user is running.\n * `isShowPlayedGame` - Determiens whether to display the current user's game history."]
    pub fn FRD_GetMyPreference(
        isPublicMode: *mut bool,
        isShowGameName: *mut bool,
        isShowPlayedGame: *mut bool,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the current user's profile information.\n # Arguments\n\n* `profile` - Pointer to write the current user's profile information to."]
    pub fn FRD_GetMyProfile(profile: *mut FriendProfile) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the current user's screen name.\n # Arguments\n\n* `name` - Pointer to write the current user's screen name to.\n * `max_size` - Max size of the screen name."]
    pub fn FRD_GetMyScreenName(name: *mut ::libc::c_char, max_size: usize) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the current user's Mii data.\n # Arguments\n\n* `mii` - Pointer to write the current user's mii data to."]
    pub fn FRD_GetMyMii(mii: *mut MiiData) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the current user's playing game.\n # Arguments\n\n* `titleId` - Pointer to write the current user's playing game to."]
    pub fn FRD_GetMyPlayingGame(titleId: *mut u64_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the current user's favourite game.\n # Arguments\n\n* `titleId` - Pointer to write the title ID of current user's favourite game to."]
    pub fn FRD_GetMyFavoriteGame(titleId: *mut u64_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the current user's comment on their friend profile.\n # Arguments\n\n* `comment` - Pointer to write the current user's comment to.\n * `max_size` - Max size of the comment."]
    pub fn FRD_GetMyComment(comment: *mut ::libc::c_char, max_size: usize) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the current user's friend key list.\n # Arguments\n\n* `friendKeyList` - Pointer to write the friend key list to.\n * `num` - Stores the number of friend keys obtained.\n * `offset` - The index of the friend key to start with.\n * `size` - Size of the friend key list. (FRIEND_LIST_SIZE)"]
    pub fn FRD_GetFriendKeyList(
        friendKeyList: *mut FriendKey,
        num: *mut u32_,
        offset: u32_,
        size: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the current user's friends' Mii data.\n # Arguments\n\n* `miiDataList` - Pointer to write Mii data to.\n * `friendKeyList` - Pointer to FriendKeys.\n * `size` - Number of Friendkeys."]
    pub fn FRD_GetFriendMii(
        miiDataList: *mut MiiData,
        friendKeyList: *const FriendKey,
        size: usize,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Get the current user's friends' profile data.\n # Arguments\n\n* `profile` - Pointer to write profile data to.\n * `friendKeyList` - Pointer to FriendKeys.\n * `size` - Number of FriendKeys."]
    pub fn FRD_GetFriendProfile(
        profile: *mut FriendProfile,
        friendKeyList: *const FriendKey,
        size: usize,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Get the current user's friends' playing game.\n # Arguments\n\n* `desc` - Pointer to write Game Description data to.\n * `friendKeyList` - Pointer to FriendKeys,\n * `size` - Number Of FriendKeys."]
    pub fn FRD_GetFriendPlayingGame(
        desc: *mut GameDescription,
        friendKeyList: *const FriendKey,
        size: usize,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Get the current user's friends' favourite game.\n # Arguments\n\n* `desc` - Pointer to write Game Description data to.\n * `friendKeyList` - Pointer to FriendKeys,\n * `count` - Number Of FriendKeys."]
    pub fn FRD_GetFriendFavouriteGame(
        desc: *mut GameDescription,
        friendKeyList: *const FriendKey,
        count: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets whether a friend key is included in the current user's friend list.\n # Arguments\n\n* `friendKeyList` - Pointer to a list of friend keys.\n * `isFromList` - Pointer to a write the friendship status to."]
    pub fn FRD_IsInFriendList(friendKeyList: *mut FriendKey, isFromList: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Updates the game mode description string.\n # Arguments\n\n* `desc` - Pointer to write the game mode description to."]
    pub fn FRD_UpdateGameModeDescription(desc: *const ::libc::c_char) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Event which is signaled when friend login states change.\n # Arguments\n\n* `event` - event which will be signaled."]
    pub fn FRD_AttachToEventNotification(event: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Get Latest Event Notification\n # Arguments\n\n* `event` - Pointer to write recieved notification event struct to.\n * `count` - Number of events\n * `recievedNotifCount` - Number of notification reccieved."]
    pub fn FRD_GetEventNotification(
        event: *mut NotificationEvent,
        count: u32_,
        recievedNotifCount: *mut u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Returns the friend code using the given principal ID.\n # Arguments\n\n* `principalId` - The principal ID being used.\n * `friendCode` - Pointer to write the friend code to."]
    pub fn FRD_PrincipalIdToFriendCode(principalId: u32_, friendCode: *mut u64_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Returns the principal ID using the given friend code.\n # Arguments\n\n* `friendCode` - The friend code being used.\n * `principalId` - Pointer to write the principal ID to."]
    pub fn FRD_FriendCodeToPrincipalId(friendCode: u64_, principalId: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Checks if the friend code is valid.\n # Arguments\n\n* `friendCode` - The friend code being used.\n * `isValid` - Pointer to write the validity of the friend code to."]
    pub fn FRD_IsValidFriendCode(friendCode: u64_, isValid: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the Friend API to use a specific SDK version.\n # Arguments\n\n* `sdkVer` - The SDK version needed to be used."]
    pub fn FRD_SetClientSdkVersion(sdkVer: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Add a Friend online.\n # Arguments\n\n* `event` - Event signaled when friend is registered.\n * `principalId` - PrincipalId of the friend to add."]
    pub fn FRD_AddFriendOnline(event: Handle, principalId: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Remove a Friend.\n # Arguments\n\n* `principalId` - PrinipalId of the friend code to remove.\n * `localFriendCode` - LocalFriendCode of the friend code to remove."]
    pub fn FRD_RemoveFriend(principalId: u32_, localFriendCode: u64_) -> Result;
}
#[doc = "< Top screen."]
pub const GSPLCD_SCREEN_TOP: _bindgen_ty_21 = 1;
#[doc = "< Bottom screen."]
pub const GSPLCD_SCREEN_BOTTOM: _bindgen_ty_21 = 2;
#[doc = "< Both screens."]
pub const GSPLCD_SCREEN_BOTH: _bindgen_ty_21 = 3;
#[doc = "LCD screens."]
pub type _bindgen_ty_21 = ::libc::c_uint;
extern "C" {
    #[must_use]
    #[doc = "Initializes GSPLCD."]
    pub fn gspLcdInit() -> Result;
}
extern "C" {
    #[doc = "Exits GSPLCD."]
    pub fn gspLcdExit();
}
extern "C" {
    #[doc = "Gets a pointer to the current gsp::Lcd session handle.\n # Returns\n\nA pointer to the current gsp::Lcd session handle."]
    pub fn gspLcdGetSessionHandle() -> *mut Handle;
}
extern "C" {
    #[must_use]
    #[doc = "Powers on both backlights."]
    pub fn GSPLCD_PowerOnAllBacklights() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Powers off both backlights."]
    pub fn GSPLCD_PowerOffAllBacklights() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Powers on the backlight.\n # Arguments\n\n* `screen` - Screen to power on."]
    pub fn GSPLCD_PowerOnBacklight(screen: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Powers off the backlight.\n # Arguments\n\n* `screen` - Screen to power off."]
    pub fn GSPLCD_PowerOffBacklight(screen: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets 3D_LEDSTATE to the input state value.\n # Arguments\n\n* `disable` - False = 3D LED enable, true = 3D LED disable."]
    pub fn GSPLCD_SetLedForceOff(disable: bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the LCD screens' vendors. Stubbed on old 3ds.\n # Arguments\n\n* `vendor` - Pointer to output the screen vendors to."]
    pub fn GSPLCD_GetVendors(vendors: *mut u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the LCD screens' brightness. Stubbed on old 3ds.\n # Arguments\n\n* `screen` - Screen to get the brightness value of.\n * `brightness` - Brightness value returned."]
    pub fn GSPLCD_GetBrightness(screen: u32_, brightness: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the LCD screens' brightness.\n # Arguments\n\n* `screen` - Screen to set the brightness value of.\n * `brightness` - Brightness value set."]
    pub fn GSPLCD_SetBrightness(screen: u32_, brightness: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the LCD screens' raw brightness.\n # Arguments\n\n* `screen` - Screen to set the brightness value of.\n * `brightness` - Brightness value set."]
    pub fn GSPLCD_SetBrightnessRaw(screen: u32_, brightness: u32_) -> Result;
}
#[doc = "< A"]
pub const KEY_A: _bindgen_ty_22 = 1;
#[doc = "< B"]
pub const KEY_B: _bindgen_ty_22 = 2;
#[doc = "< Select"]
pub const KEY_SELECT: _bindgen_ty_22 = 4;
#[doc = "< Start"]
pub const KEY_START: _bindgen_ty_22 = 8;
#[doc = "< D-Pad Right"]
pub const KEY_DRIGHT: _bindgen_ty_22 = 16;
#[doc = "< D-Pad Left"]
pub const KEY_DLEFT: _bindgen_ty_22 = 32;
#[doc = "< D-Pad Up"]
pub const KEY_DUP: _bindgen_ty_22 = 64;
#[doc = "< D-Pad Down"]
pub const KEY_DDOWN: _bindgen_ty_22 = 128;
#[doc = "< R"]
pub const KEY_R: _bindgen_ty_22 = 256;
#[doc = "< L"]
pub const KEY_L: _bindgen_ty_22 = 512;
#[doc = "< X"]
pub const KEY_X: _bindgen_ty_22 = 1024;
#[doc = "< Y"]
pub const KEY_Y: _bindgen_ty_22 = 2048;
#[doc = "< ZL (New 3DS only)"]
pub const KEY_ZL: _bindgen_ty_22 = 16384;
#[doc = "< ZR (New 3DS only)"]
pub const KEY_ZR: _bindgen_ty_22 = 32768;
#[doc = "< Touch (Not actually provided by HID)"]
pub const KEY_TOUCH: _bindgen_ty_22 = 1048576;
#[doc = "< C-Stick Right (New 3DS only)"]
pub const KEY_CSTICK_RIGHT: _bindgen_ty_22 = 16777216;
#[doc = "< C-Stick Left (New 3DS only)"]
pub const KEY_CSTICK_LEFT: _bindgen_ty_22 = 33554432;
#[doc = "< C-Stick Up (New 3DS only)"]
pub const KEY_CSTICK_UP: _bindgen_ty_22 = 67108864;
#[doc = "< C-Stick Down (New 3DS only)"]
pub const KEY_CSTICK_DOWN: _bindgen_ty_22 = 134217728;
#[doc = "< Circle Pad Right"]
pub const KEY_CPAD_RIGHT: _bindgen_ty_22 = 268435456;
#[doc = "< Circle Pad Left"]
pub const KEY_CPAD_LEFT: _bindgen_ty_22 = 536870912;
#[doc = "< Circle Pad Up"]
pub const KEY_CPAD_UP: _bindgen_ty_22 = 1073741824;
#[doc = "< Circle Pad Down"]
pub const KEY_CPAD_DOWN: _bindgen_ty_22 = 2147483648;
#[doc = "< D-Pad Up or Circle Pad Up"]
pub const KEY_UP: _bindgen_ty_22 = 1073741888;
#[doc = "< D-Pad Down or Circle Pad Down"]
pub const KEY_DOWN: _bindgen_ty_22 = 2147483776;
#[doc = "< D-Pad Left or Circle Pad Left"]
pub const KEY_LEFT: _bindgen_ty_22 = 536870944;
#[doc = "< D-Pad Right or Circle Pad Right"]
pub const KEY_RIGHT: _bindgen_ty_22 = 268435472;
#[doc = "Key values."]
pub type _bindgen_ty_22 = ::libc::c_uint;
#[doc = "Touch position."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct touchPosition {
    #[doc = "< Touch X"]
    pub px: u16_,
    #[doc = "< Touch Y"]
    pub py: u16_,
}
#[doc = "Circle Pad position."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct circlePosition {
    #[doc = "< Pad X"]
    pub dx: s16,
    #[doc = "< Pad Y"]
    pub dy: s16,
}
#[doc = "Accelerometer vector."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct accelVector {
    #[doc = "< Accelerometer X"]
    pub x: s16,
    #[doc = "< Accelerometer Y"]
    pub y: s16,
    #[doc = "< Accelerometer Z"]
    pub z: s16,
}
#[doc = "Gyroscope angular rate."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct angularRate {
    #[doc = "< Roll"]
    pub x: s16,
    #[doc = "< Yaw"]
    pub z: s16,
    #[doc = "< Pitch"]
    pub y: s16,
}
#[doc = "< Event signaled by HID-module, when the sharedmem+0(PAD/circle-pad)/+0xA8(touch-screen) region was updated."]
pub const HIDEVENT_PAD0: HID_Event = 0;
#[doc = "< Event signaled by HID-module, when the sharedmem+0(PAD/circle-pad)/+0xA8(touch-screen) region was updated."]
pub const HIDEVENT_PAD1: HID_Event = 1;
#[doc = "< Event signaled by HID-module, when the sharedmem accelerometer state was updated."]
pub const HIDEVENT_Accel: HID_Event = 2;
#[doc = "< Event signaled by HID-module, when the sharedmem gyroscope state was updated."]
pub const HIDEVENT_Gyro: HID_Event = 3;
#[doc = "< Event signaled by HID-module, when the sharedmem DebugPad state was updated."]
pub const HIDEVENT_DebugPad: HID_Event = 4;
#[doc = "< Used to know how many events there are."]
pub const HIDEVENT_MAX: HID_Event = 5;
#[doc = "HID events."]
pub type HID_Event = ::libc::c_uint;
extern "C" {
    #[doc = "< HID shared memory handle."]
    pub static mut hidMemHandle: Handle;
}
extern "C" {
    #[doc = "< HID shared memory."]
    pub static mut hidSharedMem: *mut vu32;
}
extern "C" {
    #[must_use]
    #[doc = "Initializes HID."]
    pub fn hidInit() -> Result;
}
extern "C" {
    #[doc = "Exits HID."]
    pub fn hidExit();
}
extern "C" {
    #[doc = "Sets the key repeat parameters for hidKeysRepeat.\n # Arguments\n\n* `delay` - Initial delay.\n * `interval` - Repeat interval."]
    pub fn hidSetRepeatParameters(delay: u32_, interval: u32_);
}
extern "C" {
    #[doc = "Scans HID for input data."]
    pub fn hidScanInput();
}
extern "C" {
    #[doc = "Returns a bitmask of held buttons.\n Individual buttons can be extracted using binary AND.\n # Returns\n\n32-bit bitmask of held buttons (1+ frames)."]
    pub fn hidKeysHeld() -> u32_;
}
extern "C" {
    #[doc = "Returns a bitmask of newly pressed buttons, this frame.\n Individual buttons can be extracted using binary AND.\n # Returns\n\n32-bit bitmask of newly pressed buttons."]
    pub fn hidKeysDown() -> u32_;
}
extern "C" {
    #[doc = "Returns a bitmask of newly pressed or repeated buttons, this frame.\n Individual buttons can be extracted using binary AND.\n # Returns\n\n32-bit bitmask of newly pressed or repeated buttons."]
    pub fn hidKeysDownRepeat() -> u32_;
}
extern "C" {
    #[doc = "Returns a bitmask of newly released buttons, this frame.\n Individual buttons can be extracted using binary AND.\n # Returns\n\n32-bit bitmask of newly released buttons."]
    pub fn hidKeysUp() -> u32_;
}
extern "C" {
    #[doc = "Reads the current touch position.\n # Arguments\n\n* `pos` - Pointer to output the touch position to."]
    pub fn hidTouchRead(pos: *mut touchPosition);
}
extern "C" {
    #[doc = "Reads the current circle pad position.\n # Arguments\n\n* `pos` - Pointer to output the circle pad position to."]
    pub fn hidCircleRead(pos: *mut circlePosition);
}
extern "C" {
    #[doc = "Reads the current accelerometer data.\n # Arguments\n\n* `vector` - Pointer to output the accelerometer data to."]
    pub fn hidAccelRead(vector: *mut accelVector);
}
extern "C" {
    #[doc = "Reads the current gyroscope data.\n # Arguments\n\n* `rate` - Pointer to output the gyroscope data to."]
    pub fn hidGyroRead(rate: *mut angularRate);
}
extern "C" {
    #[doc = "Waits for an HID event.\n # Arguments\n\n* `id` - ID of the event.\n * `nextEvent` - Whether to discard the current event and wait for the next event."]
    pub fn hidWaitForEvent(id: HID_Event, nextEvent: bool);
}
extern "C" {
    #[must_use]
    #[doc = "Waits for any HID or IRRST event.\n # Arguments\n\n* `nextEvents` - Whether to discard the current events and wait for the next events.\n * `cancelEvent` - Optional additional handle to wait on, otherwise 0.\n * `timeout` - Timeout."]
    pub fn hidWaitForAnyEvent(nextEvents: bool, cancelEvent: Handle, timeout: s64) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the handles for HID operation.\n # Arguments\n\n* `outMemHandle` - Pointer to output the shared memory handle to.\n * `eventpad0` - Pointer to output the pad 0 event handle to.\n * `eventpad1` - Pointer to output the pad 1 event handle to.\n * `eventaccel` - Pointer to output the accelerometer event handle to.\n * `eventgyro` - Pointer to output the gyroscope event handle to.\n * `eventdebugpad` - Pointer to output the debug pad event handle to."]
    pub fn HIDUSER_GetHandles(
        outMemHandle: *mut Handle,
        eventpad0: *mut Handle,
        eventpad1: *mut Handle,
        eventaccel: *mut Handle,
        eventgyro: *mut Handle,
        eventdebugpad: *mut Handle,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Enables the accelerometer."]
    pub fn HIDUSER_EnableAccelerometer() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Disables the accelerometer."]
    pub fn HIDUSER_DisableAccelerometer() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Enables the gyroscope."]
    pub fn HIDUSER_EnableGyroscope() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Disables the gyroscope."]
    pub fn HIDUSER_DisableGyroscope() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the gyroscope raw to dps coefficient.\n # Arguments\n\n* `coeff` - Pointer to output the coefficient to."]
    pub fn HIDUSER_GetGyroscopeRawToDpsCoefficient(coeff: *mut f32) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the current volume slider value. (0-63)\n # Arguments\n\n* `volume` - Pointer to write the volume slider value to."]
    pub fn HIDUSER_GetSoundVolume(volume: *mut u8_) -> Result;
}
extern "C" {
    #[doc = "IRRST's shared memory handle."]
    pub static mut irrstMemHandle: Handle;
}
extern "C" {
    #[doc = "IRRST's shared memory."]
    pub static mut irrstSharedMem: *mut vu32;
}
extern "C" {
    #[doc = "IRRST's state update event"]
    pub static mut irrstEvent: Handle;
}
extern "C" {
    #[must_use]
    #[doc = "Initializes IRRST."]
    pub fn irrstInit() -> Result;
}
extern "C" {
    #[doc = "Exits IRRST."]
    pub fn irrstExit();
}
extern "C" {
    #[doc = "Scans IRRST for input."]
    pub fn irrstScanInput();
}
extern "C" {
    #[doc = "Gets IRRST's held keys.\n # Returns\n\nIRRST's held keys."]
    pub fn irrstKeysHeld() -> u32_;
}
extern "C" {
    #[doc = "Reads the current c-stick position.\n # Arguments\n\n* `pos` - Pointer to output the current c-stick position to."]
    pub fn irrstCstickRead(pos: *mut circlePosition);
}
extern "C" {
    #[doc = "Waits for the IRRST input event to trigger.\n # Arguments\n\n* `nextEvent` - Whether to discard the current event and wait until the next event."]
    pub fn irrstWaitForEvent(nextEvent: bool);
}
extern "C" {
    #[must_use]
    #[doc = "Gets the shared memory and event handles for IRRST.\n # Arguments\n\n* `outMemHandle` - Pointer to write the shared memory handle to.\n * `outEventHandle` - Pointer to write the event handle to."]
    pub fn IRRST_GetHandles(outMemHandle: *mut Handle, outEventHandle: *mut Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initializes IRRST.\n # Arguments\n\n* `unk1` - Unknown.\n * `unk2` - Unknown."]
    pub fn IRRST_Initialize(unk1: u32_, unk2: u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Shuts down IRRST."]
    pub fn IRRST_Shutdown() -> Result;
}
#[doc = "sslc context."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sslcContext {
    #[doc = "< Service handle."]
    pub servhandle: Handle,
    #[doc = "< SSLC handle."]
    pub sslchandle: u32_,
    pub sharedmem_handle: Handle,
}
pub const SSLC_DefaultRootCert_Nintendo_CA: SSLC_DefaultRootCert = 1;
pub const SSLC_DefaultRootCert_Nintendo_CA_G2: SSLC_DefaultRootCert = 2;
pub const SSLC_DefaultRootCert_Nintendo_CA_G3: SSLC_DefaultRootCert = 3;
pub const SSLC_DefaultRootCert_Nintendo_Class2_CA: SSLC_DefaultRootCert = 4;
pub const SSLC_DefaultRootCert_Nintendo_Class2_CA_G2: SSLC_DefaultRootCert = 5;
pub const SSLC_DefaultRootCert_Nintendo_Class2_CA_G3: SSLC_DefaultRootCert = 6;
pub const SSLC_DefaultRootCert_CyberTrust: SSLC_DefaultRootCert = 7;
pub const SSLC_DefaultRootCert_AddTrust_External_CA: SSLC_DefaultRootCert = 8;
pub const SSLC_DefaultRootCert_COMODO: SSLC_DefaultRootCert = 9;
pub const SSLC_DefaultRootCert_USERTrust: SSLC_DefaultRootCert = 10;
pub const SSLC_DefaultRootCert_DigiCert_EV: SSLC_DefaultRootCert = 11;
pub type SSLC_DefaultRootCert = ::libc::c_uint;
pub const SSLC_DefaultClientCert_ClCertA: SSLC_DefaultClientCert = 64;
pub type SSLC_DefaultClientCert = ::libc::c_uint;
pub const SSLCOPT_Default: _bindgen_ty_23 = 0;
pub const SSLCOPT_DisableVerify: _bindgen_ty_23 = 512;
pub const SSLCOPT_TLSv10: _bindgen_ty_23 = 2048;
#[doc = "sslc options. https://www.3dbrew.org/wiki/SSL_Services#SSLOpt"]
pub type _bindgen_ty_23 = ::libc::c_uint;
extern "C" {
    #[must_use]
    #[doc = "Initializes SSLC. Normally session_handle should be 0. When non-zero this will use the specified handle for the main-service-session without using the Initialize command, instead of using srvGetServiceHandle."]
    pub fn sslcInit(session_handle: Handle) -> Result;
}
extern "C" {
    #[doc = "Exits SSLC."]
    pub fn sslcExit();
}
extern "C" {
    #[must_use]
    #[doc = "Creates a RootCertChain.\n # Arguments\n\n* `RootCertChain_contexthandle` - Output contexthandle."]
    pub fn sslcCreateRootCertChain(RootCertChain_contexthandle: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Destroys a RootCertChain.\n # Arguments\n\n* `RootCertChain_contexthandle` - RootCertChain contexthandle."]
    pub fn sslcDestroyRootCertChain(RootCertChain_contexthandle: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Adds a trusted RootCA cert to a RootCertChain.\n # Arguments\n\n* `RootCertChain_contexthandle` - RootCertChain to use.\n * `cert` - Pointer to the DER cert.\n * `certsize` - Size of the DER cert."]
    pub fn sslcAddTrustedRootCA(
        RootCertChain_contexthandle: u32_,
        cert: *const u8_,
        certsize: u32_,
        cert_contexthandle: *mut u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Adds a default RootCA cert to a RootCertChain.\n # Arguments\n\n* `RootCertChain_contexthandle` - RootCertChain to use.\n * `certID` - ID of the cert to add.\n * `cert_contexthandle` - Optional, the cert contexthandle can be written here."]
    pub fn sslcRootCertChainAddDefaultCert(
        RootCertChain_contexthandle: u32_,
        certID: SSLC_DefaultRootCert,
        cert_contexthandle: *mut u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Removes the specified cert from the RootCertChain.\n # Arguments\n\n* `RootCertChain_contexthandle` - RootCertChain to use.\n * `cert_contexthandle` - Cert contexthandle to remove from the RootCertChain."]
    pub fn sslcRootCertChainRemoveCert(
        RootCertChain_contexthandle: u32_,
        cert_contexthandle: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Creates an unknown CertChain.\n # Arguments\n\n* `CertChain_contexthandle` - Output contexthandle."]
    pub fn sslcCreate8CertChain(CertChain_contexthandle: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Destroys a CertChain from sslcCreate8CertChain().\n # Arguments\n\n* `CertChain_contexthandle` - CertChain contexthandle."]
    pub fn sslcDestroy8CertChain(CertChain_contexthandle: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Adds a cert to a CertChain from sslcCreate8CertChain().\n # Arguments\n\n* `CertChain_contexthandle` - CertChain to use.\n * `cert` - Pointer to the cert.\n * `certsize` - Size of the cert."]
    pub fn sslc8CertChainAddCert(
        CertChain_contexthandle: u32_,
        cert: *const u8_,
        certsize: u32_,
        cert_contexthandle: *mut u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Adds a default cert to a CertChain from sslcCreate8CertChain(). Not actually usable since no certIDs are implemented in SSL-module for this.\n # Arguments\n\n* `CertChain_contexthandle` - CertChain to use.\n * `certID` - ID of the cert to add.\n * `cert_contexthandle` - Optional, the cert contexthandle can be written here."]
    pub fn sslc8CertChainAddDefaultCert(
        CertChain_contexthandle: u32_,
        certID: u8_,
        cert_contexthandle: *mut u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Removes the specified cert from the CertChain from sslcCreate8CertChain().\n # Arguments\n\n* `CertChain_contexthandle` - CertChain to use.\n * `cert_contexthandle` - Cert contexthandle to remove from the CertChain."]
    pub fn sslc8CertChainRemoveCert(
        CertChain_contexthandle: u32_,
        cert_contexthandle: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Opens a new ClientCert-context.\n # Arguments\n\n* `cert` - Pointer to the DER cert.\n * `certsize` - Size of the DER cert.\n * `key` - Pointer to the DER key.\n * `keysize` - Size of the DER key.\n * `ClientCert_contexthandle` - Output contexthandle."]
    pub fn sslcOpenClientCertContext(
        cert: *const u8_,
        certsize: u32_,
        key: *const u8_,
        keysize: u32_,
        ClientCert_contexthandle: *mut u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Opens a ClientCert-context with a default certID.\n # Arguments\n\n* `certID` - ID of the ClientCert to use.\n * `ClientCert_contexthandle` - Output contexthandle."]
    pub fn sslcOpenDefaultClientCertContext(
        certID: SSLC_DefaultClientCert,
        ClientCert_contexthandle: *mut u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Closes the specified ClientCert-context.\n # Arguments\n\n* `ClientCert_contexthandle` - ClientCert-context to use."]
    pub fn sslcCloseClientCertContext(ClientCert_contexthandle: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "This uses ps:ps SeedRNG internally."]
    pub fn sslcSeedRNG() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "This uses ps:ps GenerateRandomData internally.\n # Arguments\n\n* `buf` - Output buffer.\n * `size` - Output size."]
    pub fn sslcGenerateRandomData(buf: *mut u8_, size: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Creates a sslc context.\n # Arguments\n\n* `context` - sslc context.\n * `sockfd` - Socket fd, this code automatically uses the required SOC command before using the actual sslc command.\n * `input_opt` - Input sslc options bitmask.\n * `hostname` - Server hostname."]
    pub fn sslcCreateContext(
        context: *mut sslcContext,
        sockfd: ::libc::c_int,
        input_opt: u32_,
        hostname: *const ::libc::c_char,
    ) -> Result;
}
extern "C" {
    #[must_use]
    pub fn sslcDestroyContext(context: *mut sslcContext) -> Result;
}
extern "C" {
    #[must_use]
    pub fn sslcStartConnection(
        context: *mut sslcContext,
        internal_retval: *mut ::libc::c_int,
        out: *mut u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    pub fn sslcRead(
        context: *mut sslcContext,
        buf: *mut ::libc::c_void,
        len: usize,
        peek: bool,
    ) -> Result;
}
extern "C" {
    #[must_use]
    pub fn sslcWrite(context: *mut sslcContext, buf: *const ::libc::c_void, len: usize) -> Result;
}
extern "C" {
    #[must_use]
    pub fn sslcContextSetRootCertChain(context: *mut sslcContext, handle: u32_) -> Result;
}
extern "C" {
    #[must_use]
    pub fn sslcContextSetClientCert(context: *mut sslcContext, handle: u32_) -> Result;
}
extern "C" {
    #[must_use]
    pub fn sslcContextSetHandle8(context: *mut sslcContext, handle: u32_) -> Result;
}
extern "C" {
    #[must_use]
    pub fn sslcContextClearOpt(context: *mut sslcContext, bitmask: u32_) -> Result;
}
extern "C" {
    #[must_use]
    pub fn sslcContextGetProtocolCipher(
        context: *mut sslcContext,
        outprotocols: *mut ::libc::c_char,
        outprotocols_maxsize: u32_,
        outcipher: *mut ::libc::c_char,
        outcipher_maxsize: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    pub fn sslcContextGetState(context: *mut sslcContext, out: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    pub fn sslcContextInitSharedmem(context: *mut sslcContext, buf: *mut u8_, size: u32_)
        -> Result;
}
extern "C" {
    #[must_use]
    pub fn sslcAddCert(context: *mut sslcContext, buf: *const u8_, size: u32_) -> Result;
}
#[doc = "HTTP context."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct httpcContext {
    #[doc = "< Service handle."]
    pub servhandle: Handle,
    #[doc = "< HTTP handle."]
    pub httphandle: u32_,
}
pub const HTTPC_METHOD_GET: HTTPC_RequestMethod = 1;
pub const HTTPC_METHOD_POST: HTTPC_RequestMethod = 2;
pub const HTTPC_METHOD_HEAD: HTTPC_RequestMethod = 3;
pub const HTTPC_METHOD_PUT: HTTPC_RequestMethod = 4;
pub const HTTPC_METHOD_DELETE: HTTPC_RequestMethod = 5;
#[doc = "HTTP request method."]
pub type HTTPC_RequestMethod = ::libc::c_uint;
#[doc = "< Request in progress."]
pub const HTTPC_STATUS_REQUEST_IN_PROGRESS: HTTPC_RequestStatus = 5;
#[doc = "< Download ready."]
pub const HTTPC_STATUS_DOWNLOAD_READY: HTTPC_RequestStatus = 7;
#[doc = "HTTP request status."]
pub type HTTPC_RequestStatus = ::libc::c_uint;
pub const HTTPC_KEEPALIVE_DISABLED: HTTPC_KeepAlive = 0;
pub const HTTPC_KEEPALIVE_ENABLED: HTTPC_KeepAlive = 1;
#[doc = "HTTP KeepAlive option."]
pub type HTTPC_KeepAlive = ::libc::c_uint;
extern "C" {
    #[must_use]
    #[doc = "Initializes HTTPC. For HTTP GET the sharedmem_size can be zero. The sharedmem contains data which will be later uploaded for HTTP POST. sharedmem_size should be aligned to 0x1000-bytes."]
    pub fn httpcInit(sharedmem_size: u32_) -> Result;
}
extern "C" {
    #[doc = "Exits HTTPC."]
    pub fn httpcExit();
}
extern "C" {
    #[must_use]
    #[doc = "Opens a HTTP context.\n # Arguments\n\n* `context` - Context to open.\n * `url` - URL to connect to.\n * `use_defaultproxy` - Whether the default proxy should be used (0 for default)"]
    pub fn httpcOpenContext(
        context: *mut httpcContext,
        method: HTTPC_RequestMethod,
        url: *const ::libc::c_char,
        use_defaultproxy: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Closes a HTTP context.\n # Arguments\n\n* `context` - Context to close."]
    pub fn httpcCloseContext(context: *mut httpcContext) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Cancels a HTTP connection.\n # Arguments\n\n* `context` - Context to close."]
    pub fn httpcCancelConnection(context: *mut httpcContext) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Adds a request header field to a HTTP context.\n # Arguments\n\n* `context` - Context to use.\n * `name` - Name of the field.\n * `value` - Value of the field."]
    pub fn httpcAddRequestHeaderField(
        context: *mut httpcContext,
        name: *const ::libc::c_char,
        value: *const ::libc::c_char,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Adds a POST form field to a HTTP context.\n # Arguments\n\n* `context` - Context to use.\n * `name` - Name of the field.\n * `value` - Value of the field."]
    pub fn httpcAddPostDataAscii(
        context: *mut httpcContext,
        name: *const ::libc::c_char,
        value: *const ::libc::c_char,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Adds a POST form field with binary data to a HTTP context.\n # Arguments\n\n* `context` - Context to use.\n * `name` - Name of the field.\n * `value` - The binary data to pass as a value.\n * `len` - Length of the binary data which has been passed."]
    pub fn httpcAddPostDataBinary(
        context: *mut httpcContext,
        name: *const ::libc::c_char,
        value: *const u8_,
        len: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Adds a POST body to a HTTP context.\n # Arguments\n\n* `context` - Context to use.\n * `data` - The data to be passed as raw into the body of the post request.\n * `len` - Length of data passed by data param."]
    pub fn httpcAddPostDataRaw(context: *mut httpcContext, data: *const u32_, len: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Begins a HTTP request.\n # Arguments\n\n* `context` - Context to use."]
    pub fn httpcBeginRequest(context: *mut httpcContext) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Receives data from a HTTP context.\n # Arguments\n\n* `context` - Context to use.\n * `buffer` - Buffer to receive data to.\n * `size` - Size of the buffer."]
    pub fn httpcReceiveData(context: *mut httpcContext, buffer: *mut u8_, size: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Receives data from a HTTP context with a timeout value.\n # Arguments\n\n* `context` - Context to use.\n * `buffer` - Buffer to receive data to.\n * `size` - Size of the buffer.\n * `timeout` - Maximum time in nanoseconds to wait for a reply."]
    pub fn httpcReceiveDataTimeout(
        context: *mut httpcContext,
        buffer: *mut u8_,
        size: u32_,
        timeout: u64_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the request state of a HTTP context.\n # Arguments\n\n* `context` - Context to use.\n * `out` - Pointer to output the HTTP request state to."]
    pub fn httpcGetRequestState(
        context: *mut httpcContext,
        out: *mut HTTPC_RequestStatus,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the download size state of a HTTP context.\n # Arguments\n\n* `context` - Context to use.\n * `downloadedsize` - Pointer to output the downloaded size to.\n * `contentsize` - Pointer to output the total content size to."]
    pub fn httpcGetDownloadSizeState(
        context: *mut httpcContext,
        downloadedsize: *mut u32_,
        contentsize: *mut u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the response code of the HTTP context.\n # Arguments\n\n* `context` - Context to get the response code of.\n * `out` - Pointer to write the response code to."]
    pub fn httpcGetResponseStatusCode(context: *mut httpcContext, out: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the response code of the HTTP context with a timeout value.\n # Arguments\n\n* `context` - Context to get the response code of.\n * `out` - Pointer to write the response code to.\n * `timeout` - Maximum time in nanoseconds to wait for a reply."]
    pub fn httpcGetResponseStatusCodeTimeout(
        context: *mut httpcContext,
        out: *mut u32_,
        timeout: u64_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets a response header field from a HTTP context.\n # Arguments\n\n* `context` - Context to use.\n * `name` - Name of the field.\n * `value` - Pointer to output the value of the field to.\n * `valuebuf_maxsize` - Maximum size of the value buffer."]
    pub fn httpcGetResponseHeader(
        context: *mut httpcContext,
        name: *const ::libc::c_char,
        value: *mut ::libc::c_char,
        valuebuf_maxsize: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Adds a trusted RootCA cert to a HTTP context.\n # Arguments\n\n* `context` - Context to use.\n * `cert` - Pointer to DER cert.\n * `certsize` - Size of the DER cert."]
    pub fn httpcAddTrustedRootCA(
        context: *mut httpcContext,
        cert: *const u8_,
        certsize: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Adds a default RootCA cert to a HTTP context.\n # Arguments\n\n* `context` - Context to use.\n * `certID` - ID of the cert to add, see sslc.h."]
    pub fn httpcAddDefaultCert(context: *mut httpcContext, certID: SSLC_DefaultRootCert) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the RootCertChain for a HTTP context.\n # Arguments\n\n* `context` - Context to use.\n * `RootCertChain_contexthandle` - Contexthandle for the RootCertChain."]
    pub fn httpcSelectRootCertChain(
        context: *mut httpcContext,
        RootCertChain_contexthandle: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the ClientCert for a HTTP context.\n # Arguments\n\n* `context` - Context to use.\n * `cert` - Pointer to DER cert.\n * `certsize` - Size of the DER cert.\n * `privk` - Pointer to the DER private key.\n * `privk_size` - Size of the privk."]
    pub fn httpcSetClientCert(
        context: *mut httpcContext,
        cert: *const u8_,
        certsize: u32_,
        privk: *const u8_,
        privk_size: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the default clientcert for a HTTP context.\n # Arguments\n\n* `context` - Context to use.\n * `certID` - ID of the cert to add, see sslc.h."]
    pub fn httpcSetClientCertDefault(
        context: *mut httpcContext,
        certID: SSLC_DefaultClientCert,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the ClientCert contexthandle for a HTTP context.\n # Arguments\n\n* `context` - Context to use.\n * `ClientCert_contexthandle` - Contexthandle for the ClientCert."]
    pub fn httpcSetClientCertContext(
        context: *mut httpcContext,
        ClientCert_contexthandle: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets SSL options for the context.\n The HTTPC SSL option bits are the same as those defined in sslc.h\n # Arguments\n\n* `context` - Context to set flags on.\n * `options` - SSL option flags."]
    pub fn httpcSetSSLOpt(context: *mut httpcContext, options: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the SSL options which will be cleared for the context.\n The HTTPC SSL option bits are the same as those defined in sslc.h\n # Arguments\n\n* `context` - Context to clear flags on.\n * `options` - SSL option flags."]
    pub fn httpcSetSSLClearOpt(context: *mut httpcContext, options: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Creates a RootCertChain. Up to 2 RootCertChains can be created under this user-process.\n # Arguments\n\n* `RootCertChain_contexthandle` - Output RootCertChain contexthandle."]
    pub fn httpcCreateRootCertChain(RootCertChain_contexthandle: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Destroy a RootCertChain.\n # Arguments\n\n* `RootCertChain_contexthandle` - RootCertChain to use."]
    pub fn httpcDestroyRootCertChain(RootCertChain_contexthandle: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Adds a RootCA cert to a RootCertChain.\n # Arguments\n\n* `RootCertChain_contexthandle` - RootCertChain to use.\n * `cert` - Pointer to DER cert.\n * `certsize` - Size of the DER cert.\n * `cert_contexthandle` - Optional output ptr for the cert contexthandle(this can be NULL)."]
    pub fn httpcRootCertChainAddCert(
        RootCertChain_contexthandle: u32_,
        cert: *const u8_,
        certsize: u32_,
        cert_contexthandle: *mut u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Adds a default RootCA cert to a RootCertChain.\n # Arguments\n\n* `RootCertChain_contexthandle` - RootCertChain to use.\n * `certID` - ID of the cert to add, see sslc.h.\n * `cert_contexthandle` - Optional output ptr for the cert contexthandle(this can be NULL)."]
    pub fn httpcRootCertChainAddDefaultCert(
        RootCertChain_contexthandle: u32_,
        certID: SSLC_DefaultRootCert,
        cert_contexthandle: *mut u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Removes a cert from a RootCertChain.\n # Arguments\n\n* `RootCertChain_contexthandle` - RootCertChain to use.\n * `cert_contexthandle` - Contexthandle of the cert to remove."]
    pub fn httpcRootCertChainRemoveCert(
        RootCertChain_contexthandle: u32_,
        cert_contexthandle: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Opens a ClientCert-context. Up to 2 ClientCert-contexts can be open under this user-process.\n # Arguments\n\n* `cert` - Pointer to DER cert.\n * `certsize` - Size of the DER cert.\n * `privk` - Pointer to the DER private key.\n * `privk_size` - Size of the privk.\n * `ClientCert_contexthandle` - Output ClientCert context handle."]
    pub fn httpcOpenClientCertContext(
        cert: *const u8_,
        certsize: u32_,
        privk: *const u8_,
        privk_size: u32_,
        ClientCert_contexthandle: *mut u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Opens a ClientCert-context with a default clientclient. Up to 2 ClientCert-contexts can be open under this user-process.\n # Arguments\n\n* `certID` - ID of the cert to add, see sslc.h.\n * `ClientCert_contexthandle` - Output ClientCert context handle."]
    pub fn httpcOpenDefaultClientCertContext(
        certID: SSLC_DefaultClientCert,
        ClientCert_contexthandle: *mut u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Closes a ClientCert context.\n # Arguments\n\n* `ClientCert_contexthandle` - ClientCert context to use."]
    pub fn httpcCloseClientCertContext(ClientCert_contexthandle: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Downloads data from the HTTP context into a buffer.\n The *entire* content must be downloaded before using httpcCloseContext(), otherwise httpcCloseContext() will hang.\n # Arguments\n\n* `context` - Context to download data from.\n * `buffer` - Buffer to write data to.\n * `size` - Size of the buffer.\n * `downloadedsize` - Pointer to write the size of the downloaded data to."]
    pub fn httpcDownloadData(
        context: *mut httpcContext,
        buffer: *mut u8_,
        size: u32_,
        downloadedsize: *mut u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets Keep-Alive for the context.\n # Arguments\n\n* `context` - Context to set the KeepAlive flag on.\n * `option` - HTTPC_KeepAlive option."]
    pub fn httpcSetKeepAlive(context: *mut httpcContext, option: HTTPC_KeepAlive) -> Result;
}
#[doc = "Node info struct."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct udsNodeInfo {
    pub uds_friendcodeseed: u64_,
    pub __bindgen_anon_1: udsNodeInfo__bindgen_ty_1,
    pub NetworkNodeID: u16_,
    pub pad_x22: u16_,
    pub word_x24: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union udsNodeInfo__bindgen_ty_1 {
    pub usercfg: [u8_; 24usize],
    pub __bindgen_anon_1: udsNodeInfo__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct udsNodeInfo__bindgen_ty_1__bindgen_ty_1 {
    pub username: [u16_; 10usize],
    pub unk_x1c: u16_,
    pub flag: u8_,
    pub pad_x1f: u8_,
}
impl Default for udsNodeInfo__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for udsNodeInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Connection status struct."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct udsConnectionStatus {
    pub status: u32_,
    pub unk_x4: u32_,
    pub cur_NetworkNodeID: u16_,
    pub unk_xa: u16_,
    pub unk_xc: [u32_; 8usize],
    pub total_nodes: u8_,
    pub max_nodes: u8_,
    pub node_bitmask: u16_,
}
#[doc = "Network struct stored as big-endian."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct udsNetworkStruct {
    pub host_macaddress: [u8_; 6usize],
    pub channel: u8_,
    pub pad_x7: u8_,
    pub initialized_flag: u8_,
    pub unk_x9: [u8_; 3usize],
    pub oui_value: [u8_; 3usize],
    pub oui_type: u8_,
    pub wlancommID: u32_,
    pub id8: u8_,
    pub unk_x15: u8_,
    pub attributes: u16_,
    pub networkID: u32_,
    pub total_nodes: u8_,
    pub max_nodes: u8_,
    pub unk_x1e: u8_,
    pub unk_x1f: u8_,
    pub unk_x20: [u8_; 31usize],
    pub appdata_size: u8_,
    pub appdata: [u8_; 200usize],
}
impl Default for udsNetworkStruct {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct udsBindContext {
    pub BindNodeID: u32_,
    pub event: Handle,
    pub spectator: bool,
}
#[doc = "General NWM input structure used for AP scanning."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nwmScanInputStruct {
    pub unk_x0: u16_,
    pub unk_x2: u16_,
    pub unk_x4: u16_,
    pub unk_x6: u16_,
    pub mac_address: [u8_; 6usize],
    pub unk_xe: [u8_; 38usize],
}
impl Default for nwmScanInputStruct {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "General NWM output structure from AP scanning."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nwmBeaconDataReplyHeader {
    pub maxsize: u32_,
    pub size: u32_,
    pub total_entries: u32_,
}
#[doc = "General NWM output structure from AP scanning, for each entry."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct nwmBeaconDataReplyEntry {
    pub size: u32_,
    pub unk_x4: u8_,
    pub channel: u8_,
    pub unk_x6: u8_,
    pub unk_x7: u8_,
    pub mac_address: [u8_; 6usize],
    pub unk_xe: [u8_; 6usize],
    pub unk_x14: u32_,
    pub val_x1c: u32_,
}
#[doc = "Output structure generated from host scanning output."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct udsNetworkScanInfo {
    pub datareply_entry: nwmBeaconDataReplyEntry,
    pub network: udsNetworkStruct,
    pub nodes: [udsNodeInfo; 16usize],
}
impl Default for udsNetworkScanInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub const UDSNETATTR_DisableConnectSpectators: _bindgen_ty_24 = 1;
pub const UDSNETATTR_DisableConnectClients: _bindgen_ty_24 = 2;
pub const UDSNETATTR_x4: _bindgen_ty_24 = 4;
pub const UDSNETATTR_Default: _bindgen_ty_24 = 32768;
pub type _bindgen_ty_24 = ::libc::c_uint;
pub const UDS_SENDFLAG_Default: _bindgen_ty_25 = 1;
pub const UDS_SENDFLAG_Broadcast: _bindgen_ty_25 = 2;
pub type _bindgen_ty_25 = ::libc::c_uint;
pub const UDSCONTYPE_Client: udsConnectionType = 1;
pub const UDSCONTYPE_Spectator: udsConnectionType = 2;
pub type udsConnectionType = ::libc::c_uint;
extern "C" {
    #[must_use]
    #[doc = "Initializes UDS.\n # Arguments\n\n* `sharedmem_size` - This must be 0x1000-byte aligned.\n * `username` - Optional custom UTF-8 username(converted to UTF-16 internally) that other nodes on the UDS network can use. If not set the username from system-config is used. Max len is 10 characters without NUL-terminator."]
    pub fn udsInit(sharedmem_size: usize, username: *const ::libc::c_char) -> Result;
}
extern "C" {
    #[doc = "Exits UDS."]
    pub fn udsExit();
}
extern "C" {
    #[must_use]
    #[doc = "Generates a NodeInfo struct with data loaded from system-config.\n # Arguments\n\n* `nodeinfo` - Output NodeInfo struct.\n * `username` - If set, this is the UTF-8 string to convert for use in the struct. Max len is 10 characters without NUL-terminator."]
    pub fn udsGenerateNodeInfo(
        nodeinfo: *mut udsNodeInfo,
        username: *const ::libc::c_char,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Loads the UTF-16 username stored in the input NodeInfo struct, converted to UTF-8.\n # Arguments\n\n* `nodeinfo` - Input NodeInfo struct.\n * `username` - This is the output UTF-8 string. Max len is 10 characters without NUL-terminator."]
    pub fn udsGetNodeInfoUsername(
        nodeinfo: *const udsNodeInfo,
        username: *mut ::libc::c_char,
    ) -> Result;
}
extern "C" {
    #[doc = "Checks whether a NodeInfo struct was initialized by NWM-module(not any output from udsGenerateNodeInfo()).\n # Arguments\n\n* `nodeinfo` - Input NodeInfo struct."]
    pub fn udsCheckNodeInfoInitialized(nodeinfo: *const udsNodeInfo) -> bool;
}
extern "C" {
    #[doc = "Generates a default NetworkStruct for creating networks.\n # Arguments\n\n* `network` - The output struct.\n * `wlancommID` - Unique local-WLAN communications ID for each application.\n * `id8` - Additional ID that can be used by the application for different types of networks.\n * `max_nodes` - Maximum number of nodes(devices) that can be connected to the network, including the host."]
    pub fn udsGenerateDefaultNetworkStruct(
        network: *mut udsNetworkStruct,
        wlancommID: u32_,
        id8: u8_,
        max_nodes: u8_,
    );
}
extern "C" {
    #[must_use]
    #[doc = "Scans for networks via beacon-scanning.\n # Arguments\n\n* `outbuf` - Buffer which will be used by the beacon-scanning command and for the data parsing afterwards. Normally there's no need to use the contents of this buffer once this function returns.\n * `maxsize` - Max size of the buffer.\n networks Ptr where the allocated udsNetworkScanInfo array buffer is written. The allocsize is sizeof(udsNetworkScanInfo)*total_networks.\n total_networks Total number of networks stored under the networks buffer.\n * `wlancommID` - Unique local-WLAN communications ID for each application.\n * `id8` - Additional ID that can be used by the application for different types of networks.\n * `host_macaddress` - When set, this code will only return network info from the specified host MAC address.\n When not connected to a network this *must* be false. When connected to a network this *must* be true."]
    pub fn udsScanBeacons(
        outbuf: *mut ::libc::c_void,
        maxsize: usize,
        networks: *mut *mut udsNetworkScanInfo,
        total_networks: *mut usize,
        wlancommID: u32_,
        id8: u8_,
        host_macaddress: *const u8_,
        connected: bool,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "This can be used by the host to set the appdata contained in the broadcasted beacons.\n # Arguments\n\n* `buf` - Appdata buffer.\n * `size` - Size of the input appdata."]
    pub fn udsSetApplicationData(buf: *const ::libc::c_void, size: usize) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "This can be used while on a network(host/client) to get the appdata from the current beacon.\n # Arguments\n\n* `buf` - Appdata buffer.\n * `size` - Max size of the output buffer.\n * `actual_size` - If set, the actual size of the appdata written into the buffer is stored here."]
    pub fn udsGetApplicationData(
        buf: *mut ::libc::c_void,
        size: usize,
        actual_size: *mut usize,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "This can be used with a NetworkStruct, from udsScanBeacons() mainly, for getting the appdata.\n # Arguments\n\n* `buf` - Appdata buffer.\n * `size` - Max size of the output buffer.\n * `actual_size` - If set, the actual size of the appdata written into the buffer is stored here."]
    pub fn udsGetNetworkStructApplicationData(
        network: *const udsNetworkStruct,
        buf: *mut ::libc::c_void,
        size: usize,
        actual_size: *mut usize,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Create a bind.\n # Arguments\n\n* `bindcontext` - The output bind context.\n * `NetworkNodeID` - This is the NetworkNodeID which this bind can receive data from.\n * `spectator` - False for a regular bind, true for a spectator.\n * `data_channel` - This is an arbitrary value to use for data-frame filtering. This bind will only receive data frames which contain a matching data_channel value, which was specified by udsSendTo(). The data_channel must be non-zero.\n * `recv_buffer_size` - Size of the buffer under sharedmem used for temporarily storing received data-frames which are then loaded by udsPullPacket(). The system requires this to be >=0x5F4. UDS_DEFAULT_RECVBUFSIZE can be used for this."]
    pub fn udsBind(
        bindcontext: *mut udsBindContext,
        NetworkNodeID: u16_,
        spectator: bool,
        data_channel: u8_,
        recv_buffer_size: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Remove a bind.\n # Arguments\n\n* `bindcontext` - The bind context."]
    pub fn udsUnbind(bindcontext: *mut udsBindContext) -> Result;
}
extern "C" {
    #[doc = "Waits for the bind event to occur, or checks if the event was signaled. This event is signaled every time new data is available via udsPullPacket().\n # Returns\n\nAlways true. However if wait=false, this will return false if the event wasn't signaled.\n # Arguments\n\n* `bindcontext` - The bind context.\n * `nextEvent` - Whether to discard the current event and wait for the next event.\n * `wait` - When true this will not return until the event is signaled. When false this checks if the event was signaled without waiting for it."]
    pub fn udsWaitDataAvailable(
        bindcontext: *const udsBindContext,
        nextEvent: bool,
        wait: bool,
    ) -> bool;
}
extern "C" {
    #[must_use]
    #[doc = "Receives data over the network. This data is loaded from the recv_buffer setup by udsBind(). When a node disconnects, this will still return data from that node until there's no more frames from that node in the recv_buffer.\n # Arguments\n\n* `bindcontext` - Bind context.\n * `buf` - Output receive buffer.\n * `size` - Size of the buffer.\n * `actual_size` - If set, the actual size written into the output buffer is stored here. This is zero when no data was received.\n * `src_NetworkNodeID` - If set, the source NetworkNodeID is written here. This is zero when no data was received."]
    pub fn udsPullPacket(
        bindcontext: *const udsBindContext,
        buf: *mut ::libc::c_void,
        size: usize,
        actual_size: *mut usize,
        src_NetworkNodeID: *mut u16_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sends data over the network.\n # Arguments\n\n* `dst_NetworkNodeID` - Destination NetworkNodeID.\n * `data_channel` - See udsBind().\n * `flags` - Send flags, see the UDS_SENDFLAG enum values.\n * `buf` - Input send buffer.\n * `size` - Size of the buffer."]
    pub fn udsSendTo(
        dst_NetworkNodeID: u16_,
        data_channel: u8_,
        flags: u8_,
        buf: *const ::libc::c_void,
        size: usize,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the wifi channel currently being used.\n # Arguments\n\n* `channel` - Output channel."]
    pub fn udsGetChannel(channel: *mut u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Starts hosting a new network.\n # Arguments\n\n* `network` - The NetworkStruct, you can use udsGenerateDefaultNetworkStruct() for generating this.\n * `passphrase` - Raw input passphrase buffer.\n * `passphrase_size` - Size of the passphrase buffer.\n * `context` - Optional output bind context which will be created for this host, with NetworkNodeID=UDS_BROADCAST_NETWORKNODEID.\n * `data_channel` - This is the data_channel value which will be passed to udsBind() internally.\n * `recv_buffer_size` - This is the recv_buffer_size value which will be passed to udsBind() internally."]
    pub fn udsCreateNetwork(
        network: *const udsNetworkStruct,
        passphrase: *const ::libc::c_void,
        passphrase_size: usize,
        context: *mut udsBindContext,
        data_channel: u8_,
        recv_buffer_size: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Connect to a network.\n # Arguments\n\n* `network` - The NetworkStruct, you can use udsScanBeacons() for this.\n * `passphrase` - Raw input passphrase buffer.\n * `passphrase_size` - Size of the passphrase buffer.\n * `context` - Optional output bind context which will be created for this host.\n * `recv_NetworkNodeID` - This is the NetworkNodeID passed to udsBind() internally.\n * `connection_type` - Type of connection, see the udsConnectionType enum values.\n * `data_channel` - This is the data_channel value which will be passed to udsBind() internally.\n * `recv_buffer_size` - This is the recv_buffer_size value which will be passed to udsBind() internally."]
    pub fn udsConnectNetwork(
        network: *const udsNetworkStruct,
        passphrase: *const ::libc::c_void,
        passphrase_size: usize,
        context: *mut udsBindContext,
        recv_NetworkNodeID: u16_,
        connection_type: udsConnectionType,
        data_channel: u8_,
        recv_buffer_size: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Stop hosting the network."]
    pub fn udsDestroyNetwork() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Disconnect this client device from the network."]
    pub fn udsDisconnectNetwork() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "This can be used by the host to force-disconnect client(s).\n # Arguments\n\n* `NetworkNodeID` - Target NetworkNodeID. UDS_BROADCAST_NETWORKNODEID can be used to disconnect all clients."]
    pub fn udsEjectClient(NetworkNodeID: u16_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "This can be used by the host to force-disconnect the spectators. Afterwards new spectators will not be allowed to connect until udsAllowSpectators() is used."]
    pub fn udsEjectSpectator() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "This can be used by the host to update the network attributes. If bitmask 0x4 is clear in the input bitmask, this clears that bit in the value before actually writing the value into state. Normally you should use the below wrapper functions.\n # Arguments\n\n* `bitmask` - Bitmask to clear/set in the attributes. See the UDSNETATTR enum values.\n * `flag` - When false, bit-clear, otherwise bit-set."]
    pub fn udsUpdateNetworkAttribute(bitmask: u16_, flag: bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "This uses udsUpdateNetworkAttribute() for (un)blocking new connections to this host.\n # Arguments\n\n* `block` - When true, block the specified connection types(bitmask set). Otherwise allow them(bitmask clear).\n * `clients` - When true, (un)block regular clients.\n * `flag` - When true, update UDSNETATTR_x4. Normally this should be false."]
    pub fn udsSetNewConnectionsBlocked(block: bool, clients: bool, flag: bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "This uses udsUpdateNetworkAttribute() for unblocking new spectator connections to this host. See udsEjectSpectator() for blocking new spectators."]
    pub fn udsAllowSpectators() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "This loads the current ConnectionStatus struct.\n # Arguments\n\n* `output` - Output ConnectionStatus struct."]
    pub fn udsGetConnectionStatus(output: *mut udsConnectionStatus) -> Result;
}
extern "C" {
    #[doc = "Waits for the ConnectionStatus event to occur, or checks if the event was signaled. This event is signaled when the data from udsGetConnectionStatus() was updated internally.\n # Returns\n\nAlways true. However if wait=false, this will return false if the event wasn't signaled.\n # Arguments\n\n* `nextEvent` - Whether to discard the current event and wait for the next event.\n * `wait` - When true this will not return until the event is signaled. When false this checks if the event was signaled without waiting for it."]
    pub fn udsWaitConnectionStatusEvent(nextEvent: bool, wait: bool) -> bool;
}
extern "C" {
    #[must_use]
    #[doc = "This loads a NodeInfo struct for the specified NetworkNodeID. The broadcast alias can't be used with this.\n # Arguments\n\n* `NetworkNodeID` - Target NetworkNodeID.\n * `output` - Output NodeInfo struct."]
    pub fn udsGetNodeInformation(NetworkNodeID: u16_, output: *mut udsNodeInfo) -> Result;
}
pub const NDM_EXCLUSIVE_STATE_NONE: ndmExclusiveState = 0;
pub const NDM_EXCLUSIVE_STATE_INFRASTRUCTURE: ndmExclusiveState = 1;
pub const NDM_EXCLUSIVE_STATE_LOCAL_COMMUNICATIONS: ndmExclusiveState = 2;
pub const NDM_EXCLUSIVE_STATE_STREETPASS: ndmExclusiveState = 3;
pub const NDM_EXCLUSIVE_STATE_STREETPASS_DATA: ndmExclusiveState = 4;
#[doc = "Exclusive states."]
pub type ndmExclusiveState = ::libc::c_uint;
pub const NDM_STATE_INITIAL: ndmState = 0;
pub const NDM_STATE_SUSPENDED: ndmState = 1;
pub const NDM_STATE_INFRASTRUCTURE_CONNECTING: ndmState = 2;
pub const NDM_STATE_INFRASTRUCTURE_CONNECTED: ndmState = 3;
pub const NDM_STATE_INFRASTRUCTURE_WORKING: ndmState = 4;
pub const NDM_STATE_INFRASTRUCTURE_SUSPENDING: ndmState = 5;
pub const NDM_STATE_INFRASTRUCTURE_FORCE_SUSPENDING: ndmState = 6;
pub const NDM_STATE_INFRASTRUCTURE_DISCONNECTING: ndmState = 7;
pub const NDM_STATE_INFRASTRUCTURE_FORCE_DISCONNECTING: ndmState = 8;
pub const NDM_STATE_CEC_WORKING: ndmState = 9;
pub const NDM_STATE_CEC_FORCE_SUSPENDING: ndmState = 10;
pub const NDM_STATE_CEC_SUSPENDING: ndmState = 11;
#[doc = "Current states."]
pub type ndmState = ::libc::c_uint;
pub const NDM_DAEMON_CEC: ndmDaemon = 0;
pub const NDM_DAEMON_BOSS: ndmDaemon = 1;
pub const NDM_DAEMON_NIM: ndmDaemon = 2;
pub const NDM_DAEMON_FRIENDS: ndmDaemon = 3;
pub type ndmDaemon = ::libc::c_uint;
pub const NDM_DAEMON_MASK_CEC: ndmDaemonMask = 1;
pub const NDM_DAEMON_MASK_BOSS: ndmDaemonMask = 2;
pub const NDM_DAEMON_MASK_NIM: ndmDaemonMask = 4;
pub const NDM_DAEMON_MASK_FRIENDS: ndmDaemonMask = 8;
pub const NDM_DAEMON_MASK_BACKGROUOND: ndmDaemonMask = 7;
pub const NDM_DAEMON_MASK_ALL: ndmDaemonMask = 15;
pub const NDM_DAEMON_MASK_DEFAULT: ndmDaemonMask = 9;
#[doc = "Used to specify multiple daemons."]
pub type ndmDaemonMask = ::libc::c_uint;
pub const NDM_DAEMON_STATUS_BUSY: ndmDaemonStatus = 0;
pub const NDM_DAEMON_STATUS_IDLE: ndmDaemonStatus = 1;
pub const NDM_DAEMON_STATUS_SUSPENDING: ndmDaemonStatus = 2;
pub const NDM_DAEMON_STATUS_SUSPENDED: ndmDaemonStatus = 3;
pub type ndmDaemonStatus = ::libc::c_uint;
extern "C" {
    #[must_use]
    #[doc = "Initializes ndmu."]
    pub fn ndmuInit() -> Result;
}
extern "C" {
    #[doc = "Exits ndmu."]
    pub fn ndmuExit();
}
extern "C" {
    #[must_use]
    #[doc = "Sets the network daemon to an exclusive state.\n # Arguments\n\n* `state` - State specified in the ndmExclusiveState enumerator."]
    pub fn NDMU_EnterExclusiveState(state: ndmExclusiveState) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Cancels an exclusive state for the network daemon."]
    pub fn NDMU_LeaveExclusiveState() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Returns the exclusive state for the network daemon.\n # Arguments\n\n* `state` - Pointer to write the exclsuive state to."]
    pub fn NDMU_GetExclusiveState(state: *mut ndmExclusiveState) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Locks the exclusive state."]
    pub fn NDMU_LockState() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Unlocks the exclusive state."]
    pub fn NDMU_UnlockState() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Suspends network daemon.\n # Arguments\n\n* `mask` - The specified daemon."]
    pub fn NDMU_SuspendDaemons(mask: ndmDaemonMask) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Resumes network daemon.\n # Arguments\n\n* `mask` - The specified daemon."]
    pub fn NDMU_ResumeDaemons(mask: ndmDaemonMask) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Suspends scheduling for all network daemons.\n # Arguments\n\n* `flag` - 0 = Wait for completion, 1 = Perform in background."]
    pub fn NDMU_SuspendScheduler(flag: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Resumes daemon scheduling."]
    pub fn NDMU_ResumeScheduler() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Returns the current state for the network daemon.\n # Arguments\n\n* `state` - Pointer to write the current state to."]
    pub fn NDMU_GetCurrentState(state: *mut ndmState) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Returns the daemon state.\n # Arguments\n\n* `state` - Pointer to write the daemons state to."]
    pub fn NDMU_QueryStatus(status: *mut ndmDaemonStatus) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the scan interval.\n # Arguments\n\n* `interval` - Value to set the scan interval to."]
    pub fn NDMU_SetScanInterval(interval: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Returns the scan interval.\n # Arguments\n\n* `interval` - Pointer to write the interval value to."]
    pub fn NDMU_GetScanInterval(interval: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Returns the retry interval.\n # Arguments\n\n* `interval` - Pointer to write the interval value to."]
    pub fn NDMU_GetRetryInterval(interval: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Reverts network daemon to defaults."]
    pub fn NDMU_ResetDaemons() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the current default daemon bit mask.\n # Arguments\n\n* `interval` - Pointer to write the default daemon mask value to. The default value is (DAEMONMASK_CEC | DAEMONMASK_FRIENDS)"]
    pub fn NDMU_GetDefaultDaemons(mask: *mut ndmDaemonMask) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Clears half awake mac filter."]
    pub fn NDMU_ClearMacFilter() -> Result;
}
#[doc = "< Initial installation"]
pub const IM_DEFAULT: NIM_InstallationMode = 0;
#[doc = "< Unknown"]
pub const IM_UNKNOWN1: NIM_InstallationMode = 1;
#[doc = "< Unknown"]
pub const IM_UNKNOWN2: NIM_InstallationMode = 2;
#[doc = "< Reinstall currently installed title; use this if the title is already installed (including updates)"]
pub const IM_REINSTALL: NIM_InstallationMode = 3;
#[doc = "Mode that NIM downloads/installs a title with."]
pub type NIM_InstallationMode = ::libc::c_uint;
#[doc = "< Download not yet initialized"]
pub const DS_NOT_INITIALIZED: NIM_DownloadState = 0;
#[doc = "< Download initialized"]
pub const DS_INITIALIZED: NIM_DownloadState = 1;
#[doc = "< Downloading and installing TMD"]
pub const DS_DOWNLOAD_TMD: NIM_DownloadState = 2;
#[doc = "< Initializing save data"]
pub const DS_PREPARE_SAVE_DATA: NIM_DownloadState = 3;
#[doc = "< Downloading and installing contents"]
pub const DS_DOWNLOAD_CONTENTS: NIM_DownloadState = 4;
#[doc = "< Waiting before calling AM_CommitImportTitles"]
pub const DS_WAIT_COMMIT: NIM_DownloadState = 5;
#[doc = "< Running AM_CommitImportTitles"]
pub const DS_COMMITTING: NIM_DownloadState = 6;
#[doc = "< Title installation finished"]
pub const DS_FINISHED: NIM_DownloadState = 7;
#[doc = "< (unknown error regarding title version)"]
pub const DS_VERSION_ERROR: NIM_DownloadState = 8;
#[doc = "< Creating the .ctx file?"]
pub const DS_CREATE_CONTEXT: NIM_DownloadState = 9;
#[doc = "< Irrecoverable error encountered (e.g. out of space)"]
pub const DS_CANNOT_RECOVER: NIM_DownloadState = 10;
#[doc = "< Invalid state"]
pub const DS_INVALID: NIM_DownloadState = 11;
#[doc = "Current state of a NIM download/installation."]
pub type NIM_DownloadState = ::libc::c_uint;
#[doc = "Input configuration for NIM download/installation tasks."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NIM_TitleConfig {
    #[doc = "< Title ID"]
    pub titleId: u64_,
    #[doc = "< Title version"]
    pub version: u32_,
    #[doc = "< Always 0"]
    pub unknown_0: u32_,
    #[doc = "< Age for the HOME Menu parental controls"]
    pub ratingAge: u8_,
    #[doc = "< Media type, see FS_MediaType enum"]
    pub mediaType: u8_,
    #[doc = "< Padding"]
    pub padding: [u8_; 2usize],
    #[doc = "< Unknown input, seems to be always 0"]
    pub unknown_1: u32_,
}
#[doc = "Output struct for NIM downloads/installations in progress."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NIM_TitleProgress {
    #[doc = "< State, see NIM_DownloadState enum"]
    pub state: u32_,
    #[doc = "< Last result code in NIM"]
    pub lastResult: Result,
    #[doc = "< Amount of bytes that have been downloaded"]
    pub downloadedSize: u64_,
    #[doc = "< Amount of bytes that need to be downloaded in total"]
    pub totalSize: u64_,
}
extern "C" {
    #[must_use]
    #[doc = "Initializes nim:s. This uses networking and is blocking.\n # Arguments\n\n* `buffer` - A buffer for internal use. It must be at least 0x20000 bytes long.\n * `buffer_len` - Length of the passed buffer."]
    pub fn nimsInit(buffer: *mut ::libc::c_void, buffer_len: usize) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initializes nim:s with the given TIN. This uses networking and is blocking.\n # Arguments\n\n* `buffer` - A buffer for internal use. It must be at least 0x20000 bytes long.\n * `buffer_len` - Length of the passed buffer.\n * `TIN` - The TIN to initialize nim:s with. If you do not know what a TIN is or why you would want to change it, use nimsInit instead."]
    pub fn nimsInitWithTIN(
        buffer: *mut ::libc::c_void,
        buffer_len: usize,
        TIN: *const ::libc::c_char,
    ) -> Result;
}
extern "C" {
    #[doc = "Exits nim:s."]
    pub fn nimsExit();
}
extern "C" {
    #[doc = "Gets the current nim:s session handle."]
    pub fn nimsGetSessionHandle() -> *mut Handle;
}
extern "C" {
    #[must_use]
    #[doc = "Sets an attribute.\n # Arguments\n\n* `attr` - Name of the attribute.\n * `val` - Value of the attribute."]
    pub fn NIMS_SetAttribute(attr: *const ::libc::c_char, val: *const ::libc::c_char) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Checks if nim wants a system update.\n # Arguments\n\n* `want_update` - Set to true if a system update is required. Can be NULL."]
    pub fn NIMS_WantUpdate(want_update: *mut bool) -> Result;
}
extern "C" {
    #[doc = "Makes a TitleConfig struct for use with NIMS_RegisterTask, NIMS_StartDownload or NIMS_StartDownloadSimple.\n # Arguments\n\n* `cfg` - Struct to initialize.\n * `titleId` - Title ID to download and install.\n * `version` - Version of the title to download and install.\n * `ratingAge` - Age for which the title is aged; used by parental controls in HOME Menu.\n * `mediaType` - Media type of the title to download and install."]
    pub fn NIMS_MakeTitleConfig(
        cfg: *mut NIM_TitleConfig,
        titleId: u64_,
        version: u32_,
        ratingAge: u8_,
        mediaType: FS_MediaType,
    );
}
extern "C" {
    #[must_use]
    #[doc = "Registers a background download task with NIM. These are processed in sleep mode only.\n # Arguments\n\n* `cfg` - Title config to use. See NIMS_MakeTitleConfig.\n * `name` - Name of the title in UTF-8. Will be displayed on the HOME Menu. Maximum 73 characters.\n * `maker` - Name of the maker/publisher in UTF-8. Will be displayed on the HOME Menu. Maximum 37 characters."]
    pub fn NIMS_RegisterTask(
        cfg: *const NIM_TitleConfig,
        name: *const ::libc::c_char,
        maker: *const ::libc::c_char,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Checks whether a background download task for the given title is registered with NIM.\n # Arguments\n\n* `titleId` - Title ID to check for.\n * `registered` - Whether there is a background download task registered."]
    pub fn NIMS_IsTaskRegistered(titleId: u64_, registered: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Unregisters a background download task.\n # Arguments\n\n* `titleId` - Title ID whose background download task to cancel."]
    pub fn NIMS_UnregisterTask(titleId: u64_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Starts an active download with NIM. Progress can be checked with NIMS_GetProcess. Do not exit the process while a download is in progress without calling NIMS_CancelDownload.\n # Arguments\n\n* `cfg` - Title config to use. See NIMS_MakeTitleConfig.\n * `mode` - The installation mode to use. See NIM_InstallationMode."]
    pub fn NIMS_StartDownload(cfg: *const NIM_TitleConfig, mode: NIM_InstallationMode) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Starts an active download with NIM with default installation mode; cannot reinstall titles. Progress can be checked with NIMS_GetProcess. Do not exit the process while a download is in progress without calling NIMS_CancelDownload.\n # Arguments\n\n* `cfg` - Title config to use. See NIMS_MakeTitleConfig."]
    pub fn NIMS_StartDownloadSimple(cfg: *const NIM_TitleConfig) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Checks the status of the current active download.\n # Arguments\n\n* `tp` - Title progress struct to write to. See NIM_TitleProgress."]
    pub fn NIMS_GetProgress(tp: *mut NIM_TitleProgress) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Cancels the current active download with NIM."]
    pub fn NIMS_CancelDownload() -> Result;
}
extern "C" {
    #[must_use]
    pub fn nwmExtInit() -> Result;
}
extern "C" {
    pub fn nwmExtExit();
}
extern "C" {
    #[must_use]
    #[doc = "Turns wireless on or off.\n # Arguments\n\n* `enableWifi` - True enables it, false disables it."]
    pub fn NWMEXT_ControlWirelessEnabled(enableWifi: bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initializes IRU.\n The permissions for the specified memory is set to RO. This memory must be already mapped.\n # Arguments\n\n* `sharedmem_addr` - Address of the shared memory block to use.\n * `sharedmem_size` - Size of the shared memory block."]
    pub fn iruInit(sharedmem_addr: *mut u32_, sharedmem_size: u32_) -> Result;
}
extern "C" {
    #[doc = "Shuts down IRU."]
    pub fn iruExit();
}
extern "C" {
    #[doc = "Gets the IRU service handle.\n # Returns\n\nThe IRU service handle."]
    pub fn iruGetServHandle() -> Handle;
}
extern "C" {
    #[must_use]
    #[doc = "Sends IR data.\n # Arguments\n\n* `buf` - Buffer to send data from.\n * `size` - Size of the buffer.\n * `wait` - Whether to wait for the data to be sent."]
    pub fn iruSendData(buf: *mut u8_, size: u32_, wait: bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Receives IR data.\n # Arguments\n\n* `buf` - Buffer to receive data to.\n * `size` - Size of the buffer.\n * `flag` - Flags to receive data with.\n * `transfercount` - Pointer to output the number of bytes read to.\n * `wait` - Whether to wait for the data to be received."]
    pub fn iruRecvData(
        buf: *mut u8_,
        size: u32_,
        flag: u8_,
        transfercount: *mut u32_,
        wait: bool,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initializes the IR session."]
    pub fn IRU_Initialize() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Shuts down the IR session."]
    pub fn IRU_Shutdown() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Begins sending data.\n # Arguments\n\n* `buf` - Buffer to send.\n * `size` - Size of the buffer."]
    pub fn IRU_StartSendTransfer(buf: *mut u8_, size: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Waits for a send operation to complete."]
    pub fn IRU_WaitSendTransfer() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Begins receiving data.\n # Arguments\n\n* `size` - Size of the data to receive.\n * `flag` - Flags to use when receiving."]
    pub fn IRU_StartRecvTransfer(size: u32_, flag: u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Waits for a receive operation to complete.\n # Arguments\n\n* `transfercount` - Pointer to output the number of bytes read to."]
    pub fn IRU_WaitRecvTransfer(transfercount: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the IR bit rate.\n # Arguments\n\n* `value` - Bit rate to set."]
    pub fn IRU_SetBitRate(value: u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the IR bit rate.\n # Arguments\n\n* `out` - Pointer to write the bit rate to."]
    pub fn IRU_GetBitRate(out: *mut u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the IR LED state.\n # Arguments\n\n* `value` - IR LED state to set."]
    pub fn IRU_SetIRLEDState(value: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the IR LED state.\n # Arguments\n\n* `out` - Pointer to write the IR LED state to."]
    pub fn IRU_GetIRLEDRecvState(out: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets an event which is signaled once a send finishes.\n # Arguments\n\n* `out` - Pointer to write the event handle to."]
    pub fn IRU_GetSendFinishedEvent(out: *mut Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets an event which is signaled once a receive finishes.\n # Arguments\n\n* `out` - Pointer to write the event handle to."]
    pub fn IRU_GetRecvFinishedEvent(out: *mut Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initializes NS."]
    pub fn nsInit() -> Result;
}
extern "C" {
    #[doc = "Exits NS."]
    pub fn nsExit();
}
extern "C" {
    #[must_use]
    #[doc = "Launches a title and the required firmware (only if necessary).\n # Arguments\n\n* `titleid` - ID of the title to launch, 0 for gamecard, JPN System Settings' titleID for System Settings."]
    pub fn NS_LaunchFIRM(titleid: u64_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Launches a title.\n # Arguments\n\n* `titleid` - ID of the title to launch, or 0 for gamecard.\n * `launch_flags` - Flags used when launching the title.\n * `procid` - Pointer to write the process ID of the launched title to."]
    pub fn NS_LaunchTitle(titleid: u64_, launch_flags: u32_, procid: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Terminates the application from which this function is called"]
    pub fn NS_TerminateTitle() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Launches a title and the required firmware.\n # Arguments\n\n* `titleid` - ID of the title to launch, 0 for gamecard.\n * `flags` - Flags for firm-launch. bit0: require an application title-info structure in FIRM paramters to be specified via FIRM parameters. bit1: if clear, NS will check certain Configuration Memory fields."]
    pub fn NS_LaunchApplicationFIRM(titleid: u64_, flags: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Reboots to a title.\n # Arguments\n\n* `mediatype` - Mediatype of the title.\n * `titleid` - ID of the title to launch."]
    pub fn NS_RebootToTitle(mediatype: u8_, titleid: u64_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Terminates the process with the specified titleid.\n # Arguments\n\n* `titleid` - ID of the title to terminate.\n * `timeout` - Timeout in nanoseconds. Pass 0 if not required."]
    pub fn NS_TerminateProcessTID(titleid: u64_, timeout: u64_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Reboots the system"]
    pub fn NS_RebootSystem() -> Result;
}
pub const PMLAUNCHFLAG_NORMAL_APPLICATION: _bindgen_ty_26 = 1;
pub const PMLAUNCHFLAG_LOAD_DEPENDENCIES: _bindgen_ty_26 = 2;
pub const PMLAUNCHFLAG_NOTIFY_TERMINATION: _bindgen_ty_26 = 4;
pub const PMLAUNCHFLAG_QUEUE_DEBUG_APPLICATION: _bindgen_ty_26 = 8;
pub const PMLAUNCHFLAG_TERMINATION_NOTIFICATION_MASK: _bindgen_ty_26 = 240;
#[doc = "< Forces the usage of the O3DS system mode app memory setting even if N3DS system mode is not \"Legacy\". Dev4 and Dev5 not supported. N3DS only."]
pub const PMLAUNCHFLAG_FORCE_USE_O3DS_APP_MEM: _bindgen_ty_26 = 256;
#[doc = "< In conjunction with the above, forces the 96MB app memory setting. N3DS only."]
pub const PMLAUNCHFLAG_FORCE_USE_O3DS_MAX_APP_MEM: _bindgen_ty_26 = 512;
pub const PMLAUNCHFLAG_USE_UPDATE_TITLE: _bindgen_ty_26 = 65536;
#[doc = "Launch flags for PM launch commands."]
pub type _bindgen_ty_26 = ::libc::c_uint;
extern "C" {
    #[must_use]
    #[doc = "Initializes pm:app."]
    pub fn pmAppInit() -> Result;
}
extern "C" {
    #[doc = "Exits pm:app."]
    pub fn pmAppExit();
}
extern "C" {
    #[doc = "Gets the current pm:app session handle.\n # Returns\n\nThe current pm:app session handle."]
    pub fn pmAppGetSessionHandle() -> *mut Handle;
}
extern "C" {
    #[must_use]
    #[doc = "Launches a title.\n # Arguments\n\n* `programInfo` - Program information of the title.\n * `launchFlags` - Flags to launch the title with."]
    pub fn PMAPP_LaunchTitle(programInfo: *const FS_ProgramInfo, launchFlags: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Launches a title, applying patches.\n # Arguments\n\n* `programInfo` - Program information of the title.\n * `programInfoUpdate` - Program information of the update title.\n * `launchFlags` - Flags to launch the title with."]
    pub fn PMAPP_LaunchTitleUpdate(
        programInfo: *const FS_ProgramInfo,
        programInfoUpdate: *const FS_ProgramInfo,
        launchFlags: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets a title's ExHeader Arm11CoreInfo and SystemInfo flags.\n # Arguments\n\n* `outCoreInfo` (direction out) - Pointer to write the ExHeader Arm11CoreInfo to.\n * `outSiFlags` (direction out) - Pointer to write the ExHeader SystemInfo flags to.\n * `programInfo` - Program information of the title."]
    pub fn PMAPP_GetTitleExheaderFlags(
        outCoreInfo: *mut ExHeader_Arm11CoreInfo,
        outSiFlags: *mut ExHeader_SystemInfoFlags,
        programInfo: *const FS_ProgramInfo,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the current FIRM launch parameters.\n # Arguments\n\n* `size` - Size of the FIRM launch parameter buffer.\n * `in` - Buffer to retrieve the launch parameters from."]
    pub fn PMAPP_SetFIRMLaunchParams(size: u32_, in_: *const ::libc::c_void) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the current FIRM launch parameters.\n # Arguments\n\n* `size` - Size of the FIRM launch parameter buffer.\n * `out` (direction out) - Buffer to write the launch parameters to."]
    pub fn PMAPP_GetFIRMLaunchParams(out: *mut ::libc::c_void, size: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the current FIRM launch parameters.\n # Arguments\n\n* `firmTidLow` - Low Title ID of the FIRM title to launch.\n * `size` - Size of the FIRM launch parameter buffer.\n * `in` - Buffer to retrieve the launch parameters from."]
    pub fn PMAPP_LaunchFIRMSetParams(
        firmTidLow: u32_,
        size: u32_,
        in_: *const ::libc::c_void,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Terminate most processes, to prepare for a reboot or a shutdown.\n # Arguments\n\n* `timeout` - Time limit in ns for process termination, after which the remaining processes are killed."]
    pub fn PMAPP_PrepareForReboot(timeout: s64) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Terminates the current Application\n # Arguments\n\n* `timeout` - Timeout in nanoseconds"]
    pub fn PMAPP_TerminateCurrentApplication(timeout: s64) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Terminates the processes having the specified titleId.\n # Arguments\n\n* `titleId` - Title ID of the processes to terminate\n * `timeout` - Timeout in nanoseconds"]
    pub fn PMAPP_TerminateTitle(titleId: u64_, timeout: s64) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Terminates the specified process\n # Arguments\n\n* `pid` - Process-ID of the process to terminate\n * `timeout` - Timeout in nanoseconds"]
    pub fn PMAPP_TerminateProcess(pid: u32_, timeout: s64) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Unregisters a process\n # Arguments\n\n* `tid` - TitleID of the process to unregister"]
    pub fn PMAPP_UnregisterProcess(tid: u64_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the APPLICATION cputime reslimit.\n # Arguments\n\n* `cpuTime` - Reslimit value.\n > **Note:** cpuTime can be no higher than reslimitdesc[0] & 0x7F in exheader (or 80 if the latter is 0)."]
    pub fn PMAPP_SetAppResourceLimit(cpuTime: s64) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the APPLICATION cputime reslimit.\n # Arguments\n\n* `cpuTime` (direction out) - Pointer to write the reslimit value to."]
    pub fn PMAPP_GetAppResourceLimit(outCpuTime: *mut s64) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initializes pm:dbg."]
    pub fn pmDbgInit() -> Result;
}
extern "C" {
    #[doc = "Exits pm:dbg."]
    pub fn pmDbgExit();
}
extern "C" {
    #[doc = "Gets the current pm:dbg session handle.\n # Returns\n\nThe current pm:dbg session handle."]
    pub fn pmDbgGetSessionHandle() -> *mut Handle;
}
extern "C" {
    #[must_use]
    #[doc = "Enqueues an application for debug after setting cpuTime to 0, and returns a debug handle to it.\n If another process was enqueued, this just calls RunQueuedProcess instead.\n # Arguments\n\n* `Pointer` (direction out) - to output the debug handle to.\n * `programInfo` - Program information of the title.\n * `launchFlags` - Flags to launch the title with."]
    pub fn PMDBG_LaunchAppDebug(
        outDebug: *mut Handle,
        programInfo: *const FS_ProgramInfo,
        launchFlags: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Launches an application for debug after setting cpuTime to 0.\n # Arguments\n\n* `programInfo` - Program information of the title.\n * `launchFlags` - Flags to launch the title with."]
    pub fn PMDBG_LaunchApp(programInfo: *const FS_ProgramInfo, launchFlags: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Runs the queued process and returns a debug handle to it.\n # Arguments\n\n* `Pointer` (direction out) - to output the debug handle to."]
    pub fn PMDBG_RunQueuedProcess(outDebug: *mut Handle) -> Result;
}
#[doc = "< CBC encryption."]
pub const PS_ALGORITHM_CBC_ENC: PS_AESAlgorithm = 0;
#[doc = "< CBC decryption."]
pub const PS_ALGORITHM_CBC_DEC: PS_AESAlgorithm = 1;
#[doc = "< CTR encryption."]
pub const PS_ALGORITHM_CTR_ENC: PS_AESAlgorithm = 2;
#[doc = "< CTR decryption(same as PS_ALGORITHM_CTR_ENC)."]
pub const PS_ALGORITHM_CTR_DEC: PS_AESAlgorithm = 3;
#[doc = "< CCM encryption."]
pub const PS_ALGORITHM_CCM_ENC: PS_AESAlgorithm = 4;
#[doc = "< CCM decryption."]
pub const PS_ALGORITHM_CCM_DEC: PS_AESAlgorithm = 5;
#[doc = "PS AES algorithms."]
pub type PS_AESAlgorithm = ::libc::c_uint;
#[doc = "< Key slot 0x0D."]
pub const PS_KEYSLOT_0D: PS_AESKeyType = 0;
#[doc = "< Key slot 0x2D."]
pub const PS_KEYSLOT_2D: PS_AESKeyType = 1;
#[doc = "< Key slot 0x31."]
pub const PS_KEYSLOT_31: PS_AESKeyType = 2;
#[doc = "< Key slot 0x38."]
pub const PS_KEYSLOT_38: PS_AESKeyType = 3;
#[doc = "< Key slot 0x32."]
pub const PS_KEYSLOT_32: PS_AESKeyType = 4;
#[doc = "< Key slot 0x39. (DLP)"]
pub const PS_KEYSLOT_39_DLP: PS_AESKeyType = 5;
#[doc = "< Key slot 0x2E."]
pub const PS_KEYSLOT_2E: PS_AESKeyType = 6;
#[doc = "< Invalid key slot."]
pub const PS_KEYSLOT_INVALID: PS_AESKeyType = 7;
#[doc = "< Key slot 0x36."]
pub const PS_KEYSLOT_36: PS_AESKeyType = 8;
#[doc = "< Key slot 0x39. (NFC)"]
pub const PS_KEYSLOT_39_NFC: PS_AESKeyType = 9;
#[doc = "PS key slots."]
pub type PS_AESKeyType = ::libc::c_uint;
#[doc = "RSA context."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct psRSAContext {
    pub modulo: [u8_; 256usize],
    pub exponent: [u8_; 256usize],
    pub rsa_bitsize: u32_,
    pub unk: u32_,
}
impl Default for psRSAContext {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[must_use]
    #[doc = "Initializes PS."]
    pub fn psInit() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initializes PS with the specified session handle.\n # Arguments\n\n* `handle` - Session handle."]
    pub fn psInitHandle(handle: Handle) -> Result;
}
extern "C" {
    #[doc = "Exits PS."]
    pub fn psExit();
}
extern "C" {
    #[doc = "Returns the PS session handle."]
    pub fn psGetSessionHandle() -> Handle;
}
extern "C" {
    #[must_use]
    #[doc = "Signs a RSA signature.\n # Arguments\n\n* `hash` - SHA256 hash to sign.\n * `ctx` - RSA context.\n * `signature` - RSA signature."]
    pub fn PS_SignRsaSha256(hash: *mut u8_, ctx: *mut psRSAContext, signature: *mut u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Verifies a RSA signature.\n # Arguments\n\n* `hash` - SHA256 hash to compare with.\n * `ctx` - RSA context.\n * `signature` - RSA signature."]
    pub fn PS_VerifyRsaSha256(
        hash: *mut u8_,
        ctx: *mut psRSAContext,
        signature: *mut u8_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Encrypts/Decrypts AES data. Does not support AES CCM.\n # Arguments\n\n* `size` - Size of the data.\n * `in` - Input buffer.\n * `out` - Output buffer.\n * `aes_algo` - AES algorithm to use.\n * `key_type` - Key type to use.\n * `iv` - Pointer to the CTR/IV. The output CTR/IV is also written here."]
    pub fn PS_EncryptDecryptAes(
        size: u32_,
        in_: *mut u8_,
        out: *mut u8_,
        aes_algo: PS_AESAlgorithm,
        key_type: PS_AESKeyType,
        iv: *mut u8_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Encrypts/Decrypts signed AES CCM data.\n When decrypting, if the MAC is invalid, 0xC9010401 is returned. After encrypting the MAC is located at inputbufptr.\n # Arguments\n\n* `in` - Input buffer.\n * `in_size` - Size of the input buffer. Must include MAC size when decrypting.\n * `out` - Output buffer.\n * `out_size` - Size of the output buffer. Must include MAC size when encrypting.\n * `data_len` - Length of the data to be encrypted/decrypted.\n * `mac_data_len` - Length of the MAC data.\n * `mac_len` - Length of the MAC.\n * `aes_algo` - AES algorithm to use.\n * `key_type` - Key type to use.\n * `nonce` - Pointer to the nonce."]
    pub fn PS_EncryptSignDecryptVerifyAesCcm(
        in_: *mut u8_,
        in_size: u32_,
        out: *mut u8_,
        out_size: u32_,
        data_len: u32_,
        mac_data_len: u32_,
        mac_len: u32_,
        aes_algo: PS_AESAlgorithm,
        key_type: PS_AESKeyType,
        nonce: *mut u8_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the 64-bit console friend code seed.\n # Arguments\n\n* `seed` - Pointer to write the friend code seed to."]
    pub fn PS_GetLocalFriendCodeSeed(seed: *mut u64_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the 32-bit device ID.\n # Arguments\n\n* `device_id` - Pointer to write the device ID to."]
    pub fn PS_GetDeviceId(device_id: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Generates cryptographically secure random bytes.\n # Arguments\n\n* `out` - Pointer to the buffer to write the bytes to.\n * `len` - Number of bytes to write."]
    pub fn PS_GenerateRandomBytes(out: *mut ::libc::c_void, len: usize) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initializes PTMU."]
    pub fn ptmuInit() -> Result;
}
extern "C" {
    #[doc = "Exits PTMU."]
    pub fn ptmuExit();
}
extern "C" {
    #[doc = "Gets a pointer to the current ptm:u session handle.\n # Returns\n\nA pointer to the current ptm:u session handle."]
    pub fn ptmuGetSessionHandle() -> *mut Handle;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the system's current shell state.\n # Arguments\n\n* `out` - Pointer to write the current shell state to. (0 = closed, 1 = open)"]
    pub fn PTMU_GetShellState(out: *mut u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the system's current battery level.\n # Arguments\n\n* `out` - Pointer to write the current battery level to. (0-5)"]
    pub fn PTMU_GetBatteryLevel(out: *mut u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the system's current battery charge state.\n # Arguments\n\n* `out` - Pointer to write the current battery charge state to. (0 = not charging, 1 = charging)"]
    pub fn PTMU_GetBatteryChargeState(out: *mut u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the system's current pedometer state.\n # Arguments\n\n* `out` - Pointer to write the current pedometer state to. (0 = not counting, 1 = counting)"]
    pub fn PTMU_GetPedometerState(out: *mut u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the pedometer's total step count.\n # Arguments\n\n* `steps` - Pointer to write the total step count to."]
    pub fn PTMU_GetTotalStepCount(steps: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets whether the adapter is plugged in or not\n # Arguments\n\n* `out` - Pointer to write the adapter state to."]
    pub fn PTMU_GetAdapterState(out: *mut bool) -> Result;
}
#[doc = "PDN wake events and MCU interrupts to select, combined with those of other processes"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PtmWakeEvents {
    #[doc = "< Written to PDN_WAKE_EVENTS. Don't select bit26 (MCU), PTM will do it automatically."]
    pub pdn_wake_events: u32_,
    #[doc = "< MCU interrupts to check when a MCU wake event happens."]
    pub mcu_interupt_mask: u32_,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct PtmSleepConfig {
    #[doc = "< Wake events for which the system should fully wake up."]
    pub exit_sleep_events: PtmWakeEvents,
    #[doc = "< Wake events for which the system should return to sleep."]
    pub continue_sleep_events: PtmWakeEvents,
}
#[doc = "< PTMSYSM_RequestSleep has been called (ack = 3)"]
pub const PTMNOTIFID_SLEEP_REQUESTED: _bindgen_ty_27 = 257;
#[doc = "< The sleep request has been denied by PTMSYSM_ReplyToSleepQuery(true) (no ack required)."]
pub const PTMNOTIFID_SLEEP_DENIED: _bindgen_ty_27 = 258;
#[doc = "< The sleep request has been allowed by PTMSYSM_ReplyToSleepQuery(false) (ack = 1)."]
pub const PTMNOTIFID_SLEEP_ALLOWED: _bindgen_ty_27 = 259;
#[doc = "< All processes not having \"RunnableOnSleep\" have been paused & the system is about to go to sleep (ack = 0)."]
pub const PTMNOTIFID_GOING_TO_SLEEP: _bindgen_ty_27 = 260;
#[doc = "< The system has been woken up, and the paused processes are about to be unpaused (ack = 1)."]
pub const PTMNOTIFID_FULLY_WAKING_UP: _bindgen_ty_27 = 261;
#[doc = "< The system is fully awake (no ack required)."]
pub const PTMNOTIFID_FULLY_AWAKE: _bindgen_ty_27 = 262;
#[doc = "< The system has been woken up but is about to go to sleep again (ack = 2)."]
pub const PTMNOTIFID_HALF_AWAKE: _bindgen_ty_27 = 263;
#[doc = "< The system is about to power off or reboot."]
pub const PTMNOTIFID_SHUTDOWN: _bindgen_ty_27 = 264;
#[doc = "< The battery level has reached 5% or below."]
pub const PTMNOTIFID_BATTERY_VERY_LOW: _bindgen_ty_27 = 529;
#[doc = "< The battery level has reached 10% or below."]
pub const PTMNOTIFID_BATTERY_LOW: _bindgen_ty_27 = 530;
pub type _bindgen_ty_27 = ::libc::c_uint;
extern "C" {
    #[doc = "See PTMSYSM_NotifySleepPreparationComplete. Corresponds to the number of potentially remaning notifs. until sleep/wakeup."]
    #[link_name = "ptmSysmGetNotificationAckValue__extern"]
    pub fn ptmSysmGetNotificationAckValue(id: u32_) -> s32;
}
extern "C" {
    #[must_use]
    #[doc = "Initializes ptm:sysm."]
    pub fn ptmSysmInit() -> Result;
}
extern "C" {
    #[doc = "Exits ptm:sysm."]
    pub fn ptmSysmExit();
}
extern "C" {
    #[doc = "Gets a pointer to the current ptm:sysm session handle.\n # Returns\n\nA pointer to the current ptm:sysm session handle."]
    pub fn ptmSysmGetSessionHandle() -> *mut Handle;
}
extern "C" {
    #[must_use]
    #[doc = "Requests to enter sleep mode."]
    pub fn PTMSYSM_RequestSleep() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Accepts or denies the incoming sleep mode request.\n # Arguments\n\n* `deny` - Whether or not to deny the sleep request.\n > **Note:** If deny = false, this is equivalent to calling PTMSYSM_NotifySleepPreparationComplete(3)"]
    pub fn PTMSYSM_ReplyToSleepQuery(deny: bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Acknowledges the current sleep notification and advance the internal sleep mode FSM. All subscribers must reply.\n # Arguments\n\n* `ackValue` - Use ptmSysmGetNotificationAckValue\n > **Note:** PTMNOTIFID_SLEEP_DENIED and PTMNOTIFID_FULLY_AWAKE don't require this."]
    pub fn PTMSYSM_NotifySleepPreparationComplete(ackValue: s32) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the wake events (two sets: when to fully wake up and when to return to sleep).\n # Arguments\n\n* `sleepConfig` - Pointer to the two sets of wake events.\n > **Note:** Can only be called just before acknowledging PTMNOTIFID_GOING_TO_SLEEP or PTMNOTIFID_HALF_AWAKE."]
    pub fn PTMSYSM_SetWakeEvents(sleepConfig: *const PtmSleepConfig) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the wake reason (only the first applicable wake event is taken into account).\n # Arguments\n\n* `sleepConfig` - Pointer to the two sets of wake events. Only the relevant set will be filled."]
    pub fn PTMSYSM_GetWakeReason(outSleepConfig: *mut PtmSleepConfig) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Cancels the \"half-awake\" state and fully wakes up the 3DS after some delay."]
    pub fn PTMSYSM_Awaken() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the user time by updating the user time offset.\n # Arguments\n\n* `msY2k` - The number of milliseconds since 01/01/2000."]
    pub fn PTMSYSM_SetUserTime(msY2k: s64) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Invalidates the \"system time\" (cfg block 0x30002)"]
    pub fn PTMSYSM_InvalidateSystemTime() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Reads the time and date coming from the RTC and converts the result.\n # Arguments\n\n* `outMsY2k` (direction out) - The pointer to write the number of milliseconds since 01/01/2000 to."]
    pub fn PTMSYSM_GetRtcTime(outMsY2k: *mut s64) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Writes the time and date coming to the RTC, after conversion.\n # Arguments\n\n* `msY2k` - The number of milliseconds since 01/01/2000."]
    pub fn PTMSYSM_SetRtcTime(msY2k: s64) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Returns 1 if it's a New 3DS, otherwise 0."]
    pub fn PTMSYSM_CheckNew3DS() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Configures the New 3DS' CPU clock speed and L2 cache.\n # Arguments\n\n* `value` - Bit0: enable higher clock, Bit1: enable L2 cache."]
    pub fn PTMSYSM_ConfigureNew3DSCPU(value: u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Trigger a hardware system shutdown via the MCU.\n # Arguments\n\n* `timeout:` - timeout passed to PMApp:ShutdownAsync (PrepareForReboot)."]
    pub fn PTMSYSM_ShutdownAsync(timeout: u64_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Trigger a hardware system reboot via the MCU.\n # Arguments\n\n* `timeout:` - timeout passed to PMApp:ShutdownAsync (PrepareForReboot)."]
    pub fn PTMSYSM_RebootAsync(timeout: u64_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initializes PTMGETS."]
    pub fn ptmGetsInit() -> Result;
}
extern "C" {
    #[doc = "Exits PTMGETS."]
    pub fn ptmGetsExit();
}
extern "C" {
    #[doc = "Gets a pointer to the current ptm:gets session handle.\n # Returns\n\nA pointer to the current ptm:gets session handle."]
    pub fn ptmGetsGetSessionHandle() -> *mut Handle;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the system time.\n # Arguments\n\n* `outMsY2k` (direction out) - The pointer to write the number of milliseconds since 01/01/2000 to."]
    pub fn PTMGETS_GetSystemTime(outMsY2k: *mut s64) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initializes PTMSETS."]
    pub fn ptmSetsInit() -> Result;
}
extern "C" {
    #[doc = "Exits PTMSETS."]
    pub fn ptmSetsExit();
}
extern "C" {
    #[doc = "Gets a pointer to the current ptm:sets session handle.\n # Returns\n\nA pointer to the current ptm:sets session handle."]
    pub fn ptmSetsGetSessionHandle() -> *mut Handle;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the system time.\n # Arguments\n\n* `msY2k` - The number of milliseconds since 01/01/2000."]
    pub fn PTMSETS_SetSystemTime(msY2k: s64) -> Result;
}
#[doc = "< Do not wait."]
pub const WAIT_NONE: PXIDEV_WaitType = 0;
#[doc = "< Sleep for the specified number of nanoseconds."]
pub const WAIT_SLEEP: PXIDEV_WaitType = 1;
#[doc = "< Wait for IREQ, return if timeout."]
pub const WAIT_IREQ_RETURN: PXIDEV_WaitType = 2;
#[doc = "< Wait for IREQ, continue if timeout."]
pub const WAIT_IREQ_CONTINUE: PXIDEV_WaitType = 3;
#[doc = "Card SPI wait operation type."]
pub type PXIDEV_WaitType = ::libc::c_uint;
#[doc = "< Do not deassert."]
pub const DEASSERT_NONE: PXIDEV_DeassertType = 0;
#[doc = "< Deassert before waiting."]
pub const DEASSERT_BEFORE_WAIT: PXIDEV_DeassertType = 1;
#[doc = "< Deassert after waiting."]
pub const DEASSERT_AFTER_WAIT: PXIDEV_DeassertType = 2;
#[doc = "Card SPI register deassertion type."]
pub type PXIDEV_DeassertType = ::libc::c_uint;
#[doc = "Card SPI transfer buffer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PXIDEV_SPIBuffer {
    #[doc = "< Data pointer."]
    pub ptr: *mut ::libc::c_void,
    #[doc = "< Data size."]
    pub size: u32_,
    #[doc = "< Transfer options. See pxiDevMakeTransferOption"]
    pub transferOption: u8_,
    #[doc = "< Wait operation. See pxiDevMakeWaitOperation"]
    pub waitOperation: u64_,
}
impl Default for PXIDEV_SPIBuffer {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[must_use]
    #[doc = "Initializes pxi:dev."]
    pub fn pxiDevInit() -> Result;
}
extern "C" {
    #[doc = "Shuts down pxi:dev."]
    pub fn pxiDevExit();
}
extern "C" {
    #[doc = "Creates a packed card SPI transfer option value.\n # Arguments\n\n* `baudRate` - Baud rate to use when transferring.\n * `busMode` - Bus mode to use when transferring.\n # Returns\n\nA packed card SPI transfer option value."]
    #[link_name = "pxiDevMakeTransferOption__extern"]
    pub fn pxiDevMakeTransferOption(
        baudRate: FS_CardSpiBaudRate,
        busMode: FS_CardSpiBusMode,
    ) -> u8_;
}
extern "C" {
    #[doc = "Creates a packed card SPI wait operation value.\n # Arguments\n\n* `waitType` - Type of wait to perform.\n * `deassertType` - Type of register deassertion to perform.\n * `timeout` - Timeout, in nanoseconds, to wait, if applicable.\n # Returns\n\nA packed card SPI wait operation value."]
    #[link_name = "pxiDevMakeWaitOperation__extern"]
    pub fn pxiDevMakeWaitOperation(
        waitType: PXIDEV_WaitType,
        deassertType: PXIDEV_DeassertType,
        timeout: u64_,
    ) -> u64_;
}
extern "C" {
    #[must_use]
    #[doc = "Performs multiple card SPI writes and reads.\n # Arguments\n\n* `header` - Header to lead the transfers with. Must be, at most, 8 bytes in size.\n * `writeBuffer1` - Buffer to make first transfer from.\n * `readBuffer1` - Buffer to receive first response to.\n * `writeBuffer2` - Buffer to make second transfer from.\n * `readBuffer2` - Buffer to receive second response to.\n * `footer` - Footer to follow the transfers with. Must be, at most, 8 bytes in size. Wait operation is unused."]
    pub fn PXIDEV_SPIMultiWriteRead(
        header: *mut PXIDEV_SPIBuffer,
        writeBuffer1: *mut PXIDEV_SPIBuffer,
        readBuffer1: *mut PXIDEV_SPIBuffer,
        writeBuffer2: *mut PXIDEV_SPIBuffer,
        readBuffer2: *mut PXIDEV_SPIBuffer,
        footer: *mut PXIDEV_SPIBuffer,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Performs a single card SPI write and read.\n # Arguments\n\n* `bytesRead` - Pointer to output the number of bytes received to.\n * `initialWaitOperation` - Wait operation to perform before transferring data.\n * `writeBuffer` - Buffer to transfer data from.\n * `readBuffer` - Buffer to receive data to."]
    pub fn PXIDEV_SPIWriteRead(
        bytesRead: *mut u32_,
        initialWaitOperation: u64_,
        writeBuffer: *mut PXIDEV_SPIBuffer,
        readBuffer: *mut PXIDEV_SPIBuffer,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initializes PxiPM."]
    pub fn pxiPmInit() -> Result;
}
extern "C" {
    #[doc = "Exits PxiPM."]
    pub fn pxiPmExit();
}
extern "C" {
    #[doc = "Gets the current PxiPM session handle.\n # Returns\n\nThe current PxiPM session handle."]
    pub fn pxiPmGetSessionHandle() -> *mut Handle;
}
extern "C" {
    #[must_use]
    #[doc = "Retrives the exheader information set(s) (SCI+ACI) about a program.\n # Arguments\n\n* `exheaderInfos[out]` - Pointer to the output exheader information set.\n * `programHandle` - The program handle."]
    pub fn PXIPM_GetProgramInfo(exheaderInfo: *mut ExHeader_Info, programHandle: u64_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Loads a program and registers it to Process9.\n # Arguments\n\n* `programHandle[out]` - Pointer to the output the program handle to.\n * `programInfo` - Information about the program to load.\n * `updateInfo` - Information about the program update to load."]
    pub fn PXIPM_RegisterProgram(
        programHandle: *mut u64_,
        programInfo: *const FS_ProgramInfo,
        updateInfo: *const FS_ProgramInfo,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Unloads a program and unregisters it from Process9.\n # Arguments\n\n* `programHandle` - The program handle."]
    pub fn PXIPM_UnregisterProgram(programHandle: u64_) -> Result;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timezone {
    pub tz_minuteswest: ::libc::c_int,
    pub tz_dsttime: ::libc::c_int,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct bintime {
    pub sec: time_t,
    pub frac: u64,
}
extern "C" {
    #[link_name = "bintime_addx__extern"]
    pub fn bintime_addx(_bt: *mut bintime, _x: u64);
}
extern "C" {
    #[link_name = "bintime_add__extern"]
    pub fn bintime_add(_bt: *mut bintime, _bt2: *const bintime);
}
extern "C" {
    #[link_name = "bintime_sub__extern"]
    pub fn bintime_sub(_bt: *mut bintime, _bt2: *const bintime);
}
extern "C" {
    #[link_name = "bintime_mul__extern"]
    pub fn bintime_mul(_bt: *mut bintime, _x: u_int);
}
extern "C" {
    #[link_name = "bintime_shift__extern"]
    pub fn bintime_shift(_bt: *mut bintime, _exp: ::libc::c_int);
}
extern "C" {
    #[link_name = "sbintime_getsec__extern"]
    pub fn sbintime_getsec(_sbt: sbintime_t) -> ::libc::c_int;
}
extern "C" {
    #[link_name = "bttosbt__extern"]
    pub fn bttosbt(_bt: bintime) -> sbintime_t;
}
extern "C" {
    #[link_name = "sbttobt__extern"]
    pub fn sbttobt(_sbt: sbintime_t) -> bintime;
}
extern "C" {
    #[link_name = "sbttons__extern"]
    pub fn sbttons(_sbt: sbintime_t) -> i64;
}
extern "C" {
    #[link_name = "nstosbt__extern"]
    pub fn nstosbt(_ns: i64) -> sbintime_t;
}
extern "C" {
    #[link_name = "sbttous__extern"]
    pub fn sbttous(_sbt: sbintime_t) -> i64;
}
extern "C" {
    #[link_name = "ustosbt__extern"]
    pub fn ustosbt(_us: i64) -> sbintime_t;
}
extern "C" {
    #[link_name = "sbttoms__extern"]
    pub fn sbttoms(_sbt: sbintime_t) -> i64;
}
extern "C" {
    #[link_name = "mstosbt__extern"]
    pub fn mstosbt(_ms: i64) -> sbintime_t;
}
extern "C" {
    #[link_name = "bintime2timespec__extern"]
    pub fn bintime2timespec(_bt: *const bintime, _ts: *mut timespec);
}
extern "C" {
    #[link_name = "timespec2bintime__extern"]
    pub fn timespec2bintime(_ts: *const timespec, _bt: *mut bintime);
}
extern "C" {
    #[link_name = "bintime2timeval__extern"]
    pub fn bintime2timeval(_bt: *const bintime, _tv: *mut timeval);
}
extern "C" {
    #[link_name = "timeval2bintime__extern"]
    pub fn timeval2bintime(_tv: *const timeval, _bt: *mut bintime);
}
extern "C" {
    #[link_name = "sbttots__extern"]
    pub fn sbttots(_sbt: sbintime_t) -> timespec;
}
extern "C" {
    #[link_name = "tstosbt__extern"]
    pub fn tstosbt(_ts: timespec) -> sbintime_t;
}
extern "C" {
    #[link_name = "sbttotv__extern"]
    pub fn sbttotv(_sbt: sbintime_t) -> timeval;
}
extern "C" {
    #[link_name = "tvtosbt__extern"]
    pub fn tvtosbt(_tv: timeval) -> sbintime_t;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
pub type __ULong = ::libc::c_ulong;
pub type _flock_t = _LOCK_RECURSIVE_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Bigint {
    pub _next: *mut _Bigint,
    pub _k: ::libc::c_int,
    pub _maxwds: ::libc::c_int,
    pub _sign: ::libc::c_int,
    pub _wds: ::libc::c_int,
    pub _x: [__ULong; 1usize],
}
impl Default for _Bigint {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __tm {
    pub __tm_sec: ::libc::c_int,
    pub __tm_min: ::libc::c_int,
    pub __tm_hour: ::libc::c_int,
    pub __tm_mday: ::libc::c_int,
    pub __tm_mon: ::libc::c_int,
    pub __tm_year: ::libc::c_int,
    pub __tm_wday: ::libc::c_int,
    pub __tm_yday: ::libc::c_int,
    pub __tm_isdst: ::libc::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _on_exit_args {
    pub _fnargs: [*mut ::libc::c_void; 32usize],
    pub _dso_handle: [*mut ::libc::c_void; 32usize],
    pub _fntypes: __ULong,
    pub _is_cxa: __ULong,
}
impl Default for _on_exit_args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _atexit {
    pub _next: *mut _atexit,
    pub _ind: ::libc::c_int,
    pub _fns: [::core::option::Option<unsafe extern "C" fn()>; 32usize],
    pub _on_exit_args: _on_exit_args,
}
impl Default for _atexit {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut ::libc::c_uchar,
    pub _size: ::libc::c_int,
}
impl Default for __sbuf {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut ::libc::c_uchar,
    pub _r: ::libc::c_int,
    pub _w: ::libc::c_int,
    pub _flags: ::libc::c_short,
    pub _file: ::libc::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::libc::c_int,
    pub _cookie: *mut ::libc::c_void,
    pub _read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::libc::c_void,
            arg3: *mut ::libc::c_char,
            arg4: ::libc::c_int,
        ) -> ::libc::c_int,
    >,
    pub _write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::libc::c_void,
            arg3: *const ::libc::c_char,
            arg4: ::libc::c_int,
        ) -> ::libc::c_int,
    >,
    pub _seek: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut ::libc::c_void,
            arg3: _fpos_t,
            arg4: ::libc::c_int,
        ) -> _fpos_t,
    >,
    pub _close: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut _reent, arg2: *mut ::libc::c_void) -> ::libc::c_int,
    >,
    pub _ub: __sbuf,
    pub _up: *mut ::libc::c_uchar,
    pub _ur: ::libc::c_int,
    pub _ubuf: [::libc::c_uchar; 3usize],
    pub _nbuf: [::libc::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::libc::c_int,
    pub _offset: _off_t,
    pub _data: *mut _reent,
    pub _lock: _flock_t,
    pub _mbstate: _mbstate_t,
    pub _flags2: ::libc::c_int,
}
impl Default for __sFILE {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __FILE = __sFILE;
extern "C" {
    pub static mut __sf: [__FILE; 3usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _glue {
    pub _next: *mut _glue,
    pub _niobs: ::libc::c_int,
    pub _iobs: *mut __FILE,
}
impl Default for _glue {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut __sglue: _glue;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _rand48 {
    pub _seed: [::libc::c_ushort; 3usize],
    pub _mult: [::libc::c_ushort; 3usize],
    pub _add: ::libc::c_ushort,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _reent {
    pub _errno: ::libc::c_int,
    pub _stdin: *mut __FILE,
    pub _stdout: *mut __FILE,
    pub _stderr: *mut __FILE,
    pub _inc: ::libc::c_int,
    pub _emergency: [::libc::c_char; 25usize],
    pub _locale: *mut __locale_t,
    pub __cleanup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut _reent)>,
    pub _result: *mut _Bigint,
    pub _result_k: ::libc::c_int,
    pub _p5s: *mut _Bigint,
    pub _freelist: *mut *mut _Bigint,
    pub _cvtlen: ::libc::c_int,
    pub _cvtbuf: *mut ::libc::c_char,
    pub _new: _reent__bindgen_ty_1,
    pub _sig_func: *mut ::core::option::Option<unsafe extern "C" fn(arg1: ::libc::c_int)>,
    pub deviceData: *mut ::libc::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _reent__bindgen_ty_1 {
    pub _reent: _reent__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _reent__bindgen_ty_1__bindgen_ty_1 {
    pub _strtok_last: *mut ::libc::c_char,
    pub _asctime_buf: [::libc::c_char; 26usize],
    pub _localtime_buf: __tm,
    pub _gamma_signgam: ::libc::c_int,
    pub _rand_next: ::libc::c_ulonglong,
    pub _r48: _rand48,
    pub _mblen_state: _mbstate_t,
    pub _mbtowc_state: _mbstate_t,
    pub _wctomb_state: _mbstate_t,
    pub _l64a_buf: [::libc::c_char; 8usize],
    pub _signal_buf: [::libc::c_char; 24usize],
    pub _getdate_err: ::libc::c_int,
    pub _mbrlen_state: _mbstate_t,
    pub _mbrtowc_state: _mbstate_t,
    pub _mbsrtowcs_state: _mbstate_t,
    pub _wcrtomb_state: _mbstate_t,
    pub _wcsrtombs_state: _mbstate_t,
    pub _h_errno: ::libc::c_int,
}
impl Default for _reent__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _reent__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _reent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut _impure_ptr: *mut _reent;
}
extern "C" {
    pub static mut _impure_data: _reent;
}
extern "C" {
    pub static mut __atexit: *mut _atexit;
}
extern "C" {
    pub static mut __atexit0: _atexit;
}
extern "C" {
    pub static mut __stdio_exit_handler: ::core::option::Option<unsafe extern "C" fn()>;
}
extern "C" {
    pub fn _reclaim_reent(arg1: *mut _reent);
}
extern "C" {
    pub fn _fwalk_sglue(
        arg1: *mut _reent,
        arg2: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut _reent, arg2: *mut __FILE) -> ::libc::c_int,
        >,
        arg3: *mut _glue,
    ) -> ::libc::c_int;
}
pub type locale_t = *mut __locale_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::libc::c_int,
    pub tm_min: ::libc::c_int,
    pub tm_hour: ::libc::c_int,
    pub tm_mday: ::libc::c_int,
    pub tm_mon: ::libc::c_int,
    pub tm_year: ::libc::c_int,
    pub tm_wday: ::libc::c_int,
    pub tm_yday: ::libc::c_int,
    pub tm_isdst: ::libc::c_int,
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn difftime(_time2: time_t, _time1: time_t) -> f64;
}
extern "C" {
    pub fn mktime(_timeptr: *mut tm) -> time_t;
}
extern "C" {
    pub fn time(_timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn asctime(_tblock: *const tm) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn ctime(_time: *const time_t) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn gmtime(_timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(_timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn strftime(
        _s: *mut ::libc::c_char,
        _maxsize: usize,
        _fmt: *const ::libc::c_char,
        _t: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn strftime_l(
        _s: *mut ::libc::c_char,
        _maxsize: usize,
        _fmt: *const ::libc::c_char,
        _t: *const tm,
        _l: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn asctime_r(arg1: *const tm, arg2: *mut ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn ctime_r(arg1: *const time_t, arg2: *mut ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn gmtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub fn _tzset_r(arg1: *mut _reent);
}
extern "C" {
    pub static mut _timezone: ::libc::c_long;
}
extern "C" {
    pub static mut _daylight: ::libc::c_int;
}
extern "C" {
    pub static mut _tzname: [*mut ::libc::c_char; 2usize];
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ::libc::c_int,
    pub sival_ptr: *mut ::libc::c_void,
}
impl Default for sigval {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_notify: ::libc::c_int,
    pub sigev_signo: ::libc::c_int,
    pub sigev_value: sigval,
    pub sigev_notify_function: ::core::option::Option<unsafe extern "C" fn(arg1: sigval)>,
    pub sigev_notify_attributes: *mut pthread_attr_t,
}
impl Default for sigevent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t {
    pub si_signo: ::libc::c_int,
    pub si_code: ::libc::c_int,
    pub si_value: sigval,
}
impl Default for siginfo_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type _sig_func_ptr = ::core::option::Option<unsafe extern "C" fn(arg1: ::libc::c_int)>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sigaction {
    pub sa_handler: _sig_func_ptr,
    pub sa_mask: sigset_t,
    pub sa_flags: ::libc::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigaltstack {
    pub ss_sp: *mut ::libc::c_void,
    pub ss_flags: ::libc::c_int,
    pub ss_size: usize,
}
impl Default for sigaltstack {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type stack_t = sigaltstack;
extern "C" {
    pub fn sigprocmask(
        arg1: ::libc::c_int,
        arg2: *const sigset_t,
        arg3: *mut sigset_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_sigmask(
        arg1: ::libc::c_int,
        arg2: *const sigset_t,
        arg3: *mut sigset_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn kill(arg1: pid_t, arg2: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn killpg(arg1: pid_t, arg2: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn sigaction(
        arg1: ::libc::c_int,
        arg2: *const sigaction,
        arg3: *mut sigaction,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn sigaddset(arg1: *mut sigset_t, arg2: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn sigdelset(arg1: *mut sigset_t, arg2: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn sigismember(arg1: *const sigset_t, arg2: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn sigfillset(arg1: *mut sigset_t) -> ::libc::c_int;
}
extern "C" {
    pub fn sigemptyset(arg1: *mut sigset_t) -> ::libc::c_int;
}
extern "C" {
    pub fn sigpending(arg1: *mut sigset_t) -> ::libc::c_int;
}
extern "C" {
    pub fn sigsuspend(arg1: *const sigset_t) -> ::libc::c_int;
}
extern "C" {
    pub fn sigwait(arg1: *const sigset_t, arg2: *mut ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn sigpause(arg1: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn sigaltstack(arg1: *const stack_t, arg2: *mut stack_t) -> ::libc::c_int;
}
extern "C" {
    pub fn pthread_kill(arg1: pthread_t, arg2: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn sigwaitinfo(arg1: *const sigset_t, arg2: *mut siginfo_t) -> ::libc::c_int;
}
extern "C" {
    pub fn sigtimedwait(
        arg1: *const sigset_t,
        arg2: *mut siginfo_t,
        arg3: *const timespec,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn sigqueue(arg1: pid_t, arg2: ::libc::c_int, arg3: sigval) -> ::libc::c_int;
}
extern "C" {
    pub fn sig2str(arg1: ::libc::c_int, arg2: *mut ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn str2sig(arg1: *const ::libc::c_char, arg2: *mut ::libc::c_int) -> ::libc::c_int;
}
pub type sig_atomic_t = ::libc::c_int;
pub type sig_t = _sig_func_ptr;
extern "C" {
    pub fn _signal_r(arg1: *mut _reent, arg2: ::libc::c_int, arg3: _sig_func_ptr) -> _sig_func_ptr;
}
extern "C" {
    pub fn _raise_r(arg1: *mut _reent, arg2: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn signal(arg1: ::libc::c_int, arg2: _sig_func_ptr) -> _sig_func_ptr;
}
extern "C" {
    pub fn raise(arg1: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn psignal(arg1: ::libc::c_int, arg2: *const ::libc::c_char);
}
extern "C" {
    pub fn clock_settime(clock_id: clockid_t, tp: *const timespec) -> ::libc::c_int;
}
extern "C" {
    pub fn clock_gettime(clock_id: clockid_t, tp: *mut timespec) -> ::libc::c_int;
}
extern "C" {
    pub fn clock_getres(clock_id: clockid_t, res: *mut timespec) -> ::libc::c_int;
}
extern "C" {
    pub fn timer_create(
        clock_id: clockid_t,
        evp: *mut sigevent,
        timerid: *mut timer_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn timer_delete(timerid: timer_t) -> ::libc::c_int;
}
extern "C" {
    pub fn timer_settime(
        timerid: timer_t,
        flags: ::libc::c_int,
        value: *const itimerspec,
        ovalue: *mut itimerspec,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn timer_gettime(timerid: timer_t, value: *mut itimerspec) -> ::libc::c_int;
}
extern "C" {
    pub fn timer_getoverrun(timerid: timer_t) -> ::libc::c_int;
}
extern "C" {
    pub fn nanosleep(rqtp: *const timespec, rmtp: *mut timespec) -> ::libc::c_int;
}
extern "C" {
    pub fn utimes(arg1: *const ::libc::c_char, arg2: *const timeval) -> ::libc::c_int;
}
extern "C" {
    pub fn adjtime(arg1: *const timeval, arg2: *mut timeval) -> ::libc::c_int;
}
extern "C" {
    pub fn futimes(arg1: ::libc::c_int, arg2: *const timeval) -> ::libc::c_int;
}
extern "C" {
    pub fn lutimes(arg1: *const ::libc::c_char, arg2: *const timeval) -> ::libc::c_int;
}
extern "C" {
    pub fn settimeofday(arg1: *const timeval, arg2: *const timezone) -> ::libc::c_int;
}
extern "C" {
    pub fn getitimer(__which: ::libc::c_int, __value: *mut itimerval) -> ::libc::c_int;
}
extern "C" {
    pub fn setitimer(
        __which: ::libc::c_int,
        __value: *const itimerval,
        __ovalue: *mut itimerval,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn gettimeofday(__p: *mut timeval, __tz: *mut ::libc::c_void) -> ::libc::c_int;
}
pub type socklen_t = u32;
pub type sa_family_t = u16;
#[repr(C)]
#[derive(Debug, Default)]
pub struct sockaddr {
    pub sa_family: sa_family_t,
    pub sa_data: __IncompleteArrayField<::libc::c_char>,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sockaddr_storage {
    pub ss_family: sa_family_t,
    pub __ss_padding: [::libc::c_char; 26usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct linger {
    pub l_onoff: ::libc::c_int,
    pub l_linger: ::libc::c_int,
}
extern "C" {
    pub fn accept(
        sockfd: ::libc::c_int,
        addr: *mut sockaddr,
        addrlen: *mut socklen_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn bind(sockfd: ::libc::c_int, addr: *const sockaddr, addrlen: socklen_t) -> ::libc::c_int;
}
extern "C" {
    pub fn closesocket(sockfd: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn connect(
        sockfd: ::libc::c_int,
        addr: *const sockaddr,
        addrlen: socklen_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn getpeername(
        sockfd: ::libc::c_int,
        addr: *mut sockaddr,
        addrlen: *mut socklen_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn getsockname(
        sockfd: ::libc::c_int,
        addr: *mut sockaddr,
        addrlen: *mut socklen_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn getsockopt(
        sockfd: ::libc::c_int,
        level: ::libc::c_int,
        optname: ::libc::c_int,
        optval: *mut ::libc::c_void,
        optlen: *mut socklen_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn listen(sockfd: ::libc::c_int, backlog: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn recv(
        sockfd: ::libc::c_int,
        buf: *mut ::libc::c_void,
        len: usize,
        flags: ::libc::c_int,
    ) -> isize;
}
extern "C" {
    pub fn recvfrom(
        sockfd: ::libc::c_int,
        buf: *mut ::libc::c_void,
        len: usize,
        flags: ::libc::c_int,
        src_addr: *mut sockaddr,
        addrlen: *mut socklen_t,
    ) -> isize;
}
extern "C" {
    pub fn send(
        sockfd: ::libc::c_int,
        buf: *const ::libc::c_void,
        len: usize,
        flags: ::libc::c_int,
    ) -> isize;
}
extern "C" {
    pub fn sendto(
        sockfd: ::libc::c_int,
        buf: *const ::libc::c_void,
        len: usize,
        flags: ::libc::c_int,
        dest_addr: *const sockaddr,
        addrlen: socklen_t,
    ) -> isize;
}
extern "C" {
    pub fn setsockopt(
        sockfd: ::libc::c_int,
        level: ::libc::c_int,
        optname: ::libc::c_int,
        optval: *const ::libc::c_void,
        optlen: socklen_t,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn shutdown(sockfd: ::libc::c_int, how: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn socket(
        domain: ::libc::c_int,
        type_: ::libc::c_int,
        protocol: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn sockatmark(sockfd: ::libc::c_int) -> ::libc::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sockaddr_in {
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: in_addr,
    pub sin_zero: [::libc::c_uchar; 8usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ip_mreq {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
}
#[doc = "< The mac address of the interface (u32 mac[6])"]
pub const NETOPT_MAC_ADDRESS: NetworkOpt = 4100;
#[doc = "< The ARP table [`SOCU_ARPTableEntry`]"]
pub const NETOPT_ARP_TABLE: NetworkOpt = 12290;
#[doc = "< The current IP setup [`SOCU_IPInfo`]"]
pub const NETOPT_IP_INFO: NetworkOpt = 16387;
#[doc = "< The value of the IP MTU (u32)"]
pub const NETOPT_IP_MTU: NetworkOpt = 16388;
#[doc = "< The routing table [`SOCU_RoutingTableEntry`]"]
pub const NETOPT_ROUTING_TABLE: NetworkOpt = 16390;
#[doc = "< The number of sockets in the UDP table (u32)"]
pub const NETOPT_UDP_NUMBER: NetworkOpt = 32770;
#[doc = "< The table of opened UDP sockets [`SOCU_UDPTableEntry`]"]
pub const NETOPT_UDP_TABLE: NetworkOpt = 32771;
#[doc = "< The number of sockets in the TCP table (u32)"]
pub const NETOPT_TCP_NUMBER: NetworkOpt = 36866;
#[doc = "< The table of opened TCP sockets [`SOCU_TCPTableEntry`]"]
pub const NETOPT_TCP_TABLE: NetworkOpt = 36867;
#[doc = "< The table of the DNS servers [`SOCU_DNSTableEntry`] -- Returns a buffer of size 336 but only 2 entries are set ?"]
pub const NETOPT_DNS_TABLE: NetworkOpt = 45059;
#[doc = "< The DHCP lease time remaining, in seconds"]
pub const NETOPT_DHCP_LEASE_TIME: NetworkOpt = 49153;
#[doc = "Options to be used with SOCU_GetNetworkOpt"]
pub type NetworkOpt = ::libc::c_uint;
#[doc = "One entry of the ARP table retrieved by using SOCU_GetNetworkOpt and NETOPT_ARP_TABLE"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SOCU_ARPTableEntry {
    pub unk0: u32_,
    #[doc = "< The IPv4 address associated to the entry"]
    pub ip: in_addr,
    #[doc = "< The MAC address of associated to the entry"]
    pub mac: [u8_; 6usize],
    pub padding: [u8_; 2usize],
}
#[doc = "Structure returned by SOCU_GetNetworkOpt when using NETOPT_IP_INFO"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SOCU_IPInfo {
    #[doc = "< Current IPv4 address"]
    pub ip: in_addr,
    #[doc = "< Current network mask"]
    pub netmask: in_addr,
    #[doc = "< Current network broadcast address"]
    pub broadcast: in_addr,
}
#[doc = "One entry of the routing table retrieved by using SOCU_GetNetworkOpt and NETOPT_ROUTING_TABLE"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SOCU_RoutingTableEntry {
    #[doc = "< Destination IP address of the route"]
    pub dest_ip: in_addr,
    #[doc = "< Mask used for this route"]
    pub netmask: in_addr,
    #[doc = "< Gateway address to reach the network"]
    pub gateway: in_addr,
    #[doc = "< Linux netstat flags [`ROUTING_FLAG_G`]"]
    pub flags: u32_,
    #[doc = "< number of milliseconds since 1st Jan 1900 00:00."]
    pub time: u64_,
}
#[doc = "One entry of the UDP sockets table retrieved by using SOCU_GetNetworkOpt and NETOPT_UDP_TABLE"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SOCU_UDPTableEntry {
    #[doc = "< Local address information"]
    pub local: sockaddr_storage,
    #[doc = "< Remote address information"]
    pub remote: sockaddr_storage,
}
#[doc = "One entry of the TCP sockets table retrieved by using SOCU_GetNetworkOpt and NETOPT_TCP_TABLE"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SOCU_TCPTableEntry {
    #[doc = "< [`TCP`] states defines"]
    pub state: u32_,
    #[doc = "< Local address information"]
    pub local: sockaddr_storage,
    #[doc = "< Remote address information"]
    pub remote: sockaddr_storage,
}
#[doc = "One entry of the DNS servers table retrieved by using SOCU_GetNetworkOpt and NETOPT_DNS_TABLE"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SOCU_DNSTableEntry {
    pub family: u32_,
    #[doc = "Family of the address of the DNS server"]
    pub ip: in_addr,
    #[doc = "IP of the DNS server"]
    pub padding: [u8_; 12usize],
}
extern "C" {
    #[must_use]
    #[doc = "Initializes the SOC service.\n # Arguments\n\n* `context_addr` - Address of a page-aligned (0x1000) buffer to be used.\n * `context_size` - Size of the buffer, a multiple of 0x1000.\n > **Note:** The specified context buffer can no longer be accessed by the process which called this function, since the userland permissions for this block are set to no-access."]
    pub fn socInit(context_addr: *mut u32_, context_size: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Closes the soc service.\n > **Note:** You need to call this in order to be able to use the buffer again."]
    pub fn socExit() -> Result;
}
extern "C" {
    #[doc = "Gets the system's host ID.\n # Returns\n\nThe system's host ID."]
    pub fn gethostid() -> ::libc::c_long;
}
extern "C" {
    pub fn gethostname(name: *mut ::libc::c_char, namelen: usize) -> ::libc::c_int;
}
extern "C" {
    pub fn SOCU_ShutdownSockets() -> ::libc::c_int;
}
extern "C" {
    pub fn SOCU_CloseSockets() -> ::libc::c_int;
}
extern "C" {
    #[doc = "Retrieves information from the network configuration. Similar to getsockopt().\n # Arguments\n\n* `level` - Only value allowed seems to be SOL_CONFIG\n * `optname` - The option to be retrieved\n * `optval` - Will contain the output of the command\n * `optlen` - Size of the optval buffer, will be updated to hold the size of the output\n # Returns\n\n0 if successful. -1 if failed, and errno will be set accordingly. Can also return a system error code."]
    pub fn SOCU_GetNetworkOpt(
        level: ::libc::c_int,
        optname: NetworkOpt,
        optval: *mut ::libc::c_void,
        optlen: *mut socklen_t,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Gets the system's IP address, netmask, and subnet broadcast\n # Returns\n\nerror"]
    pub fn SOCU_GetIPInfo(
        ip: *mut in_addr,
        netmask: *mut in_addr,
        broadcast: *mut in_addr,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Adds a global socket.\n # Arguments\n\n* `sockfd` - The socket fd.\n # Returns\n\nerror"]
    pub fn SOCU_AddGlobalSocket(sockfd: ::libc::c_int) -> ::libc::c_int;
}
#[doc = "< Unsigned 8-bit PCM."]
pub const MICU_ENCODING_PCM8: MICU_Encoding = 0;
#[doc = "< Unsigned 16-bit PCM."]
pub const MICU_ENCODING_PCM16: MICU_Encoding = 1;
#[doc = "< Signed 8-bit PCM."]
pub const MICU_ENCODING_PCM8_SIGNED: MICU_Encoding = 2;
#[doc = "< Signed 16-bit PCM."]
pub const MICU_ENCODING_PCM16_SIGNED: MICU_Encoding = 3;
#[doc = "Microphone audio encodings."]
pub type MICU_Encoding = ::libc::c_uint;
#[doc = "< 32728.498 Hz"]
pub const MICU_SAMPLE_RATE_32730: MICU_SampleRate = 0;
#[doc = "< 16364.479 Hz"]
pub const MICU_SAMPLE_RATE_16360: MICU_SampleRate = 1;
#[doc = "< 10909.499 Hz"]
pub const MICU_SAMPLE_RATE_10910: MICU_SampleRate = 2;
#[doc = "< 8182.1245 Hz"]
pub const MICU_SAMPLE_RATE_8180: MICU_SampleRate = 3;
#[doc = "Microphone audio sampling rates."]
pub type MICU_SampleRate = ::libc::c_uint;
extern "C" {
    #[must_use]
    #[doc = "Initializes MIC.\n # Arguments\n\n* `size` - Shared memory buffer to write audio data to. Must be aligned to 0x1000 bytes.\n * `handle` - Size of the shared memory buffer."]
    pub fn micInit(buffer: *mut u8_, bufferSize: u32_) -> Result;
}
extern "C" {
    #[doc = "Exits MIC."]
    pub fn micExit();
}
extern "C" {
    #[doc = "Gets the size of the sample data area within the shared memory buffer.\n # Returns\n\nThe sample data's size."]
    pub fn micGetSampleDataSize() -> u32_;
}
extern "C" {
    #[doc = "Gets the offset within the shared memory buffer of the last sample written.\n # Returns\n\nThe last sample's offset."]
    pub fn micGetLastSampleOffset() -> u32_;
}
extern "C" {
    #[must_use]
    #[doc = "Maps MIC shared memory.\n # Arguments\n\n* `size` - Size of the shared memory.\n * `handle` - Handle of the shared memory."]
    pub fn MICU_MapSharedMem(size: u32_, handle: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Unmaps MIC shared memory."]
    pub fn MICU_UnmapSharedMem() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Begins sampling microphone input.\n # Arguments\n\n* `encoding` - Encoding of outputted audio.\n * `sampleRate` - Sample rate of outputted audio.\n * `sharedMemAudioOffset` - Offset to write audio data to in the shared memory buffer.\n * `sharedMemAudioSize` - Size of audio data to write to the shared memory buffer. This should be at most \"bufferSize - 4\".\n * `loop` - Whether to loop back to the beginning of the buffer when the end is reached."]
    pub fn MICU_StartSampling(
        encoding: MICU_Encoding,
        sampleRate: MICU_SampleRate,
        offset: u32_,
        size: u32_,
        loop_: bool,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Adjusts the configuration of the current sampling session.\n # Arguments\n\n* `sampleRate` - Sample rate of outputted audio."]
    pub fn MICU_AdjustSampling(sampleRate: MICU_SampleRate) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Stops sampling microphone input."]
    pub fn MICU_StopSampling() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets whether microphone input is currently being sampled.\n # Arguments\n\n* `sampling` - Pointer to output the sampling state to."]
    pub fn MICU_IsSampling(sampling: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets an event handle triggered when the shared memory buffer is full.\n # Arguments\n\n* `handle` - Pointer to output the event handle to."]
    pub fn MICU_GetEventHandle(handle: *mut Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the microphone's gain.\n # Arguments\n\n* `gain` - Gain to set."]
    pub fn MICU_SetGain(gain: u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the microphone's gain.\n # Arguments\n\n* `gain` - Pointer to output the current gain to."]
    pub fn MICU_GetGain(gain: *mut u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets whether the microphone is powered on.\n # Arguments\n\n* `power` - Whether the microphone is powered on."]
    pub fn MICU_SetPower(power: bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets whether the microphone is powered on.\n # Arguments\n\n* `power` - Pointer to output the power state to."]
    pub fn MICU_GetPower(power: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets whether to clamp microphone input.\n # Arguments\n\n* `clamp` - Whether to clamp microphone input."]
    pub fn MICU_SetClamp(clamp: bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets whether to clamp microphone input.\n # Arguments\n\n* `clamp` - Pointer to output the clamp state to."]
    pub fn MICU_GetClamp(clamp: *mut bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets whether to allow sampling when the shell is closed.\n # Arguments\n\n* `allowShellClosed` - Whether to allow sampling when the shell is closed."]
    pub fn MICU_SetAllowShellClosed(allowShellClosed: bool) -> Result;
}
#[doc = "< Converting color formats."]
pub const MVDMODE_COLORFORMATCONV: MVDSTD_Mode = 0;
#[doc = "< Processing video."]
pub const MVDMODE_VIDEOPROCESSING: MVDSTD_Mode = 1;
#[doc = "Processing mode."]
pub type MVDSTD_Mode = ::libc::c_uint;
#[doc = "< YUYV422"]
pub const MVD_INPUT_YUYV422: MVDSTD_InputFormat = 65537;
#[doc = "< H264"]
pub const MVD_INPUT_H264: MVDSTD_InputFormat = 131073;
#[doc = "Input format."]
pub type MVDSTD_InputFormat = ::libc::c_uint;
#[doc = "< YUYV422"]
pub const MVD_OUTPUT_YUYV422: MVDSTD_OutputFormat = 65537;
#[doc = "< BGR565"]
pub const MVD_OUTPUT_BGR565: MVDSTD_OutputFormat = 262146;
#[doc = "< RGB565"]
pub const MVD_OUTPUT_RGB565: MVDSTD_OutputFormat = 262148;
#[doc = "Output format."]
pub type MVDSTD_OutputFormat = ::libc::c_uint;
#[doc = "Processing configuration."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MVDSTD_Config {
    #[doc = "< Input type."]
    pub input_type: MVDSTD_InputFormat,
    #[doc = "< Unknown."]
    pub unk_x04: u32_,
    #[doc = "< Unknown. Referred to as \"H264 range\" in SKATER."]
    pub unk_x08: u32_,
    #[doc = "< Input width."]
    pub inwidth: u32_,
    #[doc = "< Input height."]
    pub inheight: u32_,
    #[doc = "< Physical address of color conversion input data."]
    pub physaddr_colorconv_indata: u32_,
    #[doc = "< Physical address used with color conversion."]
    pub physaddr_colorconv_unk0: u32_,
    #[doc = "< Physical address used with color conversion."]
    pub physaddr_colorconv_unk1: u32_,
    #[doc = "< Physical address used with color conversion."]
    pub physaddr_colorconv_unk2: u32_,
    #[doc = "< Physical address used with color conversion."]
    pub physaddr_colorconv_unk3: u32_,
    #[doc = "< Unknown."]
    pub unk_x28: [u32_; 6usize],
    #[doc = "< Enables cropping with the input image when non-zero via the following 4 words."]
    pub enable_cropping: u32_,
    pub input_crop_x_pos: u32_,
    pub input_crop_y_pos: u32_,
    pub input_crop_height: u32_,
    pub input_crop_width: u32_,
    #[doc = "< Unknown."]
    pub unk_x54: u32_,
    #[doc = "< Output type."]
    pub output_type: MVDSTD_OutputFormat,
    #[doc = "< Output width."]
    pub outwidth: u32_,
    #[doc = "< Output height."]
    pub outheight: u32_,
    #[doc = "< Physical address of output data."]
    pub physaddr_outdata0: u32_,
    #[doc = "< Additional physical address for output data, only used when the output format type is value 0x00020001."]
    pub physaddr_outdata1: u32_,
    #[doc = "< Unknown."]
    pub unk_x6c: [u32_; 38usize],
    #[doc = "< This enables using the following 4 words when non-zero."]
    pub flag_x104: u32_,
    #[doc = "< Output X position in the output buffer."]
    pub output_x_pos: u32_,
    #[doc = "< Same as above except for the Y pos."]
    pub output_y_pos: u32_,
    #[doc = "< Used for aligning the output width when larger than the output width. Overrides the output width when smaller than the output width."]
    pub output_width_override: u32_,
    #[doc = "< Same as output_width_override except for the output height."]
    pub output_height_override: u32_,
    pub unk_x118: u32_,
}
impl Default for MVDSTD_Config {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MVDSTD_ProcessNALUnitOut {
    pub end_vaddr: u32_,
    pub end_physaddr: u32_,
    pub remaining_size: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MVDSTD_OutputBuffersEntry {
    pub outdata0: *mut ::libc::c_void,
    pub outdata1: *mut ::libc::c_void,
}
impl Default for MVDSTD_OutputBuffersEntry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MVDSTD_OutputBuffersEntryList {
    pub total_entries: u32_,
    pub entries: [MVDSTD_OutputBuffersEntry; 17usize],
}
impl Default for MVDSTD_OutputBuffersEntryList {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "This can be used to override the default input values for MVDSTD commands during initialization with video-processing. The default for these fields are all-zero, except for cmd1b_inval which is 1. See also here: https://www.3dbrew.org/wiki/MVD_Services"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MVDSTD_InitStruct {
    pub cmd5_inval0: s8,
    pub cmd5_inval1: s8,
    pub cmd5_inval2: s8,
    pub cmd5_inval3: u32_,
    pub cmd1b_inval: u8_,
}
extern "C" {
    #[must_use]
    #[doc = "Initializes MVDSTD.\n # Arguments\n\n* `mode` - Mode to initialize MVDSTD to.\n * `input_type` - Type of input to process.\n * `output_type` - Type of output to produce.\n * `size` - Size of the work buffer, MVD_DEFAULT_WORKBUF_SIZE can be used for this. Only used when type == MVDMODE_VIDEOPROCESSING.\n * `initstruct` - Optional MVDSTD_InitStruct, this should be NULL normally."]
    pub fn mvdstdInit(
        mode: MVDSTD_Mode,
        input_type: MVDSTD_InputFormat,
        output_type: MVDSTD_OutputFormat,
        size: u32_,
        initstruct: *mut MVDSTD_InitStruct,
    ) -> Result;
}
extern "C" {
    #[doc = "Shuts down MVDSTD."]
    pub fn mvdstdExit();
}
extern "C" {
    #[doc = "Generates a default MVDSTD configuration.\n # Arguments\n\n* `config` - Pointer to output the generated config to.\n * `input_width` - Input width.\n * `input_height` - Input height.\n * `output_width` - Output width.\n * `output_height` - Output height.\n * `vaddr_colorconv_indata` - Virtual address of the color conversion input data.\n * `vaddr_outdata0` - Virtual address of the output data.\n * `vaddr_outdata1` - Additional virtual address for output data, only used when the output format type is value 0x00020001."]
    pub fn mvdstdGenerateDefaultConfig(
        config: *mut MVDSTD_Config,
        input_width: u32_,
        input_height: u32_,
        output_width: u32_,
        output_height: u32_,
        vaddr_colorconv_indata: *mut u32_,
        vaddr_outdata0: *mut u32_,
        vaddr_outdata1: *mut u32_,
    );
}
extern "C" {
    #[must_use]
    #[doc = "Run color-format-conversion.\n # Arguments\n\n* `config` - Pointer to the configuration to use."]
    pub fn mvdstdConvertImage(config: *mut MVDSTD_Config) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Processes a video frame(specifically a NAL-unit).\n # Arguments\n\n* `inbuf_vaddr` - Input NAL-unit starting with the 3-byte \"00 00 01\" prefix. Must be located in linearmem.\n * `size` - Size of the input buffer.\n * `flag` - See here regarding this input flag: https://www.3dbrew.org/wiki/MVDSTD:ProcessNALUnit\n * `out` - Optional output MVDSTD_ProcessNALUnitOut structure."]
    pub fn mvdstdProcessVideoFrame(
        inbuf_vaddr: *mut ::libc::c_void,
        size: usize,
        flag: u32_,
        out: *mut MVDSTD_ProcessNALUnitOut,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Renders the video frame.\n # Arguments\n\n* `config` - Optional pointer to the configuration to use. When NULL, MVDSTD_SetConfig() should have been used previously for this video.\n * `wait` - When true, wait for rendering to finish. When false, you can manually call this function repeatedly until it stops returning MVD_STATUS_BUSY."]
    pub fn mvdstdRenderVideoFrame(config: *mut MVDSTD_Config, wait: bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the current configuration of MVDSTD.\n # Arguments\n\n* `config` - Pointer to the configuration to set."]
    pub fn MVDSTD_SetConfig(config: *mut MVDSTD_Config) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "New3DS Internet Browser doesn't use this. Once done, rendered frames will be written to the output buffers specified by the entrylist instead of the output specified by configuration. See here: https://www.3dbrew.org/wiki/MVDSTD:SetupOutputBuffers\n # Arguments\n\n* `entrylist` - Input entrylist.\n * `bufsize` - Size of each buffer from the entrylist."]
    pub fn mvdstdSetupOutputBuffers(
        entrylist: *mut MVDSTD_OutputBuffersEntryList,
        bufsize: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "New3DS Internet Browser doesn't use this. This overrides the entry0 output buffers originally setup by mvdstdSetupOutputBuffers(). See also here: https://www.3dbrew.org/wiki/MVDSTD:OverrideOutputBuffers\n # Arguments\n\n* `cur_outdata0` - Linearmem vaddr. The current outdata0 for this entry must match this value.\n * `cur_outdata1` - Linearmem vaddr. The current outdata1 for this entry must match this value.\n * `new_outdata0` - Linearmem vaddr. This is the new address to use for outaddr0.\n * `new_outdata1` - Linearmem vaddr. This is the new address to use for outaddr1."]
    pub fn mvdstdOverrideOutputBuffers(
        cur_outdata0: *mut ::libc::c_void,
        cur_outdata1: *mut ::libc::c_void,
        new_outdata0: *mut ::libc::c_void,
        new_outdata1: *mut ::libc::c_void,
    ) -> Result;
}
pub const NFC_OpType_1: NFC_OpType = 1;
#[doc = "Unknown."]
pub const NFC_OpType_NFCTag: NFC_OpType = 2;
#[doc = "This is the default."]
pub const NFC_OpType_RawNFC: NFC_OpType = 3;
#[doc = "NFC operation type."]
pub type NFC_OpType = ::libc::c_uint;
pub const NFC_TagState_Uninitialized: NFC_TagState = 0;
#[doc = "nfcInit() was not used yet."]
pub const NFC_TagState_ScanningStopped: NFC_TagState = 1;
#[doc = "Not currently scanning for NFC tags. Set by nfcStopScanning() and nfcInit(), when successful."]
pub const NFC_TagState_Scanning: NFC_TagState = 2;
#[doc = "Currently scanning for NFC tags. Set by nfcStartScanning() when successful."]
pub const NFC_TagState_InRange: NFC_TagState = 3;
#[doc = "NFC tag is in range. The state automatically changes to this when the state was previously value 2, without using any NFC service commands."]
pub const NFC_TagState_OutOfRange: NFC_TagState = 4;
#[doc = "NFC tag is now out of range, where the NFC tag was previously in range. This occurs automatically without using any NFC service commands. Once this state is entered, it won't automatically change to anything else when the tag is moved in range again. Hence, if you want to keep doing tag scanning after this, you must stop+start scanning."]
pub const NFC_TagState_DataReady: NFC_TagState = 5;
pub type NFC_TagState = ::libc::c_uint;
pub const NFC_amiiboFlag_Setup: _bindgen_ty_28 = 16;
#[doc = "This indicates that the amiibo was setup with amiibo Settings. nfcGetAmiiboSettings() will return an all-zero struct when this is not set."]
pub const NFC_amiiboFlag_AppDataSetup: _bindgen_ty_28 = 32;
#[doc = "Bit4-7 are always clear with nfcGetAmiiboSettings() due to \"& 0xF\"."]
pub type _bindgen_ty_28 = ::libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NFC_TagInfo {
    pub id_offset_size: u16_,
    #[doc = "\"u16 size/offset of the below ID data. Normally this is 0x7. When this is <=10, this field is the size of the below ID data. When this is >10, this is the offset of the 10-byte ID data, relative to structstart+4+<offsetfield-10>. It's unknown in what cases this 10-byte ID data is used.\""]
    pub unk_x2: u8_,
    pub unk_x3: u8_,
    pub id: [u8_; 40usize],
}
impl Default for NFC_TagInfo {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "AmiiboSettings structure, see also here: https://3dbrew.org/wiki/NFC:GetAmiiboSettings"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NFC_AmiiboSettings {
    pub mii: [u8_; 96usize],
    #[doc = "\"Owner Mii.\""]
    pub nickname: [u16_; 11usize],
    #[doc = "\"UTF-16BE Amiibo nickname.\""]
    pub flags: u8_,
    #[doc = "\"This is plaintext_amiibosettingsdata[0] & 0xF.\" See also the NFC_amiiboFlag enums."]
    pub countrycodeid: u8_,
    #[doc = "\"This is plaintext_amiibosettingsdata[1].\" \"Country Code ID, from the system which setup this amiibo.\""]
    pub setupdate_year: u16_,
    pub setupdate_month: u8_,
    pub setupdate_day: u8_,
    pub unk_x7c: [u8_; 44usize],
}
impl Default for NFC_AmiiboSettings {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "AmiiboConfig structure, see also here: https://3dbrew.org/wiki/NFC:GetAmiiboConfig"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NFC_AmiiboConfig {
    pub lastwritedate_year: u16_,
    pub lastwritedate_month: u8_,
    pub lastwritedate_day: u8_,
    pub write_counter: u16_,
    pub characterID: [u8_; 3usize],
    #[doc = "the first element is the collection ID, the second the character in this collection, the third the variant"]
    pub series: u8_,
    #[doc = "ID of the series"]
    pub amiiboID: u16_,
    #[doc = "ID shared by all exact same amiibo. Some amiibo are only distinguished by this one like regular SMB Series Mario and the gold one"]
    pub type_: u8_,
    #[doc = "Type of amiibo 0 = figure, 1 = card, 2 = plush"]
    pub pagex4_byte3: u8_,
    pub appdata_size: u16_,
    #[doc = "\"NFC module writes hard-coded u8 value 0xD8 here. This is the size of the Amiibo AppData, apps can use this with the AppData R/W commands. ...\""]
    pub zeros: [u8_; 48usize],
}
impl Default for NFC_AmiiboConfig {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Used by nfcInitializeWriteAppData() internally, see also here: https://3dbrew.org/wiki/NFC:GetAppDataInitStruct"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NFC_AppDataInitStruct {
    pub data_x0: [u8_; 12usize],
    pub data_xc: [u8_; 48usize],
}
impl Default for NFC_AppDataInitStruct {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Used by nfcWriteAppData() internally, see also: https://3dbrew.org/wiki/NFC:WriteAppData"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NFC_AppDataWriteStruct {
    pub id: [u8_; 10usize],
    pub id_size: u8_,
    pub unused_xb: [u8_; 21usize],
}
extern "C" {
    #[must_use]
    #[doc = "Initializes NFC.\n # Arguments\n\n* `type` - See the NFC_OpType enum."]
    pub fn nfcInit(type_: NFC_OpType) -> Result;
}
extern "C" {
    #[doc = "Shuts down NFC."]
    pub fn nfcExit();
}
extern "C" {
    #[doc = "Gets the NFC service handle.\n # Returns\n\nThe NFC service handle."]
    pub fn nfcGetSessionHandle() -> Handle;
}
extern "C" {
    #[must_use]
    #[doc = "Starts scanning for NFC tags.\n # Arguments\n\n* `inval` - Unknown. See NFC_STARTSCAN_DEFAULTINPUT."]
    pub fn nfcStartScanning(inval: u16_) -> Result;
}
extern "C" {
    #[doc = "Stops scanning for NFC tags."]
    pub fn nfcStopScanning();
}
extern "C" {
    #[must_use]
    #[doc = "Read amiibo NFC data and load in memory."]
    pub fn nfcLoadAmiiboData() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "If the tagstate is valid(NFC_TagState_DataReady or 6), it then sets the current tagstate to NFC_TagState_InRange."]
    pub fn nfcResetTagScanState() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "This writes the amiibo data stored in memory to the actual amiibo data storage(which is normally the NFC data pages). This can only be used if NFC_LoadAmiiboData() was used previously."]
    pub fn nfcUpdateStoredAmiiboData() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Returns the current NFC tag state.\n # Arguments\n\n* `state` - Pointer to write NFC tag state."]
    pub fn nfcGetTagState(state: *mut NFC_TagState) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Returns the current TagInfo.\n # Arguments\n\n* `out` - Pointer to write the output TagInfo."]
    pub fn nfcGetTagInfo(out: *mut NFC_TagInfo) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Opens the appdata, when the amiibo appdata was previously initialized. This must be used before reading/writing the appdata. See also: https://3dbrew.org/wiki/NFC:OpenAppData\n # Arguments\n\n* `amiibo_appid` - Amiibo AppID. See here: https://www.3dbrew.org/wiki/Amiibo"]
    pub fn nfcOpenAppData(amiibo_appid: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "This initializes the appdata using the specified input, when the appdata previously wasn't initialized. If the appdata is already initialized, you must first use the amiibo Settings applet menu option labeled \"Delete amiibo Game Data\". This automatically writes the amiibo data into the actual data storage(normally NFC data pages). See also nfcWriteAppData().\n # Arguments\n\n* `amiibo_appid` - amiibo AppID. See also nfcOpenAppData().\n * `buf` - Input buffer.\n * `size` - Buffer size."]
    pub fn nfcInitializeWriteAppData(
        amiibo_appid: u32_,
        buf: *const ::libc::c_void,
        size: usize,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Reads the appdata. The size must be >=0xD8-bytes, but the actual used size is hard-coded to 0xD8. Note that areas of appdata which were never written to by applications are uninitialized in this output buffer.\n # Arguments\n\n* `buf` - Output buffer.\n * `size` - Buffer size."]
    pub fn nfcReadAppData(buf: *mut ::libc::c_void, size: usize) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Writes the appdata, after nfcOpenAppData() was used successfully. The size should be <=0xD8-bytes. See also: https://3dbrew.org/wiki/NFC:WriteAppData\n # Arguments\n\n* `buf` - Input buffer.\n * `size` - Buffer size.\n * `taginfo` - TagInfo from nfcGetTagInfo()."]
    pub fn nfcWriteAppData(
        buf: *const ::libc::c_void,
        size: usize,
        taginfo: *mut NFC_TagInfo,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Returns the current AmiiboSettings.\n # Arguments\n\n* `out` - Pointer to write the output AmiiboSettings."]
    pub fn nfcGetAmiiboSettings(out: *mut NFC_AmiiboSettings) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Returns the current AmiiboConfig.\n # Arguments\n\n* `out` - Pointer to write the output AmiiboConfig."]
    pub fn nfcGetAmiiboConfig(out: *mut NFC_AmiiboConfig) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Starts scanning for NFC tags when initialized with NFC_OpType_RawNFC. See also: https://www.3dbrew.org/wiki/NFC:StartOtherTagScanning\n # Arguments\n\n* `unk0` - Same as nfcStartScanning() input.\n * `unk1` - Unknown."]
    pub fn nfcStartOtherTagScanning(unk0: u16_, unk1: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "This sends a raw NFC command to the tag. This can only be used when initialized with NFC_OpType_RawNFC, and when the TagState is NFC_TagState_InRange. See also: https://www.3dbrew.org/wiki/NFC:SendTagCommand\n # Arguments\n\n* `inbuf` - Input buffer.\n * `insize` - Size of the input buffer.\n * `outbuf` - Output buffer.\n * `outsize` - Size of the output buffer.\n * `actual_transfer_size` - Optional output ptr to write the actual output-size to, can be NULL.\n * `microseconds` - Timing-related field in microseconds."]
    pub fn nfcSendTagCommand(
        inbuf: *const ::libc::c_void,
        insize: usize,
        outbuf: *mut ::libc::c_void,
        outsize: usize,
        actual_transfer_size: *mut usize,
        microseconds: u64_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Unknown. This can only be used when initialized with NFC_OpType_RawNFC, and when the TagState is NFC_TagState_InRange."]
    pub fn nfcCmd21() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Unknown. This can only be used when initialized with NFC_OpType_RawNFC, and when the TagState is NFC_TagState_InRange."]
    pub fn nfcCmd22() -> Result;
}
#[doc = "Notification header data."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct NotificationHeader {
    pub dataSet: bool,
    pub unread: bool,
    pub enableJPEG: bool,
    pub isSpotPass: bool,
    pub isOptedOut: bool,
    pub unkData: [u8_; 3usize],
    pub processID: u64_,
    pub unkData2: [u8_; 8usize],
    pub jumpParam: u64_,
    pub unkData3: [u8_; 8usize],
    pub time: u64_,
    pub title: [u16_; 32usize],
}
extern "C" {
    #[must_use]
    #[doc = "Initializes NEWS."]
    pub fn newsInit() -> Result;
}
extern "C" {
    #[doc = "Exits NEWS."]
    pub fn newsExit();
}
extern "C" {
    #[must_use]
    #[doc = "Adds a notification to the home menu Notifications applet.\n # Arguments\n\n* `title` - UTF-16 title of the notification.\n * `titleLength` - Number of characters in the title, not including the null-terminator.\n * `message` - UTF-16 message of the notification, or NULL for no message.\n * `messageLength` - Number of characters in the message, not including the null-terminator.\n * `image` - Data of the image to show in the notification, or NULL for no image.\n * `imageSize` - Size of the image data in bytes.\n * `jpeg` - Whether the image is a JPEG or not."]
    pub fn NEWS_AddNotification(
        title: *const u16_,
        titleLength: u32_,
        message: *const u16_,
        messageLength: u32_,
        imageData: *const ::libc::c_void,
        imageSize: u32_,
        jpeg: bool,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets current total notifications number.\n # Arguments\n\n* `num` - Pointer where total number will be saved."]
    pub fn NEWS_GetTotalNotifications(num: *mut u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets a custom header for a specific notification.\n # Arguments\n\n* `news_id` - Identification number of the notification.\n * `header` - Pointer to notification header to set."]
    pub fn NEWS_SetNotificationHeader(news_id: u32_, header: *const NotificationHeader) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the header of a specific notification.\n # Arguments\n\n* `news_id` - Identification number of the notification.\n * `header` - Pointer where header of the notification will be saved."]
    pub fn NEWS_GetNotificationHeader(news_id: u32_, header: *mut NotificationHeader) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets a custom message for a specific notification.\n # Arguments\n\n* `news_id` - Identification number of the notification.\n * `message` - Pointer to UTF-16 message to set.\n * `size` - Size of message to set."]
    pub fn NEWS_SetNotificationMessage(news_id: u32_, message: *const u16_, size: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the message of a specific notification.\n # Arguments\n\n* `news_id` - Identification number of the notification.\n * `message` - Pointer where UTF-16 message of the notification will be saved.\n * `size` - Pointer where size of the message data will be saved in bytes."]
    pub fn NEWS_GetNotificationMessage(
        news_id: u32_,
        message: *mut u16_,
        size: *mut u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets a custom image for a specific notification.\n # Arguments\n\n* `news_id` - Identification number of the notification.\n * `buffer` - Pointer to MPO image to set.\n * `size` - Size of the MPO image to set."]
    pub fn NEWS_SetNotificationImage(
        news_id: u32_,
        buffer: *const ::libc::c_void,
        size: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the image of a specific notification.\n # Arguments\n\n* `news_id` - Identification number of the notification.\n * `buffer` - Pointer where MPO image of the notification will be saved.\n * `size` - Pointer where size of the image data will be saved in bytes."]
    pub fn NEWS_GetNotificationImage(
        news_id: u32_,
        buffer: *mut ::libc::c_void,
        size: *mut u32_,
    ) -> Result;
}
#[doc = "Head tracking coordinate pair."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct QTM_HeadTrackingInfoCoord {
    #[doc = "< X coordinate."]
    pub x: f32,
    #[doc = "< Y coordinate."]
    pub y: f32,
}
#[doc = "Head tracking info."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct QTM_HeadTrackingInfo {
    #[doc = "< Flags."]
    pub flags: [u8_; 5usize],
    #[doc = "< Padding."]
    pub padding: [u8_; 3usize],
    #[doc = "< Unknown. Not used by System_Settings."]
    pub floatdata_x08: f32,
    #[doc = "< Head coordinates."]
    pub coords0: [QTM_HeadTrackingInfoCoord; 4usize],
    #[doc = "< Unknown. Not used by System_Settings."]
    pub unk_x2c: [u32_; 5usize],
}
extern "C" {
    #[must_use]
    #[doc = "Initializes QTM."]
    pub fn qtmInit() -> Result;
}
extern "C" {
    #[doc = "Exits QTM."]
    pub fn qtmExit();
}
extern "C" {
    #[doc = "Checks whether QTM is initialized.\n # Returns\n\nWhether QTM is initialized."]
    pub fn qtmCheckInitialized() -> bool;
}
extern "C" {
    #[doc = "Checks whether a head is fully detected.\n # Arguments\n\n* `info` - Tracking info to check."]
    pub fn qtmCheckHeadFullyDetected(info: *mut QTM_HeadTrackingInfo) -> bool;
}
extern "C" {
    #[must_use]
    #[doc = "Converts QTM coordinates to screen coordinates.\n # Arguments\n\n* `coord` - Coordinates to convert.\n * `screen_width` - Width of the screen. Can be NULL to use the default value for the top screen.\n * `screen_height` - Height of the screen. Can be NULL to use the default value for the top screen.\n * `x` - Pointer to output the screen X coordinate to.\n * `y` - Pointer to output the screen Y coordinate to."]
    pub fn qtmConvertCoordToScreen(
        coord: *mut QTM_HeadTrackingInfoCoord,
        screen_width: *mut f32,
        screen_height: *mut f32,
        x: *mut u32_,
        y: *mut u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the current head tracking info.\n # Arguments\n\n* `val` - Normally 0.\n * `out` - Pointer to write head tracking info to."]
    pub fn QTM_GetHeadTrackingInfo(val: u64_, out: *mut QTM_HeadTrackingInfo) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initializes srv:pm and the service API."]
    pub fn srvPmInit() -> Result;
}
extern "C" {
    #[doc = "Exits srv:pm and the service API."]
    pub fn srvPmExit();
}
extern "C" {
    #[doc = "Gets the current srv:pm session handle.\n # Returns\n\nThe current srv:pm session handle."]
    pub fn srvPmGetSessionHandle() -> *mut Handle;
}
extern "C" {
    #[must_use]
    #[doc = "Publishes a notification to a process.\n # Arguments\n\n* `notificationId` - ID of the notification.\n * `process` - Process to publish to."]
    pub fn SRVPM_PublishToProcess(notificationId: u32_, process: Handle) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Publishes a notification to all processes.\n # Arguments\n\n* `notificationId` - ID of the notification."]
    pub fn SRVPM_PublishToAll(notificationId: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Registers a process with SRV.\n # Arguments\n\n* `pid` - ID of the process.\n * `count` - Number of services within the service access control data.\n * `serviceAccessControlList` - Service Access Control list."]
    pub fn SRVPM_RegisterProcess(
        pid: u32_,
        count: u32_,
        serviceAccessControlList: *const [::libc::c_char; 8usize],
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Unregisters a process with SRV.\n # Arguments\n\n* `pid` - ID of the process."]
    pub fn SRVPM_UnregisterProcess(pid: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initializes LOADER."]
    pub fn loaderInit() -> Result;
}
extern "C" {
    #[doc = "Exits LOADER."]
    pub fn loaderExit();
}
extern "C" {
    #[must_use]
    #[doc = "Loads a program and returns a process handle to the newly created process.\n # Arguments\n\n* `process` (direction out) - Pointer to output the process handle to.\n * `programHandle` - The handle of the program to load."]
    pub fn LOADER_LoadProcess(process: *mut Handle, programHandle: u64_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Registers a program (along with its update).\n # Arguments\n\n* `programHandle` (direction out) - Pointer to output the program handle to.\n * `programInfo` - The program info.\n * `programInfo` - The program update info."]
    pub fn LOADER_RegisterProgram(
        programHandle: *mut u64_,
        programInfo: *const FS_ProgramInfo,
        programInfoUpdate: *const FS_ProgramInfo,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Unregisters a program (along with its update).\n # Arguments\n\n* `programHandle` - The handle of the program to unregister."]
    pub fn LOADER_UnregisterProgram(programHandle: u64_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Retrives a program's main NCCH extended header info (SCI + ACI, see ExHeader_Info).\n # Arguments\n\n* `exheaderInfo` (direction out) - Pointer to output the main NCCH extended header info.\n * `programHandle` - The handle of the program to unregister"]
    pub fn LOADER_GetProgramInfo(exheaderInfo: *mut ExHeader_Info, programHandle: u64_) -> Result;
}
#[doc = "< The normal mode of the led"]
pub const LED_NORMAL: powerLedState = 1;
#[doc = "< The led pulses slowly as it does in the sleep mode"]
pub const LED_SLEEP_MODE: powerLedState = 2;
#[doc = "< Switch off power led"]
pub const LED_OFF: powerLedState = 3;
#[doc = "< Red state of the led"]
pub const LED_RED: powerLedState = 4;
#[doc = "< Blue state of the led"]
pub const LED_BLUE: powerLedState = 5;
#[doc = "< Blinking red state of power led and notification led"]
pub const LED_BLINK_RED: powerLedState = 6;
pub type powerLedState = ::libc::c_uint;
extern "C" {
    #[must_use]
    #[doc = "Initializes mcuHwc."]
    pub fn mcuHwcInit() -> Result;
}
extern "C" {
    #[doc = "Exits mcuHwc."]
    pub fn mcuHwcExit();
}
extern "C" {
    #[doc = "Gets the current mcuHwc session handle.\n # Returns\n\nA pointer to the current mcuHwc session handle."]
    pub fn mcuHwcGetSessionHandle() -> *mut Handle;
}
extern "C" {
    #[must_use]
    #[doc = "Reads data from an i2c device3 register\n # Arguments\n\n* `reg` - Register number. See https://www.3dbrew.org/wiki/I2C_Registers#Device_3 for more info\n * `data` - Pointer to write the data to.\n * `size` - Size of data to be read"]
    pub fn MCUHWC_ReadRegister(reg: u8_, data: *mut ::libc::c_void, size: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Writes data to a i2c device3 register\n # Arguments\n\n* `reg` - Register number. See https://www.3dbrew.org/wiki/I2C_Registers#Device_3 for more info\n * `data` - Pointer to write the data to.\n * `size` - Size of data to be written"]
    pub fn MCUHWC_WriteRegister(reg: u8_, data: *const ::libc::c_void, size: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the battery voltage\n # Arguments\n\n* `voltage` - Pointer to write the battery voltage to."]
    pub fn MCUHWC_GetBatteryVoltage(voltage: *mut u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the battery level\n # Arguments\n\n* `level` - Pointer to write the current battery level to."]
    pub fn MCUHWC_GetBatteryLevel(level: *mut u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the sound slider level\n # Arguments\n\n* `level` - Pointer to write the slider level to."]
    pub fn MCUHWC_GetSoundSliderLevel(level: *mut u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets Wifi LED state\n # Arguments\n\n* `state` - State of Wifi LED. (True/False)"]
    pub fn MCUHWC_SetWifiLedState(state: bool) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets Power LED state\n # Arguments\n\n* `state` - powerLedState State of power LED."]
    pub fn MCUHWC_SetPowerLedState(state: powerLedState) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets 3d slider level\n # Arguments\n\n* `level` - Pointer to write 3D slider level to."]
    pub fn MCUHWC_Get3dSliderLevel(level: *mut u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the major MCU firmware version\n # Arguments\n\n* `out` - Pointer to write the major firmware version to."]
    pub fn MCUHWC_GetFwVerHigh(out: *mut u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets the minor MCU firmware version\n # Arguments\n\n* `out` - Pointer to write the minor firmware version to."]
    pub fn MCUHWC_GetFwVerLow(out: *mut u8_) -> Result;
}
#[doc = "< Primary I2S line, used by DSP/Mic (configurable)/GBA sound controller."]
pub const CODEC_I2S_LINE_1: CodecI2sLine = 0;
#[doc = "< Secondary I2S line, used by CSND hardware."]
pub const CODEC_I2S_LINE_2: CodecI2sLine = 1;
#[doc = "I2S line enumeration"]
pub type CodecI2sLine = ::libc::c_uint;
extern "C" {
    #[must_use]
    #[doc = "Initializes CDCCHK."]
    pub fn cdcChkInit() -> Result;
}
extern "C" {
    #[doc = "Exits CDCCHK."]
    pub fn cdcChkExit();
}
extern "C" {
    #[doc = "Gets a pointer to the current cdc:CHK session handle.\n # Returns\n\nA pointer to the current cdc:CHK session handle."]
    pub fn cdcChkGetSessionHandle() -> *mut Handle;
}
extern "C" {
    #[must_use]
    #[doc = "Reads multiple registers from the CODEC, using the old\n SPI hardware interface and a 4MHz baudrate.\n # Arguments\n\n* `pageId` - CODEC Page ID.\n * `initialRegAddr` - Address of the CODEC register to start with.\n * `outData` (direction out) - Where to write the read data to.\n * `size` - Number of registers to read (bytes to read, max. 64)."]
    pub fn CDCCHK_ReadRegisters1(
        pageId: u8_,
        initialRegAddr: u8_,
        outData: *mut ::libc::c_void,
        size: usize,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Reads multiple registers from the CODEC, using the new\n SPI hardware interface and a 16MHz baudrate.\n # Arguments\n\n* `pageId` - CODEC Page ID.\n * `initialRegAddr` - Address of the CODEC register to start with.\n * `outData` (direction out) - Where to read the data to.\n * `size` - Number of registers to read (bytes to read, max. 64)."]
    pub fn CDCCHK_ReadRegisters2(
        pageId: u8_,
        initialRegAddr: u8_,
        outData: *mut ::libc::c_void,
        size: usize,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Writes multiple registers to the CODEC, using the old\n SPI hardware interface and a 4MHz baudrate.\n # Arguments\n\n* `pageId` - CODEC Page ID.\n * `initialRegAddr` - Address of the CODEC register to start with.\n * `data` - Where to read the data to write from.\n * `size` - Number of registers to write (bytes to read, max. 64)."]
    pub fn CDCCHK_WriteRegisters1(
        pageId: u8_,
        initialRegAddr: u8_,
        data: *const ::libc::c_void,
        size: usize,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Writes multiple registers to the CODEC, using the new\n SPI hardware interface and a 16MHz baudrate.\n # Arguments\n\n* `pageId` - CODEC Page ID.\n * `initialRegAddr` - Address of the CODEC register to start with.\n * `data` - Where to read the data to write from.\n * `size` - Number of registers to write (bytes to read, max. 64)."]
    pub fn CDCCHK_WriteRegisters2(
        pageId: u8_,
        initialRegAddr: u8_,
        data: *const ::libc::c_void,
        size: usize,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Reads a single register from the NTR PMIC.\n # Arguments\n\n* `outData` (direction out) - Where to read the data to (1 byte).\n * `regAddr` - Register address.\n > **Note:** The NTR PMIC is emulated by the CODEC hardware and sends\n IRQs to the MCU when relevant."]
    pub fn CDCCHK_ReadNtrPmicRegister(outData: *mut u8_, regAddr: u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Writes a single register from the NTR PMIC.\n # Arguments\n\n* `regAddr` - Register address.\n * `data` - Data to write (1 byte).\n > **Note:** The NTR PMIC is emulated by the CODEC hardware and sends\n IRQs to the MCU when relevant."]
    pub fn CDCCHK_WriteNtrPmicRegister(regAddr: u8_, data: u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the DAC volume level for the specified I2S line.\n # Arguments\n\n* `i2sLine` - I2S line to set the volume for.\n * `volume` - Volume level (-128 to 0)."]
    pub fn CDCCHK_SetI2sVolume(i2sLine: CodecI2sLine, volume: s8) -> Result;
}
#[doc = "< 8-bit Red + 8-bit Green + 8-bit Blue + 8-bit Alpha"]
pub const GX_TRANSFER_FMT_RGBA8: GX_TRANSFER_FORMAT = 0;
#[doc = "< 8-bit Red + 8-bit Green + 8-bit Blue"]
pub const GX_TRANSFER_FMT_RGB8: GX_TRANSFER_FORMAT = 1;
#[doc = "< 5-bit Red + 6-bit Green + 5-bit Blue"]
pub const GX_TRANSFER_FMT_RGB565: GX_TRANSFER_FORMAT = 2;
#[doc = "< 5-bit Red + 5-bit Green + 5-bit Blue + 1-bit Alpha"]
pub const GX_TRANSFER_FMT_RGB5A1: GX_TRANSFER_FORMAT = 3;
#[doc = "< 4-bit Red + 4-bit Green + 4-bit Blue + 4-bit Alpha"]
pub const GX_TRANSFER_FMT_RGBA4: GX_TRANSFER_FORMAT = 4;
#[doc = "Supported transfer pixel formats.\n [`GSPGPU_FramebufferFormat`]"]
pub type GX_TRANSFER_FORMAT = ::libc::c_uint;
#[doc = "< No anti-aliasing"]
pub const GX_TRANSFER_SCALE_NO: GX_TRANSFER_SCALE = 0;
#[doc = "< 2x1 anti-aliasing"]
pub const GX_TRANSFER_SCALE_X: GX_TRANSFER_SCALE = 1;
#[doc = "< 2x2 anti-aliasing"]
pub const GX_TRANSFER_SCALE_XY: GX_TRANSFER_SCALE = 2;
#[doc = "Anti-aliasing modes\n\n Please remember that the framebuffer is sideways.\n Hence if you activate 2x1 anti-aliasing the destination dimensions are w = 240*2 and h = 400"]
pub type GX_TRANSFER_SCALE = ::libc::c_uint;
#[doc = "< Trigger the PPF event"]
pub const GX_FILL_TRIGGER: GX_FILL_CONTROL = 1;
#[doc = "< Indicates if the memory fill is complete. You should not use it when requesting a transfer."]
pub const GX_FILL_FINISHED: GX_FILL_CONTROL = 2;
#[doc = "< The buffer has a 16 bit per pixel depth"]
pub const GX_FILL_16BIT_DEPTH: GX_FILL_CONTROL = 0;
#[doc = "< The buffer has a 24 bit per pixel depth"]
pub const GX_FILL_24BIT_DEPTH: GX_FILL_CONTROL = 256;
#[doc = "< The buffer has a 32 bit per pixel depth"]
pub const GX_FILL_32BIT_DEPTH: GX_FILL_CONTROL = 512;
#[doc = "GX transfer control flags"]
pub type GX_FILL_CONTROL = ::libc::c_uint;
#[doc = "GX command entry"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union gxCmdEntry_s {
    #[doc = "< Raw command data"]
    pub data: [u32_; 8usize],
    pub __bindgen_anon_1: gxCmdEntry_s__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct gxCmdEntry_s__bindgen_ty_1 {
    #[doc = "< Command type"]
    pub type_: u8_,
    pub unk1: u8_,
    pub unk2: u8_,
    pub unk3: u8_,
    #[doc = "< Command arguments"]
    pub args: [u32_; 7usize],
}
impl Default for gxCmdEntry_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "GX command queue structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tag_gxCmdQueue_s {
    #[doc = "< Pointer to array of GX command entries"]
    pub entries: *mut gxCmdEntry_s,
    #[doc = "< Capacity of the command array"]
    pub maxEntries: u16_,
    #[doc = "< Number of commands in the queue"]
    pub numEntries: u16_,
    #[doc = "< Index of the first pending command to be submitted to GX"]
    pub curEntry: u16_,
    #[doc = "< Number of commands completed by GX"]
    pub lastEntry: u16_,
    #[doc = "< User callback"]
    pub callback: ::core::option::Option<unsafe extern "C" fn(arg1: *mut tag_gxCmdQueue_s)>,
    #[doc = "< Data for user callback"]
    pub user: *mut ::libc::c_void,
}
impl Default for tag_gxCmdQueue_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "GX command queue structure"]
pub type gxCmdQueue_s = tag_gxCmdQueue_s;
extern "C" {
    #[doc = "Clears a GX command queue.\n # Arguments\n\n* `queue` - The GX command queue."]
    pub fn gxCmdQueueClear(queue: *mut gxCmdQueue_s);
}
extern "C" {
    #[doc = "Adds a command to a GX command queue.\n # Arguments\n\n* `queue` - The GX command queue.\n * `entry` - The GX command to add."]
    pub fn gxCmdQueueAdd(queue: *mut gxCmdQueue_s, entry: *const gxCmdEntry_s);
}
extern "C" {
    #[doc = "Runs a GX command queue, causing it to begin processing incoming commands as they arrive.\n # Arguments\n\n* `queue` - The GX command queue."]
    pub fn gxCmdQueueRun(queue: *mut gxCmdQueue_s);
}
extern "C" {
    #[doc = "Stops a GX command queue from processing incoming commands.\n # Arguments\n\n* `queue` - The GX command queue."]
    pub fn gxCmdQueueStop(queue: *mut gxCmdQueue_s);
}
extern "C" {
    #[doc = "Waits for a GX command queue to finish executing pending commands.\n # Arguments\n\n* `queue` - The GX command queue.\n * `timeout` - Optional timeout (in nanoseconds) to wait (specify -1 for no timeout).\n # Returns\n\nfalse if timeout expired, true otherwise."]
    pub fn gxCmdQueueWait(queue: *mut gxCmdQueue_s, timeout: s64) -> bool;
}
extern "C" {
    #[doc = "Sets the completion callback for a GX command queue.\n # Arguments\n\n* `queue` - The GX command queue.\n * `callback` - The completion callback.\n * `user` - User data."]
    #[link_name = "gxCmdQueueSetCallback__extern"]
    pub fn gxCmdQueueSetCallback(
        queue: *mut gxCmdQueue_s,
        callback: ::core::option::Option<unsafe extern "C" fn(arg1: *mut gxCmdQueue_s)>,
        user: *mut ::libc::c_void,
    );
}
extern "C" {
    #[doc = "Selects a command queue to which GX_* functions will add commands instead of immediately submitting them to GX.\n # Arguments\n\n* `queue` - The GX command queue. (Pass NULL to remove the bound command queue)"]
    pub fn GX_BindQueue(queue: *mut gxCmdQueue_s);
}
extern "C" {
    #[must_use]
    #[doc = "Requests a DMA.\n # Arguments\n\n* `src` - Source to DMA from.\n * `dst` - Destination to DMA to.\n * `length` - Length of data to transfer."]
    pub fn GX_RequestDma(src: *mut u32_, dst: *mut u32_, length: u32_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Processes a GPU command list.\n # Arguments\n\n* `buf0a` - Command list address.\n * `buf0s` - Command list size.\n * `flags` - Flags to process with."]
    pub fn GX_ProcessCommandList(buf0a: *mut u32_, buf0s: u32_, flags: u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Fills the memory of two buffers with the given values.\n # Arguments\n\n* `buf0a` - Start address of the first buffer.\n * `buf0v` - Dimensions of the first buffer.\n * `buf0e` - End address of the first buffer.\n * `control0` - Value to fill the first buffer with.\n * `buf1a` - Start address of the second buffer.\n * `buf1v` - Dimensions of the second buffer.\n * `buf1e` - End address of the second buffer.\n * `control1` - Value to fill the second buffer with."]
    pub fn GX_MemoryFill(
        buf0a: *mut u32_,
        buf0v: u32_,
        buf0e: *mut u32_,
        control0: u16_,
        buf1a: *mut u32_,
        buf1v: u32_,
        buf1e: *mut u32_,
        control1: u16_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initiates a display transfer.\n > **Note:** The PPF event will be signaled on completion.\n # Arguments\n\n* `inadr` - Address of the input.\n * `indim` - Dimensions of the input.\n * `outadr` - Address of the output.\n * `outdim` - Dimensions of the output.\n * `flags` - Flags to transfer with."]
    pub fn GX_DisplayTransfer(
        inadr: *mut u32_,
        indim: u32_,
        outadr: *mut u32_,
        outdim: u32_,
        flags: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Initiates a texture copy.\n > **Note:** The PPF event will be signaled on completion.\n # Arguments\n\n* `inadr` - Address of the input.\n * `indim` - Dimensions of the input.\n * `outadr` - Address of the output.\n * `outdim` - Dimensions of the output.\n * `size` - Size of the data to transfer.\n * `flags` - Flags to transfer with."]
    pub fn GX_TextureCopy(
        inadr: *mut u32_,
        indim: u32_,
        outadr: *mut u32_,
        outdim: u32_,
        size: u32_,
        flags: u32_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Flushes the cache regions of three buffers. (This command cannot be queued in a GX command queue)\n # Arguments\n\n* `buf0a` - Address of the first buffer.\n * `buf0s` - Size of the first buffer.\n * `buf1a` - Address of the second buffer.\n * `buf1s` - Size of the second buffer.\n * `buf2a` - Address of the third buffer.\n * `buf2s` - Size of the third buffer."]
    pub fn GX_FlushCacheRegions(
        buf0a: *mut u32_,
        buf0s: u32_,
        buf1a: *mut u32_,
        buf1s: u32_,
        buf2a: *mut u32_,
        buf2s: u32_,
    ) -> Result;
}
#[doc = "< Nearest-neighbor interpolation."]
pub const GPU_NEAREST: GPU_TEXTURE_FILTER_PARAM = 0;
#[doc = "< Linear interpolation."]
pub const GPU_LINEAR: GPU_TEXTURE_FILTER_PARAM = 1;
#[doc = "Texture filters."]
pub type GPU_TEXTURE_FILTER_PARAM = ::libc::c_uint;
#[doc = "< Clamps to edge."]
pub const GPU_CLAMP_TO_EDGE: GPU_TEXTURE_WRAP_PARAM = 0;
#[doc = "< Clamps to border."]
pub const GPU_CLAMP_TO_BORDER: GPU_TEXTURE_WRAP_PARAM = 1;
#[doc = "< Repeats texture."]
pub const GPU_REPEAT: GPU_TEXTURE_WRAP_PARAM = 2;
#[doc = "< Repeats with mirrored texture."]
pub const GPU_MIRRORED_REPEAT: GPU_TEXTURE_WRAP_PARAM = 3;
#[doc = "Texture wrap modes."]
pub type GPU_TEXTURE_WRAP_PARAM = ::libc::c_uint;
#[doc = "< 2D texture"]
pub const GPU_TEX_2D: GPU_TEXTURE_MODE_PARAM = 0;
#[doc = "< Cube map"]
pub const GPU_TEX_CUBE_MAP: GPU_TEXTURE_MODE_PARAM = 1;
#[doc = "< 2D Shadow texture"]
pub const GPU_TEX_SHADOW_2D: GPU_TEXTURE_MODE_PARAM = 2;
#[doc = "< Projection texture"]
pub const GPU_TEX_PROJECTION: GPU_TEXTURE_MODE_PARAM = 3;
#[doc = "< Shadow cube map"]
pub const GPU_TEX_SHADOW_CUBE: GPU_TEXTURE_MODE_PARAM = 4;
#[doc = "< Disabled"]
pub const GPU_TEX_DISABLED: GPU_TEXTURE_MODE_PARAM = 5;
#[doc = "Texture modes."]
pub type GPU_TEXTURE_MODE_PARAM = ::libc::c_uint;
#[doc = "< Texture unit 0."]
pub const GPU_TEXUNIT0: GPU_TEXUNIT = 1;
#[doc = "< Texture unit 1."]
pub const GPU_TEXUNIT1: GPU_TEXUNIT = 2;
#[doc = "< Texture unit 2."]
pub const GPU_TEXUNIT2: GPU_TEXUNIT = 4;
#[doc = "Supported texture units."]
pub type GPU_TEXUNIT = ::libc::c_uint;
#[doc = "< 8-bit Red + 8-bit Green + 8-bit Blue + 8-bit Alpha"]
pub const GPU_RGBA8: GPU_TEXCOLOR = 0;
#[doc = "< 8-bit Red + 8-bit Green + 8-bit Blue"]
pub const GPU_RGB8: GPU_TEXCOLOR = 1;
#[doc = "< 5-bit Red + 5-bit Green + 5-bit Blue + 1-bit Alpha"]
pub const GPU_RGBA5551: GPU_TEXCOLOR = 2;
#[doc = "< 5-bit Red + 6-bit Green + 5-bit Blue"]
pub const GPU_RGB565: GPU_TEXCOLOR = 3;
#[doc = "< 4-bit Red + 4-bit Green + 4-bit Blue + 4-bit Alpha"]
pub const GPU_RGBA4: GPU_TEXCOLOR = 4;
#[doc = "< 8-bit Luminance + 8-bit Alpha"]
pub const GPU_LA8: GPU_TEXCOLOR = 5;
#[doc = "< 8-bit Hi + 8-bit Lo"]
pub const GPU_HILO8: GPU_TEXCOLOR = 6;
#[doc = "< 8-bit Luminance"]
pub const GPU_L8: GPU_TEXCOLOR = 7;
#[doc = "< 8-bit Alpha"]
pub const GPU_A8: GPU_TEXCOLOR = 8;
#[doc = "< 4-bit Luminance + 4-bit Alpha"]
pub const GPU_LA4: GPU_TEXCOLOR = 9;
#[doc = "< 4-bit Luminance"]
pub const GPU_L4: GPU_TEXCOLOR = 10;
#[doc = "< 4-bit Alpha"]
pub const GPU_A4: GPU_TEXCOLOR = 11;
#[doc = "< ETC1 texture compression"]
pub const GPU_ETC1: GPU_TEXCOLOR = 12;
#[doc = "< ETC1 texture compression + 4-bit Alpha"]
pub const GPU_ETC1A4: GPU_TEXCOLOR = 13;
#[doc = "Supported texture formats."]
pub type GPU_TEXCOLOR = ::libc::c_uint;
#[doc = "< 2D face"]
pub const GPU_TEXFACE_2D: GPU_TEXFACE = 0;
#[doc = "< +X face"]
pub const GPU_POSITIVE_X: GPU_TEXFACE = 0;
#[doc = "< -X face"]
pub const GPU_NEGATIVE_X: GPU_TEXFACE = 1;
#[doc = "< +Y face"]
pub const GPU_POSITIVE_Y: GPU_TEXFACE = 2;
#[doc = "< -Y face"]
pub const GPU_NEGATIVE_Y: GPU_TEXFACE = 3;
#[doc = "< +Z face"]
pub const GPU_POSITIVE_Z: GPU_TEXFACE = 4;
#[doc = "< -Z face"]
pub const GPU_NEGATIVE_Z: GPU_TEXFACE = 5;
#[doc = "Texture faces."]
pub type GPU_TEXFACE = ::libc::c_uint;
#[doc = "< Clamp to zero."]
pub const GPU_PT_CLAMP_TO_ZERO: GPU_PROCTEX_CLAMP = 0;
#[doc = "< Clamp to edge."]
pub const GPU_PT_CLAMP_TO_EDGE: GPU_PROCTEX_CLAMP = 1;
#[doc = "< Symmetrical repeat."]
pub const GPU_PT_REPEAT: GPU_PROCTEX_CLAMP = 2;
#[doc = "< Mirrored repeat."]
pub const GPU_PT_MIRRORED_REPEAT: GPU_PROCTEX_CLAMP = 3;
#[doc = "< Pulse."]
pub const GPU_PT_PULSE: GPU_PROCTEX_CLAMP = 4;
#[doc = "Procedural texture clamp modes."]
pub type GPU_PROCTEX_CLAMP = ::libc::c_uint;
#[doc = "< U"]
pub const GPU_PT_U: GPU_PROCTEX_MAPFUNC = 0;
#[doc = "< U2"]
pub const GPU_PT_U2: GPU_PROCTEX_MAPFUNC = 1;
#[doc = "< V"]
pub const GPU_PT_V: GPU_PROCTEX_MAPFUNC = 2;
#[doc = "< V2"]
pub const GPU_PT_V2: GPU_PROCTEX_MAPFUNC = 3;
#[doc = "< U+V"]
pub const GPU_PT_ADD: GPU_PROCTEX_MAPFUNC = 4;
#[doc = "< U2+V2"]
pub const GPU_PT_ADD2: GPU_PROCTEX_MAPFUNC = 5;
#[doc = "< sqrt(U2+V2)"]
pub const GPU_PT_SQRT2: GPU_PROCTEX_MAPFUNC = 6;
#[doc = "< min"]
pub const GPU_PT_MIN: GPU_PROCTEX_MAPFUNC = 7;
#[doc = "< max"]
pub const GPU_PT_MAX: GPU_PROCTEX_MAPFUNC = 8;
#[doc = "< rmax"]
pub const GPU_PT_RMAX: GPU_PROCTEX_MAPFUNC = 9;
#[doc = "Procedural texture mapping functions."]
pub type GPU_PROCTEX_MAPFUNC = ::libc::c_uint;
#[doc = "< No shift."]
pub const GPU_PT_NONE: GPU_PROCTEX_SHIFT = 0;
#[doc = "< Odd shift."]
pub const GPU_PT_ODD: GPU_PROCTEX_SHIFT = 1;
#[doc = "< Even shift."]
pub const GPU_PT_EVEN: GPU_PROCTEX_SHIFT = 2;
#[doc = "Procedural texture shift values."]
pub type GPU_PROCTEX_SHIFT = ::libc::c_uint;
#[doc = "< Nearest-neighbor"]
pub const GPU_PT_NEAREST: GPU_PROCTEX_FILTER = 0;
#[doc = "< Linear interpolation"]
pub const GPU_PT_LINEAR: GPU_PROCTEX_FILTER = 1;
#[doc = "< Nearest-neighbor with mipmap using nearest-neighbor"]
pub const GPU_PT_NEAREST_MIP_NEAREST: GPU_PROCTEX_FILTER = 2;
#[doc = "< Linear interpolation with mipmap using nearest-neighbor"]
pub const GPU_PT_LINEAR_MIP_NEAREST: GPU_PROCTEX_FILTER = 3;
#[doc = "< Nearest-neighbor with mipmap using linear interpolation"]
pub const GPU_PT_NEAREST_MIP_LINEAR: GPU_PROCTEX_FILTER = 4;
#[doc = "< Linear interpolation with mipmap using linear interpolation"]
pub const GPU_PT_LINEAR_MIP_LINEAR: GPU_PROCTEX_FILTER = 5;
#[doc = "Procedural texture filter values."]
pub type GPU_PROCTEX_FILTER = ::libc::c_uint;
#[doc = "< Noise table"]
pub const GPU_LUT_NOISE: GPU_PROCTEX_LUTID = 0;
#[doc = "< RGB mapping function table"]
pub const GPU_LUT_RGBMAP: GPU_PROCTEX_LUTID = 2;
#[doc = "< Alpha mapping function table"]
pub const GPU_LUT_ALPHAMAP: GPU_PROCTEX_LUTID = 3;
#[doc = "< Color table"]
pub const GPU_LUT_COLOR: GPU_PROCTEX_LUTID = 4;
#[doc = "< Color difference table"]
pub const GPU_LUT_COLORDIF: GPU_PROCTEX_LUTID = 5;
#[doc = "Procedural texture LUT IDs."]
pub type GPU_PROCTEX_LUTID = ::libc::c_uint;
#[doc = "< 8-bit Red + 8-bit Green + 8-bit Blue + 8-bit Alpha"]
pub const GPU_RB_RGBA8: GPU_COLORBUF = 0;
#[doc = "< 8-bit Red + 8-bit Green + 8-bit Blue"]
pub const GPU_RB_RGB8: GPU_COLORBUF = 1;
#[doc = "< 5-bit Red + 5-bit Green + 5-bit Blue + 1-bit Alpha"]
pub const GPU_RB_RGBA5551: GPU_COLORBUF = 2;
#[doc = "< 5-bit Red + 6-bit Green + 5-bit Blue"]
pub const GPU_RB_RGB565: GPU_COLORBUF = 3;
#[doc = "< 4-bit Red + 4-bit Green + 4-bit Blue + 4-bit Alpha"]
pub const GPU_RB_RGBA4: GPU_COLORBUF = 4;
#[doc = "Supported color buffer formats."]
pub type GPU_COLORBUF = ::libc::c_uint;
#[doc = "< 16-bit Depth"]
pub const GPU_RB_DEPTH16: GPU_DEPTHBUF = 0;
#[doc = "< 24-bit Depth"]
pub const GPU_RB_DEPTH24: GPU_DEPTHBUF = 2;
#[doc = "< 24-bit Depth + 8-bit Stencil"]
pub const GPU_RB_DEPTH24_STENCIL8: GPU_DEPTHBUF = 3;
#[doc = "Supported depth buffer formats."]
pub type GPU_DEPTHBUF = ::libc::c_uint;
#[doc = "< Never pass."]
pub const GPU_NEVER: GPU_TESTFUNC = 0;
#[doc = "< Always pass."]
pub const GPU_ALWAYS: GPU_TESTFUNC = 1;
#[doc = "< Pass if equal."]
pub const GPU_EQUAL: GPU_TESTFUNC = 2;
#[doc = "< Pass if not equal."]
pub const GPU_NOTEQUAL: GPU_TESTFUNC = 3;
#[doc = "< Pass if less than."]
pub const GPU_LESS: GPU_TESTFUNC = 4;
#[doc = "< Pass if less than or equal."]
pub const GPU_LEQUAL: GPU_TESTFUNC = 5;
#[doc = "< Pass if greater than."]
pub const GPU_GREATER: GPU_TESTFUNC = 6;
#[doc = "< Pass if greater than or equal."]
pub const GPU_GEQUAL: GPU_TESTFUNC = 7;
#[doc = "Test functions."]
pub type GPU_TESTFUNC = ::libc::c_uint;
#[doc = "< Pass if greater than or equal."]
pub const GPU_EARLYDEPTH_GEQUAL: GPU_EARLYDEPTHFUNC = 0;
#[doc = "< Pass if greater than."]
pub const GPU_EARLYDEPTH_GREATER: GPU_EARLYDEPTHFUNC = 1;
#[doc = "< Pass if less than or equal."]
pub const GPU_EARLYDEPTH_LEQUAL: GPU_EARLYDEPTHFUNC = 2;
#[doc = "< Pass if less than."]
pub const GPU_EARLYDEPTH_LESS: GPU_EARLYDEPTHFUNC = 3;
#[doc = "Early depth test functions."]
pub type GPU_EARLYDEPTHFUNC = ::libc::c_uint;
#[doc = "< Never pass (0)."]
pub const GPU_GAS_NEVER: GPU_GASDEPTHFUNC = 0;
#[doc = "< Always pass (1)."]
pub const GPU_GAS_ALWAYS: GPU_GASDEPTHFUNC = 1;
#[doc = "< Pass if greater than (1-X)."]
pub const GPU_GAS_GREATER: GPU_GASDEPTHFUNC = 2;
#[doc = "< Pass if less than (X)."]
pub const GPU_GAS_LESS: GPU_GASDEPTHFUNC = 3;
#[doc = "Gas depth functions."]
pub type GPU_GASDEPTHFUNC = ::libc::c_uint;
#[doc = "< Disable."]
pub const GPU_SCISSOR_DISABLE: GPU_SCISSORMODE = 0;
#[doc = "< Exclude pixels inside the scissor box."]
pub const GPU_SCISSOR_INVERT: GPU_SCISSORMODE = 1;
#[doc = "< Exclude pixels outside of the scissor box."]
pub const GPU_SCISSOR_NORMAL: GPU_SCISSORMODE = 3;
#[doc = "Scissor test modes."]
pub type GPU_SCISSORMODE = ::libc::c_uint;
#[doc = "< Keep old value. (old_stencil)"]
pub const GPU_STENCIL_KEEP: GPU_STENCILOP = 0;
#[doc = "< Zero. (0)"]
pub const GPU_STENCIL_ZERO: GPU_STENCILOP = 1;
#[doc = "< Replace value. (ref)"]
pub const GPU_STENCIL_REPLACE: GPU_STENCILOP = 2;
#[doc = "< Increment value. (old_stencil + 1 saturated to [0, 255])"]
pub const GPU_STENCIL_INCR: GPU_STENCILOP = 3;
#[doc = "< Decrement value. (old_stencil - 1 saturated to [0, 255])"]
pub const GPU_STENCIL_DECR: GPU_STENCILOP = 4;
#[doc = "< Invert value. (~old_stencil)"]
pub const GPU_STENCIL_INVERT: GPU_STENCILOP = 5;
#[doc = "< Increment value. (old_stencil + 1)"]
pub const GPU_STENCIL_INCR_WRAP: GPU_STENCILOP = 6;
#[doc = "< Decrement value. (old_stencil - 1)"]
pub const GPU_STENCIL_DECR_WRAP: GPU_STENCILOP = 7;
#[doc = "Stencil operations."]
pub type GPU_STENCILOP = ::libc::c_uint;
#[doc = "< Write red."]
pub const GPU_WRITE_RED: GPU_WRITEMASK = 1;
#[doc = "< Write green."]
pub const GPU_WRITE_GREEN: GPU_WRITEMASK = 2;
#[doc = "< Write blue."]
pub const GPU_WRITE_BLUE: GPU_WRITEMASK = 4;
#[doc = "< Write alpha."]
pub const GPU_WRITE_ALPHA: GPU_WRITEMASK = 8;
#[doc = "< Write depth."]
pub const GPU_WRITE_DEPTH: GPU_WRITEMASK = 16;
#[doc = "< Write all color components."]
pub const GPU_WRITE_COLOR: GPU_WRITEMASK = 15;
#[doc = "< Write all components."]
pub const GPU_WRITE_ALL: GPU_WRITEMASK = 31;
#[doc = "Pixel write mask."]
pub type GPU_WRITEMASK = ::libc::c_uint;
#[doc = "< Add colors."]
pub const GPU_BLEND_ADD: GPU_BLENDEQUATION = 0;
#[doc = "< Subtract colors."]
pub const GPU_BLEND_SUBTRACT: GPU_BLENDEQUATION = 1;
#[doc = "< Reverse-subtract colors."]
pub const GPU_BLEND_REVERSE_SUBTRACT: GPU_BLENDEQUATION = 2;
#[doc = "< Use the minimum color."]
pub const GPU_BLEND_MIN: GPU_BLENDEQUATION = 3;
#[doc = "< Use the maximum color."]
pub const GPU_BLEND_MAX: GPU_BLENDEQUATION = 4;
#[doc = "Blend modes."]
pub type GPU_BLENDEQUATION = ::libc::c_uint;
#[doc = "< Zero."]
pub const GPU_ZERO: GPU_BLENDFACTOR = 0;
#[doc = "< One."]
pub const GPU_ONE: GPU_BLENDFACTOR = 1;
#[doc = "< Source color."]
pub const GPU_SRC_COLOR: GPU_BLENDFACTOR = 2;
#[doc = "< Source color - 1."]
pub const GPU_ONE_MINUS_SRC_COLOR: GPU_BLENDFACTOR = 3;
#[doc = "< Destination color."]
pub const GPU_DST_COLOR: GPU_BLENDFACTOR = 4;
#[doc = "< Destination color - 1."]
pub const GPU_ONE_MINUS_DST_COLOR: GPU_BLENDFACTOR = 5;
#[doc = "< Source alpha."]
pub const GPU_SRC_ALPHA: GPU_BLENDFACTOR = 6;
#[doc = "< Source alpha - 1."]
pub const GPU_ONE_MINUS_SRC_ALPHA: GPU_BLENDFACTOR = 7;
#[doc = "< Destination alpha."]
pub const GPU_DST_ALPHA: GPU_BLENDFACTOR = 8;
#[doc = "< Destination alpha - 1."]
pub const GPU_ONE_MINUS_DST_ALPHA: GPU_BLENDFACTOR = 9;
#[doc = "< Constant color."]
pub const GPU_CONSTANT_COLOR: GPU_BLENDFACTOR = 10;
#[doc = "< Constant color - 1."]
pub const GPU_ONE_MINUS_CONSTANT_COLOR: GPU_BLENDFACTOR = 11;
#[doc = "< Constant alpha."]
pub const GPU_CONSTANT_ALPHA: GPU_BLENDFACTOR = 12;
#[doc = "< Constant alpha - 1."]
pub const GPU_ONE_MINUS_CONSTANT_ALPHA: GPU_BLENDFACTOR = 13;
#[doc = "< Saturated alpha."]
pub const GPU_SRC_ALPHA_SATURATE: GPU_BLENDFACTOR = 14;
#[doc = "Blend factors."]
pub type GPU_BLENDFACTOR = ::libc::c_uint;
#[doc = "< Clear."]
pub const GPU_LOGICOP_CLEAR: GPU_LOGICOP = 0;
#[doc = "< Bitwise AND."]
pub const GPU_LOGICOP_AND: GPU_LOGICOP = 1;
#[doc = "< Reverse bitwise AND."]
pub const GPU_LOGICOP_AND_REVERSE: GPU_LOGICOP = 2;
#[doc = "< Copy."]
pub const GPU_LOGICOP_COPY: GPU_LOGICOP = 3;
#[doc = "< Set."]
pub const GPU_LOGICOP_SET: GPU_LOGICOP = 4;
#[doc = "< Inverted copy."]
pub const GPU_LOGICOP_COPY_INVERTED: GPU_LOGICOP = 5;
#[doc = "< No operation."]
pub const GPU_LOGICOP_NOOP: GPU_LOGICOP = 6;
#[doc = "< Invert."]
pub const GPU_LOGICOP_INVERT: GPU_LOGICOP = 7;
#[doc = "< Bitwise NAND."]
pub const GPU_LOGICOP_NAND: GPU_LOGICOP = 8;
#[doc = "< Bitwise OR."]
pub const GPU_LOGICOP_OR: GPU_LOGICOP = 9;
#[doc = "< Bitwise NOR."]
pub const GPU_LOGICOP_NOR: GPU_LOGICOP = 10;
#[doc = "< Bitwise XOR."]
pub const GPU_LOGICOP_XOR: GPU_LOGICOP = 11;
#[doc = "< Equivalent."]
pub const GPU_LOGICOP_EQUIV: GPU_LOGICOP = 12;
#[doc = "< Inverted bitwise AND."]
pub const GPU_LOGICOP_AND_INVERTED: GPU_LOGICOP = 13;
#[doc = "< Reverse bitwise OR."]
pub const GPU_LOGICOP_OR_REVERSE: GPU_LOGICOP = 14;
#[doc = "< Inverted bitwize OR."]
pub const GPU_LOGICOP_OR_INVERTED: GPU_LOGICOP = 15;
#[doc = "Logical operations."]
pub type GPU_LOGICOP = ::libc::c_uint;
#[doc = "< OpenGL mode."]
pub const GPU_FRAGOPMODE_GL: GPU_FRAGOPMODE = 0;
#[doc = "< Gas mode (?)."]
pub const GPU_FRAGOPMODE_GAS_ACC: GPU_FRAGOPMODE = 1;
#[doc = "< Shadow mode (?)."]
pub const GPU_FRAGOPMODE_SHADOW: GPU_FRAGOPMODE = 3;
#[doc = "Fragment operation modes."]
pub type GPU_FRAGOPMODE = ::libc::c_uint;
#[doc = "< 8-bit byte."]
pub const GPU_BYTE: GPU_FORMATS = 0;
#[doc = "< 8-bit unsigned byte."]
pub const GPU_UNSIGNED_BYTE: GPU_FORMATS = 1;
#[doc = "< 16-bit short."]
pub const GPU_SHORT: GPU_FORMATS = 2;
#[doc = "< 32-bit float."]
pub const GPU_FLOAT: GPU_FORMATS = 3;
#[doc = "Supported component formats."]
pub type GPU_FORMATS = ::libc::c_uint;
#[doc = "< Disabled."]
pub const GPU_CULL_NONE: GPU_CULLMODE = 0;
#[doc = "< Front, counter-clockwise."]
pub const GPU_CULL_FRONT_CCW: GPU_CULLMODE = 1;
#[doc = "< Back, counter-clockwise."]
pub const GPU_CULL_BACK_CCW: GPU_CULLMODE = 2;
#[doc = "Cull modes."]
pub type GPU_CULLMODE = ::libc::c_uint;
#[doc = "< Primary color."]
pub const GPU_PRIMARY_COLOR: GPU_TEVSRC = 0;
#[doc = "< Primary fragment color."]
pub const GPU_FRAGMENT_PRIMARY_COLOR: GPU_TEVSRC = 1;
#[doc = "< Secondary fragment color."]
pub const GPU_FRAGMENT_SECONDARY_COLOR: GPU_TEVSRC = 2;
#[doc = "< Texture unit 0."]
pub const GPU_TEXTURE0: GPU_TEVSRC = 3;
#[doc = "< Texture unit 1."]
pub const GPU_TEXTURE1: GPU_TEVSRC = 4;
#[doc = "< Texture unit 2."]
pub const GPU_TEXTURE2: GPU_TEVSRC = 5;
#[doc = "< Texture unit 3."]
pub const GPU_TEXTURE3: GPU_TEVSRC = 6;
#[doc = "< Previous buffer."]
pub const GPU_PREVIOUS_BUFFER: GPU_TEVSRC = 13;
#[doc = "< Constant value."]
pub const GPU_CONSTANT: GPU_TEVSRC = 14;
#[doc = "< Previous value."]
pub const GPU_PREVIOUS: GPU_TEVSRC = 15;
#[doc = "Texture combiner sources."]
pub type GPU_TEVSRC = ::libc::c_uint;
#[doc = "< Source color."]
pub const GPU_TEVOP_RGB_SRC_COLOR: GPU_TEVOP_RGB = 0;
#[doc = "< Source color - 1."]
pub const GPU_TEVOP_RGB_ONE_MINUS_SRC_COLOR: GPU_TEVOP_RGB = 1;
#[doc = "< Source alpha."]
pub const GPU_TEVOP_RGB_SRC_ALPHA: GPU_TEVOP_RGB = 2;
#[doc = "< Source alpha - 1."]
pub const GPU_TEVOP_RGB_ONE_MINUS_SRC_ALPHA: GPU_TEVOP_RGB = 3;
#[doc = "< Source red."]
pub const GPU_TEVOP_RGB_SRC_R: GPU_TEVOP_RGB = 4;
#[doc = "< Source red - 1."]
pub const GPU_TEVOP_RGB_ONE_MINUS_SRC_R: GPU_TEVOP_RGB = 5;
#[doc = "< Unknown."]
pub const GPU_TEVOP_RGB_0x06: GPU_TEVOP_RGB = 6;
#[doc = "< Unknown."]
pub const GPU_TEVOP_RGB_0x07: GPU_TEVOP_RGB = 7;
#[doc = "< Source green."]
pub const GPU_TEVOP_RGB_SRC_G: GPU_TEVOP_RGB = 8;
#[doc = "< Source green - 1."]
pub const GPU_TEVOP_RGB_ONE_MINUS_SRC_G: GPU_TEVOP_RGB = 9;
#[doc = "< Unknown."]
pub const GPU_TEVOP_RGB_0x0A: GPU_TEVOP_RGB = 10;
#[doc = "< Unknown."]
pub const GPU_TEVOP_RGB_0x0B: GPU_TEVOP_RGB = 11;
#[doc = "< Source blue."]
pub const GPU_TEVOP_RGB_SRC_B: GPU_TEVOP_RGB = 12;
#[doc = "< Source blue - 1."]
pub const GPU_TEVOP_RGB_ONE_MINUS_SRC_B: GPU_TEVOP_RGB = 13;
#[doc = "< Unknown."]
pub const GPU_TEVOP_RGB_0x0E: GPU_TEVOP_RGB = 14;
#[doc = "< Unknown."]
pub const GPU_TEVOP_RGB_0x0F: GPU_TEVOP_RGB = 15;
#[doc = "Texture RGB combiner operands."]
pub type GPU_TEVOP_RGB = ::libc::c_uint;
#[doc = "< Source alpha."]
pub const GPU_TEVOP_A_SRC_ALPHA: GPU_TEVOP_A = 0;
#[doc = "< Source alpha - 1."]
pub const GPU_TEVOP_A_ONE_MINUS_SRC_ALPHA: GPU_TEVOP_A = 1;
#[doc = "< Source red."]
pub const GPU_TEVOP_A_SRC_R: GPU_TEVOP_A = 2;
#[doc = "< Source red - 1."]
pub const GPU_TEVOP_A_ONE_MINUS_SRC_R: GPU_TEVOP_A = 3;
#[doc = "< Source green."]
pub const GPU_TEVOP_A_SRC_G: GPU_TEVOP_A = 4;
#[doc = "< Source green - 1."]
pub const GPU_TEVOP_A_ONE_MINUS_SRC_G: GPU_TEVOP_A = 5;
#[doc = "< Source blue."]
pub const GPU_TEVOP_A_SRC_B: GPU_TEVOP_A = 6;
#[doc = "< Source blue - 1."]
pub const GPU_TEVOP_A_ONE_MINUS_SRC_B: GPU_TEVOP_A = 7;
#[doc = "Texture Alpha combiner operands."]
pub type GPU_TEVOP_A = ::libc::c_uint;
#[doc = "< Replace."]
pub const GPU_REPLACE: GPU_COMBINEFUNC = 0;
#[doc = "< Modulate."]
pub const GPU_MODULATE: GPU_COMBINEFUNC = 1;
#[doc = "< Add."]
pub const GPU_ADD: GPU_COMBINEFUNC = 2;
#[doc = "< Signed add."]
pub const GPU_ADD_SIGNED: GPU_COMBINEFUNC = 3;
#[doc = "< Interpolate."]
pub const GPU_INTERPOLATE: GPU_COMBINEFUNC = 4;
#[doc = "< Subtract."]
pub const GPU_SUBTRACT: GPU_COMBINEFUNC = 5;
#[doc = "< Dot3. RGB only."]
pub const GPU_DOT3_RGB: GPU_COMBINEFUNC = 6;
#[doc = "< Multiply then add."]
pub const GPU_MULTIPLY_ADD: GPU_COMBINEFUNC = 8;
#[doc = "< Add then multiply."]
pub const GPU_ADD_MULTIPLY: GPU_COMBINEFUNC = 9;
#[doc = "Texture combiner functions."]
pub type GPU_COMBINEFUNC = ::libc::c_uint;
#[doc = "< 1x"]
pub const GPU_TEVSCALE_1: GPU_TEVSCALE = 0;
#[doc = "< 2x"]
pub const GPU_TEVSCALE_2: GPU_TEVSCALE = 1;
#[doc = "< 4x"]
pub const GPU_TEVSCALE_4: GPU_TEVSCALE = 2;
#[doc = "Texture scale factors."]
pub type GPU_TEVSCALE = ::libc::c_uint;
#[doc = "< None."]
pub const GPU_NO_FRESNEL: GPU_FRESNELSEL = 0;
#[doc = "< Primary alpha."]
pub const GPU_PRI_ALPHA_FRESNEL: GPU_FRESNELSEL = 1;
#[doc = "< Secondary alpha."]
pub const GPU_SEC_ALPHA_FRESNEL: GPU_FRESNELSEL = 2;
#[doc = "< Primary and secondary alpha."]
pub const GPU_PRI_SEC_ALPHA_FRESNEL: GPU_FRESNELSEL = 3;
#[doc = "Fresnel options."]
pub type GPU_FRESNELSEL = ::libc::c_uint;
#[doc = "< Disabled."]
pub const GPU_BUMP_NOT_USED: GPU_BUMPMODE = 0;
#[doc = "< Bump as bump mapping."]
pub const GPU_BUMP_AS_BUMP: GPU_BUMPMODE = 1;
#[doc = "< Bump as tangent/normal mapping."]
pub const GPU_BUMP_AS_TANG: GPU_BUMPMODE = 2;
#[doc = "Bump map modes."]
pub type GPU_BUMPMODE = ::libc::c_uint;
#[doc = "< D0 LUT."]
pub const GPU_LUT_D0: GPU_LIGHTLUTID = 0;
#[doc = "< D1 LUT."]
pub const GPU_LUT_D1: GPU_LIGHTLUTID = 1;
#[doc = "< Spotlight LUT."]
pub const GPU_LUT_SP: GPU_LIGHTLUTID = 2;
#[doc = "< Fresnel LUT."]
pub const GPU_LUT_FR: GPU_LIGHTLUTID = 3;
#[doc = "< Reflection-Blue LUT."]
pub const GPU_LUT_RB: GPU_LIGHTLUTID = 4;
#[doc = "< Reflection-Green LUT."]
pub const GPU_LUT_RG: GPU_LIGHTLUTID = 5;
#[doc = "< Reflection-Red LUT."]
pub const GPU_LUT_RR: GPU_LIGHTLUTID = 6;
#[doc = "< Distance attenuation LUT."]
pub const GPU_LUT_DA: GPU_LIGHTLUTID = 7;
#[doc = "LUT IDs."]
pub type GPU_LIGHTLUTID = ::libc::c_uint;
#[doc = "< Normal*HalfVector"]
pub const GPU_LUTINPUT_NH: GPU_LIGHTLUTINPUT = 0;
#[doc = "< View*HalfVector"]
pub const GPU_LUTINPUT_VH: GPU_LIGHTLUTINPUT = 1;
#[doc = "< Normal*View"]
pub const GPU_LUTINPUT_NV: GPU_LIGHTLUTINPUT = 2;
#[doc = "< LightVector*Normal"]
pub const GPU_LUTINPUT_LN: GPU_LIGHTLUTINPUT = 3;
#[doc = "< -LightVector*SpotlightVector"]
pub const GPU_LUTINPUT_SP: GPU_LIGHTLUTINPUT = 4;
#[doc = "< cosine of phi"]
pub const GPU_LUTINPUT_CP: GPU_LIGHTLUTINPUT = 5;
#[doc = "LUT inputs."]
pub type GPU_LIGHTLUTINPUT = ::libc::c_uint;
#[doc = "< 1x scale."]
pub const GPU_LUTSCALER_1x: GPU_LIGHTLUTSCALER = 0;
#[doc = "< 2x scale."]
pub const GPU_LUTSCALER_2x: GPU_LIGHTLUTSCALER = 1;
#[doc = "< 4x scale."]
pub const GPU_LUTSCALER_4x: GPU_LIGHTLUTSCALER = 2;
#[doc = "< 8x scale."]
pub const GPU_LUTSCALER_8x: GPU_LIGHTLUTSCALER = 3;
#[doc = "< 0.25x scale."]
pub const GPU_LUTSCALER_0_25x: GPU_LIGHTLUTSCALER = 6;
#[doc = "< 0.5x scale."]
pub const GPU_LUTSCALER_0_5x: GPU_LIGHTLUTSCALER = 7;
#[doc = "LUT scalers."]
pub type GPU_LIGHTLUTSCALER = ::libc::c_uint;
#[doc = "< LUTs that are common to all lights."]
pub const GPU_LUTSELECT_COMMON: GPU_LIGHTLUTSELECT = 0;
#[doc = "< Spotlight LUT."]
pub const GPU_LUTSELECT_SP: GPU_LIGHTLUTSELECT = 1;
#[doc = "< Distance attenuation LUT."]
pub const GPU_LUTSELECT_DA: GPU_LIGHTLUTSELECT = 2;
#[doc = "LUT selection."]
pub type GPU_LIGHTLUTSELECT = ::libc::c_uint;
#[doc = "< Fog/Gas unit disabled."]
pub const GPU_NO_FOG: GPU_FOGMODE = 0;
#[doc = "< Fog/Gas unit configured in Fog mode."]
pub const GPU_FOG: GPU_FOGMODE = 5;
#[doc = "< Fog/Gas unit configured in Gas mode."]
pub const GPU_GAS: GPU_FOGMODE = 7;
#[doc = "Fog modes."]
pub type GPU_FOGMODE = ::libc::c_uint;
#[doc = "< Plain density."]
pub const GPU_PLAIN_DENSITY: GPU_GASMODE = 0;
#[doc = "< Depth density."]
pub const GPU_DEPTH_DENSITY: GPU_GASMODE = 1;
#[doc = "Gas shading density source values."]
pub type GPU_GASMODE = ::libc::c_uint;
#[doc = "< Gas density used as input."]
pub const GPU_GAS_DENSITY: GPU_GASLUTINPUT = 0;
#[doc = "< Light factor used as input."]
pub const GPU_GAS_LIGHT_FACTOR: GPU_GASLUTINPUT = 1;
#[doc = "Gas color LUT inputs."]
pub type GPU_GASLUTINPUT = ::libc::c_uint;
#[doc = "< Triangles."]
pub const GPU_TRIANGLES: GPU_Primitive_t = 0;
#[doc = "< Triangle strip."]
pub const GPU_TRIANGLE_STRIP: GPU_Primitive_t = 256;
#[doc = "< Triangle fan."]
pub const GPU_TRIANGLE_FAN: GPU_Primitive_t = 512;
#[doc = "< Geometry shader primitive."]
pub const GPU_GEOMETRY_PRIM: GPU_Primitive_t = 768;
#[doc = "Supported primitives."]
pub type GPU_Primitive_t = ::libc::c_uint;
#[doc = "< Vertex shader."]
pub const GPU_VERTEX_SHADER: GPU_SHADER_TYPE = 0;
#[doc = "< Geometry shader."]
pub const GPU_GEOMETRY_SHADER: GPU_SHADER_TYPE = 1;
#[doc = "Shader types."]
pub type GPU_SHADER_TYPE = ::libc::c_uint;
extern "C" {
    #[doc = "< GPU command buffer."]
    pub static mut gpuCmdBuf: *mut u32_;
}
extern "C" {
    #[doc = "< GPU command buffer size."]
    pub static mut gpuCmdBufSize: u32_;
}
extern "C" {
    #[doc = "< GPU command buffer offset."]
    pub static mut gpuCmdBufOffset: u32_;
}
extern "C" {
    #[doc = "Sets the GPU command buffer to use.\n # Arguments\n\n* `adr` - Pointer to the command buffer.\n * `size` - Size of the command buffer.\n * `offset` - Offset of the command buffer."]
    #[link_name = "GPUCMD_SetBuffer__extern"]
    pub fn GPUCMD_SetBuffer(adr: *mut u32_, size: u32_, offset: u32_);
}
extern "C" {
    #[doc = "Sets the offset of the GPU command buffer.\n # Arguments\n\n* `offset` - Offset of the command buffer."]
    #[link_name = "GPUCMD_SetBufferOffset__extern"]
    pub fn GPUCMD_SetBufferOffset(offset: u32_);
}
extern "C" {
    #[doc = "Gets the current GPU command buffer.\n # Arguments\n\n* `addr` - Pointer to output the command buffer to.\n * `size` - Pointer to output the size (in words) of the command buffer to.\n * `offset` - Pointer to output the offset of the command buffer to."]
    #[link_name = "GPUCMD_GetBuffer__extern"]
    pub fn GPUCMD_GetBuffer(addr: *mut *mut u32_, size: *mut u32_, offset: *mut u32_);
}
extern "C" {
    #[doc = "Adds raw GPU commands to the current command buffer.\n # Arguments\n\n* `cmd` - Buffer containing commands to add.\n * `size` - Size of the buffer."]
    pub fn GPUCMD_AddRawCommands(cmd: *const u32_, size: u32_);
}
extern "C" {
    #[doc = "Adds a GPU command to the current command buffer.\n # Arguments\n\n* `header` - Header of the command.\n * `param` - Parameters of the command.\n * `paramlength` - Size of the parameter buffer."]
    pub fn GPUCMD_Add(header: u32_, param: *const u32_, paramlength: u32_);
}
extern "C" {
    #[doc = "Splits the current GPU command buffer.\n # Arguments\n\n* `addr` - Pointer to output the command buffer to.\n * `size` - Pointer to output the size (in words) of the command buffer to."]
    pub fn GPUCMD_Split(addr: *mut *mut u32_, size: *mut u32_);
}
extern "C" {
    #[doc = "Converts a 32-bit float to a 16-bit float.\n # Arguments\n\n* `f` - Float to convert.\n # Returns\n\nThe converted float."]
    pub fn f32tof16(f: f32) -> u32_;
}
extern "C" {
    #[doc = "Converts a 32-bit float to a 20-bit float.\n # Arguments\n\n* `f` - Float to convert.\n # Returns\n\nThe converted float."]
    pub fn f32tof20(f: f32) -> u32_;
}
extern "C" {
    #[doc = "Converts a 32-bit float to a 24-bit float.\n # Arguments\n\n* `f` - Float to convert.\n # Returns\n\nThe converted float."]
    pub fn f32tof24(f: f32) -> u32_;
}
extern "C" {
    #[doc = "Converts a 32-bit float to a 31-bit float.\n # Arguments\n\n* `f` - Float to convert.\n # Returns\n\nThe converted float."]
    pub fn f32tof31(f: f32) -> u32_;
}
extern "C" {
    #[doc = "Adds a command with a single parameter to the current command buffer."]
    #[link_name = "GPUCMD_AddSingleParam__extern"]
    pub fn GPUCMD_AddSingleParam(header: u32_, param: u32_);
}
#[doc = "< Vertex shader."]
pub const VERTEX_SHDR: DVLE_type = 0;
#[doc = "< Geometry shader."]
pub const GEOMETRY_SHDR: DVLE_type = 1;
#[doc = "DVLE type."]
pub type DVLE_type = ::libc::c_uint;
#[doc = "< Bool."]
pub const DVLE_CONST_BOOL: DVLE_constantType = 0;
#[doc = "< Unsigned 8-bit integer."]
pub const DVLE_CONST_u8: DVLE_constantType = 1;
#[doc = "< 24-bit float."]
pub const DVLE_CONST_FLOAT24: DVLE_constantType = 2;
#[doc = "Constant type."]
pub type DVLE_constantType = ::libc::c_uint;
#[doc = "< Position."]
pub const RESULT_POSITION: DVLE_outputAttribute_t = 0;
#[doc = "< Normal Quaternion."]
pub const RESULT_NORMALQUAT: DVLE_outputAttribute_t = 1;
#[doc = "< Color."]
pub const RESULT_COLOR: DVLE_outputAttribute_t = 2;
#[doc = "< Texture coordinate 0."]
pub const RESULT_TEXCOORD0: DVLE_outputAttribute_t = 3;
#[doc = "< Texture coordinate 0 W."]
pub const RESULT_TEXCOORD0W: DVLE_outputAttribute_t = 4;
#[doc = "< Texture coordinate 1."]
pub const RESULT_TEXCOORD1: DVLE_outputAttribute_t = 5;
#[doc = "< Texture coordinate 2."]
pub const RESULT_TEXCOORD2: DVLE_outputAttribute_t = 6;
#[doc = "< View."]
pub const RESULT_VIEW: DVLE_outputAttribute_t = 8;
#[doc = "< Dummy attribute (used as passthrough for geometry shader input)."]
pub const RESULT_DUMMY: DVLE_outputAttribute_t = 9;
#[doc = "Output attribute."]
pub type DVLE_outputAttribute_t = ::libc::c_uint;
#[doc = "< Point processing mode."]
pub const GSH_POINT: DVLE_geoShaderMode = 0;
#[doc = "< Variable-size primitive processing mode."]
pub const GSH_VARIABLE_PRIM: DVLE_geoShaderMode = 1;
#[doc = "< Fixed-size primitive processing mode."]
pub const GSH_FIXED_PRIM: DVLE_geoShaderMode = 2;
#[doc = "Geometry shader operation modes."]
pub type DVLE_geoShaderMode = ::libc::c_uint;
#[doc = "DVLP data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DVLP_s {
    #[doc = "< Code size."]
    pub codeSize: u32_,
    #[doc = "< Code data."]
    pub codeData: *mut u32_,
    #[doc = "< Operand description size."]
    pub opdescSize: u32_,
    #[doc = "< Operand description data."]
    pub opcdescData: *mut u32_,
}
impl Default for DVLP_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "DVLE constant entry data."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct DVLE_constEntry_s {
    #[doc = "< Constant type. See DVLE_constantType"]
    pub type_: u16_,
    #[doc = "< Constant ID."]
    pub id: u16_,
    #[doc = "< Constant data."]
    pub data: [u32_; 4usize],
}
#[doc = "DVLE output entry data."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct DVLE_outEntry_s {
    #[doc = "< Output type. See DVLE_outputAttribute_t"]
    pub type_: u16_,
    #[doc = "< Output register ID."]
    pub regID: u16_,
    #[doc = "< Output mask."]
    pub mask: u8_,
    #[doc = "< Unknown."]
    pub unk: [u8_; 3usize],
}
#[doc = "DVLE uniform entry data."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct DVLE_uniformEntry_s {
    #[doc = "< Symbol offset."]
    pub symbolOffset: u32_,
    #[doc = "< Start register."]
    pub startReg: u16_,
    #[doc = "< End register."]
    pub endReg: u16_,
}
#[doc = "DVLE data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DVLE_s {
    #[doc = "< DVLE type."]
    pub type_: DVLE_type,
    #[doc = "< true = merge vertex/geometry shader outmaps ('dummy' output attribute is present)."]
    pub mergeOutmaps: bool,
    #[doc = "< Geometry shader operation mode."]
    pub gshMode: DVLE_geoShaderMode,
    #[doc = "< Starting float uniform register number for storing the fixed-size primitive vertex array."]
    pub gshFixedVtxStart: u8_,
    #[doc = "< Number of fully-defined vertices in the variable-size primitive vertex array."]
    pub gshVariableVtxNum: u8_,
    #[doc = "< Number of vertices in the fixed-size primitive vertex array."]
    pub gshFixedVtxNum: u8_,
    #[doc = "< Contained DVLPs."]
    pub dvlp: *mut DVLP_s,
    #[doc = "< Offset of the start of the main function."]
    pub mainOffset: u32_,
    #[doc = "< Offset of the end of the main function."]
    pub endmainOffset: u32_,
    #[doc = "< Constant table size."]
    pub constTableSize: u32_,
    #[doc = "< Constant table data."]
    pub constTableData: *mut DVLE_constEntry_s,
    #[doc = "< Output table size."]
    pub outTableSize: u32_,
    #[doc = "< Output table data."]
    pub outTableData: *mut DVLE_outEntry_s,
    #[doc = "< Uniform table size."]
    pub uniformTableSize: u32_,
    #[doc = "< Uniform table data."]
    pub uniformTableData: *mut DVLE_uniformEntry_s,
    #[doc = "< Symbol table data."]
    pub symbolTableData: *mut ::libc::c_char,
    #[doc = "< Output map mask."]
    pub outmapMask: u8_,
    #[doc = "< Output map data."]
    pub outmapData: [u32_; 8usize],
    #[doc = "< Output map mode."]
    pub outmapMode: u32_,
    #[doc = "< Output map attribute clock."]
    pub outmapClock: u32_,
}
impl Default for DVLE_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "DVLB data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DVLB_s {
    #[doc = "< DVLE count."]
    pub numDVLE: u32_,
    #[doc = "< Primary DVLP."]
    pub DVLP: DVLP_s,
    #[doc = "< Contained DVLE."]
    pub DVLE: *mut DVLE_s,
}
impl Default for DVLB_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = "Parses a shader binary.\n # Arguments\n\n* `shbinData` - Shader binary data.\n * `shbinSize` - Shader binary size.\n # Returns\n\nThe parsed shader binary."]
    pub fn DVLB_ParseFile(shbinData: *mut u32_, shbinSize: u32_) -> *mut DVLB_s;
}
extern "C" {
    #[doc = "Frees shader binary data.\n # Arguments\n\n* `dvlb` - DVLB to free."]
    pub fn DVLB_Free(dvlb: *mut DVLB_s);
}
extern "C" {
    #[doc = "Gets a uniform register index from a shader.\n # Arguments\n\n* `dvle` - Shader to get the register from.\n * `name` - Name of the register.\n # Returns\n\nThe uniform register index."]
    pub fn DVLE_GetUniformRegister(dvle: *mut DVLE_s, name: *const ::libc::c_char) -> s8;
}
extern "C" {
    #[doc = "Generates a shader output map.\n # Arguments\n\n* `dvle` - Shader to generate an output map for."]
    pub fn DVLE_GenerateOutmap(dvle: *mut DVLE_s);
}
#[doc = "24-bit float uniforms."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct float24Uniform_s {
    #[doc = "< Uniform ID."]
    pub id: u32_,
    #[doc = "< Uniform data."]
    pub data: [u32_; 3usize],
}
#[doc = "Describes an instance of either a vertex or geometry shader."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct shaderInstance_s {
    #[doc = "< Shader DVLE."]
    pub dvle: *mut DVLE_s,
    #[doc = "< Boolean uniforms."]
    pub boolUniforms: u16_,
    #[doc = "< Used boolean uniform mask."]
    pub boolUniformMask: u16_,
    #[doc = "< Integer uniforms."]
    pub intUniforms: [u32_; 4usize],
    #[doc = "< 24-bit float uniforms."]
    pub float24Uniforms: *mut float24Uniform_s,
    #[doc = "< Used integer uniform mask."]
    pub intUniformMask: u8_,
    #[doc = "< Float uniform count."]
    pub numFloat24Uniforms: u8_,
}
impl Default for shaderInstance_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Describes an instance of a full shader program."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct shaderProgram_s {
    #[doc = "< Vertex shader."]
    pub vertexShader: *mut shaderInstance_s,
    #[doc = "< Geometry shader."]
    pub geometryShader: *mut shaderInstance_s,
    #[doc = "< Geometry shader input permutation."]
    pub geoShaderInputPermutation: [u32_; 2usize],
    #[doc = "< Geometry shader input stride."]
    pub geoShaderInputStride: u8_,
}
impl Default for shaderProgram_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[must_use]
    #[doc = "Initializes a shader instance.\n # Arguments\n\n* `si` - Shader instance to initialize.\n * `dvle` - DVLE to initialize the shader instance with."]
    pub fn shaderInstanceInit(si: *mut shaderInstance_s, dvle: *mut DVLE_s) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Frees a shader instance.\n # Arguments\n\n* `si` - Shader instance to free."]
    pub fn shaderInstanceFree(si: *mut shaderInstance_s) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets a bool uniform of a shader.\n # Arguments\n\n* `si` - Shader instance to use.\n * `id` - ID of the bool uniform.\n * `value` - Value to set."]
    pub fn shaderInstanceSetBool(
        si: *mut shaderInstance_s,
        id: ::libc::c_int,
        value: bool,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Gets a bool uniform of a shader.\n # Arguments\n\n* `si` - Shader instance to use.\n * `id` - ID of the bool uniform.\n * `value` - Pointer to output the value to."]
    pub fn shaderInstanceGetBool(
        si: *mut shaderInstance_s,
        id: ::libc::c_int,
        value: *mut bool,
    ) -> Result;
}
extern "C" {
    #[doc = "Gets the location of a shader's uniform.\n # Arguments\n\n* `si` - Shader instance to use.\n * `name` - Name of the uniform."]
    pub fn shaderInstanceGetUniformLocation(
        si: *mut shaderInstance_s,
        name: *const ::libc::c_char,
    ) -> s8;
}
extern "C" {
    #[must_use]
    #[doc = "Initializes a shader program.\n # Arguments\n\n* `sp` - Shader program to initialize."]
    pub fn shaderProgramInit(sp: *mut shaderProgram_s) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Frees a shader program.\n # Arguments\n\n* `sp` - Shader program to free."]
    pub fn shaderProgramFree(sp: *mut shaderProgram_s) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the vertex shader of a shader program.\n # Arguments\n\n* `sp` - Shader program to use.\n * `dvle` - Vertex shader to set."]
    pub fn shaderProgramSetVsh(sp: *mut shaderProgram_s, dvle: *mut DVLE_s) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Sets the geometry shader of a shader program.\n # Arguments\n\n* `sp` - Shader program to use.\n * `dvle` - Geometry shader to set.\n * `stride` - Input stride of the shader (pass 0 to match the number of outputs of the vertex shader)."]
    pub fn shaderProgramSetGsh(sp: *mut shaderProgram_s, dvle: *mut DVLE_s, stride: u8_) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Configures the permutation of the input attributes of the geometry shader of a shader program.\n # Arguments\n\n* `sp` - Shader program to use.\n * `permutation` - Attribute permutation to use."]
    pub fn shaderProgramSetGshInputPermutation(
        sp: *mut shaderProgram_s,
        permutation: u64_,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Configures the shader units to use the specified shader program.\n # Arguments\n\n* `sp` - Shader program to use.\n * `sendVshCode` - When true, the vertex shader's code and operand descriptors are uploaded.\n * `sendGshCode` - When true, the geometry shader's code and operand descriptors are uploaded."]
    pub fn shaderProgramConfigure(
        sp: *mut shaderProgram_s,
        sendVshCode: bool,
        sendGshCode: bool,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Same as shaderProgramConfigure, but always loading code/operand descriptors and uploading DVLE constants afterwards.\n # Arguments\n\n* `sp` - Shader program to use."]
    pub fn shaderProgramUse(sp: *mut shaderProgram_s) -> Result;
}
#[doc = "< Mono sound"]
pub const NDSP_OUTPUT_MONO: ndspOutputMode = 0;
#[doc = "< Stereo sound"]
pub const NDSP_OUTPUT_STEREO: ndspOutputMode = 1;
#[doc = "< 3D Surround sound"]
pub const NDSP_OUTPUT_SURROUND: ndspOutputMode = 2;
#[doc = "Data types\n# Sound output modes."]
pub type ndspOutputMode = ::libc::c_uint;
#[doc = "< \"Normal\" clipping mode (?)"]
pub const NDSP_CLIP_NORMAL: ndspClippingMode = 0;
#[doc = "< \"Soft\" clipping mode (?)"]
pub const NDSP_CLIP_SOFT: ndspClippingMode = 1;
pub type ndspClippingMode = ::libc::c_uint;
#[doc = "<?"]
pub const NDSP_SPKPOS_SQUARE: ndspSpeakerPos = 0;
#[doc = "<?"]
pub const NDSP_SPKPOS_WIDE: ndspSpeakerPos = 1;
#[doc = "<?"]
pub const NDSP_SPKPOS_NUM: ndspSpeakerPos = 2;
pub type ndspSpeakerPos = ::libc::c_uint;
#[doc = "ADPCM data."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ndspAdpcmData {
    #[doc = "< Current predictor index"]
    pub index: u16_,
    #[doc = "< Last outputted PCM16 sample."]
    pub history0: s16,
    #[doc = "< Second to last outputted PCM16 sample."]
    pub history1: s16,
}
#[doc = "Wave buffer type."]
pub type ndspWaveBuf = tag_ndspWaveBuf;
#[doc = "< The wave buffer is not queued."]
pub const NDSP_WBUF_FREE: _bindgen_ty_29 = 0;
#[doc = "< The wave buffer is queued and has not been played yet."]
pub const NDSP_WBUF_QUEUED: _bindgen_ty_29 = 1;
#[doc = "< The wave buffer is playing right now."]
pub const NDSP_WBUF_PLAYING: _bindgen_ty_29 = 2;
#[doc = "< The wave buffer has finished being played."]
pub const NDSP_WBUF_DONE: _bindgen_ty_29 = 3;
#[doc = "Wave buffer status."]
pub type _bindgen_ty_29 = ::libc::c_uint;
#[doc = "Wave buffer struct."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tag_ndspWaveBuf {
    pub __bindgen_anon_1: tag_ndspWaveBuf__bindgen_ty_1,
    #[doc = "< Total number of samples (PCM8=bytes, PCM16=halfwords, DSPADPCM=nibbles without frame headers)"]
    pub nsamples: u32_,
    #[doc = "< ADPCM data."]
    pub adpcm_data: *mut ndspAdpcmData,
    #[doc = "< Buffer offset. Only used for capture."]
    pub offset: u32_,
    #[doc = "< Whether to loop the buffer."]
    pub looping: bool,
    #[doc = "< Queuing/playback status."]
    pub status: u8_,
    #[doc = "< Sequence ID. Assigned automatically by ndspChnWaveBufAdd."]
    pub sequence_id: u16_,
    #[doc = "< Next buffer to play. Used internally, do not modify."]
    pub next: *mut ndspWaveBuf,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tag_ndspWaveBuf__bindgen_ty_1 {
    #[doc = "< Pointer to PCM8 sample data."]
    pub data_pcm8: *mut s8,
    #[doc = "< Pointer to PCM16 sample data."]
    pub data_pcm16: *mut s16,
    #[doc = "< Pointer to DSPADPCM sample data."]
    pub data_adpcm: *mut u8_,
    #[doc = "< Data virtual address."]
    pub data_vaddr: *const ::libc::c_void,
}
impl Default for tag_ndspWaveBuf__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for tag_ndspWaveBuf {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Sound frame callback function. (data = User provided data)"]
pub type ndspCallback = ::core::option::Option<unsafe extern "C" fn(data: *mut ::libc::c_void)>;
#[doc = "Auxiliary output callback function. (data = User provided data, nsamples = Number of samples, samples = Sample data)"]
pub type ndspAuxCallback = ::core::option::Option<
    unsafe extern "C" fn(
        data: *mut ::libc::c_void,
        nsamples: ::libc::c_int,
        samples: *mut *mut ::libc::c_void,
    ),
>;
extern "C" {
    #[doc = "Initialization and basic operations\n# *\n* Sets up the DSP component.\n # Arguments\n\n* `binary` - DSP binary to load.\n * `size` - Size of the DSP binary.\n * `progMask` - Program RAM block mask to load the binary to.\n * `dataMask` - Data RAM block mask to load the binary to.\n/"]
    pub fn ndspUseComponent(
        binary: *const ::libc::c_void,
        size: u32_,
        progMask: u16_,
        dataMask: u16_,
    );
}
extern "C" {
    #[must_use]
    #[doc = "Initializes NDSP."]
    pub fn ndspInit() -> Result;
}
extern "C" {
    #[doc = "Exits NDSP."]
    pub fn ndspExit();
}
extern "C" {
    #[doc = "Gets the number of dropped sound frames.\n # Returns\n\nThe number of dropped sound frames."]
    pub fn ndspGetDroppedFrames() -> u32_;
}
extern "C" {
    #[doc = "Gets the total sound frame count.\n # Returns\n\nThe total sound frame count."]
    pub fn ndspGetFrameCount() -> u32_;
}
extern "C" {
    #[doc = "General parameters\n# *\n* Sets the master volume.\n # Arguments\n\n* `volume` - Volume to set. Defaults to 1.0f.\n/"]
    pub fn ndspSetMasterVol(volume: f32);
}
extern "C" {
    #[doc = "Gets the master volume.\n # Returns\n\nThe master volume."]
    pub fn ndspGetMasterVol() -> f32;
}
extern "C" {
    #[doc = "Sets the output mode.\n # Arguments\n\n* `mode` - Output mode to set. Defaults to NDSP_OUTPUT_STEREO."]
    pub fn ndspSetOutputMode(mode: ndspOutputMode);
}
extern "C" {
    #[doc = "Gets the output mode.\n # Returns\n\nThe output mode."]
    pub fn ndspGetOutputMode() -> ndspOutputMode;
}
extern "C" {
    #[doc = "Sets the clipping mode.\n # Arguments\n\n* `mode` - Clipping mode to set. Defaults to NDSP_CLIP_SOFT."]
    pub fn ndspSetClippingMode(mode: ndspClippingMode);
}
extern "C" {
    #[doc = "Gets the clipping mode.\n # Returns\n\nThe clipping mode."]
    pub fn ndspGetClippingMode() -> ndspClippingMode;
}
extern "C" {
    #[doc = "Sets the output count.\n # Arguments\n\n* `count` - Output count to set. Defaults to 2."]
    pub fn ndspSetOutputCount(count: ::libc::c_int);
}
extern "C" {
    #[doc = "Gets the output count.\n # Returns\n\nThe output count."]
    pub fn ndspGetOutputCount() -> ::libc::c_int;
}
extern "C" {
    #[doc = "Sets the wave buffer to capture audio to.\n # Arguments\n\n* `capture` - Wave buffer to capture to."]
    pub fn ndspSetCapture(capture: *mut ndspWaveBuf);
}
extern "C" {
    #[doc = "Sets the sound frame callback.\n # Arguments\n\n* `callback` - Callback to set.\n * `data` - User-defined data to pass to the callback."]
    pub fn ndspSetCallback(callback: ndspCallback, data: *mut ::libc::c_void);
}
extern "C" {
    #[doc = "Surround\n# *\n* Sets the surround sound depth.\n # Arguments\n\n* `depth` - Depth to set. Defaults to 0x7FFF.\n/"]
    pub fn ndspSurroundSetDepth(depth: u16_);
}
extern "C" {
    #[doc = "Gets the surround sound depth.\n # Returns\n\nThe surround sound depth."]
    pub fn ndspSurroundGetDepth() -> u16_;
}
extern "C" {
    #[doc = "Sets the surround sound position.\n # Arguments\n\n* `pos` - Position to set. Defaults to NDSP_SPKPOS_SQUARE."]
    pub fn ndspSurroundSetPos(pos: ndspSpeakerPos);
}
extern "C" {
    #[doc = "Gets the surround sound position.\n # Returns\n\nThe surround sound speaker position."]
    pub fn ndspSurroundGetPos() -> ndspSpeakerPos;
}
extern "C" {
    #[doc = "Sets the surround sound rear ratio.\n # Arguments\n\n* `ratio` - Rear ratio to set. Defaults to 0x8000."]
    pub fn ndspSurroundSetRearRatio(ratio: u16_);
}
extern "C" {
    #[doc = "Gets the surround sound rear ratio.\n # Returns\n\nThe rear ratio."]
    pub fn ndspSurroundGetRearRatio() -> u16_;
}
extern "C" {
    #[doc = "Auxiliary output\n# *\n* Configures whether an auxiliary output is enabled.\n # Arguments\n\n* `id` - ID of the auxiliary output.\n * `enable` - Whether to enable the auxiliary output.\n/"]
    pub fn ndspAuxSetEnable(id: ::libc::c_int, enable: bool);
}
extern "C" {
    #[doc = "Gets whether auxiliary output is enabled.\n # Arguments\n\n* `id` - ID of the auxiliary output.\n # Returns\n\nWhether auxiliary output is enabled."]
    pub fn ndspAuxIsEnabled(id: ::libc::c_int) -> bool;
}
extern "C" {
    #[doc = "Configures whether an auxiliary output should use front bypass.\n # Arguments\n\n* `id` - ID of the auxiliary output.\n * `bypass` - Whether to use front bypass."]
    pub fn ndspAuxSetFrontBypass(id: ::libc::c_int, bypass: bool);
}
extern "C" {
    #[doc = "Gets whether auxiliary output front bypass is enabled.\n # Arguments\n\n* `id` - ID of the auxiliary output.\n # Returns\n\nWhether auxiliary output front bypass is enabled."]
    pub fn ndspAuxGetFrontBypass(id: ::libc::c_int) -> bool;
}
extern "C" {
    #[doc = "Sets the volume of an auxiliary output.\n # Arguments\n\n* `id` - ID of the auxiliary output.\n * `volume` - Volume to set."]
    pub fn ndspAuxSetVolume(id: ::libc::c_int, volume: f32);
}
extern "C" {
    #[doc = "Gets the volume of an auxiliary output.\n # Arguments\n\n* `id` - ID of the auxiliary output.\n # Returns\n\nVolume of the auxiliary output."]
    pub fn ndspAuxGetVolume(id: ::libc::c_int) -> f32;
}
extern "C" {
    #[doc = "Sets the callback of an auxiliary output.\n # Arguments\n\n* `id` - ID of the auxiliary output.\n * `callback` - Callback to set.\n * `data` - User-defined data to pass to the callback."]
    pub fn ndspAuxSetCallback(
        id: ::libc::c_int,
        callback: ndspAuxCallback,
        data: *mut ::libc::c_void,
    );
}
#[doc = "< PCM8"]
pub const NDSP_ENCODING_PCM8: _bindgen_ty_30 = 0;
#[doc = "< PCM16"]
pub const NDSP_ENCODING_PCM16: _bindgen_ty_30 = 1;
#[doc = "< DSPADPCM (GameCube format)"]
pub const NDSP_ENCODING_ADPCM: _bindgen_ty_30 = 2;
#[doc = "Data types\n# Supported sample encodings."]
pub type _bindgen_ty_30 = ::libc::c_uint;
#[doc = "< Buffer contains Mono PCM8."]
pub const NDSP_FORMAT_MONO_PCM8: _bindgen_ty_31 = 1;
#[doc = "< Buffer contains Mono PCM16."]
pub const NDSP_FORMAT_MONO_PCM16: _bindgen_ty_31 = 5;
#[doc = "< Buffer contains Mono ADPCM."]
pub const NDSP_FORMAT_MONO_ADPCM: _bindgen_ty_31 = 9;
#[doc = "< Buffer contains Stereo PCM8."]
pub const NDSP_FORMAT_STEREO_PCM8: _bindgen_ty_31 = 2;
#[doc = "< Buffer contains Stereo PCM16."]
pub const NDSP_FORMAT_STEREO_PCM16: _bindgen_ty_31 = 6;
#[doc = "< (Alias) Buffer contains Mono PCM8."]
pub const NDSP_FORMAT_PCM8: _bindgen_ty_31 = 1;
#[doc = "< (Alias) Buffer contains Mono PCM16."]
pub const NDSP_FORMAT_PCM16: _bindgen_ty_31 = 5;
#[doc = "< (Alias) Buffer contains Mono ADPCM."]
pub const NDSP_FORMAT_ADPCM: _bindgen_ty_31 = 9;
#[doc = "< Front bypass."]
pub const NDSP_FRONT_BYPASS: _bindgen_ty_31 = 16;
#[doc = "< (?) Unknown, under research"]
pub const NDSP_3D_SURROUND_PREPROCESSED: _bindgen_ty_31 = 64;
#[doc = "Channel format flags for use with ndspChnSetFormat."]
pub type _bindgen_ty_31 = ::libc::c_uint;
#[doc = "< Polyphase interpolation"]
pub const NDSP_INTERP_POLYPHASE: ndspInterpType = 0;
#[doc = "< Linear interpolation"]
pub const NDSP_INTERP_LINEAR: ndspInterpType = 1;
#[doc = "< No interpolation"]
pub const NDSP_INTERP_NONE: ndspInterpType = 2;
#[doc = "Interpolation types."]
pub type ndspInterpType = ::libc::c_uint;
extern "C" {
    #[doc = "Basic channel operation\n# *\n* Resets a channel.\n # Arguments\n\n* `id` - ID of the channel (0..23).\n/"]
    pub fn ndspChnReset(id: ::libc::c_int);
}
extern "C" {
    #[doc = "Initializes the parameters of a channel.\n # Arguments\n\n* `id` - ID of the channel (0..23)."]
    pub fn ndspChnInitParams(id: ::libc::c_int);
}
extern "C" {
    #[doc = "Checks whether a channel is currently playing.\n # Arguments\n\n* `id` - ID of the channel (0..23).\n # Returns\n\nWhether the channel is currently playing."]
    pub fn ndspChnIsPlaying(id: ::libc::c_int) -> bool;
}
extern "C" {
    #[doc = "Gets the current sample position of a channel.\n # Arguments\n\n* `id` - ID of the channel (0..23).\n # Returns\n\nThe channel's sample position."]
    pub fn ndspChnGetSamplePos(id: ::libc::c_int) -> u32_;
}
extern "C" {
    #[doc = "Gets the sequence ID of the wave buffer that is currently playing in a channel.\n # Arguments\n\n* `id` - ID of the channel (0..23).\n # Returns\n\nThe sequence ID of the wave buffer."]
    pub fn ndspChnGetWaveBufSeq(id: ::libc::c_int) -> u16_;
}
extern "C" {
    #[doc = "Checks whether a channel is currently paused.\n # Arguments\n\n* `id` - ID of the channel (0..23).\n # Returns\n\nWhether the channel is currently paused."]
    pub fn ndspChnIsPaused(id: ::libc::c_int) -> bool;
}
extern "C" {
    #[doc = "Sets the pause status of a channel.\n # Arguments\n\n* `id` - ID of the channel (0..23).\n * `paused` - Whether the channel is to be paused (true) or unpaused (false)."]
    pub fn ndspChnSetPaused(id: ::libc::c_int, paused: bool);
}
extern "C" {
    #[doc = "Configuration\n# *\n* Sets the format of a channel.\n # Arguments\n\n* `id` - ID of the channel (0..23).\n * `format` - Format to use.\n/"]
    pub fn ndspChnSetFormat(id: ::libc::c_int, format: u16_);
}
extern "C" {
    #[doc = "Gets the format of a channel.\n # Arguments\n\n* `id` - ID of the channel (0..23).\n # Returns\n\nThe format of the channel."]
    pub fn ndspChnGetFormat(id: ::libc::c_int) -> u16_;
}
extern "C" {
    #[doc = "Sets the interpolation type of a channel.\n # Arguments\n\n* `id` - ID of the channel (0..23).\n * `type` - Interpolation type to use."]
    pub fn ndspChnSetInterp(id: ::libc::c_int, type_: ndspInterpType);
}
extern "C" {
    #[doc = "Gets the interpolation type of a channel.\n # Arguments\n\n* `id` - ID of the channel (0..23).\n # Returns\n\nThe interpolation type of the channel."]
    pub fn ndspChnGetInterp(id: ::libc::c_int) -> ndspInterpType;
}
extern "C" {
    #[doc = "Sets the sample rate of a channel.\n # Arguments\n\n* `id` - ID of the channel (0..23).\n * `rate` - Sample rate to use."]
    pub fn ndspChnSetRate(id: ::libc::c_int, rate: f32);
}
extern "C" {
    #[doc = "Gets the sample rate of a channel.\n # Arguments\n\n* `id` - ID of the channel (0..23).\n # Returns\n\nThe sample rate of the channel."]
    pub fn ndspChnGetRate(id: ::libc::c_int) -> f32;
}
extern "C" {
    #[doc = "Sets the mix parameters (volumes) of a channel.\n # Arguments\n\n* `id` - ID of the channel (0..23).\n * `mix` - Mix parameters to use. Working hypothesis:\n - 0: Front left volume.\n - 1: Front right volume.\n - 2: Back left volume:\n - 3: Back right volume:\n - 4..7: Same as 0..3, but for auxiliary output 0.\n - 8..11: Same as 0..3, but for auxiliary output 1."]
    pub fn ndspChnSetMix(id: ::libc::c_int, mix: *mut f32);
}
extern "C" {
    #[doc = "Gets the mix parameters (volumes) of a channel.\n # Arguments\n\n* `id` - ID of the channel (0..23)\n * `mix` - Mix parameters to write out to. See ndspChnSetMix."]
    pub fn ndspChnGetMix(id: ::libc::c_int, mix: *mut f32);
}
extern "C" {
    #[doc = "Sets the DSPADPCM coefficients of a channel.\n # Arguments\n\n* `id` - ID of the channel (0..23).\n * `coefs` - DSPADPCM coefficients to use."]
    pub fn ndspChnSetAdpcmCoefs(id: ::libc::c_int, coefs: *mut u16_);
}
extern "C" {
    #[doc = "Wave buffers\n# *\n* Clears the wave buffer queue of a channel and stops playback.\n # Arguments\n\n* `id` - ID of the channel (0..23).\n/"]
    pub fn ndspChnWaveBufClear(id: ::libc::c_int);
}
extern "C" {
    #[doc = "Adds a wave buffer to the wave buffer queue of a channel.\n > If the channel's wave buffer queue was empty before the use of this function, playback is started.\n # Arguments\n\n* `id` - ID of the channel (0..23).\n * `buf` - Wave buffer to add."]
    pub fn ndspChnWaveBufAdd(id: ::libc::c_int, buf: *mut ndspWaveBuf);
}
extern "C" {
    #[doc = "IIR filters\n# *\n* Configures whether the IIR monopole filter of a channel is enabled.\n # Arguments\n\n* `id` - ID of the channel (0..23).\n * `enable` - Whether to enable the IIR monopole filter.\n/"]
    pub fn ndspChnIirMonoSetEnable(id: ::libc::c_int, enable: bool);
}
extern "C" {
    #[doc = "Manually sets up the parameters on monopole filter\n # Arguments\n\n* `id` - ID of the channel (0..23).\n * `enable` - Whether to enable the IIR monopole filter."]
    pub fn ndspChnIirMonoSetParamsCustomFilter(
        id: ::libc::c_int,
        a0: f32,
        a1: f32,
        b0: f32,
    ) -> bool;
}
extern "C" {
    #[doc = "Sets the monopole to be a low pass filter. (Note: This is a lower-quality filter than the biquad one.)\n # Arguments\n\n* `id` - ID of the channel (0..23).\n * `f0` - Low pass cut-off frequency."]
    pub fn ndspChnIirMonoSetParamsLowPassFilter(id: ::libc::c_int, f0: f32) -> bool;
}
extern "C" {
    #[doc = "Sets the monopole to be a high pass filter. (Note: This is a lower-quality filter than the biquad one.)\n # Arguments\n\n* `id` - ID of the channel (0..23).\n * `f0` - High pass cut-off frequency."]
    pub fn ndspChnIirMonoSetParamsHighPassFilter(id: ::libc::c_int, f0: f32) -> bool;
}
extern "C" {
    #[doc = "Configures whether the IIR biquad filter of a channel is enabled.\n # Arguments\n\n* `id` - ID of the channel (0..23).\n * `enable` - Whether to enable the IIR biquad filter."]
    pub fn ndspChnIirBiquadSetEnable(id: ::libc::c_int, enable: bool);
}
extern "C" {
    #[doc = "Manually sets up the parameters of the biquad filter\n # Arguments\n\n* `id` - ID of the channel (0..23)."]
    pub fn ndspChnIirBiquadSetParamsCustomFilter(
        id: ::libc::c_int,
        a0: f32,
        a1: f32,
        a2: f32,
        b0: f32,
        b1: f32,
        b2: f32,
    ) -> bool;
}
extern "C" {
    #[doc = "Sets the biquad to be a low pass filter.\n # Arguments\n\n* `id` - ID of the channel (0..23).\n * `f0` - Low pass cut-off frequency.\n * `Q` - \"Quality factor\", typically should be sqrt(2)/2 (i.e. 0.7071)."]
    pub fn ndspChnIirBiquadSetParamsLowPassFilter(id: ::libc::c_int, f0: f32, Q: f32) -> bool;
}
extern "C" {
    #[doc = "Sets the biquad to be a high pass filter.\n # Arguments\n\n* `id` - ID of the channel (0..23).\n * `f0` - High pass cut-off frequency.\n * `Q` - \"Quality factor\", typically should be sqrt(2)/2 (i.e. 0.7071)."]
    pub fn ndspChnIirBiquadSetParamsHighPassFilter(id: ::libc::c_int, f0: f32, Q: f32) -> bool;
}
extern "C" {
    #[doc = "Sets the biquad to be a band pass filter.\n # Arguments\n\n* `id` - ID of the channel (0..23).\n * `f0` - Mid-frequency.\n * `Q` - \"Quality factor\", typically should be sqrt(2)/2 (i.e. 0.7071)."]
    pub fn ndspChnIirBiquadSetParamsBandPassFilter(id: ::libc::c_int, f0: f32, Q: f32) -> bool;
}
extern "C" {
    #[doc = "Sets the biquad to be a notch filter.\n # Arguments\n\n* `id` - ID of the channel (0..23).\n * `f0` - Notch frequency.\n * `Q` - \"Quality factor\", typically should be sqrt(2)/2 (i.e. 0.7071)."]
    pub fn ndspChnIirBiquadSetParamsNotchFilter(id: ::libc::c_int, f0: f32, Q: f32) -> bool;
}
extern "C" {
    #[doc = "Sets the biquad to be a peaking equalizer.\n # Arguments\n\n* `id` - ID of the channel (0..23).\n * `f0` - Central frequency.\n * `Q` - \"Quality factor\", typically should be sqrt(2)/2 (i.e. 0.7071).\n * `gain` - Amount of gain (raw value = 10 ^ dB/40)"]
    pub fn ndspChnIirBiquadSetParamsPeakingEqualizer(
        id: ::libc::c_int,
        f0: f32,
        Q: f32,
        gain: f32,
    ) -> bool;
}
#[doc = "< Normal keyboard with several pages (QWERTY/accents/symbol/mobile)"]
pub const SWKBD_TYPE_NORMAL: SwkbdType = 0;
#[doc = "< QWERTY keyboard only."]
pub const SWKBD_TYPE_QWERTY: SwkbdType = 1;
#[doc = "< Number pad."]
pub const SWKBD_TYPE_NUMPAD: SwkbdType = 2;
#[doc = "< On JPN systems, a text keyboard without Japanese input capabilities, otherwise same as SWKBD_TYPE_NORMAL."]
pub const SWKBD_TYPE_WESTERN: SwkbdType = 3;
#[doc = "Keyboard types."]
pub type SwkbdType = ::libc::c_uint;
#[doc = "< All inputs are accepted."]
pub const SWKBD_ANYTHING: SwkbdValidInput = 0;
#[doc = "< Empty inputs are not accepted."]
pub const SWKBD_NOTEMPTY: SwkbdValidInput = 1;
#[doc = "< Empty or blank inputs (consisting solely of whitespace) are not accepted."]
pub const SWKBD_NOTEMPTY_NOTBLANK: SwkbdValidInput = 2;
pub const SWKBD_NOTBLANK_NOTEMPTY: SwkbdValidInput = 2;
#[doc = "< Blank inputs (consisting solely of whitespace) are not accepted, but empty inputs are."]
pub const SWKBD_NOTBLANK: SwkbdValidInput = 3;
#[doc = "< The input must have a fixed length (specified by maxTextLength in swkbdInit)."]
pub const SWKBD_FIXEDLEN: SwkbdValidInput = 4;
#[doc = "Accepted input types."]
pub type SwkbdValidInput = ::libc::c_uint;
#[doc = "< Left button (usually Cancel)"]
pub const SWKBD_BUTTON_LEFT: SwkbdButton = 0;
#[doc = "< Middle button (usually I Forgot)"]
pub const SWKBD_BUTTON_MIDDLE: SwkbdButton = 1;
#[doc = "< Right button (usually OK)"]
pub const SWKBD_BUTTON_RIGHT: SwkbdButton = 2;
pub const SWKBD_BUTTON_CONFIRM: SwkbdButton = 2;
#[doc = "< No button (returned by swkbdInputText in special cases)"]
pub const SWKBD_BUTTON_NONE: SwkbdButton = 3;
#[doc = "Keyboard dialog buttons."]
pub type SwkbdButton = ::libc::c_uint;
#[doc = "< Characters are not concealed."]
pub const SWKBD_PASSWORD_NONE: SwkbdPasswordMode = 0;
#[doc = "< Characters are concealed immediately."]
pub const SWKBD_PASSWORD_HIDE: SwkbdPasswordMode = 1;
#[doc = "< Characters are concealed a second after they've been typed."]
pub const SWKBD_PASSWORD_HIDE_DELAY: SwkbdPasswordMode = 2;
#[doc = "Keyboard password modes."]
pub type SwkbdPasswordMode = ::libc::c_uint;
#[doc = "< Disallow the use of more than a certain number of digits (0 or more)"]
pub const SWKBD_FILTER_DIGITS: _bindgen_ty_32 = 1;
#[doc = "< Disallow the use of the  sign."]
pub const SWKBD_FILTER_AT: _bindgen_ty_32 = 2;
#[doc = "< Disallow the use of the % sign."]
pub const SWKBD_FILTER_PERCENT: _bindgen_ty_32 = 4;
#[doc = "< Disallow the use of the  sign."]
pub const SWKBD_FILTER_BACKSLASH: _bindgen_ty_32 = 8;
#[doc = "< Disallow profanity using Nintendo's profanity filter."]
pub const SWKBD_FILTER_PROFANITY: _bindgen_ty_32 = 16;
#[doc = "< Use a callback in order to check the input."]
pub const SWKBD_FILTER_CALLBACK: _bindgen_ty_32 = 32;
#[doc = "Keyboard input filtering flags."]
pub type _bindgen_ty_32 = ::libc::c_uint;
#[doc = "< Parental PIN mode."]
pub const SWKBD_PARENTAL: _bindgen_ty_33 = 1;
#[doc = "< Darken the top screen when the keyboard is shown."]
pub const SWKBD_DARKEN_TOP_SCREEN: _bindgen_ty_33 = 2;
#[doc = "< Enable predictive input (necessary for Kanji input in JPN systems)."]
pub const SWKBD_PREDICTIVE_INPUT: _bindgen_ty_33 = 4;
#[doc = "< Enable multiline input."]
pub const SWKBD_MULTILINE: _bindgen_ty_33 = 8;
#[doc = "< Enable fixed-width mode."]
pub const SWKBD_FIXED_WIDTH: _bindgen_ty_33 = 16;
#[doc = "< Allow the usage of the HOME button."]
pub const SWKBD_ALLOW_HOME: _bindgen_ty_33 = 32;
#[doc = "< Allow the usage of a software-reset combination."]
pub const SWKBD_ALLOW_RESET: _bindgen_ty_33 = 64;
#[doc = "< Allow the usage of the POWER button."]
pub const SWKBD_ALLOW_POWER: _bindgen_ty_33 = 128;
#[doc = "< Default to the QWERTY page when the keyboard is shown."]
pub const SWKBD_DEFAULT_QWERTY: _bindgen_ty_33 = 512;
#[doc = "Keyboard features."]
pub type _bindgen_ty_33 = ::libc::c_uint;
#[doc = "< Specifies that the input is valid."]
pub const SWKBD_CALLBACK_OK: SwkbdCallbackResult = 0;
#[doc = "< Displays an error message, then closes the keyboard."]
pub const SWKBD_CALLBACK_CLOSE: SwkbdCallbackResult = 1;
#[doc = "< Displays an error message and continues displaying the keyboard."]
pub const SWKBD_CALLBACK_CONTINUE: SwkbdCallbackResult = 2;
#[doc = "Keyboard filter callback return values."]
pub type SwkbdCallbackResult = ::libc::c_uint;
#[doc = "< Dummy/unused."]
pub const SWKBD_NONE: SwkbdResult = -1;
#[doc = "< Invalid parameters to swkbd."]
pub const SWKBD_INVALID_INPUT: SwkbdResult = -2;
#[doc = "< Out of memory."]
pub const SWKBD_OUTOFMEM: SwkbdResult = -3;
#[doc = "< The button was clicked in 1-button dialogs."]
pub const SWKBD_D0_CLICK: SwkbdResult = 0;
#[doc = "< The left button was clicked in 2-button dialogs."]
pub const SWKBD_D1_CLICK0: SwkbdResult = 1;
#[doc = "< The right button was clicked in 2-button dialogs."]
pub const SWKBD_D1_CLICK1: SwkbdResult = 2;
#[doc = "< The left button was clicked in 3-button dialogs."]
pub const SWKBD_D2_CLICK0: SwkbdResult = 3;
#[doc = "< The middle button was clicked in 3-button dialogs."]
pub const SWKBD_D2_CLICK1: SwkbdResult = 4;
#[doc = "< The right button was clicked in 3-button dialogs."]
pub const SWKBD_D2_CLICK2: SwkbdResult = 5;
#[doc = "< The HOME button was pressed."]
pub const SWKBD_HOMEPRESSED: SwkbdResult = 10;
#[doc = "< The soft-reset key combination was pressed."]
pub const SWKBD_RESETPRESSED: SwkbdResult = 11;
#[doc = "< The POWER button was pressed."]
pub const SWKBD_POWERPRESSED: SwkbdResult = 12;
#[doc = "< The parental PIN was verified successfully."]
pub const SWKBD_PARENTAL_OK: SwkbdResult = 20;
#[doc = "< The parental PIN was incorrect."]
pub const SWKBD_PARENTAL_FAIL: SwkbdResult = 21;
#[doc = "< The filter callback returned SWKBD_CALLBACK_CLOSE."]
pub const SWKBD_BANNED_INPUT: SwkbdResult = 30;
#[doc = "Keyboard return values."]
pub type SwkbdResult = ::libc::c_int;
#[doc = "Keyboard dictionary word for predictive input."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SwkbdDictWord {
    #[doc = "< Reading of the word (that is, the string that needs to be typed)."]
    pub reading: [u16_; 41usize],
    #[doc = "< Spelling of the word."]
    pub word: [u16_; 41usize],
    #[doc = "< Language the word applies to."]
    pub language: u8_,
    #[doc = "< Specifies if the word applies to all languages."]
    pub all_languages: bool,
}
impl Default for SwkbdDictWord {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Keyboard filter callback function."]
pub type SwkbdCallbackFn = ::core::option::Option<
    unsafe extern "C" fn(
        user: *mut ::libc::c_void,
        ppMessage: *mut *const ::libc::c_char,
        text: *const ::libc::c_char,
        textlen: usize,
    ) -> SwkbdCallbackResult,
>;
#[doc = "Keyboard status data."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SwkbdStatusData {
    pub data: [u32_; 17usize],
}
#[doc = "Keyboard predictive input learning data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SwkbdLearningData {
    pub data: [u32_; 10523usize],
}
impl Default for SwkbdLearningData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Internal libctru book-keeping structure for software keyboards."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SwkbdExtra {
    pub initial_text: *const ::libc::c_char,
    pub dict: *const SwkbdDictWord,
    pub status_data: *mut SwkbdStatusData,
    pub learning_data: *mut SwkbdLearningData,
    pub callback: SwkbdCallbackFn,
    pub callback_user: *mut ::libc::c_void,
}
impl Default for SwkbdExtra {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Software keyboard parameter structure, it shouldn't be modified directly."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SwkbdState {
    pub type_: ::libc::c_int,
    pub num_buttons_m1: ::libc::c_int,
    pub valid_input: ::libc::c_int,
    pub password_mode: ::libc::c_int,
    pub is_parental_screen: ::libc::c_int,
    pub darken_top_screen: ::libc::c_int,
    pub filter_flags: u32_,
    pub save_state_flags: u32_,
    pub max_text_len: u16_,
    pub dict_word_count: u16_,
    pub max_digits: u16_,
    pub button_text: [[u16_; 17usize]; 3usize],
    pub numpad_keys: [u16_; 2usize],
    pub hint_text: [u16_; 65usize],
    pub predictive_input: bool,
    pub multiline: bool,
    pub fixed_width: bool,
    pub allow_home: bool,
    pub allow_reset: bool,
    pub allow_power: bool,
    pub unknown: bool,
    pub default_qwerty: bool,
    pub button_submits_text: [bool; 4usize],
    pub language: u16_,
    pub initial_text_offset: ::libc::c_int,
    pub dict_offset: ::libc::c_int,
    pub initial_status_offset: ::libc::c_int,
    pub initial_learning_offset: ::libc::c_int,
    pub shared_memory_size: usize,
    pub version: u32_,
    pub result: SwkbdResult,
    pub status_offset: ::libc::c_int,
    pub learning_offset: ::libc::c_int,
    pub text_offset: ::libc::c_int,
    pub text_length: u16_,
    pub callback_result: ::libc::c_int,
    pub callback_msg: [u16_; 257usize],
    pub skip_at_check: bool,
    pub __bindgen_anon_1: SwkbdState__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SwkbdState__bindgen_ty_1 {
    pub reserved: [u8_; 171usize],
    pub extra: SwkbdExtra,
}
impl Default for SwkbdState__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for SwkbdState {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = "Initializes software keyboard status.\n # Arguments\n\n* `swkbd` - Pointer to swkbd state.\n * `type` - Keyboard type.\n * `numButtons` - Number of dialog buttons to display (1, 2 or 3).\n * `maxTextLength` - Maximum number of UTF-16 code units that input text can have (or -1 to let libctru use a big default)."]
    pub fn swkbdInit(
        swkbd: *mut SwkbdState,
        type_: SwkbdType,
        numButtons: ::libc::c_int,
        maxTextLength: ::libc::c_int,
    );
}
extern "C" {
    #[doc = "Configures password mode in a software keyboard.\n # Arguments\n\n* `swkbd` - Pointer to swkbd state.\n * `mode` - Password mode."]
    #[link_name = "swkbdSetPasswordMode__extern"]
    pub fn swkbdSetPasswordMode(swkbd: *mut SwkbdState, mode: SwkbdPasswordMode);
}
extern "C" {
    #[doc = "Configures input validation in a software keyboard.\n # Arguments\n\n* `swkbd` - Pointer to swkbd state.\n * `validInput` - Specifies which inputs are valid.\n * `filterFlags` - Bitmask specifying which characters are disallowed (filtered).\n * `maxDigits` - In case digits are disallowed, specifies how many digits are allowed at maximum in input strings (0 completely restricts digit input)."]
    #[link_name = "swkbdSetValidation__extern"]
    pub fn swkbdSetValidation(
        swkbd: *mut SwkbdState,
        validInput: SwkbdValidInput,
        filterFlags: u32_,
        maxDigits: ::libc::c_int,
    );
}
extern "C" {
    #[doc = "Configures what characters will the two bottom keys in a numpad produce.\n # Arguments\n\n* `swkbd` - Pointer to swkbd state.\n * `left` - Unicode codepoint produced by the leftmost key in the bottom row (0 hides the key).\n * `left` - Unicode codepoint produced by the rightmost key in the bottom row (0 hides the key)."]
    #[link_name = "swkbdSetNumpadKeys__extern"]
    pub fn swkbdSetNumpadKeys(swkbd: *mut SwkbdState, left: ::libc::c_int, right: ::libc::c_int);
}
extern "C" {
    #[doc = "Specifies which special features are enabled in a software keyboard.\n # Arguments\n\n* `swkbd` - Pointer to swkbd state.\n * `features` - Feature bitmask."]
    pub fn swkbdSetFeatures(swkbd: *mut SwkbdState, features: u32_);
}
extern "C" {
    #[doc = "Sets the hint text of a software keyboard (that is, the help text that is displayed when the textbox is empty).\n # Arguments\n\n* `swkbd` - Pointer to swkbd state.\n * `text` - Hint text."]
    pub fn swkbdSetHintText(swkbd: *mut SwkbdState, text: *const ::libc::c_char);
}
extern "C" {
    #[doc = "Configures a dialog button in a software keyboard.\n # Arguments\n\n* `swkbd` - Pointer to swkbd state.\n * `button` - Specifies which button to configure.\n * `text` - Button text.\n * `submit` - Specifies whether pushing the button will submit the text or discard it."]
    pub fn swkbdSetButton(
        swkbd: *mut SwkbdState,
        button: SwkbdButton,
        text: *const ::libc::c_char,
        submit: bool,
    );
}
extern "C" {
    #[doc = "Sets the initial text that a software keyboard will display on launch.\n # Arguments\n\n* `swkbd` - Pointer to swkbd state.\n * `text` - Initial text."]
    pub fn swkbdSetInitialText(swkbd: *mut SwkbdState, text: *const ::libc::c_char);
}
extern "C" {
    #[doc = "Configures a word in a predictive dictionary for use with a software keyboard.\n # Arguments\n\n* `word` - Pointer to dictionary word structure.\n * `reading` - Reading of the word, that is, the sequence of characters that need to be typed to trigger the word in the predictive input system.\n * `text` - Spelling of the word, that is, the actual characters that will be produced when the user decides to select the word."]
    pub fn swkbdSetDictWord(
        word: *mut SwkbdDictWord,
        reading: *const ::libc::c_char,
        text: *const ::libc::c_char,
    );
}
extern "C" {
    #[doc = "Sets the custom word dictionary to be used with the predictive input system of a software keyboard.\n # Arguments\n\n* `swkbd` - Pointer to swkbd state.\n * `dict` - Pointer to dictionary words.\n * `wordCount` - Number of words in the dictionary."]
    pub fn swkbdSetDictionary(
        swkbd: *mut SwkbdState,
        dict: *const SwkbdDictWord,
        wordCount: ::libc::c_int,
    );
}
extern "C" {
    #[doc = "Configures software keyboard internal status management.\n # Arguments\n\n* `swkbd` - Pointer to swkbd state.\n * `data` - Pointer to internal status structure (can be in, out or both depending on the other parameters).\n * `in` - Specifies whether the data should be read from the structure when the keyboard is launched.\n * `out` - Specifies whether the data should be written to the structure when the keyboard is closed."]
    pub fn swkbdSetStatusData(
        swkbd: *mut SwkbdState,
        data: *mut SwkbdStatusData,
        in_: bool,
        out: bool,
    );
}
extern "C" {
    #[doc = "Configures software keyboard predictive input learning data management.\n # Arguments\n\n* `swkbd` - Pointer to swkbd state.\n * `data` - Pointer to learning data structure (can be in, out or both depending on the other parameters).\n * `in` - Specifies whether the data should be read from the structure when the keyboard is launched.\n * `out` - Specifies whether the data should be written to the structure when the keyboard is closed."]
    pub fn swkbdSetLearningData(
        swkbd: *mut SwkbdState,
        data: *mut SwkbdLearningData,
        in_: bool,
        out: bool,
    );
}
extern "C" {
    #[doc = "Configures a custom function to be used to check the validity of input when it is submitted in a software keyboard.\n # Arguments\n\n* `swkbd` - Pointer to swkbd state.\n * `callback` - Filter callback function.\n * `user` - Custom data to be passed to the callback function."]
    pub fn swkbdSetFilterCallback(
        swkbd: *mut SwkbdState,
        callback: SwkbdCallbackFn,
        user: *mut ::libc::c_void,
    );
}
extern "C" {
    #[doc = "Launches a software keyboard in order to input text.\n # Arguments\n\n* `swkbd` - Pointer to swkbd state.\n * `buf` - Pointer to output buffer which will hold the inputted text.\n * `bufsize` - Maximum number of UTF-8 code units that the buffer can hold (including null terminator).\n # Returns\n\nThe identifier of the dialog button that was pressed, or SWKBD_BUTTON_NONE if a different condition was triggered - in that case use swkbdGetResult to check the condition."]
    pub fn swkbdInputText(
        swkbd: *mut SwkbdState,
        buf: *mut ::libc::c_char,
        bufsize: usize,
    ) -> SwkbdButton;
}
extern "C" {
    #[doc = "Retrieves the result condition of a software keyboard after it has been used.\n # Arguments\n\n* `swkbd` - Pointer to swkbd state.\n # Returns\n\nThe result value."]
    #[link_name = "swkbdGetResult__extern"]
    pub fn swkbdGetResult(swkbd: *mut SwkbdState) -> SwkbdResult;
}
#[doc = "<??-Unknown flag"]
pub const ERROR_LANGUAGE_FLAG: _bindgen_ty_34 = 256;
#[doc = "<??-Unknown flag"]
pub const ERROR_WORD_WRAP_FLAG: _bindgen_ty_34 = 512;
pub type _bindgen_ty_34 = ::libc::c_uint;
#[doc = "< Displays the infrastructure communications-related error message corresponding to the error code."]
pub const ERROR_CODE: errorType = 0;
#[doc = "< Displays text passed to this applet."]
pub const ERROR_TEXT: errorType = 1;
#[doc = "< Displays the EULA"]
pub const ERROR_EULA: errorType = 2;
#[doc = "< Use prohibited."]
pub const ERROR_TYPE_EULA_FIRST_BOOT: errorType = 3;
#[doc = "< Use prohibited."]
pub const ERROR_TYPE_EULA_DRAW_ONLY: errorType = 4;
#[doc = "< Use prohibited."]
pub const ERROR_TYPE_AGREE: errorType = 5;
#[doc = "< Displays a network error message in a specified language."]
pub const ERROR_CODE_LANGUAGE: errorType = 256;
#[doc = "< Displays text passed to this applet in a specified language."]
pub const ERROR_TEXT_LANGUAGE: errorType = 257;
#[doc = "< Displays EULA in a specified language."]
pub const ERROR_EULA_LANGUAGE: errorType = 258;
#[doc = "< Displays the custom error message passed to this applet with automatic line wrapping"]
pub const ERROR_TEXT_WORD_WRAP: errorType = 513;
#[doc = "< Displays the custom error message with automatic line wrapping and in the specified language."]
pub const ERROR_TEXT_LANGUAGE_WORD_WRAP: errorType = 769;
pub type errorType = ::libc::c_uint;
pub const ERROR_NORMAL: errorScreenFlag = 0;
pub const ERROR_STEREO: errorScreenFlag = 1;
pub type errorScreenFlag = ::libc::c_uint;
pub const ERROR_UNKNOWN: errorReturnCode = -1;
pub const ERROR_NONE: errorReturnCode = 0;
pub const ERROR_SUCCESS: errorReturnCode = 1;
pub const ERROR_NOT_SUPPORTED: errorReturnCode = 2;
pub const ERROR_HOME_BUTTON: errorReturnCode = 10;
pub const ERROR_SOFTWARE_RESET: errorReturnCode = 11;
pub const ERROR_POWER_BUTTON: errorReturnCode = 12;
pub type errorReturnCode = ::libc::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct errorConf {
    pub type_: errorType,
    pub errorCode: ::libc::c_int,
    pub upperScreenFlag: errorScreenFlag,
    pub useLanguage: u16_,
    pub Text: [u16_; 1900usize],
    pub homeButton: bool,
    pub softwareReset: bool,
    pub appJump: bool,
    pub returnCode: errorReturnCode,
    pub eulaVersion: u16_,
}
impl Default for errorConf {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = "Init the error applet.\n # Arguments\n\n* `err` - Pointer to errorConf.\n * `type` - errorType Type of error.\n * `lang` - CFG_Language Lang of error."]
    pub fn errorInit(err: *mut errorConf, type_: errorType, lang: CFG_Language);
}
extern "C" {
    #[doc = "Sets error code to display.\n # Arguments\n\n* `err` - Pointer to errorConf.\n * `error` - Error-code to display."]
    pub fn errorCode(err: *mut errorConf, error: ::libc::c_int);
}
extern "C" {
    #[doc = "Sets error text to display.\n # Arguments\n\n* `err` - Pointer to errorConf.\n * `text` - Error-text to display."]
    pub fn errorText(err: *mut errorConf, text: *const ::libc::c_char);
}
extern "C" {
    #[doc = "Displays the error applet.\n # Arguments\n\n* `err` - Pointer to errorConf."]
    pub fn errorDisp(err: *mut errorConf);
}
#[doc = "Parameter structure passed to AppletEd"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MiiSelectorConf {
    #[doc = "< Enables canceling of selection if nonzero."]
    pub enable_cancel_button: u8_,
    #[doc = "< Makes Guets Miis selectable if nonzero."]
    pub enable_selecting_guests: u8_,
    #[doc = "< Shows applet on top screen if nonzero,\n< otherwise show it on the bottom screen."]
    pub show_on_top_screen: u8_,
    #[doc = "< "]
    pub _unk0x3: [u8_; 5usize],
    #[doc = "< UTF16-LE string displayed at the top of the applet. If\n< set to the empty string, a default title is displayed."]
    pub title: [u16_; 64usize],
    #[doc = "< "]
    pub _unk0x88: [u8_; 4usize],
    #[doc = "< If nonzero, the applet shows a page with Guest\n< Miis on launch."]
    pub show_guest_page: u8_,
    #[doc = "< "]
    pub _unk0x8D: [u8_; 3usize],
    #[doc = "< Index of the initially selected Mii. If\n< MiiSelectorConf.show_guest_page is\n< set, this is the index of a Guest Mii,\n< otherwise that of a user Mii."]
    pub initial_index: u32_,
    #[doc = "< Each byte set to a nonzero value\n< enables its corresponding Guest\n< Mii to be enabled for selection."]
    pub mii_guest_whitelist: [u8_; 6usize],
    #[doc = "< Each byte set to a nonzero value enables\n< its corresponding user Mii to be enabled\n< for selection."]
    pub mii_whitelist: [u8_; 100usize],
    #[doc = "< "]
    pub _unk0xFE: u16_,
    #[doc = "< Will be set to MIISELECTOR_MAGIC before launching the\n< applet."]
    pub magic: u32_,
}
impl Default for MiiSelectorConf {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Structure written by AppletEd"]
#[repr(C)]
pub struct MiiSelectorReturn {
    #[doc = "< 0 if a Mii was selected, 1 if the selection was\n< canceled."]
    pub no_mii_selected: u32_,
    #[doc = "< 1 if a Guest Mii was selected, 0 otherwise."]
    pub guest_mii_was_selected: u32_,
    #[doc = "< Index of the selected Guest Mii,\n< 0xFFFFFFFF if no guest was selected."]
    pub guest_mii_index: u32_,
    #[doc = "< Data of selected Mii."]
    pub mii: MiiData,
    #[doc = "< "]
    pub _pad0x68: u16_,
    #[doc = "< Checksum of the returned Mii data.\n< Stored as a big-endian value; use\n< miiSelectorChecksumIsValid to\n< verify."]
    pub checksum: u16_,
    #[doc = "< Localized name of a Guest Mii,\n< if one was selected (UTF16-LE\n< string). Zeroed otherwise."]
    pub guest_mii_name: [u16_; 12usize],
}
impl Default for MiiSelectorReturn {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "< Show the cancel button"]
pub const MIISELECTOR_CANCEL: _bindgen_ty_35 = 1;
#[doc = "< Make Guets Miis selectable"]
pub const MIISELECTOR_GUESTS: _bindgen_ty_35 = 2;
#[doc = "< Show AppletEd on top screen"]
pub const MIISELECTOR_TOP: _bindgen_ty_35 = 4;
#[doc = "< Start on guest page"]
pub const MIISELECTOR_GUESTSTART: _bindgen_ty_35 = 8;
#[doc = "AppletEd options"]
pub type _bindgen_ty_35 = ::libc::c_uint;
extern "C" {
    #[doc = "Initialize Mii selector config\n # Arguments\n\n* `conf` - Pointer to Miiselector config."]
    pub fn miiSelectorInit(conf: *mut MiiSelectorConf);
}
extern "C" {
    #[doc = "Launch the Mii selector library applet\n\n # Arguments\n\n* `conf` - Configuration determining how the applet should behave"]
    pub fn miiSelectorLaunch(conf: *const MiiSelectorConf, returnbuf: *mut MiiSelectorReturn);
}
extern "C" {
    #[doc = "Sets title of the Mii selector library applet\n\n # Arguments\n\n* `conf` - Pointer to miiSelector configuration\n * `text` - Title text of Mii selector"]
    pub fn miiSelectorSetTitle(conf: *mut MiiSelectorConf, text: *const ::libc::c_char);
}
extern "C" {
    #[doc = "Specifies which special options are enabled in the Mii selector\n\n # Arguments\n\n* `conf` - Pointer to miiSelector configuration\n * `options` - Options bitmask"]
    pub fn miiSelectorSetOptions(conf: *mut MiiSelectorConf, options: u32_);
}
extern "C" {
    #[doc = "Specifies which guest Miis will be selectable\n\n # Arguments\n\n* `conf` - Pointer to miiSelector configuration\n * `index` - Index of the guest Miis that will be whitelisted.\n MIISELECTOR_GUESTMII_SLOTS can be used to whitelist all the guest Miis."]
    pub fn miiSelectorWhitelistGuestMii(conf: *mut MiiSelectorConf, index: u32_);
}
extern "C" {
    #[doc = "Specifies which guest Miis will be unselectable\n\n # Arguments\n\n* `conf` - Pointer to miiSelector configuration\n * `index` - Index of the guest Miis that will be blacklisted.\n MIISELECTOR_GUESTMII_SLOTS can be used to blacklist all the guest Miis."]
    pub fn miiSelectorBlacklistGuestMii(conf: *mut MiiSelectorConf, index: u32_);
}
extern "C" {
    #[doc = "Specifies which user Miis will be selectable\n\n # Arguments\n\n* `conf` - Pointer to miiSelector configuration\n * `index` - Index of the user Miis that will be whitelisted.\n MIISELECTOR_USERMII_SLOTS can be used to whitlist all the user Miis"]
    pub fn miiSelectorWhitelistUserMii(conf: *mut MiiSelectorConf, index: u32_);
}
extern "C" {
    #[doc = "Specifies which user Miis will be selectable\n\n # Arguments\n\n* `conf` - Pointer to miiSelector configuration\n * `index` - Index of the user Miis that will be blacklisted.\n MIISELECTOR_USERMII_SLOTS can be used to blacklist all the user Miis"]
    pub fn miiSelectorBlacklistUserMii(conf: *mut MiiSelectorConf, index: u32_);
}
extern "C" {
    #[doc = "Specifies which Mii the cursor should start from\n\n # Arguments\n\n* `conf` - Pointer to miiSelector configuration\n * `index` - Indexed number of the Mii that the cursor will start on.\n If there is no mii with that index, the the cursor will start at the Mii\n with the index 0 (the personal Mii)."]
    #[link_name = "miiSelectorSetInitialIndex__extern"]
    pub fn miiSelectorSetInitialIndex(conf: *mut MiiSelectorConf, index: u32_);
}
extern "C" {
    #[doc = "Get Mii name\n\n # Arguments\n\n* `returnbuf` - Pointer to miiSelector return\n * `out` - String containing a Mii's name\n * `max_size` - Size of string. Since UTF8 characters range in size from 1-3 bytes\n (assuming that no non-BMP characters are used), this value should be 36 (or 30 if you are not\n dealing with guest miis)."]
    pub fn miiSelectorReturnGetName(
        returnbuf: *const MiiSelectorReturn,
        out: *mut ::libc::c_char,
        max_size: usize,
    );
}
extern "C" {
    #[doc = "Get Mii Author\n\n # Arguments\n\n* `returnbuf` - Pointer to miiSelector return\n * `out` - String containing a Mii's author\n * `max_size` - Size of string. Since UTF8 characters range in size from 1-3 bytes\n (assuming that no non-BMP characters are used), this value should be 30."]
    pub fn miiSelectorReturnGetAuthor(
        returnbuf: *const MiiSelectorReturn,
        out: *mut ::libc::c_char,
        max_size: usize,
    );
}
extern "C" {
    #[doc = "Verifies that the Mii data returned from the applet matches its\n checksum\n\n # Arguments\n\n* `returnbuf` - Buffer filled by Mii selector applet\n # Returns\n\n`true` if `returnbuf->checksum` is the same as the one computed from `returnbuf`"]
    pub fn miiSelectorChecksumIsValid(returnbuf: *const MiiSelectorReturn) -> bool;
}
#[doc = "Open directory struct"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct archive_dir_t {
    pub magic: u32_,
    #[doc = "\"arch\""]
    pub fd: Handle,
    #[doc = "CTRU handle"]
    pub index: isize,
    #[doc = "Current entry index"]
    pub size: usize,
    #[doc = "Current batch size"]
    pub entry_data: [FS_DirectoryEntry; 32usize],
}
impl Default for archive_dir_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[must_use]
    #[doc = "Mounts the SD"]
    pub fn archiveMountSdmc() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Mounts and opens an archive as deviceName\n Returns either an archive open error code, or -1 for generic failure"]
    pub fn archiveMount(
        archiveID: FS_ArchiveID,
        archivePath: FS_Path,
        deviceName: *const ::libc::c_char,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Uses FSUSER_ControlArchive with control action ARCHIVE_ACTION_COMMIT_SAVE_DATA on the opened archive. Not done automatically at unmount.\n Returns -1 if the specified device is not found"]
    pub fn archiveCommitSaveData(deviceName: *const ::libc::c_char) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Unmounts the specified device, closing its archive in the process\n Returns -1 if the specified device was not found"]
    pub fn archiveUnmount(deviceName: *const ::libc::c_char) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Unmounts all devices and cleans up any resources used by the driver"]
    pub fn archiveUnmountAll() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Get a file's mtime"]
    pub fn archive_getmtime(name: *const ::libc::c_char, mtime: *mut u64_) -> Result;
}
#[doc = "RomFS header."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct romfs_header {
    #[doc = "< Size of the header."]
    pub headerSize: u32_,
    #[doc = "< Offset of the directory hash table."]
    pub dirHashTableOff: u32_,
    #[doc = "< Size of the directory hash table."]
    pub dirHashTableSize: u32_,
    #[doc = "< Offset of the directory table."]
    pub dirTableOff: u32_,
    #[doc = "< Size of the directory table."]
    pub dirTableSize: u32_,
    #[doc = "< Offset of the file hash table."]
    pub fileHashTableOff: u32_,
    #[doc = "< Size of the file hash table."]
    pub fileHashTableSize: u32_,
    #[doc = "< Offset of the file table."]
    pub fileTableOff: u32_,
    #[doc = "< Size of the file table."]
    pub fileTableSize: u32_,
    #[doc = "< Offset of the file data."]
    pub fileDataOff: u32_,
}
#[doc = "RomFS directory."]
#[repr(C)]
#[derive(Debug, Default)]
pub struct romfs_dir {
    #[doc = "< Offset of the parent directory."]
    pub parent: u32_,
    #[doc = "< Offset of the next sibling directory."]
    pub sibling: u32_,
    #[doc = "< Offset of the first child directory."]
    pub childDir: u32_,
    #[doc = "< Offset of the first file."]
    pub childFile: u32_,
    #[doc = "< Directory hash table pointer."]
    pub nextHash: u32_,
    #[doc = "< Name length."]
    pub nameLen: u32_,
    #[doc = "< Name. (UTF-16)"]
    pub name: __IncompleteArrayField<u16_>,
}
#[doc = "RomFS file."]
#[repr(C)]
#[derive(Debug, Default)]
pub struct romfs_file {
    #[doc = "< Offset of the parent directory."]
    pub parent: u32_,
    #[doc = "< Offset of the next sibling file."]
    pub sibling: u32_,
    #[doc = "< Offset of the file's data."]
    pub dataOff: u64_,
    #[doc = "< Length of the file's data."]
    pub dataSize: u64_,
    #[doc = "< File hash table pointer."]
    pub nextHash: u32_,
    #[doc = "< Name length."]
    pub nameLen: u32_,
    #[doc = "< Name. (UTF-16)"]
    pub name: __IncompleteArrayField<u16_>,
}
extern "C" {
    #[must_use]
    #[doc = "Mounts the Application's RomFS.\n # Arguments\n\n* `name` - Device mount name.\n > This function is intended to be used to access one's own RomFS.\n If the application is running as 3DSX, it mounts the embedded RomFS section inside the 3DSX.\n If on the other hand it's an NCCH, it behaves identically to romfsMountFromCurrentProcess."]
    pub fn romfsMountSelf(name: *const ::libc::c_char) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Mounts RomFS from an open file.\n # Arguments\n\n* `fd` - FSFILE handle of the RomFS image.\n * `offset` - Offset of the RomFS within the file.\n * `name` - Device mount name."]
    pub fn romfsMountFromFile(fd: Handle, offset: u32_, name: *const ::libc::c_char) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Mounts RomFS using the current process host program RomFS.\n # Arguments\n\n* `name` - Device mount name."]
    pub fn romfsMountFromCurrentProcess(name: *const ::libc::c_char) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Mounts RomFS from the specified title.\n # Arguments\n\n* `tid` - Title ID\n * `mediatype` - Mediatype\n * `name` - Device mount name."]
    pub fn romfsMountFromTitle(
        tid: u64_,
        mediatype: FS_MediaType,
        name: *const ::libc::c_char,
    ) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Unmounts the RomFS device."]
    pub fn romfsUnmount(name: *const ::libc::c_char) -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Wrapper for romfsMountSelf with the default \"romfs\" device name."]
    #[link_name = "romfsInit__extern"]
    pub fn romfsInit() -> Result;
}
extern "C" {
    #[must_use]
    #[doc = "Wrapper for romfsUnmount with the default \"romfs\" device name."]
    #[link_name = "romfsExit__extern"]
    pub fn romfsExit() -> Result;
}
#[doc = "Character width information structure."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct charWidthInfo_s {
    #[doc = "< Horizontal offset to draw the glyph with."]
    pub left: s8,
    #[doc = "< Width of the glyph."]
    pub glyphWidth: u8_,
    #[doc = "< Width of the character, that is, horizontal distance to advance."]
    pub charWidth: u8_,
}
#[doc = "Font texture sheet information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TGLP_s {
    #[doc = "< Width of a glyph cell."]
    pub cellWidth: u8_,
    #[doc = "< Height of a glyph cell."]
    pub cellHeight: u8_,
    #[doc = "< Vertical position of the baseline."]
    pub baselinePos: u8_,
    #[doc = "< Maximum character width."]
    pub maxCharWidth: u8_,
    #[doc = "< Size in bytes of a texture sheet."]
    pub sheetSize: u32_,
    #[doc = "< Number of texture sheets."]
    pub nSheets: u16_,
    #[doc = "< GPU texture format (GPU_TEXCOLOR)."]
    pub sheetFmt: u16_,
    #[doc = "< Number of glyphs per row per sheet."]
    pub nRows: u16_,
    #[doc = "< Number of glyph rows per sheet."]
    pub nLines: u16_,
    #[doc = "< Texture sheet width."]
    pub sheetWidth: u16_,
    #[doc = "< Texture sheet height."]
    pub sheetHeight: u16_,
    #[doc = "< Pointer to texture sheet data."]
    pub sheetData: *mut u8_,
}
impl Default for TGLP_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Font character width information block type."]
pub type CWDH_s = tag_CWDH_s;
#[doc = "Font character width information block structure."]
#[repr(C)]
#[derive(Debug)]
pub struct tag_CWDH_s {
    #[doc = "< First Unicode codepoint the block applies to."]
    pub startIndex: u16_,
    #[doc = "< Last Unicode codepoint the block applies to."]
    pub endIndex: u16_,
    #[doc = "< Pointer to the next block."]
    pub next: *mut CWDH_s,
    #[doc = "< Table of character width information structures."]
    pub widths: __IncompleteArrayField<charWidthInfo_s>,
}
impl Default for tag_CWDH_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "< Identity mapping."]
pub const CMAP_TYPE_DIRECT: _bindgen_ty_36 = 0;
#[doc = "< Mapping using a table."]
pub const CMAP_TYPE_TABLE: _bindgen_ty_36 = 1;
#[doc = "< Mapping using a list of mapped characters."]
pub const CMAP_TYPE_SCAN: _bindgen_ty_36 = 2;
#[doc = "Font character map methods."]
pub type _bindgen_ty_36 = ::libc::c_uint;
#[doc = "Font character map type."]
pub type CMAP_s = tag_CMAP_s;
#[doc = "Font character map structure."]
#[repr(C)]
pub struct tag_CMAP_s {
    #[doc = "< First Unicode codepoint the block applies to."]
    pub codeBegin: u16_,
    #[doc = "< Last Unicode codepoint the block applies to."]
    pub codeEnd: u16_,
    #[doc = "< Mapping method."]
    pub mappingMethod: u16_,
    pub reserved: u16_,
    #[doc = "< Pointer to the next map."]
    pub next: *mut CMAP_s,
    pub __bindgen_anon_1: tag_CMAP_s__bindgen_ty_1,
}
#[repr(C)]
pub struct tag_CMAP_s__bindgen_ty_1 {
    #[doc = "< For CMAP_TYPE_DIRECT: index of the first glyph."]
    pub indexOffset: __BindgenUnionField<u16_>,
    #[doc = "< For CMAP_TYPE_TABLE: table of glyph indices."]
    pub indexTable: __BindgenUnionField<[u16_; 0usize]>,
    pub __bindgen_anon_1: __BindgenUnionField<tag_CMAP_s__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: u16,
}
#[doc = "For CMAP_TYPE_SCAN: Mapping data."]
#[repr(C)]
#[derive(Debug, Default)]
pub struct tag_CMAP_s__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< Number of pairs."]
    pub nScanEntries: u16_,
    pub scanEntries: __IncompleteArrayField<tag_CMAP_s__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>,
}
#[doc = "Mapping pairs."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tag_CMAP_s__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< Unicode codepoint."]
    pub code: u16_,
    #[doc = "< Mapped glyph index."]
    pub glyphIndex: u16_,
}
impl Default for tag_CMAP_s__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for tag_CMAP_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Font information structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FINF_s {
    #[doc = "< Signature (FINF)."]
    pub signature: u32_,
    #[doc = "< Section size."]
    pub sectionSize: u32_,
    #[doc = "< Font type"]
    pub fontType: u8_,
    #[doc = "< Line feed vertical distance."]
    pub lineFeed: u8_,
    #[doc = "< Glyph index of the replacement character."]
    pub alterCharIndex: u16_,
    #[doc = "< Default character width information."]
    pub defaultWidth: charWidthInfo_s,
    #[doc = "< Font encoding (?)"]
    pub encoding: u8_,
    #[doc = "< Pointer to texture sheet information."]
    pub tglp: *mut TGLP_s,
    #[doc = "< Pointer to the first character width information block."]
    pub cwdh: *mut CWDH_s,
    #[doc = "< Pointer to the first character map."]
    pub cmap: *mut CMAP_s,
    #[doc = "< Font height."]
    pub height: u8_,
    #[doc = "< Font width."]
    pub width: u8_,
    #[doc = "< Font ascent."]
    pub ascent: u8_,
    pub padding: u8_,
}
impl Default for FINF_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Font structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CFNT_s {
    #[doc = "< Signature (CFNU)."]
    pub signature: u32_,
    #[doc = "< Endianness constant (0xFEFF)."]
    pub endianness: u16_,
    #[doc = "< Header size."]
    pub headerSize: u16_,
    #[doc = "< Format version."]
    pub version: u32_,
    #[doc = "< File size."]
    pub fileSize: u32_,
    #[doc = "< Number of blocks."]
    pub nBlocks: u32_,
    #[doc = "< Font information."]
    pub finf: FINF_s,
}
impl Default for CFNT_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "Font glyph position structure."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fontGlyphPos_s {
    #[doc = "< Texture sheet index to use to render the glyph."]
    pub sheetIndex: ::libc::c_int,
    #[doc = "< Horizontal offset to draw the glyph width."]
    pub xOffset: f32,
    #[doc = "< Horizontal distance to advance after drawing the glyph."]
    pub xAdvance: f32,
    #[doc = "< Glyph width."]
    pub width: f32,
    pub texcoord: fontGlyphPos_s__bindgen_ty_1,
    pub vtxcoord: fontGlyphPos_s__bindgen_ty_2,
}
#[doc = "Texture coordinates to use to render the glyph."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fontGlyphPos_s__bindgen_ty_1 {
    pub left: f32,
    pub top: f32,
    pub right: f32,
    pub bottom: f32,
}
#[doc = "Vertex coordinates to use to render the glyph."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fontGlyphPos_s__bindgen_ty_2 {
    pub left: f32,
    pub top: f32,
    pub right: f32,
    pub bottom: f32,
}
#[doc = "< Calculates vertex coordinates in addition to texture coordinates."]
pub const GLYPH_POS_CALC_VTXCOORD: _bindgen_ty_37 = 1;
#[doc = "< Position the glyph at the baseline instead of at the top-left corner."]
pub const GLYPH_POS_AT_BASELINE: _bindgen_ty_37 = 2;
#[doc = "< Indicates that the Y axis points up instead of down."]
pub const GLYPH_POS_Y_POINTS_UP: _bindgen_ty_37 = 4;
#[doc = "Flags for use with fontCalcGlyphPos."]
pub type _bindgen_ty_37 = ::libc::c_uint;
extern "C" {
    #[must_use]
    #[doc = "Ensures the shared system font is mapped."]
    pub fn fontEnsureMapped() -> Result;
}
extern "C" {
    #[doc = "Fixes the pointers internal to a just-loaded font\n # Arguments\n\n* `font` - Font to fix\n > Should never be run on the system font, and only once on any other font."]
    pub fn fontFixPointers(font: *mut CFNT_s);
}
extern "C" {
    #[doc = "Gets the currently loaded system font"]
    #[link_name = "fontGetSystemFont__extern"]
    pub fn fontGetSystemFont() -> *mut CFNT_s;
}
extern "C" {
    #[doc = "Retrieves the font information structure of a font.\n # Arguments\n\n* `font` - Pointer to font structure. If NULL, the shared system font is used."]
    #[link_name = "fontGetInfo__extern"]
    pub fn fontGetInfo(font: *mut CFNT_s) -> *mut FINF_s;
}
extern "C" {
    #[doc = "Retrieves the texture sheet information of a font.\n # Arguments\n\n* `font` - Pointer to font structure. If NULL, the shared system font is used."]
    #[link_name = "fontGetGlyphInfo__extern"]
    pub fn fontGetGlyphInfo(font: *mut CFNT_s) -> *mut TGLP_s;
}
extern "C" {
    #[doc = "Retrieves the pointer to texture data for the specified texture sheet.\n # Arguments\n\n* `font` - Pointer to font structure. If NULL, the shared system font is used.\n * `sheetIndex` - Index of the texture sheet."]
    #[link_name = "fontGetGlyphSheetTex__extern"]
    pub fn fontGetGlyphSheetTex(
        font: *mut CFNT_s,
        sheetIndex: ::libc::c_int,
    ) -> *mut ::libc::c_void;
}
extern "C" {
    #[doc = "Retrieves the glyph index of the specified Unicode codepoint.\n # Arguments\n\n* `font` - Pointer to font structure. If NULL, the shared system font is used.\n * `codePoint` - Unicode codepoint."]
    pub fn fontGlyphIndexFromCodePoint(font: *mut CFNT_s, codePoint: u32_) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Retrieves character width information of the specified glyph.\n # Arguments\n\n* `font` - Pointer to font structure. If NULL, the shared system font is used.\n * `glyphIndex` - Index of the glyph."]
    pub fn fontGetCharWidthInfo(
        font: *mut CFNT_s,
        glyphIndex: ::libc::c_int,
    ) -> *mut charWidthInfo_s;
}
extern "C" {
    #[doc = "Calculates position information for the specified glyph.\n # Arguments\n\n* `out` - Output structure in which to write the information.\n * `font` - Pointer to font structure. If NULL, the shared system font is used.\n * `glyphIndex` - Index of the glyph.\n * `flags` - Calculation flags (see GLYPH_POS_* flags).\n * `scaleX` - Scale factor to apply horizontally.\n * `scaleY` - Scale factor to apply vertically."]
    pub fn fontCalcGlyphPos(
        out: *mut fontGlyphPos_s,
        font: *mut CFNT_s,
        glyphIndex: ::libc::c_int,
        flags: u32_,
        scaleX: f32,
        scaleY: f32,
    );
}
extern "C" {
    pub fn gdbHioDevInit() -> ::libc::c_int;
}
extern "C" {
    pub fn gdbHioDevExit();
}
extern "C" {
    pub fn gdbHioDevGetStdin() -> ::libc::c_int;
}
extern "C" {
    pub fn gdbHioDevGetStdout() -> ::libc::c_int;
}
extern "C" {
    pub fn gdbHioDevGetStderr() -> ::libc::c_int;
}
extern "C" {
    pub fn gdbHioDevRedirectStdStreams(in_: bool, out: bool, err: bool) -> ::libc::c_int;
}
extern "C" {
    pub fn gdbHioDevGettimeofday(tv: *mut timeval, tz: *mut ::libc::c_void) -> ::libc::c_int;
}
extern "C" {
    pub fn gdbHioDevIsatty(fd: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn gdbHioDevSystem(command: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Address of the host connected through 3dslink"]
    pub static mut __3dslink_host: in_addr;
}
extern "C" {
    #[doc = "Connects to the 3dslink host, setting up an output stream.\n # Arguments\n\n* `redirStdout` (direction in) - Whether to redirect stdout to nxlink output.\n * `redirStderr` (direction in) - Whether to redirect stderr to nxlink output.\n # Returns\n\nSocket fd on success, negative number on failure.\n > **Note:** The socket should be closed with close() during application cleanup."]
    pub fn link3dsConnectToHost(redirStdout: bool, redirStderr: bool) -> ::libc::c_int;
}
extern "C" {
    #[doc = "Same as link3dsConnectToHost but redirecting both stdout/stderr."]
    #[link_name = "link3dsStdio__extern"]
    pub fn link3dsStdio() -> ::libc::c_int;
}
extern "C" {
    #[doc = "Same as link3dsConnectToHost but redirecting only stderr."]
    #[link_name = "link3dsStdioForDebug__extern"]
    pub fn link3dsStdioForDebug() -> ::libc::c_int;
}
pub type error_t = ::libc::c_int;
extern "C" {
    pub fn __errno() -> *mut ::libc::c_int;
}
extern "C" {
    pub static _sys_errlist: [*const ::libc::c_char; 0usize];
}
extern "C" {
    pub static mut _sys_nerr: ::libc::c_int;
}
